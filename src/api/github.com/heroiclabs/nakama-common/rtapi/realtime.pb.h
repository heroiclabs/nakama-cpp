// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: github.com/heroiclabs/nakama-common/rtapi/realtime.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/wrappers.pb.h>
#include "github.com/heroiclabs/nakama-common/api/api.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[59]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
namespace nakama {
namespace realtime {
class Channel;
class ChannelDefaultTypeInternal;
extern ChannelDefaultTypeInternal _Channel_default_instance_;
class ChannelJoin;
class ChannelJoinDefaultTypeInternal;
extern ChannelJoinDefaultTypeInternal _ChannelJoin_default_instance_;
class ChannelLeave;
class ChannelLeaveDefaultTypeInternal;
extern ChannelLeaveDefaultTypeInternal _ChannelLeave_default_instance_;
class ChannelMessageAck;
class ChannelMessageAckDefaultTypeInternal;
extern ChannelMessageAckDefaultTypeInternal _ChannelMessageAck_default_instance_;
class ChannelMessageRemove;
class ChannelMessageRemoveDefaultTypeInternal;
extern ChannelMessageRemoveDefaultTypeInternal _ChannelMessageRemove_default_instance_;
class ChannelMessageSend;
class ChannelMessageSendDefaultTypeInternal;
extern ChannelMessageSendDefaultTypeInternal _ChannelMessageSend_default_instance_;
class ChannelMessageUpdate;
class ChannelMessageUpdateDefaultTypeInternal;
extern ChannelMessageUpdateDefaultTypeInternal _ChannelMessageUpdate_default_instance_;
class ChannelPresenceEvent;
class ChannelPresenceEventDefaultTypeInternal;
extern ChannelPresenceEventDefaultTypeInternal _ChannelPresenceEvent_default_instance_;
class Envelope;
class EnvelopeDefaultTypeInternal;
extern EnvelopeDefaultTypeInternal _Envelope_default_instance_;
class Error;
class ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class Error_ContextEntry_DoNotUse;
class Error_ContextEntry_DoNotUseDefaultTypeInternal;
extern Error_ContextEntry_DoNotUseDefaultTypeInternal _Error_ContextEntry_DoNotUse_default_instance_;
class Match;
class MatchDefaultTypeInternal;
extern MatchDefaultTypeInternal _Match_default_instance_;
class MatchCreate;
class MatchCreateDefaultTypeInternal;
extern MatchCreateDefaultTypeInternal _MatchCreate_default_instance_;
class MatchData;
class MatchDataDefaultTypeInternal;
extern MatchDataDefaultTypeInternal _MatchData_default_instance_;
class MatchDataSend;
class MatchDataSendDefaultTypeInternal;
extern MatchDataSendDefaultTypeInternal _MatchDataSend_default_instance_;
class MatchJoin;
class MatchJoinDefaultTypeInternal;
extern MatchJoinDefaultTypeInternal _MatchJoin_default_instance_;
class MatchJoin_MetadataEntry_DoNotUse;
class MatchJoin_MetadataEntry_DoNotUseDefaultTypeInternal;
extern MatchJoin_MetadataEntry_DoNotUseDefaultTypeInternal _MatchJoin_MetadataEntry_DoNotUse_default_instance_;
class MatchLeave;
class MatchLeaveDefaultTypeInternal;
extern MatchLeaveDefaultTypeInternal _MatchLeave_default_instance_;
class MatchPresenceEvent;
class MatchPresenceEventDefaultTypeInternal;
extern MatchPresenceEventDefaultTypeInternal _MatchPresenceEvent_default_instance_;
class MatchmakerAdd;
class MatchmakerAddDefaultTypeInternal;
extern MatchmakerAddDefaultTypeInternal _MatchmakerAdd_default_instance_;
class MatchmakerAdd_NumericPropertiesEntry_DoNotUse;
class MatchmakerAdd_NumericPropertiesEntry_DoNotUseDefaultTypeInternal;
extern MatchmakerAdd_NumericPropertiesEntry_DoNotUseDefaultTypeInternal _MatchmakerAdd_NumericPropertiesEntry_DoNotUse_default_instance_;
class MatchmakerAdd_StringPropertiesEntry_DoNotUse;
class MatchmakerAdd_StringPropertiesEntry_DoNotUseDefaultTypeInternal;
extern MatchmakerAdd_StringPropertiesEntry_DoNotUseDefaultTypeInternal _MatchmakerAdd_StringPropertiesEntry_DoNotUse_default_instance_;
class MatchmakerMatched;
class MatchmakerMatchedDefaultTypeInternal;
extern MatchmakerMatchedDefaultTypeInternal _MatchmakerMatched_default_instance_;
class MatchmakerMatched_MatchmakerUser;
class MatchmakerMatched_MatchmakerUserDefaultTypeInternal;
extern MatchmakerMatched_MatchmakerUserDefaultTypeInternal _MatchmakerMatched_MatchmakerUser_default_instance_;
class MatchmakerMatched_MatchmakerUser_NumericPropertiesEntry_DoNotUse;
class MatchmakerMatched_MatchmakerUser_NumericPropertiesEntry_DoNotUseDefaultTypeInternal;
extern MatchmakerMatched_MatchmakerUser_NumericPropertiesEntry_DoNotUseDefaultTypeInternal _MatchmakerMatched_MatchmakerUser_NumericPropertiesEntry_DoNotUse_default_instance_;
class MatchmakerMatched_MatchmakerUser_StringPropertiesEntry_DoNotUse;
class MatchmakerMatched_MatchmakerUser_StringPropertiesEntry_DoNotUseDefaultTypeInternal;
extern MatchmakerMatched_MatchmakerUser_StringPropertiesEntry_DoNotUseDefaultTypeInternal _MatchmakerMatched_MatchmakerUser_StringPropertiesEntry_DoNotUse_default_instance_;
class MatchmakerRemove;
class MatchmakerRemoveDefaultTypeInternal;
extern MatchmakerRemoveDefaultTypeInternal _MatchmakerRemove_default_instance_;
class MatchmakerTicket;
class MatchmakerTicketDefaultTypeInternal;
extern MatchmakerTicketDefaultTypeInternal _MatchmakerTicket_default_instance_;
class Notifications;
class NotificationsDefaultTypeInternal;
extern NotificationsDefaultTypeInternal _Notifications_default_instance_;
class Party;
class PartyDefaultTypeInternal;
extern PartyDefaultTypeInternal _Party_default_instance_;
class PartyAccept;
class PartyAcceptDefaultTypeInternal;
extern PartyAcceptDefaultTypeInternal _PartyAccept_default_instance_;
class PartyClose;
class PartyCloseDefaultTypeInternal;
extern PartyCloseDefaultTypeInternal _PartyClose_default_instance_;
class PartyCreate;
class PartyCreateDefaultTypeInternal;
extern PartyCreateDefaultTypeInternal _PartyCreate_default_instance_;
class PartyData;
class PartyDataDefaultTypeInternal;
extern PartyDataDefaultTypeInternal _PartyData_default_instance_;
class PartyDataSend;
class PartyDataSendDefaultTypeInternal;
extern PartyDataSendDefaultTypeInternal _PartyDataSend_default_instance_;
class PartyJoin;
class PartyJoinDefaultTypeInternal;
extern PartyJoinDefaultTypeInternal _PartyJoin_default_instance_;
class PartyJoinRequest;
class PartyJoinRequestDefaultTypeInternal;
extern PartyJoinRequestDefaultTypeInternal _PartyJoinRequest_default_instance_;
class PartyJoinRequestList;
class PartyJoinRequestListDefaultTypeInternal;
extern PartyJoinRequestListDefaultTypeInternal _PartyJoinRequestList_default_instance_;
class PartyLeader;
class PartyLeaderDefaultTypeInternal;
extern PartyLeaderDefaultTypeInternal _PartyLeader_default_instance_;
class PartyLeave;
class PartyLeaveDefaultTypeInternal;
extern PartyLeaveDefaultTypeInternal _PartyLeave_default_instance_;
class PartyMatchmakerAdd;
class PartyMatchmakerAddDefaultTypeInternal;
extern PartyMatchmakerAddDefaultTypeInternal _PartyMatchmakerAdd_default_instance_;
class PartyMatchmakerAdd_NumericPropertiesEntry_DoNotUse;
class PartyMatchmakerAdd_NumericPropertiesEntry_DoNotUseDefaultTypeInternal;
extern PartyMatchmakerAdd_NumericPropertiesEntry_DoNotUseDefaultTypeInternal _PartyMatchmakerAdd_NumericPropertiesEntry_DoNotUse_default_instance_;
class PartyMatchmakerAdd_StringPropertiesEntry_DoNotUse;
class PartyMatchmakerAdd_StringPropertiesEntry_DoNotUseDefaultTypeInternal;
extern PartyMatchmakerAdd_StringPropertiesEntry_DoNotUseDefaultTypeInternal _PartyMatchmakerAdd_StringPropertiesEntry_DoNotUse_default_instance_;
class PartyMatchmakerRemove;
class PartyMatchmakerRemoveDefaultTypeInternal;
extern PartyMatchmakerRemoveDefaultTypeInternal _PartyMatchmakerRemove_default_instance_;
class PartyMatchmakerTicket;
class PartyMatchmakerTicketDefaultTypeInternal;
extern PartyMatchmakerTicketDefaultTypeInternal _PartyMatchmakerTicket_default_instance_;
class PartyPresenceEvent;
class PartyPresenceEventDefaultTypeInternal;
extern PartyPresenceEventDefaultTypeInternal _PartyPresenceEvent_default_instance_;
class PartyPromote;
class PartyPromoteDefaultTypeInternal;
extern PartyPromoteDefaultTypeInternal _PartyPromote_default_instance_;
class PartyRemove;
class PartyRemoveDefaultTypeInternal;
extern PartyRemoveDefaultTypeInternal _PartyRemove_default_instance_;
class Ping;
class PingDefaultTypeInternal;
extern PingDefaultTypeInternal _Ping_default_instance_;
class Pong;
class PongDefaultTypeInternal;
extern PongDefaultTypeInternal _Pong_default_instance_;
class Status;
class StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
class StatusFollow;
class StatusFollowDefaultTypeInternal;
extern StatusFollowDefaultTypeInternal _StatusFollow_default_instance_;
class StatusPresenceEvent;
class StatusPresenceEventDefaultTypeInternal;
extern StatusPresenceEventDefaultTypeInternal _StatusPresenceEvent_default_instance_;
class StatusUnfollow;
class StatusUnfollowDefaultTypeInternal;
extern StatusUnfollowDefaultTypeInternal _StatusUnfollow_default_instance_;
class StatusUpdate;
class StatusUpdateDefaultTypeInternal;
extern StatusUpdateDefaultTypeInternal _StatusUpdate_default_instance_;
class Stream;
class StreamDefaultTypeInternal;
extern StreamDefaultTypeInternal _Stream_default_instance_;
class StreamData;
class StreamDataDefaultTypeInternal;
extern StreamDataDefaultTypeInternal _StreamData_default_instance_;
class StreamPresenceEvent;
class StreamPresenceEventDefaultTypeInternal;
extern StreamPresenceEventDefaultTypeInternal _StreamPresenceEvent_default_instance_;
class UserPresence;
class UserPresenceDefaultTypeInternal;
extern UserPresenceDefaultTypeInternal _UserPresence_default_instance_;
}  // namespace realtime
}  // namespace nakama
PROTOBUF_NAMESPACE_OPEN
template<> ::nakama::realtime::Channel* Arena::CreateMaybeMessage<::nakama::realtime::Channel>(Arena*);
template<> ::nakama::realtime::ChannelJoin* Arena::CreateMaybeMessage<::nakama::realtime::ChannelJoin>(Arena*);
template<> ::nakama::realtime::ChannelLeave* Arena::CreateMaybeMessage<::nakama::realtime::ChannelLeave>(Arena*);
template<> ::nakama::realtime::ChannelMessageAck* Arena::CreateMaybeMessage<::nakama::realtime::ChannelMessageAck>(Arena*);
template<> ::nakama::realtime::ChannelMessageRemove* Arena::CreateMaybeMessage<::nakama::realtime::ChannelMessageRemove>(Arena*);
template<> ::nakama::realtime::ChannelMessageSend* Arena::CreateMaybeMessage<::nakama::realtime::ChannelMessageSend>(Arena*);
template<> ::nakama::realtime::ChannelMessageUpdate* Arena::CreateMaybeMessage<::nakama::realtime::ChannelMessageUpdate>(Arena*);
template<> ::nakama::realtime::ChannelPresenceEvent* Arena::CreateMaybeMessage<::nakama::realtime::ChannelPresenceEvent>(Arena*);
template<> ::nakama::realtime::Envelope* Arena::CreateMaybeMessage<::nakama::realtime::Envelope>(Arena*);
template<> ::nakama::realtime::Error* Arena::CreateMaybeMessage<::nakama::realtime::Error>(Arena*);
template<> ::nakama::realtime::Error_ContextEntry_DoNotUse* Arena::CreateMaybeMessage<::nakama::realtime::Error_ContextEntry_DoNotUse>(Arena*);
template<> ::nakama::realtime::Match* Arena::CreateMaybeMessage<::nakama::realtime::Match>(Arena*);
template<> ::nakama::realtime::MatchCreate* Arena::CreateMaybeMessage<::nakama::realtime::MatchCreate>(Arena*);
template<> ::nakama::realtime::MatchData* Arena::CreateMaybeMessage<::nakama::realtime::MatchData>(Arena*);
template<> ::nakama::realtime::MatchDataSend* Arena::CreateMaybeMessage<::nakama::realtime::MatchDataSend>(Arena*);
template<> ::nakama::realtime::MatchJoin* Arena::CreateMaybeMessage<::nakama::realtime::MatchJoin>(Arena*);
template<> ::nakama::realtime::MatchJoin_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::nakama::realtime::MatchJoin_MetadataEntry_DoNotUse>(Arena*);
template<> ::nakama::realtime::MatchLeave* Arena::CreateMaybeMessage<::nakama::realtime::MatchLeave>(Arena*);
template<> ::nakama::realtime::MatchPresenceEvent* Arena::CreateMaybeMessage<::nakama::realtime::MatchPresenceEvent>(Arena*);
template<> ::nakama::realtime::MatchmakerAdd* Arena::CreateMaybeMessage<::nakama::realtime::MatchmakerAdd>(Arena*);
template<> ::nakama::realtime::MatchmakerAdd_NumericPropertiesEntry_DoNotUse* Arena::CreateMaybeMessage<::nakama::realtime::MatchmakerAdd_NumericPropertiesEntry_DoNotUse>(Arena*);
template<> ::nakama::realtime::MatchmakerAdd_StringPropertiesEntry_DoNotUse* Arena::CreateMaybeMessage<::nakama::realtime::MatchmakerAdd_StringPropertiesEntry_DoNotUse>(Arena*);
template<> ::nakama::realtime::MatchmakerMatched* Arena::CreateMaybeMessage<::nakama::realtime::MatchmakerMatched>(Arena*);
template<> ::nakama::realtime::MatchmakerMatched_MatchmakerUser* Arena::CreateMaybeMessage<::nakama::realtime::MatchmakerMatched_MatchmakerUser>(Arena*);
template<> ::nakama::realtime::MatchmakerMatched_MatchmakerUser_NumericPropertiesEntry_DoNotUse* Arena::CreateMaybeMessage<::nakama::realtime::MatchmakerMatched_MatchmakerUser_NumericPropertiesEntry_DoNotUse>(Arena*);
template<> ::nakama::realtime::MatchmakerMatched_MatchmakerUser_StringPropertiesEntry_DoNotUse* Arena::CreateMaybeMessage<::nakama::realtime::MatchmakerMatched_MatchmakerUser_StringPropertiesEntry_DoNotUse>(Arena*);
template<> ::nakama::realtime::MatchmakerRemove* Arena::CreateMaybeMessage<::nakama::realtime::MatchmakerRemove>(Arena*);
template<> ::nakama::realtime::MatchmakerTicket* Arena::CreateMaybeMessage<::nakama::realtime::MatchmakerTicket>(Arena*);
template<> ::nakama::realtime::Notifications* Arena::CreateMaybeMessage<::nakama::realtime::Notifications>(Arena*);
template<> ::nakama::realtime::Party* Arena::CreateMaybeMessage<::nakama::realtime::Party>(Arena*);
template<> ::nakama::realtime::PartyAccept* Arena::CreateMaybeMessage<::nakama::realtime::PartyAccept>(Arena*);
template<> ::nakama::realtime::PartyClose* Arena::CreateMaybeMessage<::nakama::realtime::PartyClose>(Arena*);
template<> ::nakama::realtime::PartyCreate* Arena::CreateMaybeMessage<::nakama::realtime::PartyCreate>(Arena*);
template<> ::nakama::realtime::PartyData* Arena::CreateMaybeMessage<::nakama::realtime::PartyData>(Arena*);
template<> ::nakama::realtime::PartyDataSend* Arena::CreateMaybeMessage<::nakama::realtime::PartyDataSend>(Arena*);
template<> ::nakama::realtime::PartyJoin* Arena::CreateMaybeMessage<::nakama::realtime::PartyJoin>(Arena*);
template<> ::nakama::realtime::PartyJoinRequest* Arena::CreateMaybeMessage<::nakama::realtime::PartyJoinRequest>(Arena*);
template<> ::nakama::realtime::PartyJoinRequestList* Arena::CreateMaybeMessage<::nakama::realtime::PartyJoinRequestList>(Arena*);
template<> ::nakama::realtime::PartyLeader* Arena::CreateMaybeMessage<::nakama::realtime::PartyLeader>(Arena*);
template<> ::nakama::realtime::PartyLeave* Arena::CreateMaybeMessage<::nakama::realtime::PartyLeave>(Arena*);
template<> ::nakama::realtime::PartyMatchmakerAdd* Arena::CreateMaybeMessage<::nakama::realtime::PartyMatchmakerAdd>(Arena*);
template<> ::nakama::realtime::PartyMatchmakerAdd_NumericPropertiesEntry_DoNotUse* Arena::CreateMaybeMessage<::nakama::realtime::PartyMatchmakerAdd_NumericPropertiesEntry_DoNotUse>(Arena*);
template<> ::nakama::realtime::PartyMatchmakerAdd_StringPropertiesEntry_DoNotUse* Arena::CreateMaybeMessage<::nakama::realtime::PartyMatchmakerAdd_StringPropertiesEntry_DoNotUse>(Arena*);
template<> ::nakama::realtime::PartyMatchmakerRemove* Arena::CreateMaybeMessage<::nakama::realtime::PartyMatchmakerRemove>(Arena*);
template<> ::nakama::realtime::PartyMatchmakerTicket* Arena::CreateMaybeMessage<::nakama::realtime::PartyMatchmakerTicket>(Arena*);
template<> ::nakama::realtime::PartyPresenceEvent* Arena::CreateMaybeMessage<::nakama::realtime::PartyPresenceEvent>(Arena*);
template<> ::nakama::realtime::PartyPromote* Arena::CreateMaybeMessage<::nakama::realtime::PartyPromote>(Arena*);
template<> ::nakama::realtime::PartyRemove* Arena::CreateMaybeMessage<::nakama::realtime::PartyRemove>(Arena*);
template<> ::nakama::realtime::Ping* Arena::CreateMaybeMessage<::nakama::realtime::Ping>(Arena*);
template<> ::nakama::realtime::Pong* Arena::CreateMaybeMessage<::nakama::realtime::Pong>(Arena*);
template<> ::nakama::realtime::Status* Arena::CreateMaybeMessage<::nakama::realtime::Status>(Arena*);
template<> ::nakama::realtime::StatusFollow* Arena::CreateMaybeMessage<::nakama::realtime::StatusFollow>(Arena*);
template<> ::nakama::realtime::StatusPresenceEvent* Arena::CreateMaybeMessage<::nakama::realtime::StatusPresenceEvent>(Arena*);
template<> ::nakama::realtime::StatusUnfollow* Arena::CreateMaybeMessage<::nakama::realtime::StatusUnfollow>(Arena*);
template<> ::nakama::realtime::StatusUpdate* Arena::CreateMaybeMessage<::nakama::realtime::StatusUpdate>(Arena*);
template<> ::nakama::realtime::Stream* Arena::CreateMaybeMessage<::nakama::realtime::Stream>(Arena*);
template<> ::nakama::realtime::StreamData* Arena::CreateMaybeMessage<::nakama::realtime::StreamData>(Arena*);
template<> ::nakama::realtime::StreamPresenceEvent* Arena::CreateMaybeMessage<::nakama::realtime::StreamPresenceEvent>(Arena*);
template<> ::nakama::realtime::UserPresence* Arena::CreateMaybeMessage<::nakama::realtime::UserPresence>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace nakama {
namespace realtime {

enum ChannelJoin_Type : int {
  ChannelJoin_Type_TYPE_UNSPECIFIED = 0,
  ChannelJoin_Type_ROOM = 1,
  ChannelJoin_Type_DIRECT_MESSAGE = 2,
  ChannelJoin_Type_GROUP = 3,
  ChannelJoin_Type_ChannelJoin_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ChannelJoin_Type_ChannelJoin_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ChannelJoin_Type_IsValid(int value);
constexpr ChannelJoin_Type ChannelJoin_Type_Type_MIN = ChannelJoin_Type_TYPE_UNSPECIFIED;
constexpr ChannelJoin_Type ChannelJoin_Type_Type_MAX = ChannelJoin_Type_GROUP;
constexpr int ChannelJoin_Type_Type_ARRAYSIZE = ChannelJoin_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChannelJoin_Type_descriptor();
template<typename T>
inline const std::string& ChannelJoin_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChannelJoin_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChannelJoin_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChannelJoin_Type_descriptor(), enum_t_value);
}
inline bool ChannelJoin_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChannelJoin_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChannelJoin_Type>(
    ChannelJoin_Type_descriptor(), name, value);
}
enum Error_Code : int {
  Error_Code_RUNTIME_EXCEPTION = 0,
  Error_Code_UNRECOGNIZED_PAYLOAD = 1,
  Error_Code_MISSING_PAYLOAD = 2,
  Error_Code_BAD_INPUT = 3,
  Error_Code_MATCH_NOT_FOUND = 4,
  Error_Code_MATCH_JOIN_REJECTED = 5,
  Error_Code_RUNTIME_FUNCTION_NOT_FOUND = 6,
  Error_Code_RUNTIME_FUNCTION_EXCEPTION = 7,
  Error_Code_Error_Code_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Error_Code_Error_Code_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Error_Code_IsValid(int value);
constexpr Error_Code Error_Code_Code_MIN = Error_Code_RUNTIME_EXCEPTION;
constexpr Error_Code Error_Code_Code_MAX = Error_Code_RUNTIME_FUNCTION_EXCEPTION;
constexpr int Error_Code_Code_ARRAYSIZE = Error_Code_Code_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Error_Code_descriptor();
template<typename T>
inline const std::string& Error_Code_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Error_Code>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Error_Code_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Error_Code_descriptor(), enum_t_value);
}
inline bool Error_Code_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Error_Code* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Error_Code>(
    Error_Code_descriptor(), name, value);
}
// ===================================================================

class Envelope PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.Envelope) */ {
 public:
  inline Envelope() : Envelope(nullptr) {}
  virtual ~Envelope();

  Envelope(const Envelope& from);
  Envelope(Envelope&& from) noexcept
    : Envelope() {
    *this = ::std::move(from);
  }

  inline Envelope& operator=(const Envelope& from) {
    CopyFrom(from);
    return *this;
  }
  inline Envelope& operator=(Envelope&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Envelope& default_instance();

  enum MessageCase {
    kChannel = 2,
    kChannelJoin = 3,
    kChannelLeave = 4,
    kChannelMessage = 5,
    kChannelMessageAck = 6,
    kChannelMessageSend = 7,
    kChannelMessageUpdate = 8,
    kChannelMessageRemove = 9,
    kChannelPresenceEvent = 10,
    kError = 11,
    kMatch = 12,
    kMatchCreate = 13,
    kMatchData = 14,
    kMatchDataSend = 15,
    kMatchJoin = 16,
    kMatchLeave = 17,
    kMatchPresenceEvent = 18,
    kMatchmakerAdd = 19,
    kMatchmakerMatched = 20,
    kMatchmakerRemove = 21,
    kMatchmakerTicket = 22,
    kNotifications = 23,
    kRpc = 24,
    kStatus = 25,
    kStatusFollow = 26,
    kStatusPresenceEvent = 27,
    kStatusUnfollow = 28,
    kStatusUpdate = 29,
    kStreamData = 30,
    kStreamPresenceEvent = 31,
    kPing = 32,
    kPong = 33,
    kParty = 34,
    kPartyCreate = 35,
    kPartyJoin = 36,
    kPartyLeave = 37,
    kPartyPromote = 38,
    kPartyLeader = 39,
    kPartyAccept = 40,
    kPartyRemove = 41,
    kPartyClose = 42,
    kPartyJoinRequestList = 43,
    kPartyJoinRequest = 44,
    kPartyMatchmakerAdd = 45,
    kPartyMatchmakerRemove = 46,
    kPartyMatchmakerTicket = 47,
    kPartyData = 48,
    kPartyDataSend = 49,
    kPartyPresenceEvent = 50,
    MESSAGE_NOT_SET = 0,
  };

  static inline const Envelope* internal_default_instance() {
    return reinterpret_cast<const Envelope*>(
               &_Envelope_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Envelope& a, Envelope& b) {
    a.Swap(&b);
  }
  inline void Swap(Envelope* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Envelope* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Envelope* New() const final {
    return CreateMaybeMessage<Envelope>(nullptr);
  }

  Envelope* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Envelope>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Envelope& from);
  void MergeFrom(const Envelope& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Envelope* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.Envelope";
  }
  protected:
  explicit Envelope(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCidFieldNumber = 1,
    kChannelFieldNumber = 2,
    kChannelJoinFieldNumber = 3,
    kChannelLeaveFieldNumber = 4,
    kChannelMessageFieldNumber = 5,
    kChannelMessageAckFieldNumber = 6,
    kChannelMessageSendFieldNumber = 7,
    kChannelMessageUpdateFieldNumber = 8,
    kChannelMessageRemoveFieldNumber = 9,
    kChannelPresenceEventFieldNumber = 10,
    kErrorFieldNumber = 11,
    kMatchFieldNumber = 12,
    kMatchCreateFieldNumber = 13,
    kMatchDataFieldNumber = 14,
    kMatchDataSendFieldNumber = 15,
    kMatchJoinFieldNumber = 16,
    kMatchLeaveFieldNumber = 17,
    kMatchPresenceEventFieldNumber = 18,
    kMatchmakerAddFieldNumber = 19,
    kMatchmakerMatchedFieldNumber = 20,
    kMatchmakerRemoveFieldNumber = 21,
    kMatchmakerTicketFieldNumber = 22,
    kNotificationsFieldNumber = 23,
    kRpcFieldNumber = 24,
    kStatusFieldNumber = 25,
    kStatusFollowFieldNumber = 26,
    kStatusPresenceEventFieldNumber = 27,
    kStatusUnfollowFieldNumber = 28,
    kStatusUpdateFieldNumber = 29,
    kStreamDataFieldNumber = 30,
    kStreamPresenceEventFieldNumber = 31,
    kPingFieldNumber = 32,
    kPongFieldNumber = 33,
    kPartyFieldNumber = 34,
    kPartyCreateFieldNumber = 35,
    kPartyJoinFieldNumber = 36,
    kPartyLeaveFieldNumber = 37,
    kPartyPromoteFieldNumber = 38,
    kPartyLeaderFieldNumber = 39,
    kPartyAcceptFieldNumber = 40,
    kPartyRemoveFieldNumber = 41,
    kPartyCloseFieldNumber = 42,
    kPartyJoinRequestListFieldNumber = 43,
    kPartyJoinRequestFieldNumber = 44,
    kPartyMatchmakerAddFieldNumber = 45,
    kPartyMatchmakerRemoveFieldNumber = 46,
    kPartyMatchmakerTicketFieldNumber = 47,
    kPartyDataFieldNumber = 48,
    kPartyDataSendFieldNumber = 49,
    kPartyPresenceEventFieldNumber = 50,
  };
  // string cid = 1;
  void clear_cid();
  const std::string& cid() const;
  void set_cid(const std::string& value);
  void set_cid(std::string&& value);
  void set_cid(const char* value);
  void set_cid(const char* value, size_t size);
  std::string* mutable_cid();
  std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // .nakama.realtime.Channel channel = 2;
  bool has_channel() const;
  private:
  bool _internal_has_channel() const;
  public:
  void clear_channel();
  const ::nakama::realtime::Channel& channel() const;
  ::nakama::realtime::Channel* release_channel();
  ::nakama::realtime::Channel* mutable_channel();
  void set_allocated_channel(::nakama::realtime::Channel* channel);
  private:
  const ::nakama::realtime::Channel& _internal_channel() const;
  ::nakama::realtime::Channel* _internal_mutable_channel();
  public:
  void unsafe_arena_set_allocated_channel(
      ::nakama::realtime::Channel* channel);
  ::nakama::realtime::Channel* unsafe_arena_release_channel();

  // .nakama.realtime.ChannelJoin channel_join = 3;
  bool has_channel_join() const;
  private:
  bool _internal_has_channel_join() const;
  public:
  void clear_channel_join();
  const ::nakama::realtime::ChannelJoin& channel_join() const;
  ::nakama::realtime::ChannelJoin* release_channel_join();
  ::nakama::realtime::ChannelJoin* mutable_channel_join();
  void set_allocated_channel_join(::nakama::realtime::ChannelJoin* channel_join);
  private:
  const ::nakama::realtime::ChannelJoin& _internal_channel_join() const;
  ::nakama::realtime::ChannelJoin* _internal_mutable_channel_join();
  public:
  void unsafe_arena_set_allocated_channel_join(
      ::nakama::realtime::ChannelJoin* channel_join);
  ::nakama::realtime::ChannelJoin* unsafe_arena_release_channel_join();

  // .nakama.realtime.ChannelLeave channel_leave = 4;
  bool has_channel_leave() const;
  private:
  bool _internal_has_channel_leave() const;
  public:
  void clear_channel_leave();
  const ::nakama::realtime::ChannelLeave& channel_leave() const;
  ::nakama::realtime::ChannelLeave* release_channel_leave();
  ::nakama::realtime::ChannelLeave* mutable_channel_leave();
  void set_allocated_channel_leave(::nakama::realtime::ChannelLeave* channel_leave);
  private:
  const ::nakama::realtime::ChannelLeave& _internal_channel_leave() const;
  ::nakama::realtime::ChannelLeave* _internal_mutable_channel_leave();
  public:
  void unsafe_arena_set_allocated_channel_leave(
      ::nakama::realtime::ChannelLeave* channel_leave);
  ::nakama::realtime::ChannelLeave* unsafe_arena_release_channel_leave();

  // .nakama.api.ChannelMessage channel_message = 5;
  bool has_channel_message() const;
  private:
  bool _internal_has_channel_message() const;
  public:
  void clear_channel_message();
  const ::nakama::api::ChannelMessage& channel_message() const;
  ::nakama::api::ChannelMessage* release_channel_message();
  ::nakama::api::ChannelMessage* mutable_channel_message();
  void set_allocated_channel_message(::nakama::api::ChannelMessage* channel_message);
  private:
  const ::nakama::api::ChannelMessage& _internal_channel_message() const;
  ::nakama::api::ChannelMessage* _internal_mutable_channel_message();
  public:
  void unsafe_arena_set_allocated_channel_message(
      ::nakama::api::ChannelMessage* channel_message);
  ::nakama::api::ChannelMessage* unsafe_arena_release_channel_message();

  // .nakama.realtime.ChannelMessageAck channel_message_ack = 6;
  bool has_channel_message_ack() const;
  private:
  bool _internal_has_channel_message_ack() const;
  public:
  void clear_channel_message_ack();
  const ::nakama::realtime::ChannelMessageAck& channel_message_ack() const;
  ::nakama::realtime::ChannelMessageAck* release_channel_message_ack();
  ::nakama::realtime::ChannelMessageAck* mutable_channel_message_ack();
  void set_allocated_channel_message_ack(::nakama::realtime::ChannelMessageAck* channel_message_ack);
  private:
  const ::nakama::realtime::ChannelMessageAck& _internal_channel_message_ack() const;
  ::nakama::realtime::ChannelMessageAck* _internal_mutable_channel_message_ack();
  public:
  void unsafe_arena_set_allocated_channel_message_ack(
      ::nakama::realtime::ChannelMessageAck* channel_message_ack);
  ::nakama::realtime::ChannelMessageAck* unsafe_arena_release_channel_message_ack();

  // .nakama.realtime.ChannelMessageSend channel_message_send = 7;
  bool has_channel_message_send() const;
  private:
  bool _internal_has_channel_message_send() const;
  public:
  void clear_channel_message_send();
  const ::nakama::realtime::ChannelMessageSend& channel_message_send() const;
  ::nakama::realtime::ChannelMessageSend* release_channel_message_send();
  ::nakama::realtime::ChannelMessageSend* mutable_channel_message_send();
  void set_allocated_channel_message_send(::nakama::realtime::ChannelMessageSend* channel_message_send);
  private:
  const ::nakama::realtime::ChannelMessageSend& _internal_channel_message_send() const;
  ::nakama::realtime::ChannelMessageSend* _internal_mutable_channel_message_send();
  public:
  void unsafe_arena_set_allocated_channel_message_send(
      ::nakama::realtime::ChannelMessageSend* channel_message_send);
  ::nakama::realtime::ChannelMessageSend* unsafe_arena_release_channel_message_send();

  // .nakama.realtime.ChannelMessageUpdate channel_message_update = 8;
  bool has_channel_message_update() const;
  private:
  bool _internal_has_channel_message_update() const;
  public:
  void clear_channel_message_update();
  const ::nakama::realtime::ChannelMessageUpdate& channel_message_update() const;
  ::nakama::realtime::ChannelMessageUpdate* release_channel_message_update();
  ::nakama::realtime::ChannelMessageUpdate* mutable_channel_message_update();
  void set_allocated_channel_message_update(::nakama::realtime::ChannelMessageUpdate* channel_message_update);
  private:
  const ::nakama::realtime::ChannelMessageUpdate& _internal_channel_message_update() const;
  ::nakama::realtime::ChannelMessageUpdate* _internal_mutable_channel_message_update();
  public:
  void unsafe_arena_set_allocated_channel_message_update(
      ::nakama::realtime::ChannelMessageUpdate* channel_message_update);
  ::nakama::realtime::ChannelMessageUpdate* unsafe_arena_release_channel_message_update();

  // .nakama.realtime.ChannelMessageRemove channel_message_remove = 9;
  bool has_channel_message_remove() const;
  private:
  bool _internal_has_channel_message_remove() const;
  public:
  void clear_channel_message_remove();
  const ::nakama::realtime::ChannelMessageRemove& channel_message_remove() const;
  ::nakama::realtime::ChannelMessageRemove* release_channel_message_remove();
  ::nakama::realtime::ChannelMessageRemove* mutable_channel_message_remove();
  void set_allocated_channel_message_remove(::nakama::realtime::ChannelMessageRemove* channel_message_remove);
  private:
  const ::nakama::realtime::ChannelMessageRemove& _internal_channel_message_remove() const;
  ::nakama::realtime::ChannelMessageRemove* _internal_mutable_channel_message_remove();
  public:
  void unsafe_arena_set_allocated_channel_message_remove(
      ::nakama::realtime::ChannelMessageRemove* channel_message_remove);
  ::nakama::realtime::ChannelMessageRemove* unsafe_arena_release_channel_message_remove();

  // .nakama.realtime.ChannelPresenceEvent channel_presence_event = 10;
  bool has_channel_presence_event() const;
  private:
  bool _internal_has_channel_presence_event() const;
  public:
  void clear_channel_presence_event();
  const ::nakama::realtime::ChannelPresenceEvent& channel_presence_event() const;
  ::nakama::realtime::ChannelPresenceEvent* release_channel_presence_event();
  ::nakama::realtime::ChannelPresenceEvent* mutable_channel_presence_event();
  void set_allocated_channel_presence_event(::nakama::realtime::ChannelPresenceEvent* channel_presence_event);
  private:
  const ::nakama::realtime::ChannelPresenceEvent& _internal_channel_presence_event() const;
  ::nakama::realtime::ChannelPresenceEvent* _internal_mutable_channel_presence_event();
  public:
  void unsafe_arena_set_allocated_channel_presence_event(
      ::nakama::realtime::ChannelPresenceEvent* channel_presence_event);
  ::nakama::realtime::ChannelPresenceEvent* unsafe_arena_release_channel_presence_event();

  // .nakama.realtime.Error error = 11;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::nakama::realtime::Error& error() const;
  ::nakama::realtime::Error* release_error();
  ::nakama::realtime::Error* mutable_error();
  void set_allocated_error(::nakama::realtime::Error* error);
  private:
  const ::nakama::realtime::Error& _internal_error() const;
  ::nakama::realtime::Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::nakama::realtime::Error* error);
  ::nakama::realtime::Error* unsafe_arena_release_error();

  // .nakama.realtime.Match match = 12;
  bool has_match() const;
  private:
  bool _internal_has_match() const;
  public:
  void clear_match();
  const ::nakama::realtime::Match& match() const;
  ::nakama::realtime::Match* release_match();
  ::nakama::realtime::Match* mutable_match();
  void set_allocated_match(::nakama::realtime::Match* match);
  private:
  const ::nakama::realtime::Match& _internal_match() const;
  ::nakama::realtime::Match* _internal_mutable_match();
  public:
  void unsafe_arena_set_allocated_match(
      ::nakama::realtime::Match* match);
  ::nakama::realtime::Match* unsafe_arena_release_match();

  // .nakama.realtime.MatchCreate match_create = 13;
  bool has_match_create() const;
  private:
  bool _internal_has_match_create() const;
  public:
  void clear_match_create();
  const ::nakama::realtime::MatchCreate& match_create() const;
  ::nakama::realtime::MatchCreate* release_match_create();
  ::nakama::realtime::MatchCreate* mutable_match_create();
  void set_allocated_match_create(::nakama::realtime::MatchCreate* match_create);
  private:
  const ::nakama::realtime::MatchCreate& _internal_match_create() const;
  ::nakama::realtime::MatchCreate* _internal_mutable_match_create();
  public:
  void unsafe_arena_set_allocated_match_create(
      ::nakama::realtime::MatchCreate* match_create);
  ::nakama::realtime::MatchCreate* unsafe_arena_release_match_create();

  // .nakama.realtime.MatchData match_data = 14;
  bool has_match_data() const;
  private:
  bool _internal_has_match_data() const;
  public:
  void clear_match_data();
  const ::nakama::realtime::MatchData& match_data() const;
  ::nakama::realtime::MatchData* release_match_data();
  ::nakama::realtime::MatchData* mutable_match_data();
  void set_allocated_match_data(::nakama::realtime::MatchData* match_data);
  private:
  const ::nakama::realtime::MatchData& _internal_match_data() const;
  ::nakama::realtime::MatchData* _internal_mutable_match_data();
  public:
  void unsafe_arena_set_allocated_match_data(
      ::nakama::realtime::MatchData* match_data);
  ::nakama::realtime::MatchData* unsafe_arena_release_match_data();

  // .nakama.realtime.MatchDataSend match_data_send = 15;
  bool has_match_data_send() const;
  private:
  bool _internal_has_match_data_send() const;
  public:
  void clear_match_data_send();
  const ::nakama::realtime::MatchDataSend& match_data_send() const;
  ::nakama::realtime::MatchDataSend* release_match_data_send();
  ::nakama::realtime::MatchDataSend* mutable_match_data_send();
  void set_allocated_match_data_send(::nakama::realtime::MatchDataSend* match_data_send);
  private:
  const ::nakama::realtime::MatchDataSend& _internal_match_data_send() const;
  ::nakama::realtime::MatchDataSend* _internal_mutable_match_data_send();
  public:
  void unsafe_arena_set_allocated_match_data_send(
      ::nakama::realtime::MatchDataSend* match_data_send);
  ::nakama::realtime::MatchDataSend* unsafe_arena_release_match_data_send();

  // .nakama.realtime.MatchJoin match_join = 16;
  bool has_match_join() const;
  private:
  bool _internal_has_match_join() const;
  public:
  void clear_match_join();
  const ::nakama::realtime::MatchJoin& match_join() const;
  ::nakama::realtime::MatchJoin* release_match_join();
  ::nakama::realtime::MatchJoin* mutable_match_join();
  void set_allocated_match_join(::nakama::realtime::MatchJoin* match_join);
  private:
  const ::nakama::realtime::MatchJoin& _internal_match_join() const;
  ::nakama::realtime::MatchJoin* _internal_mutable_match_join();
  public:
  void unsafe_arena_set_allocated_match_join(
      ::nakama::realtime::MatchJoin* match_join);
  ::nakama::realtime::MatchJoin* unsafe_arena_release_match_join();

  // .nakama.realtime.MatchLeave match_leave = 17;
  bool has_match_leave() const;
  private:
  bool _internal_has_match_leave() const;
  public:
  void clear_match_leave();
  const ::nakama::realtime::MatchLeave& match_leave() const;
  ::nakama::realtime::MatchLeave* release_match_leave();
  ::nakama::realtime::MatchLeave* mutable_match_leave();
  void set_allocated_match_leave(::nakama::realtime::MatchLeave* match_leave);
  private:
  const ::nakama::realtime::MatchLeave& _internal_match_leave() const;
  ::nakama::realtime::MatchLeave* _internal_mutable_match_leave();
  public:
  void unsafe_arena_set_allocated_match_leave(
      ::nakama::realtime::MatchLeave* match_leave);
  ::nakama::realtime::MatchLeave* unsafe_arena_release_match_leave();

  // .nakama.realtime.MatchPresenceEvent match_presence_event = 18;
  bool has_match_presence_event() const;
  private:
  bool _internal_has_match_presence_event() const;
  public:
  void clear_match_presence_event();
  const ::nakama::realtime::MatchPresenceEvent& match_presence_event() const;
  ::nakama::realtime::MatchPresenceEvent* release_match_presence_event();
  ::nakama::realtime::MatchPresenceEvent* mutable_match_presence_event();
  void set_allocated_match_presence_event(::nakama::realtime::MatchPresenceEvent* match_presence_event);
  private:
  const ::nakama::realtime::MatchPresenceEvent& _internal_match_presence_event() const;
  ::nakama::realtime::MatchPresenceEvent* _internal_mutable_match_presence_event();
  public:
  void unsafe_arena_set_allocated_match_presence_event(
      ::nakama::realtime::MatchPresenceEvent* match_presence_event);
  ::nakama::realtime::MatchPresenceEvent* unsafe_arena_release_match_presence_event();

  // .nakama.realtime.MatchmakerAdd matchmaker_add = 19;
  bool has_matchmaker_add() const;
  private:
  bool _internal_has_matchmaker_add() const;
  public:
  void clear_matchmaker_add();
  const ::nakama::realtime::MatchmakerAdd& matchmaker_add() const;
  ::nakama::realtime::MatchmakerAdd* release_matchmaker_add();
  ::nakama::realtime::MatchmakerAdd* mutable_matchmaker_add();
  void set_allocated_matchmaker_add(::nakama::realtime::MatchmakerAdd* matchmaker_add);
  private:
  const ::nakama::realtime::MatchmakerAdd& _internal_matchmaker_add() const;
  ::nakama::realtime::MatchmakerAdd* _internal_mutable_matchmaker_add();
  public:
  void unsafe_arena_set_allocated_matchmaker_add(
      ::nakama::realtime::MatchmakerAdd* matchmaker_add);
  ::nakama::realtime::MatchmakerAdd* unsafe_arena_release_matchmaker_add();

  // .nakama.realtime.MatchmakerMatched matchmaker_matched = 20;
  bool has_matchmaker_matched() const;
  private:
  bool _internal_has_matchmaker_matched() const;
  public:
  void clear_matchmaker_matched();
  const ::nakama::realtime::MatchmakerMatched& matchmaker_matched() const;
  ::nakama::realtime::MatchmakerMatched* release_matchmaker_matched();
  ::nakama::realtime::MatchmakerMatched* mutable_matchmaker_matched();
  void set_allocated_matchmaker_matched(::nakama::realtime::MatchmakerMatched* matchmaker_matched);
  private:
  const ::nakama::realtime::MatchmakerMatched& _internal_matchmaker_matched() const;
  ::nakama::realtime::MatchmakerMatched* _internal_mutable_matchmaker_matched();
  public:
  void unsafe_arena_set_allocated_matchmaker_matched(
      ::nakama::realtime::MatchmakerMatched* matchmaker_matched);
  ::nakama::realtime::MatchmakerMatched* unsafe_arena_release_matchmaker_matched();

  // .nakama.realtime.MatchmakerRemove matchmaker_remove = 21;
  bool has_matchmaker_remove() const;
  private:
  bool _internal_has_matchmaker_remove() const;
  public:
  void clear_matchmaker_remove();
  const ::nakama::realtime::MatchmakerRemove& matchmaker_remove() const;
  ::nakama::realtime::MatchmakerRemove* release_matchmaker_remove();
  ::nakama::realtime::MatchmakerRemove* mutable_matchmaker_remove();
  void set_allocated_matchmaker_remove(::nakama::realtime::MatchmakerRemove* matchmaker_remove);
  private:
  const ::nakama::realtime::MatchmakerRemove& _internal_matchmaker_remove() const;
  ::nakama::realtime::MatchmakerRemove* _internal_mutable_matchmaker_remove();
  public:
  void unsafe_arena_set_allocated_matchmaker_remove(
      ::nakama::realtime::MatchmakerRemove* matchmaker_remove);
  ::nakama::realtime::MatchmakerRemove* unsafe_arena_release_matchmaker_remove();

  // .nakama.realtime.MatchmakerTicket matchmaker_ticket = 22;
  bool has_matchmaker_ticket() const;
  private:
  bool _internal_has_matchmaker_ticket() const;
  public:
  void clear_matchmaker_ticket();
  const ::nakama::realtime::MatchmakerTicket& matchmaker_ticket() const;
  ::nakama::realtime::MatchmakerTicket* release_matchmaker_ticket();
  ::nakama::realtime::MatchmakerTicket* mutable_matchmaker_ticket();
  void set_allocated_matchmaker_ticket(::nakama::realtime::MatchmakerTicket* matchmaker_ticket);
  private:
  const ::nakama::realtime::MatchmakerTicket& _internal_matchmaker_ticket() const;
  ::nakama::realtime::MatchmakerTicket* _internal_mutable_matchmaker_ticket();
  public:
  void unsafe_arena_set_allocated_matchmaker_ticket(
      ::nakama::realtime::MatchmakerTicket* matchmaker_ticket);
  ::nakama::realtime::MatchmakerTicket* unsafe_arena_release_matchmaker_ticket();

  // .nakama.realtime.Notifications notifications = 23;
  bool has_notifications() const;
  private:
  bool _internal_has_notifications() const;
  public:
  void clear_notifications();
  const ::nakama::realtime::Notifications& notifications() const;
  ::nakama::realtime::Notifications* release_notifications();
  ::nakama::realtime::Notifications* mutable_notifications();
  void set_allocated_notifications(::nakama::realtime::Notifications* notifications);
  private:
  const ::nakama::realtime::Notifications& _internal_notifications() const;
  ::nakama::realtime::Notifications* _internal_mutable_notifications();
  public:
  void unsafe_arena_set_allocated_notifications(
      ::nakama::realtime::Notifications* notifications);
  ::nakama::realtime::Notifications* unsafe_arena_release_notifications();

  // .nakama.api.Rpc rpc = 24;
  bool has_rpc() const;
  private:
  bool _internal_has_rpc() const;
  public:
  void clear_rpc();
  const ::nakama::api::Rpc& rpc() const;
  ::nakama::api::Rpc* release_rpc();
  ::nakama::api::Rpc* mutable_rpc();
  void set_allocated_rpc(::nakama::api::Rpc* rpc);
  private:
  const ::nakama::api::Rpc& _internal_rpc() const;
  ::nakama::api::Rpc* _internal_mutable_rpc();
  public:
  void unsafe_arena_set_allocated_rpc(
      ::nakama::api::Rpc* rpc);
  ::nakama::api::Rpc* unsafe_arena_release_rpc();

  // .nakama.realtime.Status status = 25;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::nakama::realtime::Status& status() const;
  ::nakama::realtime::Status* release_status();
  ::nakama::realtime::Status* mutable_status();
  void set_allocated_status(::nakama::realtime::Status* status);
  private:
  const ::nakama::realtime::Status& _internal_status() const;
  ::nakama::realtime::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::nakama::realtime::Status* status);
  ::nakama::realtime::Status* unsafe_arena_release_status();

  // .nakama.realtime.StatusFollow status_follow = 26;
  bool has_status_follow() const;
  private:
  bool _internal_has_status_follow() const;
  public:
  void clear_status_follow();
  const ::nakama::realtime::StatusFollow& status_follow() const;
  ::nakama::realtime::StatusFollow* release_status_follow();
  ::nakama::realtime::StatusFollow* mutable_status_follow();
  void set_allocated_status_follow(::nakama::realtime::StatusFollow* status_follow);
  private:
  const ::nakama::realtime::StatusFollow& _internal_status_follow() const;
  ::nakama::realtime::StatusFollow* _internal_mutable_status_follow();
  public:
  void unsafe_arena_set_allocated_status_follow(
      ::nakama::realtime::StatusFollow* status_follow);
  ::nakama::realtime::StatusFollow* unsafe_arena_release_status_follow();

  // .nakama.realtime.StatusPresenceEvent status_presence_event = 27;
  bool has_status_presence_event() const;
  private:
  bool _internal_has_status_presence_event() const;
  public:
  void clear_status_presence_event();
  const ::nakama::realtime::StatusPresenceEvent& status_presence_event() const;
  ::nakama::realtime::StatusPresenceEvent* release_status_presence_event();
  ::nakama::realtime::StatusPresenceEvent* mutable_status_presence_event();
  void set_allocated_status_presence_event(::nakama::realtime::StatusPresenceEvent* status_presence_event);
  private:
  const ::nakama::realtime::StatusPresenceEvent& _internal_status_presence_event() const;
  ::nakama::realtime::StatusPresenceEvent* _internal_mutable_status_presence_event();
  public:
  void unsafe_arena_set_allocated_status_presence_event(
      ::nakama::realtime::StatusPresenceEvent* status_presence_event);
  ::nakama::realtime::StatusPresenceEvent* unsafe_arena_release_status_presence_event();

  // .nakama.realtime.StatusUnfollow status_unfollow = 28;
  bool has_status_unfollow() const;
  private:
  bool _internal_has_status_unfollow() const;
  public:
  void clear_status_unfollow();
  const ::nakama::realtime::StatusUnfollow& status_unfollow() const;
  ::nakama::realtime::StatusUnfollow* release_status_unfollow();
  ::nakama::realtime::StatusUnfollow* mutable_status_unfollow();
  void set_allocated_status_unfollow(::nakama::realtime::StatusUnfollow* status_unfollow);
  private:
  const ::nakama::realtime::StatusUnfollow& _internal_status_unfollow() const;
  ::nakama::realtime::StatusUnfollow* _internal_mutable_status_unfollow();
  public:
  void unsafe_arena_set_allocated_status_unfollow(
      ::nakama::realtime::StatusUnfollow* status_unfollow);
  ::nakama::realtime::StatusUnfollow* unsafe_arena_release_status_unfollow();

  // .nakama.realtime.StatusUpdate status_update = 29;
  bool has_status_update() const;
  private:
  bool _internal_has_status_update() const;
  public:
  void clear_status_update();
  const ::nakama::realtime::StatusUpdate& status_update() const;
  ::nakama::realtime::StatusUpdate* release_status_update();
  ::nakama::realtime::StatusUpdate* mutable_status_update();
  void set_allocated_status_update(::nakama::realtime::StatusUpdate* status_update);
  private:
  const ::nakama::realtime::StatusUpdate& _internal_status_update() const;
  ::nakama::realtime::StatusUpdate* _internal_mutable_status_update();
  public:
  void unsafe_arena_set_allocated_status_update(
      ::nakama::realtime::StatusUpdate* status_update);
  ::nakama::realtime::StatusUpdate* unsafe_arena_release_status_update();

  // .nakama.realtime.StreamData stream_data = 30;
  bool has_stream_data() const;
  private:
  bool _internal_has_stream_data() const;
  public:
  void clear_stream_data();
  const ::nakama::realtime::StreamData& stream_data() const;
  ::nakama::realtime::StreamData* release_stream_data();
  ::nakama::realtime::StreamData* mutable_stream_data();
  void set_allocated_stream_data(::nakama::realtime::StreamData* stream_data);
  private:
  const ::nakama::realtime::StreamData& _internal_stream_data() const;
  ::nakama::realtime::StreamData* _internal_mutable_stream_data();
  public:
  void unsafe_arena_set_allocated_stream_data(
      ::nakama::realtime::StreamData* stream_data);
  ::nakama::realtime::StreamData* unsafe_arena_release_stream_data();

  // .nakama.realtime.StreamPresenceEvent stream_presence_event = 31;
  bool has_stream_presence_event() const;
  private:
  bool _internal_has_stream_presence_event() const;
  public:
  void clear_stream_presence_event();
  const ::nakama::realtime::StreamPresenceEvent& stream_presence_event() const;
  ::nakama::realtime::StreamPresenceEvent* release_stream_presence_event();
  ::nakama::realtime::StreamPresenceEvent* mutable_stream_presence_event();
  void set_allocated_stream_presence_event(::nakama::realtime::StreamPresenceEvent* stream_presence_event);
  private:
  const ::nakama::realtime::StreamPresenceEvent& _internal_stream_presence_event() const;
  ::nakama::realtime::StreamPresenceEvent* _internal_mutable_stream_presence_event();
  public:
  void unsafe_arena_set_allocated_stream_presence_event(
      ::nakama::realtime::StreamPresenceEvent* stream_presence_event);
  ::nakama::realtime::StreamPresenceEvent* unsafe_arena_release_stream_presence_event();

  // .nakama.realtime.Ping ping = 32;
  bool has_ping() const;
  private:
  bool _internal_has_ping() const;
  public:
  void clear_ping();
  const ::nakama::realtime::Ping& ping() const;
  ::nakama::realtime::Ping* release_ping();
  ::nakama::realtime::Ping* mutable_ping();
  void set_allocated_ping(::nakama::realtime::Ping* ping);
  private:
  const ::nakama::realtime::Ping& _internal_ping() const;
  ::nakama::realtime::Ping* _internal_mutable_ping();
  public:
  void unsafe_arena_set_allocated_ping(
      ::nakama::realtime::Ping* ping);
  ::nakama::realtime::Ping* unsafe_arena_release_ping();

  // .nakama.realtime.Pong pong = 33;
  bool has_pong() const;
  private:
  bool _internal_has_pong() const;
  public:
  void clear_pong();
  const ::nakama::realtime::Pong& pong() const;
  ::nakama::realtime::Pong* release_pong();
  ::nakama::realtime::Pong* mutable_pong();
  void set_allocated_pong(::nakama::realtime::Pong* pong);
  private:
  const ::nakama::realtime::Pong& _internal_pong() const;
  ::nakama::realtime::Pong* _internal_mutable_pong();
  public:
  void unsafe_arena_set_allocated_pong(
      ::nakama::realtime::Pong* pong);
  ::nakama::realtime::Pong* unsafe_arena_release_pong();

  // .nakama.realtime.Party party = 34;
  bool has_party() const;
  private:
  bool _internal_has_party() const;
  public:
  void clear_party();
  const ::nakama::realtime::Party& party() const;
  ::nakama::realtime::Party* release_party();
  ::nakama::realtime::Party* mutable_party();
  void set_allocated_party(::nakama::realtime::Party* party);
  private:
  const ::nakama::realtime::Party& _internal_party() const;
  ::nakama::realtime::Party* _internal_mutable_party();
  public:
  void unsafe_arena_set_allocated_party(
      ::nakama::realtime::Party* party);
  ::nakama::realtime::Party* unsafe_arena_release_party();

  // .nakama.realtime.PartyCreate party_create = 35;
  bool has_party_create() const;
  private:
  bool _internal_has_party_create() const;
  public:
  void clear_party_create();
  const ::nakama::realtime::PartyCreate& party_create() const;
  ::nakama::realtime::PartyCreate* release_party_create();
  ::nakama::realtime::PartyCreate* mutable_party_create();
  void set_allocated_party_create(::nakama::realtime::PartyCreate* party_create);
  private:
  const ::nakama::realtime::PartyCreate& _internal_party_create() const;
  ::nakama::realtime::PartyCreate* _internal_mutable_party_create();
  public:
  void unsafe_arena_set_allocated_party_create(
      ::nakama::realtime::PartyCreate* party_create);
  ::nakama::realtime::PartyCreate* unsafe_arena_release_party_create();

  // .nakama.realtime.PartyJoin party_join = 36;
  bool has_party_join() const;
  private:
  bool _internal_has_party_join() const;
  public:
  void clear_party_join();
  const ::nakama::realtime::PartyJoin& party_join() const;
  ::nakama::realtime::PartyJoin* release_party_join();
  ::nakama::realtime::PartyJoin* mutable_party_join();
  void set_allocated_party_join(::nakama::realtime::PartyJoin* party_join);
  private:
  const ::nakama::realtime::PartyJoin& _internal_party_join() const;
  ::nakama::realtime::PartyJoin* _internal_mutable_party_join();
  public:
  void unsafe_arena_set_allocated_party_join(
      ::nakama::realtime::PartyJoin* party_join);
  ::nakama::realtime::PartyJoin* unsafe_arena_release_party_join();

  // .nakama.realtime.PartyLeave party_leave = 37;
  bool has_party_leave() const;
  private:
  bool _internal_has_party_leave() const;
  public:
  void clear_party_leave();
  const ::nakama::realtime::PartyLeave& party_leave() const;
  ::nakama::realtime::PartyLeave* release_party_leave();
  ::nakama::realtime::PartyLeave* mutable_party_leave();
  void set_allocated_party_leave(::nakama::realtime::PartyLeave* party_leave);
  private:
  const ::nakama::realtime::PartyLeave& _internal_party_leave() const;
  ::nakama::realtime::PartyLeave* _internal_mutable_party_leave();
  public:
  void unsafe_arena_set_allocated_party_leave(
      ::nakama::realtime::PartyLeave* party_leave);
  ::nakama::realtime::PartyLeave* unsafe_arena_release_party_leave();

  // .nakama.realtime.PartyPromote party_promote = 38;
  bool has_party_promote() const;
  private:
  bool _internal_has_party_promote() const;
  public:
  void clear_party_promote();
  const ::nakama::realtime::PartyPromote& party_promote() const;
  ::nakama::realtime::PartyPromote* release_party_promote();
  ::nakama::realtime::PartyPromote* mutable_party_promote();
  void set_allocated_party_promote(::nakama::realtime::PartyPromote* party_promote);
  private:
  const ::nakama::realtime::PartyPromote& _internal_party_promote() const;
  ::nakama::realtime::PartyPromote* _internal_mutable_party_promote();
  public:
  void unsafe_arena_set_allocated_party_promote(
      ::nakama::realtime::PartyPromote* party_promote);
  ::nakama::realtime::PartyPromote* unsafe_arena_release_party_promote();

  // .nakama.realtime.PartyLeader party_leader = 39;
  bool has_party_leader() const;
  private:
  bool _internal_has_party_leader() const;
  public:
  void clear_party_leader();
  const ::nakama::realtime::PartyLeader& party_leader() const;
  ::nakama::realtime::PartyLeader* release_party_leader();
  ::nakama::realtime::PartyLeader* mutable_party_leader();
  void set_allocated_party_leader(::nakama::realtime::PartyLeader* party_leader);
  private:
  const ::nakama::realtime::PartyLeader& _internal_party_leader() const;
  ::nakama::realtime::PartyLeader* _internal_mutable_party_leader();
  public:
  void unsafe_arena_set_allocated_party_leader(
      ::nakama::realtime::PartyLeader* party_leader);
  ::nakama::realtime::PartyLeader* unsafe_arena_release_party_leader();

  // .nakama.realtime.PartyAccept party_accept = 40;
  bool has_party_accept() const;
  private:
  bool _internal_has_party_accept() const;
  public:
  void clear_party_accept();
  const ::nakama::realtime::PartyAccept& party_accept() const;
  ::nakama::realtime::PartyAccept* release_party_accept();
  ::nakama::realtime::PartyAccept* mutable_party_accept();
  void set_allocated_party_accept(::nakama::realtime::PartyAccept* party_accept);
  private:
  const ::nakama::realtime::PartyAccept& _internal_party_accept() const;
  ::nakama::realtime::PartyAccept* _internal_mutable_party_accept();
  public:
  void unsafe_arena_set_allocated_party_accept(
      ::nakama::realtime::PartyAccept* party_accept);
  ::nakama::realtime::PartyAccept* unsafe_arena_release_party_accept();

  // .nakama.realtime.PartyRemove party_remove = 41;
  bool has_party_remove() const;
  private:
  bool _internal_has_party_remove() const;
  public:
  void clear_party_remove();
  const ::nakama::realtime::PartyRemove& party_remove() const;
  ::nakama::realtime::PartyRemove* release_party_remove();
  ::nakama::realtime::PartyRemove* mutable_party_remove();
  void set_allocated_party_remove(::nakama::realtime::PartyRemove* party_remove);
  private:
  const ::nakama::realtime::PartyRemove& _internal_party_remove() const;
  ::nakama::realtime::PartyRemove* _internal_mutable_party_remove();
  public:
  void unsafe_arena_set_allocated_party_remove(
      ::nakama::realtime::PartyRemove* party_remove);
  ::nakama::realtime::PartyRemove* unsafe_arena_release_party_remove();

  // .nakama.realtime.PartyClose party_close = 42;
  bool has_party_close() const;
  private:
  bool _internal_has_party_close() const;
  public:
  void clear_party_close();
  const ::nakama::realtime::PartyClose& party_close() const;
  ::nakama::realtime::PartyClose* release_party_close();
  ::nakama::realtime::PartyClose* mutable_party_close();
  void set_allocated_party_close(::nakama::realtime::PartyClose* party_close);
  private:
  const ::nakama::realtime::PartyClose& _internal_party_close() const;
  ::nakama::realtime::PartyClose* _internal_mutable_party_close();
  public:
  void unsafe_arena_set_allocated_party_close(
      ::nakama::realtime::PartyClose* party_close);
  ::nakama::realtime::PartyClose* unsafe_arena_release_party_close();

  // .nakama.realtime.PartyJoinRequestList party_join_request_list = 43;
  bool has_party_join_request_list() const;
  private:
  bool _internal_has_party_join_request_list() const;
  public:
  void clear_party_join_request_list();
  const ::nakama::realtime::PartyJoinRequestList& party_join_request_list() const;
  ::nakama::realtime::PartyJoinRequestList* release_party_join_request_list();
  ::nakama::realtime::PartyJoinRequestList* mutable_party_join_request_list();
  void set_allocated_party_join_request_list(::nakama::realtime::PartyJoinRequestList* party_join_request_list);
  private:
  const ::nakama::realtime::PartyJoinRequestList& _internal_party_join_request_list() const;
  ::nakama::realtime::PartyJoinRequestList* _internal_mutable_party_join_request_list();
  public:
  void unsafe_arena_set_allocated_party_join_request_list(
      ::nakama::realtime::PartyJoinRequestList* party_join_request_list);
  ::nakama::realtime::PartyJoinRequestList* unsafe_arena_release_party_join_request_list();

  // .nakama.realtime.PartyJoinRequest party_join_request = 44;
  bool has_party_join_request() const;
  private:
  bool _internal_has_party_join_request() const;
  public:
  void clear_party_join_request();
  const ::nakama::realtime::PartyJoinRequest& party_join_request() const;
  ::nakama::realtime::PartyJoinRequest* release_party_join_request();
  ::nakama::realtime::PartyJoinRequest* mutable_party_join_request();
  void set_allocated_party_join_request(::nakama::realtime::PartyJoinRequest* party_join_request);
  private:
  const ::nakama::realtime::PartyJoinRequest& _internal_party_join_request() const;
  ::nakama::realtime::PartyJoinRequest* _internal_mutable_party_join_request();
  public:
  void unsafe_arena_set_allocated_party_join_request(
      ::nakama::realtime::PartyJoinRequest* party_join_request);
  ::nakama::realtime::PartyJoinRequest* unsafe_arena_release_party_join_request();

  // .nakama.realtime.PartyMatchmakerAdd party_matchmaker_add = 45;
  bool has_party_matchmaker_add() const;
  private:
  bool _internal_has_party_matchmaker_add() const;
  public:
  void clear_party_matchmaker_add();
  const ::nakama::realtime::PartyMatchmakerAdd& party_matchmaker_add() const;
  ::nakama::realtime::PartyMatchmakerAdd* release_party_matchmaker_add();
  ::nakama::realtime::PartyMatchmakerAdd* mutable_party_matchmaker_add();
  void set_allocated_party_matchmaker_add(::nakama::realtime::PartyMatchmakerAdd* party_matchmaker_add);
  private:
  const ::nakama::realtime::PartyMatchmakerAdd& _internal_party_matchmaker_add() const;
  ::nakama::realtime::PartyMatchmakerAdd* _internal_mutable_party_matchmaker_add();
  public:
  void unsafe_arena_set_allocated_party_matchmaker_add(
      ::nakama::realtime::PartyMatchmakerAdd* party_matchmaker_add);
  ::nakama::realtime::PartyMatchmakerAdd* unsafe_arena_release_party_matchmaker_add();

  // .nakama.realtime.PartyMatchmakerRemove party_matchmaker_remove = 46;
  bool has_party_matchmaker_remove() const;
  private:
  bool _internal_has_party_matchmaker_remove() const;
  public:
  void clear_party_matchmaker_remove();
  const ::nakama::realtime::PartyMatchmakerRemove& party_matchmaker_remove() const;
  ::nakama::realtime::PartyMatchmakerRemove* release_party_matchmaker_remove();
  ::nakama::realtime::PartyMatchmakerRemove* mutable_party_matchmaker_remove();
  void set_allocated_party_matchmaker_remove(::nakama::realtime::PartyMatchmakerRemove* party_matchmaker_remove);
  private:
  const ::nakama::realtime::PartyMatchmakerRemove& _internal_party_matchmaker_remove() const;
  ::nakama::realtime::PartyMatchmakerRemove* _internal_mutable_party_matchmaker_remove();
  public:
  void unsafe_arena_set_allocated_party_matchmaker_remove(
      ::nakama::realtime::PartyMatchmakerRemove* party_matchmaker_remove);
  ::nakama::realtime::PartyMatchmakerRemove* unsafe_arena_release_party_matchmaker_remove();

  // .nakama.realtime.PartyMatchmakerTicket party_matchmaker_ticket = 47;
  bool has_party_matchmaker_ticket() const;
  private:
  bool _internal_has_party_matchmaker_ticket() const;
  public:
  void clear_party_matchmaker_ticket();
  const ::nakama::realtime::PartyMatchmakerTicket& party_matchmaker_ticket() const;
  ::nakama::realtime::PartyMatchmakerTicket* release_party_matchmaker_ticket();
  ::nakama::realtime::PartyMatchmakerTicket* mutable_party_matchmaker_ticket();
  void set_allocated_party_matchmaker_ticket(::nakama::realtime::PartyMatchmakerTicket* party_matchmaker_ticket);
  private:
  const ::nakama::realtime::PartyMatchmakerTicket& _internal_party_matchmaker_ticket() const;
  ::nakama::realtime::PartyMatchmakerTicket* _internal_mutable_party_matchmaker_ticket();
  public:
  void unsafe_arena_set_allocated_party_matchmaker_ticket(
      ::nakama::realtime::PartyMatchmakerTicket* party_matchmaker_ticket);
  ::nakama::realtime::PartyMatchmakerTicket* unsafe_arena_release_party_matchmaker_ticket();

  // .nakama.realtime.PartyData party_data = 48;
  bool has_party_data() const;
  private:
  bool _internal_has_party_data() const;
  public:
  void clear_party_data();
  const ::nakama::realtime::PartyData& party_data() const;
  ::nakama::realtime::PartyData* release_party_data();
  ::nakama::realtime::PartyData* mutable_party_data();
  void set_allocated_party_data(::nakama::realtime::PartyData* party_data);
  private:
  const ::nakama::realtime::PartyData& _internal_party_data() const;
  ::nakama::realtime::PartyData* _internal_mutable_party_data();
  public:
  void unsafe_arena_set_allocated_party_data(
      ::nakama::realtime::PartyData* party_data);
  ::nakama::realtime::PartyData* unsafe_arena_release_party_data();

  // .nakama.realtime.PartyDataSend party_data_send = 49;
  bool has_party_data_send() const;
  private:
  bool _internal_has_party_data_send() const;
  public:
  void clear_party_data_send();
  const ::nakama::realtime::PartyDataSend& party_data_send() const;
  ::nakama::realtime::PartyDataSend* release_party_data_send();
  ::nakama::realtime::PartyDataSend* mutable_party_data_send();
  void set_allocated_party_data_send(::nakama::realtime::PartyDataSend* party_data_send);
  private:
  const ::nakama::realtime::PartyDataSend& _internal_party_data_send() const;
  ::nakama::realtime::PartyDataSend* _internal_mutable_party_data_send();
  public:
  void unsafe_arena_set_allocated_party_data_send(
      ::nakama::realtime::PartyDataSend* party_data_send);
  ::nakama::realtime::PartyDataSend* unsafe_arena_release_party_data_send();

  // .nakama.realtime.PartyPresenceEvent party_presence_event = 50;
  bool has_party_presence_event() const;
  private:
  bool _internal_has_party_presence_event() const;
  public:
  void clear_party_presence_event();
  const ::nakama::realtime::PartyPresenceEvent& party_presence_event() const;
  ::nakama::realtime::PartyPresenceEvent* release_party_presence_event();
  ::nakama::realtime::PartyPresenceEvent* mutable_party_presence_event();
  void set_allocated_party_presence_event(::nakama::realtime::PartyPresenceEvent* party_presence_event);
  private:
  const ::nakama::realtime::PartyPresenceEvent& _internal_party_presence_event() const;
  ::nakama::realtime::PartyPresenceEvent* _internal_mutable_party_presence_event();
  public:
  void unsafe_arena_set_allocated_party_presence_event(
      ::nakama::realtime::PartyPresenceEvent* party_presence_event);
  ::nakama::realtime::PartyPresenceEvent* unsafe_arena_release_party_presence_event();

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:nakama.realtime.Envelope)
 private:
  class _Internal;
  void set_has_channel();
  void set_has_channel_join();
  void set_has_channel_leave();
  void set_has_channel_message();
  void set_has_channel_message_ack();
  void set_has_channel_message_send();
  void set_has_channel_message_update();
  void set_has_channel_message_remove();
  void set_has_channel_presence_event();
  void set_has_error();
  void set_has_match();
  void set_has_match_create();
  void set_has_match_data();
  void set_has_match_data_send();
  void set_has_match_join();
  void set_has_match_leave();
  void set_has_match_presence_event();
  void set_has_matchmaker_add();
  void set_has_matchmaker_matched();
  void set_has_matchmaker_remove();
  void set_has_matchmaker_ticket();
  void set_has_notifications();
  void set_has_rpc();
  void set_has_status();
  void set_has_status_follow();
  void set_has_status_presence_event();
  void set_has_status_unfollow();
  void set_has_status_update();
  void set_has_stream_data();
  void set_has_stream_presence_event();
  void set_has_ping();
  void set_has_pong();
  void set_has_party();
  void set_has_party_create();
  void set_has_party_join();
  void set_has_party_leave();
  void set_has_party_promote();
  void set_has_party_leader();
  void set_has_party_accept();
  void set_has_party_remove();
  void set_has_party_close();
  void set_has_party_join_request_list();
  void set_has_party_join_request();
  void set_has_party_matchmaker_add();
  void set_has_party_matchmaker_remove();
  void set_has_party_matchmaker_ticket();
  void set_has_party_data();
  void set_has_party_data_send();
  void set_has_party_presence_event();

  inline bool has_message() const;
  inline void clear_has_message();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
  union MessageUnion {
    MessageUnion() {}
    ::nakama::realtime::Channel* channel_;
    ::nakama::realtime::ChannelJoin* channel_join_;
    ::nakama::realtime::ChannelLeave* channel_leave_;
    ::nakama::api::ChannelMessage* channel_message_;
    ::nakama::realtime::ChannelMessageAck* channel_message_ack_;
    ::nakama::realtime::ChannelMessageSend* channel_message_send_;
    ::nakama::realtime::ChannelMessageUpdate* channel_message_update_;
    ::nakama::realtime::ChannelMessageRemove* channel_message_remove_;
    ::nakama::realtime::ChannelPresenceEvent* channel_presence_event_;
    ::nakama::realtime::Error* error_;
    ::nakama::realtime::Match* match_;
    ::nakama::realtime::MatchCreate* match_create_;
    ::nakama::realtime::MatchData* match_data_;
    ::nakama::realtime::MatchDataSend* match_data_send_;
    ::nakama::realtime::MatchJoin* match_join_;
    ::nakama::realtime::MatchLeave* match_leave_;
    ::nakama::realtime::MatchPresenceEvent* match_presence_event_;
    ::nakama::realtime::MatchmakerAdd* matchmaker_add_;
    ::nakama::realtime::MatchmakerMatched* matchmaker_matched_;
    ::nakama::realtime::MatchmakerRemove* matchmaker_remove_;
    ::nakama::realtime::MatchmakerTicket* matchmaker_ticket_;
    ::nakama::realtime::Notifications* notifications_;
    ::nakama::api::Rpc* rpc_;
    ::nakama::realtime::Status* status_;
    ::nakama::realtime::StatusFollow* status_follow_;
    ::nakama::realtime::StatusPresenceEvent* status_presence_event_;
    ::nakama::realtime::StatusUnfollow* status_unfollow_;
    ::nakama::realtime::StatusUpdate* status_update_;
    ::nakama::realtime::StreamData* stream_data_;
    ::nakama::realtime::StreamPresenceEvent* stream_presence_event_;
    ::nakama::realtime::Ping* ping_;
    ::nakama::realtime::Pong* pong_;
    ::nakama::realtime::Party* party_;
    ::nakama::realtime::PartyCreate* party_create_;
    ::nakama::realtime::PartyJoin* party_join_;
    ::nakama::realtime::PartyLeave* party_leave_;
    ::nakama::realtime::PartyPromote* party_promote_;
    ::nakama::realtime::PartyLeader* party_leader_;
    ::nakama::realtime::PartyAccept* party_accept_;
    ::nakama::realtime::PartyRemove* party_remove_;
    ::nakama::realtime::PartyClose* party_close_;
    ::nakama::realtime::PartyJoinRequestList* party_join_request_list_;
    ::nakama::realtime::PartyJoinRequest* party_join_request_;
    ::nakama::realtime::PartyMatchmakerAdd* party_matchmaker_add_;
    ::nakama::realtime::PartyMatchmakerRemove* party_matchmaker_remove_;
    ::nakama::realtime::PartyMatchmakerTicket* party_matchmaker_ticket_;
    ::nakama::realtime::PartyData* party_data_;
    ::nakama::realtime::PartyDataSend* party_data_send_;
    ::nakama::realtime::PartyPresenceEvent* party_presence_event_;
  } message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class Channel PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.Channel) */ {
 public:
  inline Channel() : Channel(nullptr) {}
  virtual ~Channel();

  Channel(const Channel& from);
  Channel(Channel&& from) noexcept
    : Channel() {
    *this = ::std::move(from);
  }

  inline Channel& operator=(const Channel& from) {
    CopyFrom(from);
    return *this;
  }
  inline Channel& operator=(Channel&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Channel& default_instance();

  static inline const Channel* internal_default_instance() {
    return reinterpret_cast<const Channel*>(
               &_Channel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Channel& a, Channel& b) {
    a.Swap(&b);
  }
  inline void Swap(Channel* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Channel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Channel* New() const final {
    return CreateMaybeMessage<Channel>(nullptr);
  }

  Channel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Channel>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Channel& from);
  void MergeFrom(const Channel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Channel* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.Channel";
  }
  protected:
  explicit Channel(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPresencesFieldNumber = 2,
    kIdFieldNumber = 1,
    kRoomNameFieldNumber = 4,
    kGroupIdFieldNumber = 5,
    kUserIdOneFieldNumber = 6,
    kUserIdTwoFieldNumber = 7,
    kSelfFieldNumber = 3,
  };
  // repeated .nakama.realtime.UserPresence presences = 2;
  int presences_size() const;
  private:
  int _internal_presences_size() const;
  public:
  void clear_presences();
  ::nakama::realtime::UserPresence* mutable_presences(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >*
      mutable_presences();
  private:
  const ::nakama::realtime::UserPresence& _internal_presences(int index) const;
  ::nakama::realtime::UserPresence* _internal_add_presences();
  public:
  const ::nakama::realtime::UserPresence& presences(int index) const;
  ::nakama::realtime::UserPresence* add_presences();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >&
      presences() const;

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string room_name = 4;
  void clear_room_name();
  const std::string& room_name() const;
  void set_room_name(const std::string& value);
  void set_room_name(std::string&& value);
  void set_room_name(const char* value);
  void set_room_name(const char* value, size_t size);
  std::string* mutable_room_name();
  std::string* release_room_name();
  void set_allocated_room_name(std::string* room_name);
  private:
  const std::string& _internal_room_name() const;
  void _internal_set_room_name(const std::string& value);
  std::string* _internal_mutable_room_name();
  public:

  // string group_id = 5;
  void clear_group_id();
  const std::string& group_id() const;
  void set_group_id(const std::string& value);
  void set_group_id(std::string&& value);
  void set_group_id(const char* value);
  void set_group_id(const char* value, size_t size);
  std::string* mutable_group_id();
  std::string* release_group_id();
  void set_allocated_group_id(std::string* group_id);
  private:
  const std::string& _internal_group_id() const;
  void _internal_set_group_id(const std::string& value);
  std::string* _internal_mutable_group_id();
  public:

  // string user_id_one = 6;
  void clear_user_id_one();
  const std::string& user_id_one() const;
  void set_user_id_one(const std::string& value);
  void set_user_id_one(std::string&& value);
  void set_user_id_one(const char* value);
  void set_user_id_one(const char* value, size_t size);
  std::string* mutable_user_id_one();
  std::string* release_user_id_one();
  void set_allocated_user_id_one(std::string* user_id_one);
  private:
  const std::string& _internal_user_id_one() const;
  void _internal_set_user_id_one(const std::string& value);
  std::string* _internal_mutable_user_id_one();
  public:

  // string user_id_two = 7;
  void clear_user_id_two();
  const std::string& user_id_two() const;
  void set_user_id_two(const std::string& value);
  void set_user_id_two(std::string&& value);
  void set_user_id_two(const char* value);
  void set_user_id_two(const char* value, size_t size);
  std::string* mutable_user_id_two();
  std::string* release_user_id_two();
  void set_allocated_user_id_two(std::string* user_id_two);
  private:
  const std::string& _internal_user_id_two() const;
  void _internal_set_user_id_two(const std::string& value);
  std::string* _internal_mutable_user_id_two();
  public:

  // .nakama.realtime.UserPresence self = 3;
  bool has_self() const;
  private:
  bool _internal_has_self() const;
  public:
  void clear_self();
  const ::nakama::realtime::UserPresence& self() const;
  ::nakama::realtime::UserPresence* release_self();
  ::nakama::realtime::UserPresence* mutable_self();
  void set_allocated_self(::nakama::realtime::UserPresence* self);
  private:
  const ::nakama::realtime::UserPresence& _internal_self() const;
  ::nakama::realtime::UserPresence* _internal_mutable_self();
  public:
  void unsafe_arena_set_allocated_self(
      ::nakama::realtime::UserPresence* self);
  ::nakama::realtime::UserPresence* unsafe_arena_release_self();

  // @@protoc_insertion_point(class_scope:nakama.realtime.Channel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence > presences_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_one_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_two_;
  ::nakama::realtime::UserPresence* self_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class ChannelJoin PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.ChannelJoin) */ {
 public:
  inline ChannelJoin() : ChannelJoin(nullptr) {}
  virtual ~ChannelJoin();

  ChannelJoin(const ChannelJoin& from);
  ChannelJoin(ChannelJoin&& from) noexcept
    : ChannelJoin() {
    *this = ::std::move(from);
  }

  inline ChannelJoin& operator=(const ChannelJoin& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelJoin& operator=(ChannelJoin&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChannelJoin& default_instance();

  static inline const ChannelJoin* internal_default_instance() {
    return reinterpret_cast<const ChannelJoin*>(
               &_ChannelJoin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ChannelJoin& a, ChannelJoin& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelJoin* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelJoin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChannelJoin* New() const final {
    return CreateMaybeMessage<ChannelJoin>(nullptr);
  }

  ChannelJoin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChannelJoin>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChannelJoin& from);
  void MergeFrom(const ChannelJoin& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelJoin* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.ChannelJoin";
  }
  protected:
  explicit ChannelJoin(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ChannelJoin_Type Type;
  static constexpr Type TYPE_UNSPECIFIED =
    ChannelJoin_Type_TYPE_UNSPECIFIED;
  static constexpr Type ROOM =
    ChannelJoin_Type_ROOM;
  static constexpr Type DIRECT_MESSAGE =
    ChannelJoin_Type_DIRECT_MESSAGE;
  static constexpr Type GROUP =
    ChannelJoin_Type_GROUP;
  static inline bool Type_IsValid(int value) {
    return ChannelJoin_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    ChannelJoin_Type_Type_MIN;
  static constexpr Type Type_MAX =
    ChannelJoin_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    ChannelJoin_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return ChannelJoin_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return ChannelJoin_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return ChannelJoin_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTargetFieldNumber = 1,
    kPersistenceFieldNumber = 3,
    kHiddenFieldNumber = 4,
    kTypeFieldNumber = 2,
  };
  // string target = 1;
  void clear_target();
  const std::string& target() const;
  void set_target(const std::string& value);
  void set_target(std::string&& value);
  void set_target(const char* value);
  void set_target(const char* value, size_t size);
  std::string* mutable_target();
  std::string* release_target();
  void set_allocated_target(std::string* target);
  private:
  const std::string& _internal_target() const;
  void _internal_set_target(const std::string& value);
  std::string* _internal_mutable_target();
  public:

  // .google.protobuf.BoolValue persistence = 3;
  bool has_persistence() const;
  private:
  bool _internal_has_persistence() const;
  public:
  void clear_persistence();
  const PROTOBUF_NAMESPACE_ID::BoolValue& persistence() const;
  PROTOBUF_NAMESPACE_ID::BoolValue* release_persistence();
  PROTOBUF_NAMESPACE_ID::BoolValue* mutable_persistence();
  void set_allocated_persistence(PROTOBUF_NAMESPACE_ID::BoolValue* persistence);
  private:
  const PROTOBUF_NAMESPACE_ID::BoolValue& _internal_persistence() const;
  PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_persistence();
  public:
  void unsafe_arena_set_allocated_persistence(
      PROTOBUF_NAMESPACE_ID::BoolValue* persistence);
  PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_persistence();

  // .google.protobuf.BoolValue hidden = 4;
  bool has_hidden() const;
  private:
  bool _internal_has_hidden() const;
  public:
  void clear_hidden();
  const PROTOBUF_NAMESPACE_ID::BoolValue& hidden() const;
  PROTOBUF_NAMESPACE_ID::BoolValue* release_hidden();
  PROTOBUF_NAMESPACE_ID::BoolValue* mutable_hidden();
  void set_allocated_hidden(PROTOBUF_NAMESPACE_ID::BoolValue* hidden);
  private:
  const PROTOBUF_NAMESPACE_ID::BoolValue& _internal_hidden() const;
  PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_hidden();
  public:
  void unsafe_arena_set_allocated_hidden(
      PROTOBUF_NAMESPACE_ID::BoolValue* hidden);
  PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_hidden();

  // int32 type = 2;
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::int32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:nakama.realtime.ChannelJoin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_;
  PROTOBUF_NAMESPACE_ID::BoolValue* persistence_;
  PROTOBUF_NAMESPACE_ID::BoolValue* hidden_;
  ::PROTOBUF_NAMESPACE_ID::int32 type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class ChannelLeave PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.ChannelLeave) */ {
 public:
  inline ChannelLeave() : ChannelLeave(nullptr) {}
  virtual ~ChannelLeave();

  ChannelLeave(const ChannelLeave& from);
  ChannelLeave(ChannelLeave&& from) noexcept
    : ChannelLeave() {
    *this = ::std::move(from);
  }

  inline ChannelLeave& operator=(const ChannelLeave& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelLeave& operator=(ChannelLeave&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChannelLeave& default_instance();

  static inline const ChannelLeave* internal_default_instance() {
    return reinterpret_cast<const ChannelLeave*>(
               &_ChannelLeave_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ChannelLeave& a, ChannelLeave& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelLeave* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelLeave* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChannelLeave* New() const final {
    return CreateMaybeMessage<ChannelLeave>(nullptr);
  }

  ChannelLeave* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChannelLeave>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChannelLeave& from);
  void MergeFrom(const ChannelLeave& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelLeave* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.ChannelLeave";
  }
  protected:
  explicit ChannelLeave(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelIdFieldNumber = 1,
  };
  // string channel_id = 1;
  void clear_channel_id();
  const std::string& channel_id() const;
  void set_channel_id(const std::string& value);
  void set_channel_id(std::string&& value);
  void set_channel_id(const char* value);
  void set_channel_id(const char* value, size_t size);
  std::string* mutable_channel_id();
  std::string* release_channel_id();
  void set_allocated_channel_id(std::string* channel_id);
  private:
  const std::string& _internal_channel_id() const;
  void _internal_set_channel_id(const std::string& value);
  std::string* _internal_mutable_channel_id();
  public:

  // @@protoc_insertion_point(class_scope:nakama.realtime.ChannelLeave)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channel_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class ChannelMessageAck PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.ChannelMessageAck) */ {
 public:
  inline ChannelMessageAck() : ChannelMessageAck(nullptr) {}
  virtual ~ChannelMessageAck();

  ChannelMessageAck(const ChannelMessageAck& from);
  ChannelMessageAck(ChannelMessageAck&& from) noexcept
    : ChannelMessageAck() {
    *this = ::std::move(from);
  }

  inline ChannelMessageAck& operator=(const ChannelMessageAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelMessageAck& operator=(ChannelMessageAck&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChannelMessageAck& default_instance();

  static inline const ChannelMessageAck* internal_default_instance() {
    return reinterpret_cast<const ChannelMessageAck*>(
               &_ChannelMessageAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ChannelMessageAck& a, ChannelMessageAck& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelMessageAck* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelMessageAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChannelMessageAck* New() const final {
    return CreateMaybeMessage<ChannelMessageAck>(nullptr);
  }

  ChannelMessageAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChannelMessageAck>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChannelMessageAck& from);
  void MergeFrom(const ChannelMessageAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelMessageAck* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.ChannelMessageAck";
  }
  protected:
  explicit ChannelMessageAck(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelIdFieldNumber = 1,
    kMessageIdFieldNumber = 2,
    kUsernameFieldNumber = 4,
    kRoomNameFieldNumber = 8,
    kGroupIdFieldNumber = 9,
    kUserIdOneFieldNumber = 10,
    kUserIdTwoFieldNumber = 11,
    kCodeFieldNumber = 3,
    kCreateTimeFieldNumber = 5,
    kUpdateTimeFieldNumber = 6,
    kPersistentFieldNumber = 7,
  };
  // string channel_id = 1;
  void clear_channel_id();
  const std::string& channel_id() const;
  void set_channel_id(const std::string& value);
  void set_channel_id(std::string&& value);
  void set_channel_id(const char* value);
  void set_channel_id(const char* value, size_t size);
  std::string* mutable_channel_id();
  std::string* release_channel_id();
  void set_allocated_channel_id(std::string* channel_id);
  private:
  const std::string& _internal_channel_id() const;
  void _internal_set_channel_id(const std::string& value);
  std::string* _internal_mutable_channel_id();
  public:

  // string message_id = 2;
  void clear_message_id();
  const std::string& message_id() const;
  void set_message_id(const std::string& value);
  void set_message_id(std::string&& value);
  void set_message_id(const char* value);
  void set_message_id(const char* value, size_t size);
  std::string* mutable_message_id();
  std::string* release_message_id();
  void set_allocated_message_id(std::string* message_id);
  private:
  const std::string& _internal_message_id() const;
  void _internal_set_message_id(const std::string& value);
  std::string* _internal_mutable_message_id();
  public:

  // string username = 4;
  void clear_username();
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string room_name = 8;
  void clear_room_name();
  const std::string& room_name() const;
  void set_room_name(const std::string& value);
  void set_room_name(std::string&& value);
  void set_room_name(const char* value);
  void set_room_name(const char* value, size_t size);
  std::string* mutable_room_name();
  std::string* release_room_name();
  void set_allocated_room_name(std::string* room_name);
  private:
  const std::string& _internal_room_name() const;
  void _internal_set_room_name(const std::string& value);
  std::string* _internal_mutable_room_name();
  public:

  // string group_id = 9;
  void clear_group_id();
  const std::string& group_id() const;
  void set_group_id(const std::string& value);
  void set_group_id(std::string&& value);
  void set_group_id(const char* value);
  void set_group_id(const char* value, size_t size);
  std::string* mutable_group_id();
  std::string* release_group_id();
  void set_allocated_group_id(std::string* group_id);
  private:
  const std::string& _internal_group_id() const;
  void _internal_set_group_id(const std::string& value);
  std::string* _internal_mutable_group_id();
  public:

  // string user_id_one = 10;
  void clear_user_id_one();
  const std::string& user_id_one() const;
  void set_user_id_one(const std::string& value);
  void set_user_id_one(std::string&& value);
  void set_user_id_one(const char* value);
  void set_user_id_one(const char* value, size_t size);
  std::string* mutable_user_id_one();
  std::string* release_user_id_one();
  void set_allocated_user_id_one(std::string* user_id_one);
  private:
  const std::string& _internal_user_id_one() const;
  void _internal_set_user_id_one(const std::string& value);
  std::string* _internal_mutable_user_id_one();
  public:

  // string user_id_two = 11;
  void clear_user_id_two();
  const std::string& user_id_two() const;
  void set_user_id_two(const std::string& value);
  void set_user_id_two(std::string&& value);
  void set_user_id_two(const char* value);
  void set_user_id_two(const char* value, size_t size);
  std::string* mutable_user_id_two();
  std::string* release_user_id_two();
  void set_allocated_user_id_two(std::string* user_id_two);
  private:
  const std::string& _internal_user_id_two() const;
  void _internal_set_user_id_two(const std::string& value);
  std::string* _internal_mutable_user_id_two();
  public:

  // .google.protobuf.Int32Value code = 3;
  bool has_code() const;
  private:
  bool _internal_has_code() const;
  public:
  void clear_code();
  const PROTOBUF_NAMESPACE_ID::Int32Value& code() const;
  PROTOBUF_NAMESPACE_ID::Int32Value* release_code();
  PROTOBUF_NAMESPACE_ID::Int32Value* mutable_code();
  void set_allocated_code(PROTOBUF_NAMESPACE_ID::Int32Value* code);
  private:
  const PROTOBUF_NAMESPACE_ID::Int32Value& _internal_code() const;
  PROTOBUF_NAMESPACE_ID::Int32Value* _internal_mutable_code();
  public:
  void unsafe_arena_set_allocated_code(
      PROTOBUF_NAMESPACE_ID::Int32Value* code);
  PROTOBUF_NAMESPACE_ID::Int32Value* unsafe_arena_release_code();

  // .google.protobuf.Timestamp create_time = 5;
  bool has_create_time() const;
  private:
  bool _internal_has_create_time() const;
  public:
  void clear_create_time();
  const PROTOBUF_NAMESPACE_ID::Timestamp& create_time() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_create_time();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_create_time();
  void set_allocated_create_time(PROTOBUF_NAMESPACE_ID::Timestamp* create_time);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_create_time() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_create_time();
  public:
  void unsafe_arena_set_allocated_create_time(
      PROTOBUF_NAMESPACE_ID::Timestamp* create_time);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_create_time();

  // .google.protobuf.Timestamp update_time = 6;
  bool has_update_time() const;
  private:
  bool _internal_has_update_time() const;
  public:
  void clear_update_time();
  const PROTOBUF_NAMESPACE_ID::Timestamp& update_time() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_update_time();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_update_time();
  void set_allocated_update_time(PROTOBUF_NAMESPACE_ID::Timestamp* update_time);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_update_time() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_update_time();
  public:
  void unsafe_arena_set_allocated_update_time(
      PROTOBUF_NAMESPACE_ID::Timestamp* update_time);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_update_time();

  // .google.protobuf.BoolValue persistent = 7;
  bool has_persistent() const;
  private:
  bool _internal_has_persistent() const;
  public:
  void clear_persistent();
  const PROTOBUF_NAMESPACE_ID::BoolValue& persistent() const;
  PROTOBUF_NAMESPACE_ID::BoolValue* release_persistent();
  PROTOBUF_NAMESPACE_ID::BoolValue* mutable_persistent();
  void set_allocated_persistent(PROTOBUF_NAMESPACE_ID::BoolValue* persistent);
  private:
  const PROTOBUF_NAMESPACE_ID::BoolValue& _internal_persistent() const;
  PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_persistent();
  public:
  void unsafe_arena_set_allocated_persistent(
      PROTOBUF_NAMESPACE_ID::BoolValue* persistent);
  PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_persistent();

  // @@protoc_insertion_point(class_scope:nakama.realtime.ChannelMessageAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channel_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_one_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_two_;
  PROTOBUF_NAMESPACE_ID::Int32Value* code_;
  PROTOBUF_NAMESPACE_ID::Timestamp* create_time_;
  PROTOBUF_NAMESPACE_ID::Timestamp* update_time_;
  PROTOBUF_NAMESPACE_ID::BoolValue* persistent_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class ChannelMessageSend PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.ChannelMessageSend) */ {
 public:
  inline ChannelMessageSend() : ChannelMessageSend(nullptr) {}
  virtual ~ChannelMessageSend();

  ChannelMessageSend(const ChannelMessageSend& from);
  ChannelMessageSend(ChannelMessageSend&& from) noexcept
    : ChannelMessageSend() {
    *this = ::std::move(from);
  }

  inline ChannelMessageSend& operator=(const ChannelMessageSend& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelMessageSend& operator=(ChannelMessageSend&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChannelMessageSend& default_instance();

  static inline const ChannelMessageSend* internal_default_instance() {
    return reinterpret_cast<const ChannelMessageSend*>(
               &_ChannelMessageSend_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ChannelMessageSend& a, ChannelMessageSend& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelMessageSend* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelMessageSend* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChannelMessageSend* New() const final {
    return CreateMaybeMessage<ChannelMessageSend>(nullptr);
  }

  ChannelMessageSend* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChannelMessageSend>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChannelMessageSend& from);
  void MergeFrom(const ChannelMessageSend& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelMessageSend* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.ChannelMessageSend";
  }
  protected:
  explicit ChannelMessageSend(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelIdFieldNumber = 1,
    kContentFieldNumber = 2,
  };
  // string channel_id = 1;
  void clear_channel_id();
  const std::string& channel_id() const;
  void set_channel_id(const std::string& value);
  void set_channel_id(std::string&& value);
  void set_channel_id(const char* value);
  void set_channel_id(const char* value, size_t size);
  std::string* mutable_channel_id();
  std::string* release_channel_id();
  void set_allocated_channel_id(std::string* channel_id);
  private:
  const std::string& _internal_channel_id() const;
  void _internal_set_channel_id(const std::string& value);
  std::string* _internal_mutable_channel_id();
  public:

  // string content = 2;
  void clear_content();
  const std::string& content() const;
  void set_content(const std::string& value);
  void set_content(std::string&& value);
  void set_content(const char* value);
  void set_content(const char* value, size_t size);
  std::string* mutable_content();
  std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // @@protoc_insertion_point(class_scope:nakama.realtime.ChannelMessageSend)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channel_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class ChannelMessageUpdate PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.ChannelMessageUpdate) */ {
 public:
  inline ChannelMessageUpdate() : ChannelMessageUpdate(nullptr) {}
  virtual ~ChannelMessageUpdate();

  ChannelMessageUpdate(const ChannelMessageUpdate& from);
  ChannelMessageUpdate(ChannelMessageUpdate&& from) noexcept
    : ChannelMessageUpdate() {
    *this = ::std::move(from);
  }

  inline ChannelMessageUpdate& operator=(const ChannelMessageUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelMessageUpdate& operator=(ChannelMessageUpdate&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChannelMessageUpdate& default_instance();

  static inline const ChannelMessageUpdate* internal_default_instance() {
    return reinterpret_cast<const ChannelMessageUpdate*>(
               &_ChannelMessageUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ChannelMessageUpdate& a, ChannelMessageUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelMessageUpdate* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelMessageUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChannelMessageUpdate* New() const final {
    return CreateMaybeMessage<ChannelMessageUpdate>(nullptr);
  }

  ChannelMessageUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChannelMessageUpdate>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChannelMessageUpdate& from);
  void MergeFrom(const ChannelMessageUpdate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelMessageUpdate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.ChannelMessageUpdate";
  }
  protected:
  explicit ChannelMessageUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelIdFieldNumber = 1,
    kMessageIdFieldNumber = 2,
    kContentFieldNumber = 3,
  };
  // string channel_id = 1;
  void clear_channel_id();
  const std::string& channel_id() const;
  void set_channel_id(const std::string& value);
  void set_channel_id(std::string&& value);
  void set_channel_id(const char* value);
  void set_channel_id(const char* value, size_t size);
  std::string* mutable_channel_id();
  std::string* release_channel_id();
  void set_allocated_channel_id(std::string* channel_id);
  private:
  const std::string& _internal_channel_id() const;
  void _internal_set_channel_id(const std::string& value);
  std::string* _internal_mutable_channel_id();
  public:

  // string message_id = 2;
  void clear_message_id();
  const std::string& message_id() const;
  void set_message_id(const std::string& value);
  void set_message_id(std::string&& value);
  void set_message_id(const char* value);
  void set_message_id(const char* value, size_t size);
  std::string* mutable_message_id();
  std::string* release_message_id();
  void set_allocated_message_id(std::string* message_id);
  private:
  const std::string& _internal_message_id() const;
  void _internal_set_message_id(const std::string& value);
  std::string* _internal_mutable_message_id();
  public:

  // string content = 3;
  void clear_content();
  const std::string& content() const;
  void set_content(const std::string& value);
  void set_content(std::string&& value);
  void set_content(const char* value);
  void set_content(const char* value, size_t size);
  std::string* mutable_content();
  std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // @@protoc_insertion_point(class_scope:nakama.realtime.ChannelMessageUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channel_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class ChannelMessageRemove PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.ChannelMessageRemove) */ {
 public:
  inline ChannelMessageRemove() : ChannelMessageRemove(nullptr) {}
  virtual ~ChannelMessageRemove();

  ChannelMessageRemove(const ChannelMessageRemove& from);
  ChannelMessageRemove(ChannelMessageRemove&& from) noexcept
    : ChannelMessageRemove() {
    *this = ::std::move(from);
  }

  inline ChannelMessageRemove& operator=(const ChannelMessageRemove& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelMessageRemove& operator=(ChannelMessageRemove&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChannelMessageRemove& default_instance();

  static inline const ChannelMessageRemove* internal_default_instance() {
    return reinterpret_cast<const ChannelMessageRemove*>(
               &_ChannelMessageRemove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ChannelMessageRemove& a, ChannelMessageRemove& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelMessageRemove* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelMessageRemove* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChannelMessageRemove* New() const final {
    return CreateMaybeMessage<ChannelMessageRemove>(nullptr);
  }

  ChannelMessageRemove* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChannelMessageRemove>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChannelMessageRemove& from);
  void MergeFrom(const ChannelMessageRemove& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelMessageRemove* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.ChannelMessageRemove";
  }
  protected:
  explicit ChannelMessageRemove(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelIdFieldNumber = 1,
    kMessageIdFieldNumber = 2,
  };
  // string channel_id = 1;
  void clear_channel_id();
  const std::string& channel_id() const;
  void set_channel_id(const std::string& value);
  void set_channel_id(std::string&& value);
  void set_channel_id(const char* value);
  void set_channel_id(const char* value, size_t size);
  std::string* mutable_channel_id();
  std::string* release_channel_id();
  void set_allocated_channel_id(std::string* channel_id);
  private:
  const std::string& _internal_channel_id() const;
  void _internal_set_channel_id(const std::string& value);
  std::string* _internal_mutable_channel_id();
  public:

  // string message_id = 2;
  void clear_message_id();
  const std::string& message_id() const;
  void set_message_id(const std::string& value);
  void set_message_id(std::string&& value);
  void set_message_id(const char* value);
  void set_message_id(const char* value, size_t size);
  std::string* mutable_message_id();
  std::string* release_message_id();
  void set_allocated_message_id(std::string* message_id);
  private:
  const std::string& _internal_message_id() const;
  void _internal_set_message_id(const std::string& value);
  std::string* _internal_mutable_message_id();
  public:

  // @@protoc_insertion_point(class_scope:nakama.realtime.ChannelMessageRemove)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channel_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class ChannelPresenceEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.ChannelPresenceEvent) */ {
 public:
  inline ChannelPresenceEvent() : ChannelPresenceEvent(nullptr) {}
  virtual ~ChannelPresenceEvent();

  ChannelPresenceEvent(const ChannelPresenceEvent& from);
  ChannelPresenceEvent(ChannelPresenceEvent&& from) noexcept
    : ChannelPresenceEvent() {
    *this = ::std::move(from);
  }

  inline ChannelPresenceEvent& operator=(const ChannelPresenceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelPresenceEvent& operator=(ChannelPresenceEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChannelPresenceEvent& default_instance();

  static inline const ChannelPresenceEvent* internal_default_instance() {
    return reinterpret_cast<const ChannelPresenceEvent*>(
               &_ChannelPresenceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ChannelPresenceEvent& a, ChannelPresenceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelPresenceEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelPresenceEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChannelPresenceEvent* New() const final {
    return CreateMaybeMessage<ChannelPresenceEvent>(nullptr);
  }

  ChannelPresenceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChannelPresenceEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChannelPresenceEvent& from);
  void MergeFrom(const ChannelPresenceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelPresenceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.ChannelPresenceEvent";
  }
  protected:
  explicit ChannelPresenceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJoinsFieldNumber = 2,
    kLeavesFieldNumber = 3,
    kChannelIdFieldNumber = 1,
    kRoomNameFieldNumber = 4,
    kGroupIdFieldNumber = 5,
    kUserIdOneFieldNumber = 6,
    kUserIdTwoFieldNumber = 7,
  };
  // repeated .nakama.realtime.UserPresence joins = 2;
  int joins_size() const;
  private:
  int _internal_joins_size() const;
  public:
  void clear_joins();
  ::nakama::realtime::UserPresence* mutable_joins(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >*
      mutable_joins();
  private:
  const ::nakama::realtime::UserPresence& _internal_joins(int index) const;
  ::nakama::realtime::UserPresence* _internal_add_joins();
  public:
  const ::nakama::realtime::UserPresence& joins(int index) const;
  ::nakama::realtime::UserPresence* add_joins();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >&
      joins() const;

  // repeated .nakama.realtime.UserPresence leaves = 3;
  int leaves_size() const;
  private:
  int _internal_leaves_size() const;
  public:
  void clear_leaves();
  ::nakama::realtime::UserPresence* mutable_leaves(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >*
      mutable_leaves();
  private:
  const ::nakama::realtime::UserPresence& _internal_leaves(int index) const;
  ::nakama::realtime::UserPresence* _internal_add_leaves();
  public:
  const ::nakama::realtime::UserPresence& leaves(int index) const;
  ::nakama::realtime::UserPresence* add_leaves();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >&
      leaves() const;

  // string channel_id = 1;
  void clear_channel_id();
  const std::string& channel_id() const;
  void set_channel_id(const std::string& value);
  void set_channel_id(std::string&& value);
  void set_channel_id(const char* value);
  void set_channel_id(const char* value, size_t size);
  std::string* mutable_channel_id();
  std::string* release_channel_id();
  void set_allocated_channel_id(std::string* channel_id);
  private:
  const std::string& _internal_channel_id() const;
  void _internal_set_channel_id(const std::string& value);
  std::string* _internal_mutable_channel_id();
  public:

  // string room_name = 4;
  void clear_room_name();
  const std::string& room_name() const;
  void set_room_name(const std::string& value);
  void set_room_name(std::string&& value);
  void set_room_name(const char* value);
  void set_room_name(const char* value, size_t size);
  std::string* mutable_room_name();
  std::string* release_room_name();
  void set_allocated_room_name(std::string* room_name);
  private:
  const std::string& _internal_room_name() const;
  void _internal_set_room_name(const std::string& value);
  std::string* _internal_mutable_room_name();
  public:

  // string group_id = 5;
  void clear_group_id();
  const std::string& group_id() const;
  void set_group_id(const std::string& value);
  void set_group_id(std::string&& value);
  void set_group_id(const char* value);
  void set_group_id(const char* value, size_t size);
  std::string* mutable_group_id();
  std::string* release_group_id();
  void set_allocated_group_id(std::string* group_id);
  private:
  const std::string& _internal_group_id() const;
  void _internal_set_group_id(const std::string& value);
  std::string* _internal_mutable_group_id();
  public:

  // string user_id_one = 6;
  void clear_user_id_one();
  const std::string& user_id_one() const;
  void set_user_id_one(const std::string& value);
  void set_user_id_one(std::string&& value);
  void set_user_id_one(const char* value);
  void set_user_id_one(const char* value, size_t size);
  std::string* mutable_user_id_one();
  std::string* release_user_id_one();
  void set_allocated_user_id_one(std::string* user_id_one);
  private:
  const std::string& _internal_user_id_one() const;
  void _internal_set_user_id_one(const std::string& value);
  std::string* _internal_mutable_user_id_one();
  public:

  // string user_id_two = 7;
  void clear_user_id_two();
  const std::string& user_id_two() const;
  void set_user_id_two(const std::string& value);
  void set_user_id_two(std::string&& value);
  void set_user_id_two(const char* value);
  void set_user_id_two(const char* value, size_t size);
  std::string* mutable_user_id_two();
  std::string* release_user_id_two();
  void set_allocated_user_id_two(std::string* user_id_two);
  private:
  const std::string& _internal_user_id_two() const;
  void _internal_set_user_id_two(const std::string& value);
  std::string* _internal_mutable_user_id_two();
  public:

  // @@protoc_insertion_point(class_scope:nakama.realtime.ChannelPresenceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence > joins_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence > leaves_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channel_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_one_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_two_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class Error_ContextEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Error_ContextEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Error_ContextEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Error_ContextEntry_DoNotUse();
  explicit Error_ContextEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Error_ContextEntry_DoNotUse& other);
  static const Error_ContextEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Error_ContextEntry_DoNotUse*>(&_Error_ContextEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "nakama.realtime.Error.ContextEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "nakama.realtime.Error.ContextEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[9];
  }

  public:
};

// -------------------------------------------------------------------

class Error PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.Error) */ {
 public:
  inline Error() : Error(nullptr) {}
  virtual ~Error();

  Error(const Error& from);
  Error(Error&& from) noexcept
    : Error() {
    *this = ::std::move(from);
  }

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  inline Error& operator=(Error&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Error& default_instance();

  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Error& a, Error& b) {
    a.Swap(&b);
  }
  inline void Swap(Error* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Error* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Error* New() const final {
    return CreateMaybeMessage<Error>(nullptr);
  }

  Error* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Error>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Error* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.Error";
  }
  protected:
  explicit Error(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  typedef Error_Code Code;
  static constexpr Code RUNTIME_EXCEPTION =
    Error_Code_RUNTIME_EXCEPTION;
  static constexpr Code UNRECOGNIZED_PAYLOAD =
    Error_Code_UNRECOGNIZED_PAYLOAD;
  static constexpr Code MISSING_PAYLOAD =
    Error_Code_MISSING_PAYLOAD;
  static constexpr Code BAD_INPUT =
    Error_Code_BAD_INPUT;
  static constexpr Code MATCH_NOT_FOUND =
    Error_Code_MATCH_NOT_FOUND;
  static constexpr Code MATCH_JOIN_REJECTED =
    Error_Code_MATCH_JOIN_REJECTED;
  static constexpr Code RUNTIME_FUNCTION_NOT_FOUND =
    Error_Code_RUNTIME_FUNCTION_NOT_FOUND;
  static constexpr Code RUNTIME_FUNCTION_EXCEPTION =
    Error_Code_RUNTIME_FUNCTION_EXCEPTION;
  static inline bool Code_IsValid(int value) {
    return Error_Code_IsValid(value);
  }
  static constexpr Code Code_MIN =
    Error_Code_Code_MIN;
  static constexpr Code Code_MAX =
    Error_Code_Code_MAX;
  static constexpr int Code_ARRAYSIZE =
    Error_Code_Code_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Code_descriptor() {
    return Error_Code_descriptor();
  }
  template<typename T>
  static inline const std::string& Code_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Code>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Code_Name.");
    return Error_Code_Name(enum_t_value);
  }
  static inline bool Code_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Code* value) {
    return Error_Code_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kContextFieldNumber = 3,
    kMessageFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // map<string, string> context = 3;
  int context_size() const;
  private:
  int _internal_context_size() const;
  public:
  void clear_context();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_context() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_context();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      context() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_context();

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // int32 code = 1;
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:nakama.realtime.Error)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Error_ContextEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> context_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class Match PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.Match) */ {
 public:
  inline Match() : Match(nullptr) {}
  virtual ~Match();

  Match(const Match& from);
  Match(Match&& from) noexcept
    : Match() {
    *this = ::std::move(from);
  }

  inline Match& operator=(const Match& from) {
    CopyFrom(from);
    return *this;
  }
  inline Match& operator=(Match&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Match& default_instance();

  static inline const Match* internal_default_instance() {
    return reinterpret_cast<const Match*>(
               &_Match_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Match& a, Match& b) {
    a.Swap(&b);
  }
  inline void Swap(Match* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Match* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Match* New() const final {
    return CreateMaybeMessage<Match>(nullptr);
  }

  Match* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Match>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Match& from);
  void MergeFrom(const Match& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Match* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.Match";
  }
  protected:
  explicit Match(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPresencesFieldNumber = 5,
    kMatchIdFieldNumber = 1,
    kLabelFieldNumber = 3,
    kSelfFieldNumber = 6,
    kAuthoritativeFieldNumber = 2,
    kSizeFieldNumber = 4,
  };
  // repeated .nakama.realtime.UserPresence presences = 5;
  int presences_size() const;
  private:
  int _internal_presences_size() const;
  public:
  void clear_presences();
  ::nakama::realtime::UserPresence* mutable_presences(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >*
      mutable_presences();
  private:
  const ::nakama::realtime::UserPresence& _internal_presences(int index) const;
  ::nakama::realtime::UserPresence* _internal_add_presences();
  public:
  const ::nakama::realtime::UserPresence& presences(int index) const;
  ::nakama::realtime::UserPresence* add_presences();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >&
      presences() const;

  // string match_id = 1;
  void clear_match_id();
  const std::string& match_id() const;
  void set_match_id(const std::string& value);
  void set_match_id(std::string&& value);
  void set_match_id(const char* value);
  void set_match_id(const char* value, size_t size);
  std::string* mutable_match_id();
  std::string* release_match_id();
  void set_allocated_match_id(std::string* match_id);
  private:
  const std::string& _internal_match_id() const;
  void _internal_set_match_id(const std::string& value);
  std::string* _internal_mutable_match_id();
  public:

  // .google.protobuf.StringValue label = 3;
  bool has_label() const;
  private:
  bool _internal_has_label() const;
  public:
  void clear_label();
  const PROTOBUF_NAMESPACE_ID::StringValue& label() const;
  PROTOBUF_NAMESPACE_ID::StringValue* release_label();
  PROTOBUF_NAMESPACE_ID::StringValue* mutable_label();
  void set_allocated_label(PROTOBUF_NAMESPACE_ID::StringValue* label);
  private:
  const PROTOBUF_NAMESPACE_ID::StringValue& _internal_label() const;
  PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_label();
  public:
  void unsafe_arena_set_allocated_label(
      PROTOBUF_NAMESPACE_ID::StringValue* label);
  PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_label();

  // .nakama.realtime.UserPresence self = 6;
  bool has_self() const;
  private:
  bool _internal_has_self() const;
  public:
  void clear_self();
  const ::nakama::realtime::UserPresence& self() const;
  ::nakama::realtime::UserPresence* release_self();
  ::nakama::realtime::UserPresence* mutable_self();
  void set_allocated_self(::nakama::realtime::UserPresence* self);
  private:
  const ::nakama::realtime::UserPresence& _internal_self() const;
  ::nakama::realtime::UserPresence* _internal_mutable_self();
  public:
  void unsafe_arena_set_allocated_self(
      ::nakama::realtime::UserPresence* self);
  ::nakama::realtime::UserPresence* unsafe_arena_release_self();

  // bool authoritative = 2;
  void clear_authoritative();
  bool authoritative() const;
  void set_authoritative(bool value);
  private:
  bool _internal_authoritative() const;
  void _internal_set_authoritative(bool value);
  public:

  // int32 size = 4;
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::int32 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_size() const;
  void _internal_set_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:nakama.realtime.Match)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence > presences_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr match_id_;
  PROTOBUF_NAMESPACE_ID::StringValue* label_;
  ::nakama::realtime::UserPresence* self_;
  bool authoritative_;
  ::PROTOBUF_NAMESPACE_ID::int32 size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class MatchCreate PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.MatchCreate) */ {
 public:
  inline MatchCreate() : MatchCreate(nullptr) {}
  virtual ~MatchCreate();

  MatchCreate(const MatchCreate& from);
  MatchCreate(MatchCreate&& from) noexcept
    : MatchCreate() {
    *this = ::std::move(from);
  }

  inline MatchCreate& operator=(const MatchCreate& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatchCreate& operator=(MatchCreate&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MatchCreate& default_instance();

  static inline const MatchCreate* internal_default_instance() {
    return reinterpret_cast<const MatchCreate*>(
               &_MatchCreate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(MatchCreate& a, MatchCreate& b) {
    a.Swap(&b);
  }
  inline void Swap(MatchCreate* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatchCreate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MatchCreate* New() const final {
    return CreateMaybeMessage<MatchCreate>(nullptr);
  }

  MatchCreate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MatchCreate>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MatchCreate& from);
  void MergeFrom(const MatchCreate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchCreate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.MatchCreate";
  }
  protected:
  explicit MatchCreate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:nakama.realtime.MatchCreate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class MatchData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.MatchData) */ {
 public:
  inline MatchData() : MatchData(nullptr) {}
  virtual ~MatchData();

  MatchData(const MatchData& from);
  MatchData(MatchData&& from) noexcept
    : MatchData() {
    *this = ::std::move(from);
  }

  inline MatchData& operator=(const MatchData& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatchData& operator=(MatchData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MatchData& default_instance();

  static inline const MatchData* internal_default_instance() {
    return reinterpret_cast<const MatchData*>(
               &_MatchData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(MatchData& a, MatchData& b) {
    a.Swap(&b);
  }
  inline void Swap(MatchData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatchData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MatchData* New() const final {
    return CreateMaybeMessage<MatchData>(nullptr);
  }

  MatchData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MatchData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MatchData& from);
  void MergeFrom(const MatchData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.MatchData";
  }
  protected:
  explicit MatchData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMatchIdFieldNumber = 1,
    kDataFieldNumber = 4,
    kPresenceFieldNumber = 2,
    kOpCodeFieldNumber = 3,
    kReliableFieldNumber = 5,
  };
  // string match_id = 1;
  void clear_match_id();
  const std::string& match_id() const;
  void set_match_id(const std::string& value);
  void set_match_id(std::string&& value);
  void set_match_id(const char* value);
  void set_match_id(const char* value, size_t size);
  std::string* mutable_match_id();
  std::string* release_match_id();
  void set_allocated_match_id(std::string* match_id);
  private:
  const std::string& _internal_match_id() const;
  void _internal_set_match_id(const std::string& value);
  std::string* _internal_mutable_match_id();
  public:

  // bytes data = 4;
  void clear_data();
  const std::string& data() const;
  void set_data(const std::string& value);
  void set_data(std::string&& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  std::string* mutable_data();
  std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .nakama.realtime.UserPresence presence = 2;
  bool has_presence() const;
  private:
  bool _internal_has_presence() const;
  public:
  void clear_presence();
  const ::nakama::realtime::UserPresence& presence() const;
  ::nakama::realtime::UserPresence* release_presence();
  ::nakama::realtime::UserPresence* mutable_presence();
  void set_allocated_presence(::nakama::realtime::UserPresence* presence);
  private:
  const ::nakama::realtime::UserPresence& _internal_presence() const;
  ::nakama::realtime::UserPresence* _internal_mutable_presence();
  public:
  void unsafe_arena_set_allocated_presence(
      ::nakama::realtime::UserPresence* presence);
  ::nakama::realtime::UserPresence* unsafe_arena_release_presence();

  // int64 op_code = 3;
  void clear_op_code();
  ::PROTOBUF_NAMESPACE_ID::int64 op_code() const;
  void set_op_code(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_op_code() const;
  void _internal_set_op_code(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // bool reliable = 5;
  void clear_reliable();
  bool reliable() const;
  void set_reliable(bool value);
  private:
  bool _internal_reliable() const;
  void _internal_set_reliable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:nakama.realtime.MatchData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr match_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::nakama::realtime::UserPresence* presence_;
  ::PROTOBUF_NAMESPACE_ID::int64 op_code_;
  bool reliable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class MatchDataSend PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.MatchDataSend) */ {
 public:
  inline MatchDataSend() : MatchDataSend(nullptr) {}
  virtual ~MatchDataSend();

  MatchDataSend(const MatchDataSend& from);
  MatchDataSend(MatchDataSend&& from) noexcept
    : MatchDataSend() {
    *this = ::std::move(from);
  }

  inline MatchDataSend& operator=(const MatchDataSend& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatchDataSend& operator=(MatchDataSend&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MatchDataSend& default_instance();

  static inline const MatchDataSend* internal_default_instance() {
    return reinterpret_cast<const MatchDataSend*>(
               &_MatchDataSend_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(MatchDataSend& a, MatchDataSend& b) {
    a.Swap(&b);
  }
  inline void Swap(MatchDataSend* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatchDataSend* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MatchDataSend* New() const final {
    return CreateMaybeMessage<MatchDataSend>(nullptr);
  }

  MatchDataSend* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MatchDataSend>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MatchDataSend& from);
  void MergeFrom(const MatchDataSend& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchDataSend* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.MatchDataSend";
  }
  protected:
  explicit MatchDataSend(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPresencesFieldNumber = 4,
    kMatchIdFieldNumber = 1,
    kDataFieldNumber = 3,
    kOpCodeFieldNumber = 2,
    kReliableFieldNumber = 5,
  };
  // repeated .nakama.realtime.UserPresence presences = 4;
  int presences_size() const;
  private:
  int _internal_presences_size() const;
  public:
  void clear_presences();
  ::nakama::realtime::UserPresence* mutable_presences(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >*
      mutable_presences();
  private:
  const ::nakama::realtime::UserPresence& _internal_presences(int index) const;
  ::nakama::realtime::UserPresence* _internal_add_presences();
  public:
  const ::nakama::realtime::UserPresence& presences(int index) const;
  ::nakama::realtime::UserPresence* add_presences();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >&
      presences() const;

  // string match_id = 1;
  void clear_match_id();
  const std::string& match_id() const;
  void set_match_id(const std::string& value);
  void set_match_id(std::string&& value);
  void set_match_id(const char* value);
  void set_match_id(const char* value, size_t size);
  std::string* mutable_match_id();
  std::string* release_match_id();
  void set_allocated_match_id(std::string* match_id);
  private:
  const std::string& _internal_match_id() const;
  void _internal_set_match_id(const std::string& value);
  std::string* _internal_mutable_match_id();
  public:

  // bytes data = 3;
  void clear_data();
  const std::string& data() const;
  void set_data(const std::string& value);
  void set_data(std::string&& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  std::string* mutable_data();
  std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // int64 op_code = 2;
  void clear_op_code();
  ::PROTOBUF_NAMESPACE_ID::int64 op_code() const;
  void set_op_code(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_op_code() const;
  void _internal_set_op_code(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // bool reliable = 5;
  void clear_reliable();
  bool reliable() const;
  void set_reliable(bool value);
  private:
  bool _internal_reliable() const;
  void _internal_set_reliable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:nakama.realtime.MatchDataSend)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence > presences_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr match_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::int64 op_code_;
  bool reliable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class MatchJoin_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MatchJoin_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MatchJoin_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  MatchJoin_MetadataEntry_DoNotUse();
  explicit MatchJoin_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const MatchJoin_MetadataEntry_DoNotUse& other);
  static const MatchJoin_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MatchJoin_MetadataEntry_DoNotUse*>(&_MatchJoin_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "nakama.realtime.MatchJoin.MetadataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "nakama.realtime.MatchJoin.MetadataEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[15];
  }

  public:
};

// -------------------------------------------------------------------

class MatchJoin PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.MatchJoin) */ {
 public:
  inline MatchJoin() : MatchJoin(nullptr) {}
  virtual ~MatchJoin();

  MatchJoin(const MatchJoin& from);
  MatchJoin(MatchJoin&& from) noexcept
    : MatchJoin() {
    *this = ::std::move(from);
  }

  inline MatchJoin& operator=(const MatchJoin& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatchJoin& operator=(MatchJoin&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MatchJoin& default_instance();

  enum IdCase {
    kMatchId = 1,
    kToken = 2,
    ID_NOT_SET = 0,
  };

  static inline const MatchJoin* internal_default_instance() {
    return reinterpret_cast<const MatchJoin*>(
               &_MatchJoin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(MatchJoin& a, MatchJoin& b) {
    a.Swap(&b);
  }
  inline void Swap(MatchJoin* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatchJoin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MatchJoin* New() const final {
    return CreateMaybeMessage<MatchJoin>(nullptr);
  }

  MatchJoin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MatchJoin>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MatchJoin& from);
  void MergeFrom(const MatchJoin& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchJoin* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.MatchJoin";
  }
  protected:
  explicit MatchJoin(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 3,
    kMatchIdFieldNumber = 1,
    kTokenFieldNumber = 2,
  };
  // map<string, string> metadata = 3;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_metadata();

  // string match_id = 1;
  private:
  bool _internal_has_match_id() const;
  public:
  void clear_match_id();
  const std::string& match_id() const;
  void set_match_id(const std::string& value);
  void set_match_id(std::string&& value);
  void set_match_id(const char* value);
  void set_match_id(const char* value, size_t size);
  std::string* mutable_match_id();
  std::string* release_match_id();
  void set_allocated_match_id(std::string* match_id);
  private:
  const std::string& _internal_match_id() const;
  void _internal_set_match_id(const std::string& value);
  std::string* _internal_mutable_match_id();
  public:

  // string token = 2;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const std::string& token() const;
  void set_token(const std::string& value);
  void set_token(std::string&& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  std::string* mutable_token();
  std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  void clear_id();
  IdCase id_case() const;
  // @@protoc_insertion_point(class_scope:nakama.realtime.MatchJoin)
 private:
  class _Internal;
  void set_has_match_id();
  void set_has_token();

  inline bool has_id() const;
  inline void clear_has_id();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      MatchJoin_MetadataEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> metadata_;
  union IdUnion {
    IdUnion() {}
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr match_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  } id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class MatchLeave PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.MatchLeave) */ {
 public:
  inline MatchLeave() : MatchLeave(nullptr) {}
  virtual ~MatchLeave();

  MatchLeave(const MatchLeave& from);
  MatchLeave(MatchLeave&& from) noexcept
    : MatchLeave() {
    *this = ::std::move(from);
  }

  inline MatchLeave& operator=(const MatchLeave& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatchLeave& operator=(MatchLeave&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MatchLeave& default_instance();

  static inline const MatchLeave* internal_default_instance() {
    return reinterpret_cast<const MatchLeave*>(
               &_MatchLeave_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(MatchLeave& a, MatchLeave& b) {
    a.Swap(&b);
  }
  inline void Swap(MatchLeave* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatchLeave* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MatchLeave* New() const final {
    return CreateMaybeMessage<MatchLeave>(nullptr);
  }

  MatchLeave* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MatchLeave>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MatchLeave& from);
  void MergeFrom(const MatchLeave& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchLeave* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.MatchLeave";
  }
  protected:
  explicit MatchLeave(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMatchIdFieldNumber = 1,
  };
  // string match_id = 1;
  void clear_match_id();
  const std::string& match_id() const;
  void set_match_id(const std::string& value);
  void set_match_id(std::string&& value);
  void set_match_id(const char* value);
  void set_match_id(const char* value, size_t size);
  std::string* mutable_match_id();
  std::string* release_match_id();
  void set_allocated_match_id(std::string* match_id);
  private:
  const std::string& _internal_match_id() const;
  void _internal_set_match_id(const std::string& value);
  std::string* _internal_mutable_match_id();
  public:

  // @@protoc_insertion_point(class_scope:nakama.realtime.MatchLeave)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr match_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class MatchPresenceEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.MatchPresenceEvent) */ {
 public:
  inline MatchPresenceEvent() : MatchPresenceEvent(nullptr) {}
  virtual ~MatchPresenceEvent();

  MatchPresenceEvent(const MatchPresenceEvent& from);
  MatchPresenceEvent(MatchPresenceEvent&& from) noexcept
    : MatchPresenceEvent() {
    *this = ::std::move(from);
  }

  inline MatchPresenceEvent& operator=(const MatchPresenceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatchPresenceEvent& operator=(MatchPresenceEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MatchPresenceEvent& default_instance();

  static inline const MatchPresenceEvent* internal_default_instance() {
    return reinterpret_cast<const MatchPresenceEvent*>(
               &_MatchPresenceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(MatchPresenceEvent& a, MatchPresenceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MatchPresenceEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatchPresenceEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MatchPresenceEvent* New() const final {
    return CreateMaybeMessage<MatchPresenceEvent>(nullptr);
  }

  MatchPresenceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MatchPresenceEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MatchPresenceEvent& from);
  void MergeFrom(const MatchPresenceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchPresenceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.MatchPresenceEvent";
  }
  protected:
  explicit MatchPresenceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJoinsFieldNumber = 2,
    kLeavesFieldNumber = 3,
    kMatchIdFieldNumber = 1,
  };
  // repeated .nakama.realtime.UserPresence joins = 2;
  int joins_size() const;
  private:
  int _internal_joins_size() const;
  public:
  void clear_joins();
  ::nakama::realtime::UserPresence* mutable_joins(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >*
      mutable_joins();
  private:
  const ::nakama::realtime::UserPresence& _internal_joins(int index) const;
  ::nakama::realtime::UserPresence* _internal_add_joins();
  public:
  const ::nakama::realtime::UserPresence& joins(int index) const;
  ::nakama::realtime::UserPresence* add_joins();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >&
      joins() const;

  // repeated .nakama.realtime.UserPresence leaves = 3;
  int leaves_size() const;
  private:
  int _internal_leaves_size() const;
  public:
  void clear_leaves();
  ::nakama::realtime::UserPresence* mutable_leaves(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >*
      mutable_leaves();
  private:
  const ::nakama::realtime::UserPresence& _internal_leaves(int index) const;
  ::nakama::realtime::UserPresence* _internal_add_leaves();
  public:
  const ::nakama::realtime::UserPresence& leaves(int index) const;
  ::nakama::realtime::UserPresence* add_leaves();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >&
      leaves() const;

  // string match_id = 1;
  void clear_match_id();
  const std::string& match_id() const;
  void set_match_id(const std::string& value);
  void set_match_id(std::string&& value);
  void set_match_id(const char* value);
  void set_match_id(const char* value, size_t size);
  std::string* mutable_match_id();
  std::string* release_match_id();
  void set_allocated_match_id(std::string* match_id);
  private:
  const std::string& _internal_match_id() const;
  void _internal_set_match_id(const std::string& value);
  std::string* _internal_mutable_match_id();
  public:

  // @@protoc_insertion_point(class_scope:nakama.realtime.MatchPresenceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence > joins_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence > leaves_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr match_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class MatchmakerAdd_StringPropertiesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MatchmakerAdd_StringPropertiesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MatchmakerAdd_StringPropertiesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  MatchmakerAdd_StringPropertiesEntry_DoNotUse();
  explicit MatchmakerAdd_StringPropertiesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const MatchmakerAdd_StringPropertiesEntry_DoNotUse& other);
  static const MatchmakerAdd_StringPropertiesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MatchmakerAdd_StringPropertiesEntry_DoNotUse*>(&_MatchmakerAdd_StringPropertiesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "nakama.realtime.MatchmakerAdd.StringPropertiesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "nakama.realtime.MatchmakerAdd.StringPropertiesEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[19];
  }

  public:
};

// -------------------------------------------------------------------

class MatchmakerAdd_NumericPropertiesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MatchmakerAdd_NumericPropertiesEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MatchmakerAdd_NumericPropertiesEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> SuperType;
  MatchmakerAdd_NumericPropertiesEntry_DoNotUse();
  explicit MatchmakerAdd_NumericPropertiesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const MatchmakerAdd_NumericPropertiesEntry_DoNotUse& other);
  static const MatchmakerAdd_NumericPropertiesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MatchmakerAdd_NumericPropertiesEntry_DoNotUse*>(&_MatchmakerAdd_NumericPropertiesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "nakama.realtime.MatchmakerAdd.NumericPropertiesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[20];
  }

  public:
};

// -------------------------------------------------------------------

class MatchmakerAdd PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.MatchmakerAdd) */ {
 public:
  inline MatchmakerAdd() : MatchmakerAdd(nullptr) {}
  virtual ~MatchmakerAdd();

  MatchmakerAdd(const MatchmakerAdd& from);
  MatchmakerAdd(MatchmakerAdd&& from) noexcept
    : MatchmakerAdd() {
    *this = ::std::move(from);
  }

  inline MatchmakerAdd& operator=(const MatchmakerAdd& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatchmakerAdd& operator=(MatchmakerAdd&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MatchmakerAdd& default_instance();

  static inline const MatchmakerAdd* internal_default_instance() {
    return reinterpret_cast<const MatchmakerAdd*>(
               &_MatchmakerAdd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(MatchmakerAdd& a, MatchmakerAdd& b) {
    a.Swap(&b);
  }
  inline void Swap(MatchmakerAdd* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatchmakerAdd* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MatchmakerAdd* New() const final {
    return CreateMaybeMessage<MatchmakerAdd>(nullptr);
  }

  MatchmakerAdd* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MatchmakerAdd>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MatchmakerAdd& from);
  void MergeFrom(const MatchmakerAdd& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchmakerAdd* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.MatchmakerAdd";
  }
  protected:
  explicit MatchmakerAdd(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kStringPropertiesFieldNumber = 4,
    kNumericPropertiesFieldNumber = 5,
    kQueryFieldNumber = 3,
    kCountMultipleFieldNumber = 6,
    kMinCountFieldNumber = 1,
    kMaxCountFieldNumber = 2,
  };
  // map<string, string> string_properties = 4;
  int string_properties_size() const;
  private:
  int _internal_string_properties_size() const;
  public:
  void clear_string_properties();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_string_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_string_properties();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      string_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_string_properties();

  // map<string, double> numeric_properties = 5;
  int numeric_properties_size() const;
  private:
  int _internal_numeric_properties_size() const;
  public:
  void clear_numeric_properties();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_numeric_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_numeric_properties();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      numeric_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_numeric_properties();

  // string query = 3;
  void clear_query();
  const std::string& query() const;
  void set_query(const std::string& value);
  void set_query(std::string&& value);
  void set_query(const char* value);
  void set_query(const char* value, size_t size);
  std::string* mutable_query();
  std::string* release_query();
  void set_allocated_query(std::string* query);
  private:
  const std::string& _internal_query() const;
  void _internal_set_query(const std::string& value);
  std::string* _internal_mutable_query();
  public:

  // .google.protobuf.Int32Value count_multiple = 6;
  bool has_count_multiple() const;
  private:
  bool _internal_has_count_multiple() const;
  public:
  void clear_count_multiple();
  const PROTOBUF_NAMESPACE_ID::Int32Value& count_multiple() const;
  PROTOBUF_NAMESPACE_ID::Int32Value* release_count_multiple();
  PROTOBUF_NAMESPACE_ID::Int32Value* mutable_count_multiple();
  void set_allocated_count_multiple(PROTOBUF_NAMESPACE_ID::Int32Value* count_multiple);
  private:
  const PROTOBUF_NAMESPACE_ID::Int32Value& _internal_count_multiple() const;
  PROTOBUF_NAMESPACE_ID::Int32Value* _internal_mutable_count_multiple();
  public:
  void unsafe_arena_set_allocated_count_multiple(
      PROTOBUF_NAMESPACE_ID::Int32Value* count_multiple);
  PROTOBUF_NAMESPACE_ID::Int32Value* unsafe_arena_release_count_multiple();

  // int32 min_count = 1;
  void clear_min_count();
  ::PROTOBUF_NAMESPACE_ID::int32 min_count() const;
  void set_min_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_min_count() const;
  void _internal_set_min_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 max_count = 2;
  void clear_max_count();
  ::PROTOBUF_NAMESPACE_ID::int32 max_count() const;
  void set_max_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_max_count() const;
  void _internal_set_max_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:nakama.realtime.MatchmakerAdd)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      MatchmakerAdd_StringPropertiesEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> string_properties_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      MatchmakerAdd_NumericPropertiesEntry_DoNotUse,
      std::string, double,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> numeric_properties_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr query_;
  PROTOBUF_NAMESPACE_ID::Int32Value* count_multiple_;
  ::PROTOBUF_NAMESPACE_ID::int32 min_count_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class MatchmakerMatched_MatchmakerUser_StringPropertiesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MatchmakerMatched_MatchmakerUser_StringPropertiesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MatchmakerMatched_MatchmakerUser_StringPropertiesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  MatchmakerMatched_MatchmakerUser_StringPropertiesEntry_DoNotUse();
  explicit MatchmakerMatched_MatchmakerUser_StringPropertiesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const MatchmakerMatched_MatchmakerUser_StringPropertiesEntry_DoNotUse& other);
  static const MatchmakerMatched_MatchmakerUser_StringPropertiesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MatchmakerMatched_MatchmakerUser_StringPropertiesEntry_DoNotUse*>(&_MatchmakerMatched_MatchmakerUser_StringPropertiesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "nakama.realtime.MatchmakerMatched.MatchmakerUser.StringPropertiesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "nakama.realtime.MatchmakerMatched.MatchmakerUser.StringPropertiesEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[22];
  }

  public:
};

// -------------------------------------------------------------------

class MatchmakerMatched_MatchmakerUser_NumericPropertiesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MatchmakerMatched_MatchmakerUser_NumericPropertiesEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MatchmakerMatched_MatchmakerUser_NumericPropertiesEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> SuperType;
  MatchmakerMatched_MatchmakerUser_NumericPropertiesEntry_DoNotUse();
  explicit MatchmakerMatched_MatchmakerUser_NumericPropertiesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const MatchmakerMatched_MatchmakerUser_NumericPropertiesEntry_DoNotUse& other);
  static const MatchmakerMatched_MatchmakerUser_NumericPropertiesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MatchmakerMatched_MatchmakerUser_NumericPropertiesEntry_DoNotUse*>(&_MatchmakerMatched_MatchmakerUser_NumericPropertiesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "nakama.realtime.MatchmakerMatched.MatchmakerUser.NumericPropertiesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[23];
  }

  public:
};

// -------------------------------------------------------------------

class MatchmakerMatched_MatchmakerUser PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.MatchmakerMatched.MatchmakerUser) */ {
 public:
  inline MatchmakerMatched_MatchmakerUser() : MatchmakerMatched_MatchmakerUser(nullptr) {}
  virtual ~MatchmakerMatched_MatchmakerUser();

  MatchmakerMatched_MatchmakerUser(const MatchmakerMatched_MatchmakerUser& from);
  MatchmakerMatched_MatchmakerUser(MatchmakerMatched_MatchmakerUser&& from) noexcept
    : MatchmakerMatched_MatchmakerUser() {
    *this = ::std::move(from);
  }

  inline MatchmakerMatched_MatchmakerUser& operator=(const MatchmakerMatched_MatchmakerUser& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatchmakerMatched_MatchmakerUser& operator=(MatchmakerMatched_MatchmakerUser&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MatchmakerMatched_MatchmakerUser& default_instance();

  static inline const MatchmakerMatched_MatchmakerUser* internal_default_instance() {
    return reinterpret_cast<const MatchmakerMatched_MatchmakerUser*>(
               &_MatchmakerMatched_MatchmakerUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(MatchmakerMatched_MatchmakerUser& a, MatchmakerMatched_MatchmakerUser& b) {
    a.Swap(&b);
  }
  inline void Swap(MatchmakerMatched_MatchmakerUser* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatchmakerMatched_MatchmakerUser* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MatchmakerMatched_MatchmakerUser* New() const final {
    return CreateMaybeMessage<MatchmakerMatched_MatchmakerUser>(nullptr);
  }

  MatchmakerMatched_MatchmakerUser* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MatchmakerMatched_MatchmakerUser>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MatchmakerMatched_MatchmakerUser& from);
  void MergeFrom(const MatchmakerMatched_MatchmakerUser& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchmakerMatched_MatchmakerUser* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.MatchmakerMatched.MatchmakerUser";
  }
  protected:
  explicit MatchmakerMatched_MatchmakerUser(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kStringPropertiesFieldNumber = 5,
    kNumericPropertiesFieldNumber = 6,
    kPartyIdFieldNumber = 2,
    kPresenceFieldNumber = 1,
  };
  // map<string, string> string_properties = 5;
  int string_properties_size() const;
  private:
  int _internal_string_properties_size() const;
  public:
  void clear_string_properties();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_string_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_string_properties();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      string_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_string_properties();

  // map<string, double> numeric_properties = 6;
  int numeric_properties_size() const;
  private:
  int _internal_numeric_properties_size() const;
  public:
  void clear_numeric_properties();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_numeric_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_numeric_properties();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      numeric_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_numeric_properties();

  // string party_id = 2;
  void clear_party_id();
  const std::string& party_id() const;
  void set_party_id(const std::string& value);
  void set_party_id(std::string&& value);
  void set_party_id(const char* value);
  void set_party_id(const char* value, size_t size);
  std::string* mutable_party_id();
  std::string* release_party_id();
  void set_allocated_party_id(std::string* party_id);
  private:
  const std::string& _internal_party_id() const;
  void _internal_set_party_id(const std::string& value);
  std::string* _internal_mutable_party_id();
  public:

  // .nakama.realtime.UserPresence presence = 1;
  bool has_presence() const;
  private:
  bool _internal_has_presence() const;
  public:
  void clear_presence();
  const ::nakama::realtime::UserPresence& presence() const;
  ::nakama::realtime::UserPresence* release_presence();
  ::nakama::realtime::UserPresence* mutable_presence();
  void set_allocated_presence(::nakama::realtime::UserPresence* presence);
  private:
  const ::nakama::realtime::UserPresence& _internal_presence() const;
  ::nakama::realtime::UserPresence* _internal_mutable_presence();
  public:
  void unsafe_arena_set_allocated_presence(
      ::nakama::realtime::UserPresence* presence);
  ::nakama::realtime::UserPresence* unsafe_arena_release_presence();

  // @@protoc_insertion_point(class_scope:nakama.realtime.MatchmakerMatched.MatchmakerUser)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      MatchmakerMatched_MatchmakerUser_StringPropertiesEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> string_properties_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      MatchmakerMatched_MatchmakerUser_NumericPropertiesEntry_DoNotUse,
      std::string, double,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> numeric_properties_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr party_id_;
  ::nakama::realtime::UserPresence* presence_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class MatchmakerMatched PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.MatchmakerMatched) */ {
 public:
  inline MatchmakerMatched() : MatchmakerMatched(nullptr) {}
  virtual ~MatchmakerMatched();

  MatchmakerMatched(const MatchmakerMatched& from);
  MatchmakerMatched(MatchmakerMatched&& from) noexcept
    : MatchmakerMatched() {
    *this = ::std::move(from);
  }

  inline MatchmakerMatched& operator=(const MatchmakerMatched& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatchmakerMatched& operator=(MatchmakerMatched&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MatchmakerMatched& default_instance();

  enum IdCase {
    kMatchId = 2,
    kToken = 3,
    ID_NOT_SET = 0,
  };

  static inline const MatchmakerMatched* internal_default_instance() {
    return reinterpret_cast<const MatchmakerMatched*>(
               &_MatchmakerMatched_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(MatchmakerMatched& a, MatchmakerMatched& b) {
    a.Swap(&b);
  }
  inline void Swap(MatchmakerMatched* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatchmakerMatched* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MatchmakerMatched* New() const final {
    return CreateMaybeMessage<MatchmakerMatched>(nullptr);
  }

  MatchmakerMatched* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MatchmakerMatched>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MatchmakerMatched& from);
  void MergeFrom(const MatchmakerMatched& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchmakerMatched* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.MatchmakerMatched";
  }
  protected:
  explicit MatchmakerMatched(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef MatchmakerMatched_MatchmakerUser MatchmakerUser;

  // accessors -------------------------------------------------------

  enum : int {
    kUsersFieldNumber = 4,
    kTicketFieldNumber = 1,
    kSelfFieldNumber = 5,
    kMatchIdFieldNumber = 2,
    kTokenFieldNumber = 3,
  };
  // repeated .nakama.realtime.MatchmakerMatched.MatchmakerUser users = 4;
  int users_size() const;
  private:
  int _internal_users_size() const;
  public:
  void clear_users();
  ::nakama::realtime::MatchmakerMatched_MatchmakerUser* mutable_users(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::MatchmakerMatched_MatchmakerUser >*
      mutable_users();
  private:
  const ::nakama::realtime::MatchmakerMatched_MatchmakerUser& _internal_users(int index) const;
  ::nakama::realtime::MatchmakerMatched_MatchmakerUser* _internal_add_users();
  public:
  const ::nakama::realtime::MatchmakerMatched_MatchmakerUser& users(int index) const;
  ::nakama::realtime::MatchmakerMatched_MatchmakerUser* add_users();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::MatchmakerMatched_MatchmakerUser >&
      users() const;

  // string ticket = 1;
  void clear_ticket();
  const std::string& ticket() const;
  void set_ticket(const std::string& value);
  void set_ticket(std::string&& value);
  void set_ticket(const char* value);
  void set_ticket(const char* value, size_t size);
  std::string* mutable_ticket();
  std::string* release_ticket();
  void set_allocated_ticket(std::string* ticket);
  private:
  const std::string& _internal_ticket() const;
  void _internal_set_ticket(const std::string& value);
  std::string* _internal_mutable_ticket();
  public:

  // .nakama.realtime.MatchmakerMatched.MatchmakerUser self = 5;
  bool has_self() const;
  private:
  bool _internal_has_self() const;
  public:
  void clear_self();
  const ::nakama::realtime::MatchmakerMatched_MatchmakerUser& self() const;
  ::nakama::realtime::MatchmakerMatched_MatchmakerUser* release_self();
  ::nakama::realtime::MatchmakerMatched_MatchmakerUser* mutable_self();
  void set_allocated_self(::nakama::realtime::MatchmakerMatched_MatchmakerUser* self);
  private:
  const ::nakama::realtime::MatchmakerMatched_MatchmakerUser& _internal_self() const;
  ::nakama::realtime::MatchmakerMatched_MatchmakerUser* _internal_mutable_self();
  public:
  void unsafe_arena_set_allocated_self(
      ::nakama::realtime::MatchmakerMatched_MatchmakerUser* self);
  ::nakama::realtime::MatchmakerMatched_MatchmakerUser* unsafe_arena_release_self();

  // string match_id = 2;
  private:
  bool _internal_has_match_id() const;
  public:
  void clear_match_id();
  const std::string& match_id() const;
  void set_match_id(const std::string& value);
  void set_match_id(std::string&& value);
  void set_match_id(const char* value);
  void set_match_id(const char* value, size_t size);
  std::string* mutable_match_id();
  std::string* release_match_id();
  void set_allocated_match_id(std::string* match_id);
  private:
  const std::string& _internal_match_id() const;
  void _internal_set_match_id(const std::string& value);
  std::string* _internal_mutable_match_id();
  public:

  // string token = 3;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const std::string& token() const;
  void set_token(const std::string& value);
  void set_token(std::string&& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  std::string* mutable_token();
  std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  void clear_id();
  IdCase id_case() const;
  // @@protoc_insertion_point(class_scope:nakama.realtime.MatchmakerMatched)
 private:
  class _Internal;
  void set_has_match_id();
  void set_has_token();

  inline bool has_id() const;
  inline void clear_has_id();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::MatchmakerMatched_MatchmakerUser > users_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ticket_;
  ::nakama::realtime::MatchmakerMatched_MatchmakerUser* self_;
  union IdUnion {
    IdUnion() {}
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr match_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  } id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class MatchmakerRemove PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.MatchmakerRemove) */ {
 public:
  inline MatchmakerRemove() : MatchmakerRemove(nullptr) {}
  virtual ~MatchmakerRemove();

  MatchmakerRemove(const MatchmakerRemove& from);
  MatchmakerRemove(MatchmakerRemove&& from) noexcept
    : MatchmakerRemove() {
    *this = ::std::move(from);
  }

  inline MatchmakerRemove& operator=(const MatchmakerRemove& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatchmakerRemove& operator=(MatchmakerRemove&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MatchmakerRemove& default_instance();

  static inline const MatchmakerRemove* internal_default_instance() {
    return reinterpret_cast<const MatchmakerRemove*>(
               &_MatchmakerRemove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(MatchmakerRemove& a, MatchmakerRemove& b) {
    a.Swap(&b);
  }
  inline void Swap(MatchmakerRemove* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatchmakerRemove* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MatchmakerRemove* New() const final {
    return CreateMaybeMessage<MatchmakerRemove>(nullptr);
  }

  MatchmakerRemove* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MatchmakerRemove>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MatchmakerRemove& from);
  void MergeFrom(const MatchmakerRemove& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchmakerRemove* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.MatchmakerRemove";
  }
  protected:
  explicit MatchmakerRemove(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTicketFieldNumber = 1,
  };
  // string ticket = 1;
  void clear_ticket();
  const std::string& ticket() const;
  void set_ticket(const std::string& value);
  void set_ticket(std::string&& value);
  void set_ticket(const char* value);
  void set_ticket(const char* value, size_t size);
  std::string* mutable_ticket();
  std::string* release_ticket();
  void set_allocated_ticket(std::string* ticket);
  private:
  const std::string& _internal_ticket() const;
  void _internal_set_ticket(const std::string& value);
  std::string* _internal_mutable_ticket();
  public:

  // @@protoc_insertion_point(class_scope:nakama.realtime.MatchmakerRemove)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ticket_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class MatchmakerTicket PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.MatchmakerTicket) */ {
 public:
  inline MatchmakerTicket() : MatchmakerTicket(nullptr) {}
  virtual ~MatchmakerTicket();

  MatchmakerTicket(const MatchmakerTicket& from);
  MatchmakerTicket(MatchmakerTicket&& from) noexcept
    : MatchmakerTicket() {
    *this = ::std::move(from);
  }

  inline MatchmakerTicket& operator=(const MatchmakerTicket& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatchmakerTicket& operator=(MatchmakerTicket&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MatchmakerTicket& default_instance();

  static inline const MatchmakerTicket* internal_default_instance() {
    return reinterpret_cast<const MatchmakerTicket*>(
               &_MatchmakerTicket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(MatchmakerTicket& a, MatchmakerTicket& b) {
    a.Swap(&b);
  }
  inline void Swap(MatchmakerTicket* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatchmakerTicket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MatchmakerTicket* New() const final {
    return CreateMaybeMessage<MatchmakerTicket>(nullptr);
  }

  MatchmakerTicket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MatchmakerTicket>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MatchmakerTicket& from);
  void MergeFrom(const MatchmakerTicket& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchmakerTicket* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.MatchmakerTicket";
  }
  protected:
  explicit MatchmakerTicket(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTicketFieldNumber = 1,
  };
  // string ticket = 1;
  void clear_ticket();
  const std::string& ticket() const;
  void set_ticket(const std::string& value);
  void set_ticket(std::string&& value);
  void set_ticket(const char* value);
  void set_ticket(const char* value, size_t size);
  std::string* mutable_ticket();
  std::string* release_ticket();
  void set_allocated_ticket(std::string* ticket);
  private:
  const std::string& _internal_ticket() const;
  void _internal_set_ticket(const std::string& value);
  std::string* _internal_mutable_ticket();
  public:

  // @@protoc_insertion_point(class_scope:nakama.realtime.MatchmakerTicket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ticket_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class Notifications PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.Notifications) */ {
 public:
  inline Notifications() : Notifications(nullptr) {}
  virtual ~Notifications();

  Notifications(const Notifications& from);
  Notifications(Notifications&& from) noexcept
    : Notifications() {
    *this = ::std::move(from);
  }

  inline Notifications& operator=(const Notifications& from) {
    CopyFrom(from);
    return *this;
  }
  inline Notifications& operator=(Notifications&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Notifications& default_instance();

  static inline const Notifications* internal_default_instance() {
    return reinterpret_cast<const Notifications*>(
               &_Notifications_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(Notifications& a, Notifications& b) {
    a.Swap(&b);
  }
  inline void Swap(Notifications* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Notifications* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Notifications* New() const final {
    return CreateMaybeMessage<Notifications>(nullptr);
  }

  Notifications* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Notifications>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Notifications& from);
  void MergeFrom(const Notifications& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Notifications* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.Notifications";
  }
  protected:
  explicit Notifications(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNotificationsFieldNumber = 1,
  };
  // repeated .nakama.api.Notification notifications = 1;
  int notifications_size() const;
  private:
  int _internal_notifications_size() const;
  public:
  void clear_notifications();
  ::nakama::api::Notification* mutable_notifications(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::api::Notification >*
      mutable_notifications();
  private:
  const ::nakama::api::Notification& _internal_notifications(int index) const;
  ::nakama::api::Notification* _internal_add_notifications();
  public:
  const ::nakama::api::Notification& notifications(int index) const;
  ::nakama::api::Notification* add_notifications();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::api::Notification >&
      notifications() const;

  // @@protoc_insertion_point(class_scope:nakama.realtime.Notifications)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::api::Notification > notifications_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class Party PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.Party) */ {
 public:
  inline Party() : Party(nullptr) {}
  virtual ~Party();

  Party(const Party& from);
  Party(Party&& from) noexcept
    : Party() {
    *this = ::std::move(from);
  }

  inline Party& operator=(const Party& from) {
    CopyFrom(from);
    return *this;
  }
  inline Party& operator=(Party&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Party& default_instance();

  static inline const Party* internal_default_instance() {
    return reinterpret_cast<const Party*>(
               &_Party_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(Party& a, Party& b) {
    a.Swap(&b);
  }
  inline void Swap(Party* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Party* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Party* New() const final {
    return CreateMaybeMessage<Party>(nullptr);
  }

  Party* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Party>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Party& from);
  void MergeFrom(const Party& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Party* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.Party";
  }
  protected:
  explicit Party(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPresencesFieldNumber = 6,
    kPartyIdFieldNumber = 1,
    kSelfFieldNumber = 4,
    kLeaderFieldNumber = 5,
    kOpenFieldNumber = 2,
    kMaxSizeFieldNumber = 3,
  };
  // repeated .nakama.realtime.UserPresence presences = 6;
  int presences_size() const;
  private:
  int _internal_presences_size() const;
  public:
  void clear_presences();
  ::nakama::realtime::UserPresence* mutable_presences(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >*
      mutable_presences();
  private:
  const ::nakama::realtime::UserPresence& _internal_presences(int index) const;
  ::nakama::realtime::UserPresence* _internal_add_presences();
  public:
  const ::nakama::realtime::UserPresence& presences(int index) const;
  ::nakama::realtime::UserPresence* add_presences();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >&
      presences() const;

  // string party_id = 1;
  void clear_party_id();
  const std::string& party_id() const;
  void set_party_id(const std::string& value);
  void set_party_id(std::string&& value);
  void set_party_id(const char* value);
  void set_party_id(const char* value, size_t size);
  std::string* mutable_party_id();
  std::string* release_party_id();
  void set_allocated_party_id(std::string* party_id);
  private:
  const std::string& _internal_party_id() const;
  void _internal_set_party_id(const std::string& value);
  std::string* _internal_mutable_party_id();
  public:

  // .nakama.realtime.UserPresence self = 4;
  bool has_self() const;
  private:
  bool _internal_has_self() const;
  public:
  void clear_self();
  const ::nakama::realtime::UserPresence& self() const;
  ::nakama::realtime::UserPresence* release_self();
  ::nakama::realtime::UserPresence* mutable_self();
  void set_allocated_self(::nakama::realtime::UserPresence* self);
  private:
  const ::nakama::realtime::UserPresence& _internal_self() const;
  ::nakama::realtime::UserPresence* _internal_mutable_self();
  public:
  void unsafe_arena_set_allocated_self(
      ::nakama::realtime::UserPresence* self);
  ::nakama::realtime::UserPresence* unsafe_arena_release_self();

  // .nakama.realtime.UserPresence leader = 5;
  bool has_leader() const;
  private:
  bool _internal_has_leader() const;
  public:
  void clear_leader();
  const ::nakama::realtime::UserPresence& leader() const;
  ::nakama::realtime::UserPresence* release_leader();
  ::nakama::realtime::UserPresence* mutable_leader();
  void set_allocated_leader(::nakama::realtime::UserPresence* leader);
  private:
  const ::nakama::realtime::UserPresence& _internal_leader() const;
  ::nakama::realtime::UserPresence* _internal_mutable_leader();
  public:
  void unsafe_arena_set_allocated_leader(
      ::nakama::realtime::UserPresence* leader);
  ::nakama::realtime::UserPresence* unsafe_arena_release_leader();

  // bool open = 2;
  void clear_open();
  bool open() const;
  void set_open(bool value);
  private:
  bool _internal_open() const;
  void _internal_set_open(bool value);
  public:

  // int32 max_size = 3;
  void clear_max_size();
  ::PROTOBUF_NAMESPACE_ID::int32 max_size() const;
  void set_max_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_max_size() const;
  void _internal_set_max_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:nakama.realtime.Party)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence > presences_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr party_id_;
  ::nakama::realtime::UserPresence* self_;
  ::nakama::realtime::UserPresence* leader_;
  bool open_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class PartyCreate PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.PartyCreate) */ {
 public:
  inline PartyCreate() : PartyCreate(nullptr) {}
  virtual ~PartyCreate();

  PartyCreate(const PartyCreate& from);
  PartyCreate(PartyCreate&& from) noexcept
    : PartyCreate() {
    *this = ::std::move(from);
  }

  inline PartyCreate& operator=(const PartyCreate& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartyCreate& operator=(PartyCreate&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PartyCreate& default_instance();

  static inline const PartyCreate* internal_default_instance() {
    return reinterpret_cast<const PartyCreate*>(
               &_PartyCreate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(PartyCreate& a, PartyCreate& b) {
    a.Swap(&b);
  }
  inline void Swap(PartyCreate* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartyCreate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PartyCreate* New() const final {
    return CreateMaybeMessage<PartyCreate>(nullptr);
  }

  PartyCreate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PartyCreate>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PartyCreate& from);
  void MergeFrom(const PartyCreate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartyCreate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.PartyCreate";
  }
  protected:
  explicit PartyCreate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpenFieldNumber = 1,
    kMaxSizeFieldNumber = 2,
  };
  // bool open = 1;
  void clear_open();
  bool open() const;
  void set_open(bool value);
  private:
  bool _internal_open() const;
  void _internal_set_open(bool value);
  public:

  // int32 max_size = 2;
  void clear_max_size();
  ::PROTOBUF_NAMESPACE_ID::int32 max_size() const;
  void set_max_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_max_size() const;
  void _internal_set_max_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:nakama.realtime.PartyCreate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool open_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class PartyJoin PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.PartyJoin) */ {
 public:
  inline PartyJoin() : PartyJoin(nullptr) {}
  virtual ~PartyJoin();

  PartyJoin(const PartyJoin& from);
  PartyJoin(PartyJoin&& from) noexcept
    : PartyJoin() {
    *this = ::std::move(from);
  }

  inline PartyJoin& operator=(const PartyJoin& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartyJoin& operator=(PartyJoin&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PartyJoin& default_instance();

  static inline const PartyJoin* internal_default_instance() {
    return reinterpret_cast<const PartyJoin*>(
               &_PartyJoin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(PartyJoin& a, PartyJoin& b) {
    a.Swap(&b);
  }
  inline void Swap(PartyJoin* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartyJoin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PartyJoin* New() const final {
    return CreateMaybeMessage<PartyJoin>(nullptr);
  }

  PartyJoin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PartyJoin>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PartyJoin& from);
  void MergeFrom(const PartyJoin& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartyJoin* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.PartyJoin";
  }
  protected:
  explicit PartyJoin(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartyIdFieldNumber = 1,
  };
  // string party_id = 1;
  void clear_party_id();
  const std::string& party_id() const;
  void set_party_id(const std::string& value);
  void set_party_id(std::string&& value);
  void set_party_id(const char* value);
  void set_party_id(const char* value, size_t size);
  std::string* mutable_party_id();
  std::string* release_party_id();
  void set_allocated_party_id(std::string* party_id);
  private:
  const std::string& _internal_party_id() const;
  void _internal_set_party_id(const std::string& value);
  std::string* _internal_mutable_party_id();
  public:

  // @@protoc_insertion_point(class_scope:nakama.realtime.PartyJoin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr party_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class PartyLeave PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.PartyLeave) */ {
 public:
  inline PartyLeave() : PartyLeave(nullptr) {}
  virtual ~PartyLeave();

  PartyLeave(const PartyLeave& from);
  PartyLeave(PartyLeave&& from) noexcept
    : PartyLeave() {
    *this = ::std::move(from);
  }

  inline PartyLeave& operator=(const PartyLeave& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartyLeave& operator=(PartyLeave&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PartyLeave& default_instance();

  static inline const PartyLeave* internal_default_instance() {
    return reinterpret_cast<const PartyLeave*>(
               &_PartyLeave_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(PartyLeave& a, PartyLeave& b) {
    a.Swap(&b);
  }
  inline void Swap(PartyLeave* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartyLeave* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PartyLeave* New() const final {
    return CreateMaybeMessage<PartyLeave>(nullptr);
  }

  PartyLeave* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PartyLeave>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PartyLeave& from);
  void MergeFrom(const PartyLeave& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartyLeave* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.PartyLeave";
  }
  protected:
  explicit PartyLeave(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartyIdFieldNumber = 1,
  };
  // string party_id = 1;
  void clear_party_id();
  const std::string& party_id() const;
  void set_party_id(const std::string& value);
  void set_party_id(std::string&& value);
  void set_party_id(const char* value);
  void set_party_id(const char* value, size_t size);
  std::string* mutable_party_id();
  std::string* release_party_id();
  void set_allocated_party_id(std::string* party_id);
  private:
  const std::string& _internal_party_id() const;
  void _internal_set_party_id(const std::string& value);
  std::string* _internal_mutable_party_id();
  public:

  // @@protoc_insertion_point(class_scope:nakama.realtime.PartyLeave)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr party_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class PartyPromote PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.PartyPromote) */ {
 public:
  inline PartyPromote() : PartyPromote(nullptr) {}
  virtual ~PartyPromote();

  PartyPromote(const PartyPromote& from);
  PartyPromote(PartyPromote&& from) noexcept
    : PartyPromote() {
    *this = ::std::move(from);
  }

  inline PartyPromote& operator=(const PartyPromote& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartyPromote& operator=(PartyPromote&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PartyPromote& default_instance();

  static inline const PartyPromote* internal_default_instance() {
    return reinterpret_cast<const PartyPromote*>(
               &_PartyPromote_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(PartyPromote& a, PartyPromote& b) {
    a.Swap(&b);
  }
  inline void Swap(PartyPromote* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartyPromote* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PartyPromote* New() const final {
    return CreateMaybeMessage<PartyPromote>(nullptr);
  }

  PartyPromote* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PartyPromote>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PartyPromote& from);
  void MergeFrom(const PartyPromote& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartyPromote* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.PartyPromote";
  }
  protected:
  explicit PartyPromote(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartyIdFieldNumber = 1,
    kPresenceFieldNumber = 2,
  };
  // string party_id = 1;
  void clear_party_id();
  const std::string& party_id() const;
  void set_party_id(const std::string& value);
  void set_party_id(std::string&& value);
  void set_party_id(const char* value);
  void set_party_id(const char* value, size_t size);
  std::string* mutable_party_id();
  std::string* release_party_id();
  void set_allocated_party_id(std::string* party_id);
  private:
  const std::string& _internal_party_id() const;
  void _internal_set_party_id(const std::string& value);
  std::string* _internal_mutable_party_id();
  public:

  // .nakama.realtime.UserPresence presence = 2;
  bool has_presence() const;
  private:
  bool _internal_has_presence() const;
  public:
  void clear_presence();
  const ::nakama::realtime::UserPresence& presence() const;
  ::nakama::realtime::UserPresence* release_presence();
  ::nakama::realtime::UserPresence* mutable_presence();
  void set_allocated_presence(::nakama::realtime::UserPresence* presence);
  private:
  const ::nakama::realtime::UserPresence& _internal_presence() const;
  ::nakama::realtime::UserPresence* _internal_mutable_presence();
  public:
  void unsafe_arena_set_allocated_presence(
      ::nakama::realtime::UserPresence* presence);
  ::nakama::realtime::UserPresence* unsafe_arena_release_presence();

  // @@protoc_insertion_point(class_scope:nakama.realtime.PartyPromote)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr party_id_;
  ::nakama::realtime::UserPresence* presence_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class PartyLeader PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.PartyLeader) */ {
 public:
  inline PartyLeader() : PartyLeader(nullptr) {}
  virtual ~PartyLeader();

  PartyLeader(const PartyLeader& from);
  PartyLeader(PartyLeader&& from) noexcept
    : PartyLeader() {
    *this = ::std::move(from);
  }

  inline PartyLeader& operator=(const PartyLeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartyLeader& operator=(PartyLeader&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PartyLeader& default_instance();

  static inline const PartyLeader* internal_default_instance() {
    return reinterpret_cast<const PartyLeader*>(
               &_PartyLeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(PartyLeader& a, PartyLeader& b) {
    a.Swap(&b);
  }
  inline void Swap(PartyLeader* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartyLeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PartyLeader* New() const final {
    return CreateMaybeMessage<PartyLeader>(nullptr);
  }

  PartyLeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PartyLeader>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PartyLeader& from);
  void MergeFrom(const PartyLeader& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartyLeader* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.PartyLeader";
  }
  protected:
  explicit PartyLeader(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartyIdFieldNumber = 1,
    kPresenceFieldNumber = 2,
  };
  // string party_id = 1;
  void clear_party_id();
  const std::string& party_id() const;
  void set_party_id(const std::string& value);
  void set_party_id(std::string&& value);
  void set_party_id(const char* value);
  void set_party_id(const char* value, size_t size);
  std::string* mutable_party_id();
  std::string* release_party_id();
  void set_allocated_party_id(std::string* party_id);
  private:
  const std::string& _internal_party_id() const;
  void _internal_set_party_id(const std::string& value);
  std::string* _internal_mutable_party_id();
  public:

  // .nakama.realtime.UserPresence presence = 2;
  bool has_presence() const;
  private:
  bool _internal_has_presence() const;
  public:
  void clear_presence();
  const ::nakama::realtime::UserPresence& presence() const;
  ::nakama::realtime::UserPresence* release_presence();
  ::nakama::realtime::UserPresence* mutable_presence();
  void set_allocated_presence(::nakama::realtime::UserPresence* presence);
  private:
  const ::nakama::realtime::UserPresence& _internal_presence() const;
  ::nakama::realtime::UserPresence* _internal_mutable_presence();
  public:
  void unsafe_arena_set_allocated_presence(
      ::nakama::realtime::UserPresence* presence);
  ::nakama::realtime::UserPresence* unsafe_arena_release_presence();

  // @@protoc_insertion_point(class_scope:nakama.realtime.PartyLeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr party_id_;
  ::nakama::realtime::UserPresence* presence_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class PartyAccept PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.PartyAccept) */ {
 public:
  inline PartyAccept() : PartyAccept(nullptr) {}
  virtual ~PartyAccept();

  PartyAccept(const PartyAccept& from);
  PartyAccept(PartyAccept&& from) noexcept
    : PartyAccept() {
    *this = ::std::move(from);
  }

  inline PartyAccept& operator=(const PartyAccept& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartyAccept& operator=(PartyAccept&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PartyAccept& default_instance();

  static inline const PartyAccept* internal_default_instance() {
    return reinterpret_cast<const PartyAccept*>(
               &_PartyAccept_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(PartyAccept& a, PartyAccept& b) {
    a.Swap(&b);
  }
  inline void Swap(PartyAccept* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartyAccept* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PartyAccept* New() const final {
    return CreateMaybeMessage<PartyAccept>(nullptr);
  }

  PartyAccept* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PartyAccept>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PartyAccept& from);
  void MergeFrom(const PartyAccept& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartyAccept* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.PartyAccept";
  }
  protected:
  explicit PartyAccept(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartyIdFieldNumber = 1,
    kPresenceFieldNumber = 2,
  };
  // string party_id = 1;
  void clear_party_id();
  const std::string& party_id() const;
  void set_party_id(const std::string& value);
  void set_party_id(std::string&& value);
  void set_party_id(const char* value);
  void set_party_id(const char* value, size_t size);
  std::string* mutable_party_id();
  std::string* release_party_id();
  void set_allocated_party_id(std::string* party_id);
  private:
  const std::string& _internal_party_id() const;
  void _internal_set_party_id(const std::string& value);
  std::string* _internal_mutable_party_id();
  public:

  // .nakama.realtime.UserPresence presence = 2;
  bool has_presence() const;
  private:
  bool _internal_has_presence() const;
  public:
  void clear_presence();
  const ::nakama::realtime::UserPresence& presence() const;
  ::nakama::realtime::UserPresence* release_presence();
  ::nakama::realtime::UserPresence* mutable_presence();
  void set_allocated_presence(::nakama::realtime::UserPresence* presence);
  private:
  const ::nakama::realtime::UserPresence& _internal_presence() const;
  ::nakama::realtime::UserPresence* _internal_mutable_presence();
  public:
  void unsafe_arena_set_allocated_presence(
      ::nakama::realtime::UserPresence* presence);
  ::nakama::realtime::UserPresence* unsafe_arena_release_presence();

  // @@protoc_insertion_point(class_scope:nakama.realtime.PartyAccept)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr party_id_;
  ::nakama::realtime::UserPresence* presence_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class PartyRemove PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.PartyRemove) */ {
 public:
  inline PartyRemove() : PartyRemove(nullptr) {}
  virtual ~PartyRemove();

  PartyRemove(const PartyRemove& from);
  PartyRemove(PartyRemove&& from) noexcept
    : PartyRemove() {
    *this = ::std::move(from);
  }

  inline PartyRemove& operator=(const PartyRemove& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartyRemove& operator=(PartyRemove&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PartyRemove& default_instance();

  static inline const PartyRemove* internal_default_instance() {
    return reinterpret_cast<const PartyRemove*>(
               &_PartyRemove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(PartyRemove& a, PartyRemove& b) {
    a.Swap(&b);
  }
  inline void Swap(PartyRemove* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartyRemove* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PartyRemove* New() const final {
    return CreateMaybeMessage<PartyRemove>(nullptr);
  }

  PartyRemove* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PartyRemove>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PartyRemove& from);
  void MergeFrom(const PartyRemove& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartyRemove* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.PartyRemove";
  }
  protected:
  explicit PartyRemove(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartyIdFieldNumber = 1,
    kPresenceFieldNumber = 2,
  };
  // string party_id = 1;
  void clear_party_id();
  const std::string& party_id() const;
  void set_party_id(const std::string& value);
  void set_party_id(std::string&& value);
  void set_party_id(const char* value);
  void set_party_id(const char* value, size_t size);
  std::string* mutable_party_id();
  std::string* release_party_id();
  void set_allocated_party_id(std::string* party_id);
  private:
  const std::string& _internal_party_id() const;
  void _internal_set_party_id(const std::string& value);
  std::string* _internal_mutable_party_id();
  public:

  // .nakama.realtime.UserPresence presence = 2;
  bool has_presence() const;
  private:
  bool _internal_has_presence() const;
  public:
  void clear_presence();
  const ::nakama::realtime::UserPresence& presence() const;
  ::nakama::realtime::UserPresence* release_presence();
  ::nakama::realtime::UserPresence* mutable_presence();
  void set_allocated_presence(::nakama::realtime::UserPresence* presence);
  private:
  const ::nakama::realtime::UserPresence& _internal_presence() const;
  ::nakama::realtime::UserPresence* _internal_mutable_presence();
  public:
  void unsafe_arena_set_allocated_presence(
      ::nakama::realtime::UserPresence* presence);
  ::nakama::realtime::UserPresence* unsafe_arena_release_presence();

  // @@protoc_insertion_point(class_scope:nakama.realtime.PartyRemove)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr party_id_;
  ::nakama::realtime::UserPresence* presence_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class PartyClose PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.PartyClose) */ {
 public:
  inline PartyClose() : PartyClose(nullptr) {}
  virtual ~PartyClose();

  PartyClose(const PartyClose& from);
  PartyClose(PartyClose&& from) noexcept
    : PartyClose() {
    *this = ::std::move(from);
  }

  inline PartyClose& operator=(const PartyClose& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartyClose& operator=(PartyClose&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PartyClose& default_instance();

  static inline const PartyClose* internal_default_instance() {
    return reinterpret_cast<const PartyClose*>(
               &_PartyClose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(PartyClose& a, PartyClose& b) {
    a.Swap(&b);
  }
  inline void Swap(PartyClose* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartyClose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PartyClose* New() const final {
    return CreateMaybeMessage<PartyClose>(nullptr);
  }

  PartyClose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PartyClose>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PartyClose& from);
  void MergeFrom(const PartyClose& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartyClose* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.PartyClose";
  }
  protected:
  explicit PartyClose(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartyIdFieldNumber = 1,
  };
  // string party_id = 1;
  void clear_party_id();
  const std::string& party_id() const;
  void set_party_id(const std::string& value);
  void set_party_id(std::string&& value);
  void set_party_id(const char* value);
  void set_party_id(const char* value, size_t size);
  std::string* mutable_party_id();
  std::string* release_party_id();
  void set_allocated_party_id(std::string* party_id);
  private:
  const std::string& _internal_party_id() const;
  void _internal_set_party_id(const std::string& value);
  std::string* _internal_mutable_party_id();
  public:

  // @@protoc_insertion_point(class_scope:nakama.realtime.PartyClose)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr party_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class PartyJoinRequestList PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.PartyJoinRequestList) */ {
 public:
  inline PartyJoinRequestList() : PartyJoinRequestList(nullptr) {}
  virtual ~PartyJoinRequestList();

  PartyJoinRequestList(const PartyJoinRequestList& from);
  PartyJoinRequestList(PartyJoinRequestList&& from) noexcept
    : PartyJoinRequestList() {
    *this = ::std::move(from);
  }

  inline PartyJoinRequestList& operator=(const PartyJoinRequestList& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartyJoinRequestList& operator=(PartyJoinRequestList&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PartyJoinRequestList& default_instance();

  static inline const PartyJoinRequestList* internal_default_instance() {
    return reinterpret_cast<const PartyJoinRequestList*>(
               &_PartyJoinRequestList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(PartyJoinRequestList& a, PartyJoinRequestList& b) {
    a.Swap(&b);
  }
  inline void Swap(PartyJoinRequestList* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartyJoinRequestList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PartyJoinRequestList* New() const final {
    return CreateMaybeMessage<PartyJoinRequestList>(nullptr);
  }

  PartyJoinRequestList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PartyJoinRequestList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PartyJoinRequestList& from);
  void MergeFrom(const PartyJoinRequestList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartyJoinRequestList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.PartyJoinRequestList";
  }
  protected:
  explicit PartyJoinRequestList(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartyIdFieldNumber = 1,
  };
  // string party_id = 1;
  void clear_party_id();
  const std::string& party_id() const;
  void set_party_id(const std::string& value);
  void set_party_id(std::string&& value);
  void set_party_id(const char* value);
  void set_party_id(const char* value, size_t size);
  std::string* mutable_party_id();
  std::string* release_party_id();
  void set_allocated_party_id(std::string* party_id);
  private:
  const std::string& _internal_party_id() const;
  void _internal_set_party_id(const std::string& value);
  std::string* _internal_mutable_party_id();
  public:

  // @@protoc_insertion_point(class_scope:nakama.realtime.PartyJoinRequestList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr party_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class PartyJoinRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.PartyJoinRequest) */ {
 public:
  inline PartyJoinRequest() : PartyJoinRequest(nullptr) {}
  virtual ~PartyJoinRequest();

  PartyJoinRequest(const PartyJoinRequest& from);
  PartyJoinRequest(PartyJoinRequest&& from) noexcept
    : PartyJoinRequest() {
    *this = ::std::move(from);
  }

  inline PartyJoinRequest& operator=(const PartyJoinRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartyJoinRequest& operator=(PartyJoinRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PartyJoinRequest& default_instance();

  static inline const PartyJoinRequest* internal_default_instance() {
    return reinterpret_cast<const PartyJoinRequest*>(
               &_PartyJoinRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(PartyJoinRequest& a, PartyJoinRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PartyJoinRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartyJoinRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PartyJoinRequest* New() const final {
    return CreateMaybeMessage<PartyJoinRequest>(nullptr);
  }

  PartyJoinRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PartyJoinRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PartyJoinRequest& from);
  void MergeFrom(const PartyJoinRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartyJoinRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.PartyJoinRequest";
  }
  protected:
  explicit PartyJoinRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPresencesFieldNumber = 2,
    kPartyIdFieldNumber = 1,
  };
  // repeated .nakama.realtime.UserPresence presences = 2;
  int presences_size() const;
  private:
  int _internal_presences_size() const;
  public:
  void clear_presences();
  ::nakama::realtime::UserPresence* mutable_presences(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >*
      mutable_presences();
  private:
  const ::nakama::realtime::UserPresence& _internal_presences(int index) const;
  ::nakama::realtime::UserPresence* _internal_add_presences();
  public:
  const ::nakama::realtime::UserPresence& presences(int index) const;
  ::nakama::realtime::UserPresence* add_presences();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >&
      presences() const;

  // string party_id = 1;
  void clear_party_id();
  const std::string& party_id() const;
  void set_party_id(const std::string& value);
  void set_party_id(std::string&& value);
  void set_party_id(const char* value);
  void set_party_id(const char* value, size_t size);
  std::string* mutable_party_id();
  std::string* release_party_id();
  void set_allocated_party_id(std::string* party_id);
  private:
  const std::string& _internal_party_id() const;
  void _internal_set_party_id(const std::string& value);
  std::string* _internal_mutable_party_id();
  public:

  // @@protoc_insertion_point(class_scope:nakama.realtime.PartyJoinRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence > presences_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr party_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class PartyMatchmakerAdd_StringPropertiesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PartyMatchmakerAdd_StringPropertiesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PartyMatchmakerAdd_StringPropertiesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  PartyMatchmakerAdd_StringPropertiesEntry_DoNotUse();
  explicit PartyMatchmakerAdd_StringPropertiesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const PartyMatchmakerAdd_StringPropertiesEntry_DoNotUse& other);
  static const PartyMatchmakerAdd_StringPropertiesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PartyMatchmakerAdd_StringPropertiesEntry_DoNotUse*>(&_PartyMatchmakerAdd_StringPropertiesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "nakama.realtime.PartyMatchmakerAdd.StringPropertiesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "nakama.realtime.PartyMatchmakerAdd.StringPropertiesEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[40];
  }

  public:
};

// -------------------------------------------------------------------

class PartyMatchmakerAdd_NumericPropertiesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PartyMatchmakerAdd_NumericPropertiesEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PartyMatchmakerAdd_NumericPropertiesEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> SuperType;
  PartyMatchmakerAdd_NumericPropertiesEntry_DoNotUse();
  explicit PartyMatchmakerAdd_NumericPropertiesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const PartyMatchmakerAdd_NumericPropertiesEntry_DoNotUse& other);
  static const PartyMatchmakerAdd_NumericPropertiesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PartyMatchmakerAdd_NumericPropertiesEntry_DoNotUse*>(&_PartyMatchmakerAdd_NumericPropertiesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "nakama.realtime.PartyMatchmakerAdd.NumericPropertiesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[41];
  }

  public:
};

// -------------------------------------------------------------------

class PartyMatchmakerAdd PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.PartyMatchmakerAdd) */ {
 public:
  inline PartyMatchmakerAdd() : PartyMatchmakerAdd(nullptr) {}
  virtual ~PartyMatchmakerAdd();

  PartyMatchmakerAdd(const PartyMatchmakerAdd& from);
  PartyMatchmakerAdd(PartyMatchmakerAdd&& from) noexcept
    : PartyMatchmakerAdd() {
    *this = ::std::move(from);
  }

  inline PartyMatchmakerAdd& operator=(const PartyMatchmakerAdd& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartyMatchmakerAdd& operator=(PartyMatchmakerAdd&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PartyMatchmakerAdd& default_instance();

  static inline const PartyMatchmakerAdd* internal_default_instance() {
    return reinterpret_cast<const PartyMatchmakerAdd*>(
               &_PartyMatchmakerAdd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(PartyMatchmakerAdd& a, PartyMatchmakerAdd& b) {
    a.Swap(&b);
  }
  inline void Swap(PartyMatchmakerAdd* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartyMatchmakerAdd* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PartyMatchmakerAdd* New() const final {
    return CreateMaybeMessage<PartyMatchmakerAdd>(nullptr);
  }

  PartyMatchmakerAdd* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PartyMatchmakerAdd>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PartyMatchmakerAdd& from);
  void MergeFrom(const PartyMatchmakerAdd& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartyMatchmakerAdd* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.PartyMatchmakerAdd";
  }
  protected:
  explicit PartyMatchmakerAdd(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kStringPropertiesFieldNumber = 5,
    kNumericPropertiesFieldNumber = 6,
    kPartyIdFieldNumber = 1,
    kQueryFieldNumber = 4,
    kCountMultipleFieldNumber = 7,
    kMinCountFieldNumber = 2,
    kMaxCountFieldNumber = 3,
  };
  // map<string, string> string_properties = 5;
  int string_properties_size() const;
  private:
  int _internal_string_properties_size() const;
  public:
  void clear_string_properties();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_string_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_string_properties();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      string_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_string_properties();

  // map<string, double> numeric_properties = 6;
  int numeric_properties_size() const;
  private:
  int _internal_numeric_properties_size() const;
  public:
  void clear_numeric_properties();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_numeric_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_numeric_properties();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      numeric_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_numeric_properties();

  // string party_id = 1;
  void clear_party_id();
  const std::string& party_id() const;
  void set_party_id(const std::string& value);
  void set_party_id(std::string&& value);
  void set_party_id(const char* value);
  void set_party_id(const char* value, size_t size);
  std::string* mutable_party_id();
  std::string* release_party_id();
  void set_allocated_party_id(std::string* party_id);
  private:
  const std::string& _internal_party_id() const;
  void _internal_set_party_id(const std::string& value);
  std::string* _internal_mutable_party_id();
  public:

  // string query = 4;
  void clear_query();
  const std::string& query() const;
  void set_query(const std::string& value);
  void set_query(std::string&& value);
  void set_query(const char* value);
  void set_query(const char* value, size_t size);
  std::string* mutable_query();
  std::string* release_query();
  void set_allocated_query(std::string* query);
  private:
  const std::string& _internal_query() const;
  void _internal_set_query(const std::string& value);
  std::string* _internal_mutable_query();
  public:

  // .google.protobuf.Int32Value count_multiple = 7;
  bool has_count_multiple() const;
  private:
  bool _internal_has_count_multiple() const;
  public:
  void clear_count_multiple();
  const PROTOBUF_NAMESPACE_ID::Int32Value& count_multiple() const;
  PROTOBUF_NAMESPACE_ID::Int32Value* release_count_multiple();
  PROTOBUF_NAMESPACE_ID::Int32Value* mutable_count_multiple();
  void set_allocated_count_multiple(PROTOBUF_NAMESPACE_ID::Int32Value* count_multiple);
  private:
  const PROTOBUF_NAMESPACE_ID::Int32Value& _internal_count_multiple() const;
  PROTOBUF_NAMESPACE_ID::Int32Value* _internal_mutable_count_multiple();
  public:
  void unsafe_arena_set_allocated_count_multiple(
      PROTOBUF_NAMESPACE_ID::Int32Value* count_multiple);
  PROTOBUF_NAMESPACE_ID::Int32Value* unsafe_arena_release_count_multiple();

  // int32 min_count = 2;
  void clear_min_count();
  ::PROTOBUF_NAMESPACE_ID::int32 min_count() const;
  void set_min_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_min_count() const;
  void _internal_set_min_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 max_count = 3;
  void clear_max_count();
  ::PROTOBUF_NAMESPACE_ID::int32 max_count() const;
  void set_max_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_max_count() const;
  void _internal_set_max_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:nakama.realtime.PartyMatchmakerAdd)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      PartyMatchmakerAdd_StringPropertiesEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> string_properties_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      PartyMatchmakerAdd_NumericPropertiesEntry_DoNotUse,
      std::string, double,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> numeric_properties_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr party_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr query_;
  PROTOBUF_NAMESPACE_ID::Int32Value* count_multiple_;
  ::PROTOBUF_NAMESPACE_ID::int32 min_count_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class PartyMatchmakerRemove PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.PartyMatchmakerRemove) */ {
 public:
  inline PartyMatchmakerRemove() : PartyMatchmakerRemove(nullptr) {}
  virtual ~PartyMatchmakerRemove();

  PartyMatchmakerRemove(const PartyMatchmakerRemove& from);
  PartyMatchmakerRemove(PartyMatchmakerRemove&& from) noexcept
    : PartyMatchmakerRemove() {
    *this = ::std::move(from);
  }

  inline PartyMatchmakerRemove& operator=(const PartyMatchmakerRemove& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartyMatchmakerRemove& operator=(PartyMatchmakerRemove&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PartyMatchmakerRemove& default_instance();

  static inline const PartyMatchmakerRemove* internal_default_instance() {
    return reinterpret_cast<const PartyMatchmakerRemove*>(
               &_PartyMatchmakerRemove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(PartyMatchmakerRemove& a, PartyMatchmakerRemove& b) {
    a.Swap(&b);
  }
  inline void Swap(PartyMatchmakerRemove* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartyMatchmakerRemove* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PartyMatchmakerRemove* New() const final {
    return CreateMaybeMessage<PartyMatchmakerRemove>(nullptr);
  }

  PartyMatchmakerRemove* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PartyMatchmakerRemove>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PartyMatchmakerRemove& from);
  void MergeFrom(const PartyMatchmakerRemove& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartyMatchmakerRemove* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.PartyMatchmakerRemove";
  }
  protected:
  explicit PartyMatchmakerRemove(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartyIdFieldNumber = 1,
    kTicketFieldNumber = 2,
  };
  // string party_id = 1;
  void clear_party_id();
  const std::string& party_id() const;
  void set_party_id(const std::string& value);
  void set_party_id(std::string&& value);
  void set_party_id(const char* value);
  void set_party_id(const char* value, size_t size);
  std::string* mutable_party_id();
  std::string* release_party_id();
  void set_allocated_party_id(std::string* party_id);
  private:
  const std::string& _internal_party_id() const;
  void _internal_set_party_id(const std::string& value);
  std::string* _internal_mutable_party_id();
  public:

  // string ticket = 2;
  void clear_ticket();
  const std::string& ticket() const;
  void set_ticket(const std::string& value);
  void set_ticket(std::string&& value);
  void set_ticket(const char* value);
  void set_ticket(const char* value, size_t size);
  std::string* mutable_ticket();
  std::string* release_ticket();
  void set_allocated_ticket(std::string* ticket);
  private:
  const std::string& _internal_ticket() const;
  void _internal_set_ticket(const std::string& value);
  std::string* _internal_mutable_ticket();
  public:

  // @@protoc_insertion_point(class_scope:nakama.realtime.PartyMatchmakerRemove)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr party_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ticket_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class PartyMatchmakerTicket PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.PartyMatchmakerTicket) */ {
 public:
  inline PartyMatchmakerTicket() : PartyMatchmakerTicket(nullptr) {}
  virtual ~PartyMatchmakerTicket();

  PartyMatchmakerTicket(const PartyMatchmakerTicket& from);
  PartyMatchmakerTicket(PartyMatchmakerTicket&& from) noexcept
    : PartyMatchmakerTicket() {
    *this = ::std::move(from);
  }

  inline PartyMatchmakerTicket& operator=(const PartyMatchmakerTicket& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartyMatchmakerTicket& operator=(PartyMatchmakerTicket&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PartyMatchmakerTicket& default_instance();

  static inline const PartyMatchmakerTicket* internal_default_instance() {
    return reinterpret_cast<const PartyMatchmakerTicket*>(
               &_PartyMatchmakerTicket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(PartyMatchmakerTicket& a, PartyMatchmakerTicket& b) {
    a.Swap(&b);
  }
  inline void Swap(PartyMatchmakerTicket* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartyMatchmakerTicket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PartyMatchmakerTicket* New() const final {
    return CreateMaybeMessage<PartyMatchmakerTicket>(nullptr);
  }

  PartyMatchmakerTicket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PartyMatchmakerTicket>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PartyMatchmakerTicket& from);
  void MergeFrom(const PartyMatchmakerTicket& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartyMatchmakerTicket* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.PartyMatchmakerTicket";
  }
  protected:
  explicit PartyMatchmakerTicket(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartyIdFieldNumber = 1,
    kTicketFieldNumber = 2,
  };
  // string party_id = 1;
  void clear_party_id();
  const std::string& party_id() const;
  void set_party_id(const std::string& value);
  void set_party_id(std::string&& value);
  void set_party_id(const char* value);
  void set_party_id(const char* value, size_t size);
  std::string* mutable_party_id();
  std::string* release_party_id();
  void set_allocated_party_id(std::string* party_id);
  private:
  const std::string& _internal_party_id() const;
  void _internal_set_party_id(const std::string& value);
  std::string* _internal_mutable_party_id();
  public:

  // string ticket = 2;
  void clear_ticket();
  const std::string& ticket() const;
  void set_ticket(const std::string& value);
  void set_ticket(std::string&& value);
  void set_ticket(const char* value);
  void set_ticket(const char* value, size_t size);
  std::string* mutable_ticket();
  std::string* release_ticket();
  void set_allocated_ticket(std::string* ticket);
  private:
  const std::string& _internal_ticket() const;
  void _internal_set_ticket(const std::string& value);
  std::string* _internal_mutable_ticket();
  public:

  // @@protoc_insertion_point(class_scope:nakama.realtime.PartyMatchmakerTicket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr party_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ticket_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class PartyData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.PartyData) */ {
 public:
  inline PartyData() : PartyData(nullptr) {}
  virtual ~PartyData();

  PartyData(const PartyData& from);
  PartyData(PartyData&& from) noexcept
    : PartyData() {
    *this = ::std::move(from);
  }

  inline PartyData& operator=(const PartyData& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartyData& operator=(PartyData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PartyData& default_instance();

  static inline const PartyData* internal_default_instance() {
    return reinterpret_cast<const PartyData*>(
               &_PartyData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(PartyData& a, PartyData& b) {
    a.Swap(&b);
  }
  inline void Swap(PartyData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartyData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PartyData* New() const final {
    return CreateMaybeMessage<PartyData>(nullptr);
  }

  PartyData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PartyData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PartyData& from);
  void MergeFrom(const PartyData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartyData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.PartyData";
  }
  protected:
  explicit PartyData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartyIdFieldNumber = 1,
    kDataFieldNumber = 4,
    kPresenceFieldNumber = 2,
    kOpCodeFieldNumber = 3,
  };
  // string party_id = 1;
  void clear_party_id();
  const std::string& party_id() const;
  void set_party_id(const std::string& value);
  void set_party_id(std::string&& value);
  void set_party_id(const char* value);
  void set_party_id(const char* value, size_t size);
  std::string* mutable_party_id();
  std::string* release_party_id();
  void set_allocated_party_id(std::string* party_id);
  private:
  const std::string& _internal_party_id() const;
  void _internal_set_party_id(const std::string& value);
  std::string* _internal_mutable_party_id();
  public:

  // bytes data = 4;
  void clear_data();
  const std::string& data() const;
  void set_data(const std::string& value);
  void set_data(std::string&& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  std::string* mutable_data();
  std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .nakama.realtime.UserPresence presence = 2;
  bool has_presence() const;
  private:
  bool _internal_has_presence() const;
  public:
  void clear_presence();
  const ::nakama::realtime::UserPresence& presence() const;
  ::nakama::realtime::UserPresence* release_presence();
  ::nakama::realtime::UserPresence* mutable_presence();
  void set_allocated_presence(::nakama::realtime::UserPresence* presence);
  private:
  const ::nakama::realtime::UserPresence& _internal_presence() const;
  ::nakama::realtime::UserPresence* _internal_mutable_presence();
  public:
  void unsafe_arena_set_allocated_presence(
      ::nakama::realtime::UserPresence* presence);
  ::nakama::realtime::UserPresence* unsafe_arena_release_presence();

  // int64 op_code = 3;
  void clear_op_code();
  ::PROTOBUF_NAMESPACE_ID::int64 op_code() const;
  void set_op_code(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_op_code() const;
  void _internal_set_op_code(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:nakama.realtime.PartyData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr party_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::nakama::realtime::UserPresence* presence_;
  ::PROTOBUF_NAMESPACE_ID::int64 op_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class PartyDataSend PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.PartyDataSend) */ {
 public:
  inline PartyDataSend() : PartyDataSend(nullptr) {}
  virtual ~PartyDataSend();

  PartyDataSend(const PartyDataSend& from);
  PartyDataSend(PartyDataSend&& from) noexcept
    : PartyDataSend() {
    *this = ::std::move(from);
  }

  inline PartyDataSend& operator=(const PartyDataSend& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartyDataSend& operator=(PartyDataSend&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PartyDataSend& default_instance();

  static inline const PartyDataSend* internal_default_instance() {
    return reinterpret_cast<const PartyDataSend*>(
               &_PartyDataSend_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(PartyDataSend& a, PartyDataSend& b) {
    a.Swap(&b);
  }
  inline void Swap(PartyDataSend* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartyDataSend* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PartyDataSend* New() const final {
    return CreateMaybeMessage<PartyDataSend>(nullptr);
  }

  PartyDataSend* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PartyDataSend>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PartyDataSend& from);
  void MergeFrom(const PartyDataSend& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartyDataSend* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.PartyDataSend";
  }
  protected:
  explicit PartyDataSend(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartyIdFieldNumber = 1,
    kDataFieldNumber = 3,
    kOpCodeFieldNumber = 2,
  };
  // string party_id = 1;
  void clear_party_id();
  const std::string& party_id() const;
  void set_party_id(const std::string& value);
  void set_party_id(std::string&& value);
  void set_party_id(const char* value);
  void set_party_id(const char* value, size_t size);
  std::string* mutable_party_id();
  std::string* release_party_id();
  void set_allocated_party_id(std::string* party_id);
  private:
  const std::string& _internal_party_id() const;
  void _internal_set_party_id(const std::string& value);
  std::string* _internal_mutable_party_id();
  public:

  // bytes data = 3;
  void clear_data();
  const std::string& data() const;
  void set_data(const std::string& value);
  void set_data(std::string&& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  std::string* mutable_data();
  std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // int64 op_code = 2;
  void clear_op_code();
  ::PROTOBUF_NAMESPACE_ID::int64 op_code() const;
  void set_op_code(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_op_code() const;
  void _internal_set_op_code(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:nakama.realtime.PartyDataSend)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr party_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::int64 op_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class PartyPresenceEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.PartyPresenceEvent) */ {
 public:
  inline PartyPresenceEvent() : PartyPresenceEvent(nullptr) {}
  virtual ~PartyPresenceEvent();

  PartyPresenceEvent(const PartyPresenceEvent& from);
  PartyPresenceEvent(PartyPresenceEvent&& from) noexcept
    : PartyPresenceEvent() {
    *this = ::std::move(from);
  }

  inline PartyPresenceEvent& operator=(const PartyPresenceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartyPresenceEvent& operator=(PartyPresenceEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PartyPresenceEvent& default_instance();

  static inline const PartyPresenceEvent* internal_default_instance() {
    return reinterpret_cast<const PartyPresenceEvent*>(
               &_PartyPresenceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(PartyPresenceEvent& a, PartyPresenceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(PartyPresenceEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartyPresenceEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PartyPresenceEvent* New() const final {
    return CreateMaybeMessage<PartyPresenceEvent>(nullptr);
  }

  PartyPresenceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PartyPresenceEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PartyPresenceEvent& from);
  void MergeFrom(const PartyPresenceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartyPresenceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.PartyPresenceEvent";
  }
  protected:
  explicit PartyPresenceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJoinsFieldNumber = 2,
    kLeavesFieldNumber = 3,
    kPartyIdFieldNumber = 1,
  };
  // repeated .nakama.realtime.UserPresence joins = 2;
  int joins_size() const;
  private:
  int _internal_joins_size() const;
  public:
  void clear_joins();
  ::nakama::realtime::UserPresence* mutable_joins(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >*
      mutable_joins();
  private:
  const ::nakama::realtime::UserPresence& _internal_joins(int index) const;
  ::nakama::realtime::UserPresence* _internal_add_joins();
  public:
  const ::nakama::realtime::UserPresence& joins(int index) const;
  ::nakama::realtime::UserPresence* add_joins();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >&
      joins() const;

  // repeated .nakama.realtime.UserPresence leaves = 3;
  int leaves_size() const;
  private:
  int _internal_leaves_size() const;
  public:
  void clear_leaves();
  ::nakama::realtime::UserPresence* mutable_leaves(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >*
      mutable_leaves();
  private:
  const ::nakama::realtime::UserPresence& _internal_leaves(int index) const;
  ::nakama::realtime::UserPresence* _internal_add_leaves();
  public:
  const ::nakama::realtime::UserPresence& leaves(int index) const;
  ::nakama::realtime::UserPresence* add_leaves();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >&
      leaves() const;

  // string party_id = 1;
  void clear_party_id();
  const std::string& party_id() const;
  void set_party_id(const std::string& value);
  void set_party_id(std::string&& value);
  void set_party_id(const char* value);
  void set_party_id(const char* value, size_t size);
  std::string* mutable_party_id();
  std::string* release_party_id();
  void set_allocated_party_id(std::string* party_id);
  private:
  const std::string& _internal_party_id() const;
  void _internal_set_party_id(const std::string& value);
  std::string* _internal_mutable_party_id();
  public:

  // @@protoc_insertion_point(class_scope:nakama.realtime.PartyPresenceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence > joins_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence > leaves_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr party_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class Ping PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.Ping) */ {
 public:
  inline Ping() : Ping(nullptr) {}
  virtual ~Ping();

  Ping(const Ping& from);
  Ping(Ping&& from) noexcept
    : Ping() {
    *this = ::std::move(from);
  }

  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ping& operator=(Ping&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Ping& default_instance();

  static inline const Ping* internal_default_instance() {
    return reinterpret_cast<const Ping*>(
               &_Ping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(Ping& a, Ping& b) {
    a.Swap(&b);
  }
  inline void Swap(Ping* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ping* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Ping* New() const final {
    return CreateMaybeMessage<Ping>(nullptr);
  }

  Ping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Ping>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Ping& from);
  void MergeFrom(const Ping& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ping* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.Ping";
  }
  protected:
  explicit Ping(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:nakama.realtime.Ping)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class Pong PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.Pong) */ {
 public:
  inline Pong() : Pong(nullptr) {}
  virtual ~Pong();

  Pong(const Pong& from);
  Pong(Pong&& from) noexcept
    : Pong() {
    *this = ::std::move(from);
  }

  inline Pong& operator=(const Pong& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pong& operator=(Pong&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Pong& default_instance();

  static inline const Pong* internal_default_instance() {
    return reinterpret_cast<const Pong*>(
               &_Pong_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(Pong& a, Pong& b) {
    a.Swap(&b);
  }
  inline void Swap(Pong* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pong* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Pong* New() const final {
    return CreateMaybeMessage<Pong>(nullptr);
  }

  Pong* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Pong>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Pong& from);
  void MergeFrom(const Pong& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pong* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.Pong";
  }
  protected:
  explicit Pong(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:nakama.realtime.Pong)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class Status PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.Status) */ {
 public:
  inline Status() : Status(nullptr) {}
  virtual ~Status();

  Status(const Status& from);
  Status(Status&& from) noexcept
    : Status() {
    *this = ::std::move(from);
  }

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline Status& operator=(Status&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Status& default_instance();

  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
               &_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(Status& a, Status& b) {
    a.Swap(&b);
  }
  inline void Swap(Status* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Status* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Status* New() const final {
    return CreateMaybeMessage<Status>(nullptr);
  }

  Status* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Status>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Status& from);
  void MergeFrom(const Status& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Status* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.Status";
  }
  protected:
  explicit Status(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPresencesFieldNumber = 1,
  };
  // repeated .nakama.realtime.UserPresence presences = 1;
  int presences_size() const;
  private:
  int _internal_presences_size() const;
  public:
  void clear_presences();
  ::nakama::realtime::UserPresence* mutable_presences(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >*
      mutable_presences();
  private:
  const ::nakama::realtime::UserPresence& _internal_presences(int index) const;
  ::nakama::realtime::UserPresence* _internal_add_presences();
  public:
  const ::nakama::realtime::UserPresence& presences(int index) const;
  ::nakama::realtime::UserPresence* add_presences();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >&
      presences() const;

  // @@protoc_insertion_point(class_scope:nakama.realtime.Status)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence > presences_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class StatusFollow PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.StatusFollow) */ {
 public:
  inline StatusFollow() : StatusFollow(nullptr) {}
  virtual ~StatusFollow();

  StatusFollow(const StatusFollow& from);
  StatusFollow(StatusFollow&& from) noexcept
    : StatusFollow() {
    *this = ::std::move(from);
  }

  inline StatusFollow& operator=(const StatusFollow& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusFollow& operator=(StatusFollow&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StatusFollow& default_instance();

  static inline const StatusFollow* internal_default_instance() {
    return reinterpret_cast<const StatusFollow*>(
               &_StatusFollow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(StatusFollow& a, StatusFollow& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusFollow* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusFollow* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StatusFollow* New() const final {
    return CreateMaybeMessage<StatusFollow>(nullptr);
  }

  StatusFollow* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StatusFollow>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StatusFollow& from);
  void MergeFrom(const StatusFollow& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusFollow* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.StatusFollow";
  }
  protected:
  explicit StatusFollow(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdsFieldNumber = 1,
    kUsernamesFieldNumber = 2,
  };
  // repeated string user_ids = 1;
  int user_ids_size() const;
  private:
  int _internal_user_ids_size() const;
  public:
  void clear_user_ids();
  const std::string& user_ids(int index) const;
  std::string* mutable_user_ids(int index);
  void set_user_ids(int index, const std::string& value);
  void set_user_ids(int index, std::string&& value);
  void set_user_ids(int index, const char* value);
  void set_user_ids(int index, const char* value, size_t size);
  std::string* add_user_ids();
  void add_user_ids(const std::string& value);
  void add_user_ids(std::string&& value);
  void add_user_ids(const char* value);
  void add_user_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& user_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_user_ids();
  private:
  const std::string& _internal_user_ids(int index) const;
  std::string* _internal_add_user_ids();
  public:

  // repeated string usernames = 2;
  int usernames_size() const;
  private:
  int _internal_usernames_size() const;
  public:
  void clear_usernames();
  const std::string& usernames(int index) const;
  std::string* mutable_usernames(int index);
  void set_usernames(int index, const std::string& value);
  void set_usernames(int index, std::string&& value);
  void set_usernames(int index, const char* value);
  void set_usernames(int index, const char* value, size_t size);
  std::string* add_usernames();
  void add_usernames(const std::string& value);
  void add_usernames(std::string&& value);
  void add_usernames(const char* value);
  void add_usernames(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& usernames() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_usernames();
  private:
  const std::string& _internal_usernames(int index) const;
  std::string* _internal_add_usernames();
  public:

  // @@protoc_insertion_point(class_scope:nakama.realtime.StatusFollow)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> user_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> usernames_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class StatusPresenceEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.StatusPresenceEvent) */ {
 public:
  inline StatusPresenceEvent() : StatusPresenceEvent(nullptr) {}
  virtual ~StatusPresenceEvent();

  StatusPresenceEvent(const StatusPresenceEvent& from);
  StatusPresenceEvent(StatusPresenceEvent&& from) noexcept
    : StatusPresenceEvent() {
    *this = ::std::move(from);
  }

  inline StatusPresenceEvent& operator=(const StatusPresenceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusPresenceEvent& operator=(StatusPresenceEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StatusPresenceEvent& default_instance();

  static inline const StatusPresenceEvent* internal_default_instance() {
    return reinterpret_cast<const StatusPresenceEvent*>(
               &_StatusPresenceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(StatusPresenceEvent& a, StatusPresenceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusPresenceEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusPresenceEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StatusPresenceEvent* New() const final {
    return CreateMaybeMessage<StatusPresenceEvent>(nullptr);
  }

  StatusPresenceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StatusPresenceEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StatusPresenceEvent& from);
  void MergeFrom(const StatusPresenceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusPresenceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.StatusPresenceEvent";
  }
  protected:
  explicit StatusPresenceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJoinsFieldNumber = 2,
    kLeavesFieldNumber = 3,
  };
  // repeated .nakama.realtime.UserPresence joins = 2;
  int joins_size() const;
  private:
  int _internal_joins_size() const;
  public:
  void clear_joins();
  ::nakama::realtime::UserPresence* mutable_joins(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >*
      mutable_joins();
  private:
  const ::nakama::realtime::UserPresence& _internal_joins(int index) const;
  ::nakama::realtime::UserPresence* _internal_add_joins();
  public:
  const ::nakama::realtime::UserPresence& joins(int index) const;
  ::nakama::realtime::UserPresence* add_joins();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >&
      joins() const;

  // repeated .nakama.realtime.UserPresence leaves = 3;
  int leaves_size() const;
  private:
  int _internal_leaves_size() const;
  public:
  void clear_leaves();
  ::nakama::realtime::UserPresence* mutable_leaves(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >*
      mutable_leaves();
  private:
  const ::nakama::realtime::UserPresence& _internal_leaves(int index) const;
  ::nakama::realtime::UserPresence* _internal_add_leaves();
  public:
  const ::nakama::realtime::UserPresence& leaves(int index) const;
  ::nakama::realtime::UserPresence* add_leaves();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >&
      leaves() const;

  // @@protoc_insertion_point(class_scope:nakama.realtime.StatusPresenceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence > joins_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence > leaves_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class StatusUnfollow PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.StatusUnfollow) */ {
 public:
  inline StatusUnfollow() : StatusUnfollow(nullptr) {}
  virtual ~StatusUnfollow();

  StatusUnfollow(const StatusUnfollow& from);
  StatusUnfollow(StatusUnfollow&& from) noexcept
    : StatusUnfollow() {
    *this = ::std::move(from);
  }

  inline StatusUnfollow& operator=(const StatusUnfollow& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusUnfollow& operator=(StatusUnfollow&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StatusUnfollow& default_instance();

  static inline const StatusUnfollow* internal_default_instance() {
    return reinterpret_cast<const StatusUnfollow*>(
               &_StatusUnfollow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(StatusUnfollow& a, StatusUnfollow& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusUnfollow* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusUnfollow* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StatusUnfollow* New() const final {
    return CreateMaybeMessage<StatusUnfollow>(nullptr);
  }

  StatusUnfollow* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StatusUnfollow>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StatusUnfollow& from);
  void MergeFrom(const StatusUnfollow& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusUnfollow* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.StatusUnfollow";
  }
  protected:
  explicit StatusUnfollow(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdsFieldNumber = 1,
  };
  // repeated string user_ids = 1;
  int user_ids_size() const;
  private:
  int _internal_user_ids_size() const;
  public:
  void clear_user_ids();
  const std::string& user_ids(int index) const;
  std::string* mutable_user_ids(int index);
  void set_user_ids(int index, const std::string& value);
  void set_user_ids(int index, std::string&& value);
  void set_user_ids(int index, const char* value);
  void set_user_ids(int index, const char* value, size_t size);
  std::string* add_user_ids();
  void add_user_ids(const std::string& value);
  void add_user_ids(std::string&& value);
  void add_user_ids(const char* value);
  void add_user_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& user_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_user_ids();
  private:
  const std::string& _internal_user_ids(int index) const;
  std::string* _internal_add_user_ids();
  public:

  // @@protoc_insertion_point(class_scope:nakama.realtime.StatusUnfollow)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> user_ids_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class StatusUpdate PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.StatusUpdate) */ {
 public:
  inline StatusUpdate() : StatusUpdate(nullptr) {}
  virtual ~StatusUpdate();

  StatusUpdate(const StatusUpdate& from);
  StatusUpdate(StatusUpdate&& from) noexcept
    : StatusUpdate() {
    *this = ::std::move(from);
  }

  inline StatusUpdate& operator=(const StatusUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusUpdate& operator=(StatusUpdate&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StatusUpdate& default_instance();

  static inline const StatusUpdate* internal_default_instance() {
    return reinterpret_cast<const StatusUpdate*>(
               &_StatusUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(StatusUpdate& a, StatusUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusUpdate* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StatusUpdate* New() const final {
    return CreateMaybeMessage<StatusUpdate>(nullptr);
  }

  StatusUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StatusUpdate>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StatusUpdate& from);
  void MergeFrom(const StatusUpdate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusUpdate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.StatusUpdate";
  }
  protected:
  explicit StatusUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .google.protobuf.StringValue status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const PROTOBUF_NAMESPACE_ID::StringValue& status() const;
  PROTOBUF_NAMESPACE_ID::StringValue* release_status();
  PROTOBUF_NAMESPACE_ID::StringValue* mutable_status();
  void set_allocated_status(PROTOBUF_NAMESPACE_ID::StringValue* status);
  private:
  const PROTOBUF_NAMESPACE_ID::StringValue& _internal_status() const;
  PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      PROTOBUF_NAMESPACE_ID::StringValue* status);
  PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:nakama.realtime.StatusUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  PROTOBUF_NAMESPACE_ID::StringValue* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class Stream PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.Stream) */ {
 public:
  inline Stream() : Stream(nullptr) {}
  virtual ~Stream();

  Stream(const Stream& from);
  Stream(Stream&& from) noexcept
    : Stream() {
    *this = ::std::move(from);
  }

  inline Stream& operator=(const Stream& from) {
    CopyFrom(from);
    return *this;
  }
  inline Stream& operator=(Stream&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Stream& default_instance();

  static inline const Stream* internal_default_instance() {
    return reinterpret_cast<const Stream*>(
               &_Stream_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(Stream& a, Stream& b) {
    a.Swap(&b);
  }
  inline void Swap(Stream* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Stream* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Stream* New() const final {
    return CreateMaybeMessage<Stream>(nullptr);
  }

  Stream* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Stream>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Stream& from);
  void MergeFrom(const Stream& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Stream* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.Stream";
  }
  protected:
  explicit Stream(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubjectFieldNumber = 2,
    kSubcontextFieldNumber = 3,
    kLabelFieldNumber = 4,
    kModeFieldNumber = 1,
  };
  // string subject = 2;
  void clear_subject();
  const std::string& subject() const;
  void set_subject(const std::string& value);
  void set_subject(std::string&& value);
  void set_subject(const char* value);
  void set_subject(const char* value, size_t size);
  std::string* mutable_subject();
  std::string* release_subject();
  void set_allocated_subject(std::string* subject);
  private:
  const std::string& _internal_subject() const;
  void _internal_set_subject(const std::string& value);
  std::string* _internal_mutable_subject();
  public:

  // string subcontext = 3;
  void clear_subcontext();
  const std::string& subcontext() const;
  void set_subcontext(const std::string& value);
  void set_subcontext(std::string&& value);
  void set_subcontext(const char* value);
  void set_subcontext(const char* value, size_t size);
  std::string* mutable_subcontext();
  std::string* release_subcontext();
  void set_allocated_subcontext(std::string* subcontext);
  private:
  const std::string& _internal_subcontext() const;
  void _internal_set_subcontext(const std::string& value);
  std::string* _internal_mutable_subcontext();
  public:

  // string label = 4;
  void clear_label();
  const std::string& label() const;
  void set_label(const std::string& value);
  void set_label(std::string&& value);
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  std::string* mutable_label();
  std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // int32 mode = 1;
  void clear_mode();
  ::PROTOBUF_NAMESPACE_ID::int32 mode() const;
  void set_mode(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_mode() const;
  void _internal_set_mode(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:nakama.realtime.Stream)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subject_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subcontext_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
  ::PROTOBUF_NAMESPACE_ID::int32 mode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class StreamData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.StreamData) */ {
 public:
  inline StreamData() : StreamData(nullptr) {}
  virtual ~StreamData();

  StreamData(const StreamData& from);
  StreamData(StreamData&& from) noexcept
    : StreamData() {
    *this = ::std::move(from);
  }

  inline StreamData& operator=(const StreamData& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamData& operator=(StreamData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StreamData& default_instance();

  static inline const StreamData* internal_default_instance() {
    return reinterpret_cast<const StreamData*>(
               &_StreamData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(StreamData& a, StreamData& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StreamData* New() const final {
    return CreateMaybeMessage<StreamData>(nullptr);
  }

  StreamData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StreamData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StreamData& from);
  void MergeFrom(const StreamData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.StreamData";
  }
  protected:
  explicit StreamData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 3,
    kStreamFieldNumber = 1,
    kSenderFieldNumber = 2,
    kReliableFieldNumber = 4,
  };
  // string data = 3;
  void clear_data();
  const std::string& data() const;
  void set_data(const std::string& value);
  void set_data(std::string&& value);
  void set_data(const char* value);
  void set_data(const char* value, size_t size);
  std::string* mutable_data();
  std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .nakama.realtime.Stream stream = 1;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::nakama::realtime::Stream& stream() const;
  ::nakama::realtime::Stream* release_stream();
  ::nakama::realtime::Stream* mutable_stream();
  void set_allocated_stream(::nakama::realtime::Stream* stream);
  private:
  const ::nakama::realtime::Stream& _internal_stream() const;
  ::nakama::realtime::Stream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::nakama::realtime::Stream* stream);
  ::nakama::realtime::Stream* unsafe_arena_release_stream();

  // .nakama.realtime.UserPresence sender = 2;
  bool has_sender() const;
  private:
  bool _internal_has_sender() const;
  public:
  void clear_sender();
  const ::nakama::realtime::UserPresence& sender() const;
  ::nakama::realtime::UserPresence* release_sender();
  ::nakama::realtime::UserPresence* mutable_sender();
  void set_allocated_sender(::nakama::realtime::UserPresence* sender);
  private:
  const ::nakama::realtime::UserPresence& _internal_sender() const;
  ::nakama::realtime::UserPresence* _internal_mutable_sender();
  public:
  void unsafe_arena_set_allocated_sender(
      ::nakama::realtime::UserPresence* sender);
  ::nakama::realtime::UserPresence* unsafe_arena_release_sender();

  // bool reliable = 4;
  void clear_reliable();
  bool reliable() const;
  void set_reliable(bool value);
  private:
  bool _internal_reliable() const;
  void _internal_set_reliable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:nakama.realtime.StreamData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::nakama::realtime::Stream* stream_;
  ::nakama::realtime::UserPresence* sender_;
  bool reliable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class StreamPresenceEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.StreamPresenceEvent) */ {
 public:
  inline StreamPresenceEvent() : StreamPresenceEvent(nullptr) {}
  virtual ~StreamPresenceEvent();

  StreamPresenceEvent(const StreamPresenceEvent& from);
  StreamPresenceEvent(StreamPresenceEvent&& from) noexcept
    : StreamPresenceEvent() {
    *this = ::std::move(from);
  }

  inline StreamPresenceEvent& operator=(const StreamPresenceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamPresenceEvent& operator=(StreamPresenceEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StreamPresenceEvent& default_instance();

  static inline const StreamPresenceEvent* internal_default_instance() {
    return reinterpret_cast<const StreamPresenceEvent*>(
               &_StreamPresenceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(StreamPresenceEvent& a, StreamPresenceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamPresenceEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamPresenceEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StreamPresenceEvent* New() const final {
    return CreateMaybeMessage<StreamPresenceEvent>(nullptr);
  }

  StreamPresenceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StreamPresenceEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StreamPresenceEvent& from);
  void MergeFrom(const StreamPresenceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamPresenceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.StreamPresenceEvent";
  }
  protected:
  explicit StreamPresenceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJoinsFieldNumber = 2,
    kLeavesFieldNumber = 3,
    kStreamFieldNumber = 1,
  };
  // repeated .nakama.realtime.UserPresence joins = 2;
  int joins_size() const;
  private:
  int _internal_joins_size() const;
  public:
  void clear_joins();
  ::nakama::realtime::UserPresence* mutable_joins(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >*
      mutable_joins();
  private:
  const ::nakama::realtime::UserPresence& _internal_joins(int index) const;
  ::nakama::realtime::UserPresence* _internal_add_joins();
  public:
  const ::nakama::realtime::UserPresence& joins(int index) const;
  ::nakama::realtime::UserPresence* add_joins();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >&
      joins() const;

  // repeated .nakama.realtime.UserPresence leaves = 3;
  int leaves_size() const;
  private:
  int _internal_leaves_size() const;
  public:
  void clear_leaves();
  ::nakama::realtime::UserPresence* mutable_leaves(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >*
      mutable_leaves();
  private:
  const ::nakama::realtime::UserPresence& _internal_leaves(int index) const;
  ::nakama::realtime::UserPresence* _internal_add_leaves();
  public:
  const ::nakama::realtime::UserPresence& leaves(int index) const;
  ::nakama::realtime::UserPresence* add_leaves();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >&
      leaves() const;

  // .nakama.realtime.Stream stream = 1;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::nakama::realtime::Stream& stream() const;
  ::nakama::realtime::Stream* release_stream();
  ::nakama::realtime::Stream* mutable_stream();
  void set_allocated_stream(::nakama::realtime::Stream* stream);
  private:
  const ::nakama::realtime::Stream& _internal_stream() const;
  ::nakama::realtime::Stream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::nakama::realtime::Stream* stream);
  ::nakama::realtime::Stream* unsafe_arena_release_stream();

  // @@protoc_insertion_point(class_scope:nakama.realtime.StreamPresenceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence > joins_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence > leaves_;
  ::nakama::realtime::Stream* stream_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// -------------------------------------------------------------------

class UserPresence PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.UserPresence) */ {
 public:
  inline UserPresence() : UserPresence(nullptr) {}
  virtual ~UserPresence();

  UserPresence(const UserPresence& from);
  UserPresence(UserPresence&& from) noexcept
    : UserPresence() {
    *this = ::std::move(from);
  }

  inline UserPresence& operator=(const UserPresence& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserPresence& operator=(UserPresence&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UserPresence& default_instance();

  static inline const UserPresence* internal_default_instance() {
    return reinterpret_cast<const UserPresence*>(
               &_UserPresence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(UserPresence& a, UserPresence& b) {
    a.Swap(&b);
  }
  inline void Swap(UserPresence* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserPresence* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UserPresence* New() const final {
    return CreateMaybeMessage<UserPresence>(nullptr);
  }

  UserPresence* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserPresence>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UserPresence& from);
  void MergeFrom(const UserPresence& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserPresence* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nakama.realtime.UserPresence";
  }
  protected:
  explicit UserPresence(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto);
    return ::descriptor_table_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kSessionIdFieldNumber = 2,
    kUsernameFieldNumber = 3,
    kStatusFieldNumber = 5,
    kPersistenceFieldNumber = 4,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  void set_user_id(const std::string& value);
  void set_user_id(std::string&& value);
  void set_user_id(const char* value);
  void set_user_id(const char* value, size_t size);
  std::string* mutable_user_id();
  std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string session_id = 2;
  void clear_session_id();
  const std::string& session_id() const;
  void set_session_id(const std::string& value);
  void set_session_id(std::string&& value);
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  std::string* mutable_session_id();
  std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // string username = 3;
  void clear_username();
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // .google.protobuf.StringValue status = 5;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const PROTOBUF_NAMESPACE_ID::StringValue& status() const;
  PROTOBUF_NAMESPACE_ID::StringValue* release_status();
  PROTOBUF_NAMESPACE_ID::StringValue* mutable_status();
  void set_allocated_status(PROTOBUF_NAMESPACE_ID::StringValue* status);
  private:
  const PROTOBUF_NAMESPACE_ID::StringValue& _internal_status() const;
  PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      PROTOBUF_NAMESPACE_ID::StringValue* status);
  PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_status();

  // bool persistence = 4;
  void clear_persistence();
  bool persistence() const;
  void set_persistence(bool value);
  private:
  bool _internal_persistence() const;
  void _internal_set_persistence(bool value);
  public:

  // @@protoc_insertion_point(class_scope:nakama.realtime.UserPresence)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  PROTOBUF_NAMESPACE_ID::StringValue* status_;
  bool persistence_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Envelope

// string cid = 1;
inline void Envelope::clear_cid() {
  cid_.ClearToEmpty();
}
inline const std::string& Envelope::cid() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.cid)
  return _internal_cid();
}
inline void Envelope::set_cid(const std::string& value) {
  _internal_set_cid(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.Envelope.cid)
}
inline std::string* Envelope::mutable_cid() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.cid)
  return _internal_mutable_cid();
}
inline const std::string& Envelope::_internal_cid() const {
  return cid_.Get();
}
inline void Envelope::_internal_set_cid(const std::string& value) {
  
  cid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Envelope::set_cid(std::string&& value) {
  
  cid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.Envelope.cid)
}
inline void Envelope::set_cid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  cid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.Envelope.cid)
}
inline void Envelope::set_cid(const char* value,
    size_t size) {
  
  cid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.Envelope.cid)
}
inline std::string* Envelope::_internal_mutable_cid() {
  
  return cid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Envelope::release_cid() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.cid)
  return cid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Envelope::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    
  } else {
    
  }
  cid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.Envelope.cid)
}

// .nakama.realtime.Channel channel = 2;
inline bool Envelope::_internal_has_channel() const {
  return message_case() == kChannel;
}
inline bool Envelope::has_channel() const {
  return _internal_has_channel();
}
inline void Envelope::set_has_channel() {
  _oneof_case_[0] = kChannel;
}
inline void Envelope::clear_channel() {
  if (_internal_has_channel()) {
    if (GetArena() == nullptr) {
      delete message_.channel_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::Channel* Envelope::release_channel() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.channel)
  if (_internal_has_channel()) {
    clear_has_message();
      ::nakama::realtime::Channel* temp = message_.channel_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.channel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::Channel& Envelope::_internal_channel() const {
  return _internal_has_channel()
      ? *message_.channel_
      : reinterpret_cast< ::nakama::realtime::Channel&>(::nakama::realtime::_Channel_default_instance_);
}
inline const ::nakama::realtime::Channel& Envelope::channel() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.channel)
  return _internal_channel();
}
inline ::nakama::realtime::Channel* Envelope::unsafe_arena_release_channel() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.channel)
  if (_internal_has_channel()) {
    clear_has_message();
    ::nakama::realtime::Channel* temp = message_.channel_;
    message_.channel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_channel(::nakama::realtime::Channel* channel) {
  clear_message();
  if (channel) {
    set_has_channel();
    message_.channel_ = channel;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.channel)
}
inline ::nakama::realtime::Channel* Envelope::_internal_mutable_channel() {
  if (!_internal_has_channel()) {
    clear_message();
    set_has_channel();
    message_.channel_ = CreateMaybeMessage< ::nakama::realtime::Channel >(GetArena());
  }
  return message_.channel_;
}
inline ::nakama::realtime::Channel* Envelope::mutable_channel() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.channel)
  return _internal_mutable_channel();
}

// .nakama.realtime.ChannelJoin channel_join = 3;
inline bool Envelope::_internal_has_channel_join() const {
  return message_case() == kChannelJoin;
}
inline bool Envelope::has_channel_join() const {
  return _internal_has_channel_join();
}
inline void Envelope::set_has_channel_join() {
  _oneof_case_[0] = kChannelJoin;
}
inline void Envelope::clear_channel_join() {
  if (_internal_has_channel_join()) {
    if (GetArena() == nullptr) {
      delete message_.channel_join_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::ChannelJoin* Envelope::release_channel_join() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.channel_join)
  if (_internal_has_channel_join()) {
    clear_has_message();
      ::nakama::realtime::ChannelJoin* temp = message_.channel_join_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.channel_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::ChannelJoin& Envelope::_internal_channel_join() const {
  return _internal_has_channel_join()
      ? *message_.channel_join_
      : reinterpret_cast< ::nakama::realtime::ChannelJoin&>(::nakama::realtime::_ChannelJoin_default_instance_);
}
inline const ::nakama::realtime::ChannelJoin& Envelope::channel_join() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.channel_join)
  return _internal_channel_join();
}
inline ::nakama::realtime::ChannelJoin* Envelope::unsafe_arena_release_channel_join() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.channel_join)
  if (_internal_has_channel_join()) {
    clear_has_message();
    ::nakama::realtime::ChannelJoin* temp = message_.channel_join_;
    message_.channel_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_channel_join(::nakama::realtime::ChannelJoin* channel_join) {
  clear_message();
  if (channel_join) {
    set_has_channel_join();
    message_.channel_join_ = channel_join;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.channel_join)
}
inline ::nakama::realtime::ChannelJoin* Envelope::_internal_mutable_channel_join() {
  if (!_internal_has_channel_join()) {
    clear_message();
    set_has_channel_join();
    message_.channel_join_ = CreateMaybeMessage< ::nakama::realtime::ChannelJoin >(GetArena());
  }
  return message_.channel_join_;
}
inline ::nakama::realtime::ChannelJoin* Envelope::mutable_channel_join() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.channel_join)
  return _internal_mutable_channel_join();
}

// .nakama.realtime.ChannelLeave channel_leave = 4;
inline bool Envelope::_internal_has_channel_leave() const {
  return message_case() == kChannelLeave;
}
inline bool Envelope::has_channel_leave() const {
  return _internal_has_channel_leave();
}
inline void Envelope::set_has_channel_leave() {
  _oneof_case_[0] = kChannelLeave;
}
inline void Envelope::clear_channel_leave() {
  if (_internal_has_channel_leave()) {
    if (GetArena() == nullptr) {
      delete message_.channel_leave_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::ChannelLeave* Envelope::release_channel_leave() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.channel_leave)
  if (_internal_has_channel_leave()) {
    clear_has_message();
      ::nakama::realtime::ChannelLeave* temp = message_.channel_leave_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.channel_leave_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::ChannelLeave& Envelope::_internal_channel_leave() const {
  return _internal_has_channel_leave()
      ? *message_.channel_leave_
      : reinterpret_cast< ::nakama::realtime::ChannelLeave&>(::nakama::realtime::_ChannelLeave_default_instance_);
}
inline const ::nakama::realtime::ChannelLeave& Envelope::channel_leave() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.channel_leave)
  return _internal_channel_leave();
}
inline ::nakama::realtime::ChannelLeave* Envelope::unsafe_arena_release_channel_leave() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.channel_leave)
  if (_internal_has_channel_leave()) {
    clear_has_message();
    ::nakama::realtime::ChannelLeave* temp = message_.channel_leave_;
    message_.channel_leave_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_channel_leave(::nakama::realtime::ChannelLeave* channel_leave) {
  clear_message();
  if (channel_leave) {
    set_has_channel_leave();
    message_.channel_leave_ = channel_leave;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.channel_leave)
}
inline ::nakama::realtime::ChannelLeave* Envelope::_internal_mutable_channel_leave() {
  if (!_internal_has_channel_leave()) {
    clear_message();
    set_has_channel_leave();
    message_.channel_leave_ = CreateMaybeMessage< ::nakama::realtime::ChannelLeave >(GetArena());
  }
  return message_.channel_leave_;
}
inline ::nakama::realtime::ChannelLeave* Envelope::mutable_channel_leave() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.channel_leave)
  return _internal_mutable_channel_leave();
}

// .nakama.api.ChannelMessage channel_message = 5;
inline bool Envelope::_internal_has_channel_message() const {
  return message_case() == kChannelMessage;
}
inline bool Envelope::has_channel_message() const {
  return _internal_has_channel_message();
}
inline void Envelope::set_has_channel_message() {
  _oneof_case_[0] = kChannelMessage;
}
inline ::nakama::api::ChannelMessage* Envelope::release_channel_message() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.channel_message)
  if (_internal_has_channel_message()) {
    clear_has_message();
      ::nakama::api::ChannelMessage* temp = message_.channel_message_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.channel_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::api::ChannelMessage& Envelope::_internal_channel_message() const {
  return _internal_has_channel_message()
      ? *message_.channel_message_
      : reinterpret_cast< ::nakama::api::ChannelMessage&>(::nakama::api::_ChannelMessage_default_instance_);
}
inline const ::nakama::api::ChannelMessage& Envelope::channel_message() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.channel_message)
  return _internal_channel_message();
}
inline ::nakama::api::ChannelMessage* Envelope::unsafe_arena_release_channel_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.channel_message)
  if (_internal_has_channel_message()) {
    clear_has_message();
    ::nakama::api::ChannelMessage* temp = message_.channel_message_;
    message_.channel_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_channel_message(::nakama::api::ChannelMessage* channel_message) {
  clear_message();
  if (channel_message) {
    set_has_channel_message();
    message_.channel_message_ = channel_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.channel_message)
}
inline ::nakama::api::ChannelMessage* Envelope::_internal_mutable_channel_message() {
  if (!_internal_has_channel_message()) {
    clear_message();
    set_has_channel_message();
    message_.channel_message_ = CreateMaybeMessage< ::nakama::api::ChannelMessage >(GetArena());
  }
  return message_.channel_message_;
}
inline ::nakama::api::ChannelMessage* Envelope::mutable_channel_message() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.channel_message)
  return _internal_mutable_channel_message();
}

// .nakama.realtime.ChannelMessageAck channel_message_ack = 6;
inline bool Envelope::_internal_has_channel_message_ack() const {
  return message_case() == kChannelMessageAck;
}
inline bool Envelope::has_channel_message_ack() const {
  return _internal_has_channel_message_ack();
}
inline void Envelope::set_has_channel_message_ack() {
  _oneof_case_[0] = kChannelMessageAck;
}
inline void Envelope::clear_channel_message_ack() {
  if (_internal_has_channel_message_ack()) {
    if (GetArena() == nullptr) {
      delete message_.channel_message_ack_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::ChannelMessageAck* Envelope::release_channel_message_ack() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.channel_message_ack)
  if (_internal_has_channel_message_ack()) {
    clear_has_message();
      ::nakama::realtime::ChannelMessageAck* temp = message_.channel_message_ack_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.channel_message_ack_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::ChannelMessageAck& Envelope::_internal_channel_message_ack() const {
  return _internal_has_channel_message_ack()
      ? *message_.channel_message_ack_
      : reinterpret_cast< ::nakama::realtime::ChannelMessageAck&>(::nakama::realtime::_ChannelMessageAck_default_instance_);
}
inline const ::nakama::realtime::ChannelMessageAck& Envelope::channel_message_ack() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.channel_message_ack)
  return _internal_channel_message_ack();
}
inline ::nakama::realtime::ChannelMessageAck* Envelope::unsafe_arena_release_channel_message_ack() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.channel_message_ack)
  if (_internal_has_channel_message_ack()) {
    clear_has_message();
    ::nakama::realtime::ChannelMessageAck* temp = message_.channel_message_ack_;
    message_.channel_message_ack_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_channel_message_ack(::nakama::realtime::ChannelMessageAck* channel_message_ack) {
  clear_message();
  if (channel_message_ack) {
    set_has_channel_message_ack();
    message_.channel_message_ack_ = channel_message_ack;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.channel_message_ack)
}
inline ::nakama::realtime::ChannelMessageAck* Envelope::_internal_mutable_channel_message_ack() {
  if (!_internal_has_channel_message_ack()) {
    clear_message();
    set_has_channel_message_ack();
    message_.channel_message_ack_ = CreateMaybeMessage< ::nakama::realtime::ChannelMessageAck >(GetArena());
  }
  return message_.channel_message_ack_;
}
inline ::nakama::realtime::ChannelMessageAck* Envelope::mutable_channel_message_ack() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.channel_message_ack)
  return _internal_mutable_channel_message_ack();
}

// .nakama.realtime.ChannelMessageSend channel_message_send = 7;
inline bool Envelope::_internal_has_channel_message_send() const {
  return message_case() == kChannelMessageSend;
}
inline bool Envelope::has_channel_message_send() const {
  return _internal_has_channel_message_send();
}
inline void Envelope::set_has_channel_message_send() {
  _oneof_case_[0] = kChannelMessageSend;
}
inline void Envelope::clear_channel_message_send() {
  if (_internal_has_channel_message_send()) {
    if (GetArena() == nullptr) {
      delete message_.channel_message_send_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::ChannelMessageSend* Envelope::release_channel_message_send() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.channel_message_send)
  if (_internal_has_channel_message_send()) {
    clear_has_message();
      ::nakama::realtime::ChannelMessageSend* temp = message_.channel_message_send_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.channel_message_send_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::ChannelMessageSend& Envelope::_internal_channel_message_send() const {
  return _internal_has_channel_message_send()
      ? *message_.channel_message_send_
      : reinterpret_cast< ::nakama::realtime::ChannelMessageSend&>(::nakama::realtime::_ChannelMessageSend_default_instance_);
}
inline const ::nakama::realtime::ChannelMessageSend& Envelope::channel_message_send() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.channel_message_send)
  return _internal_channel_message_send();
}
inline ::nakama::realtime::ChannelMessageSend* Envelope::unsafe_arena_release_channel_message_send() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.channel_message_send)
  if (_internal_has_channel_message_send()) {
    clear_has_message();
    ::nakama::realtime::ChannelMessageSend* temp = message_.channel_message_send_;
    message_.channel_message_send_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_channel_message_send(::nakama::realtime::ChannelMessageSend* channel_message_send) {
  clear_message();
  if (channel_message_send) {
    set_has_channel_message_send();
    message_.channel_message_send_ = channel_message_send;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.channel_message_send)
}
inline ::nakama::realtime::ChannelMessageSend* Envelope::_internal_mutable_channel_message_send() {
  if (!_internal_has_channel_message_send()) {
    clear_message();
    set_has_channel_message_send();
    message_.channel_message_send_ = CreateMaybeMessage< ::nakama::realtime::ChannelMessageSend >(GetArena());
  }
  return message_.channel_message_send_;
}
inline ::nakama::realtime::ChannelMessageSend* Envelope::mutable_channel_message_send() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.channel_message_send)
  return _internal_mutable_channel_message_send();
}

// .nakama.realtime.ChannelMessageUpdate channel_message_update = 8;
inline bool Envelope::_internal_has_channel_message_update() const {
  return message_case() == kChannelMessageUpdate;
}
inline bool Envelope::has_channel_message_update() const {
  return _internal_has_channel_message_update();
}
inline void Envelope::set_has_channel_message_update() {
  _oneof_case_[0] = kChannelMessageUpdate;
}
inline void Envelope::clear_channel_message_update() {
  if (_internal_has_channel_message_update()) {
    if (GetArena() == nullptr) {
      delete message_.channel_message_update_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::ChannelMessageUpdate* Envelope::release_channel_message_update() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.channel_message_update)
  if (_internal_has_channel_message_update()) {
    clear_has_message();
      ::nakama::realtime::ChannelMessageUpdate* temp = message_.channel_message_update_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.channel_message_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::ChannelMessageUpdate& Envelope::_internal_channel_message_update() const {
  return _internal_has_channel_message_update()
      ? *message_.channel_message_update_
      : reinterpret_cast< ::nakama::realtime::ChannelMessageUpdate&>(::nakama::realtime::_ChannelMessageUpdate_default_instance_);
}
inline const ::nakama::realtime::ChannelMessageUpdate& Envelope::channel_message_update() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.channel_message_update)
  return _internal_channel_message_update();
}
inline ::nakama::realtime::ChannelMessageUpdate* Envelope::unsafe_arena_release_channel_message_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.channel_message_update)
  if (_internal_has_channel_message_update()) {
    clear_has_message();
    ::nakama::realtime::ChannelMessageUpdate* temp = message_.channel_message_update_;
    message_.channel_message_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_channel_message_update(::nakama::realtime::ChannelMessageUpdate* channel_message_update) {
  clear_message();
  if (channel_message_update) {
    set_has_channel_message_update();
    message_.channel_message_update_ = channel_message_update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.channel_message_update)
}
inline ::nakama::realtime::ChannelMessageUpdate* Envelope::_internal_mutable_channel_message_update() {
  if (!_internal_has_channel_message_update()) {
    clear_message();
    set_has_channel_message_update();
    message_.channel_message_update_ = CreateMaybeMessage< ::nakama::realtime::ChannelMessageUpdate >(GetArena());
  }
  return message_.channel_message_update_;
}
inline ::nakama::realtime::ChannelMessageUpdate* Envelope::mutable_channel_message_update() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.channel_message_update)
  return _internal_mutable_channel_message_update();
}

// .nakama.realtime.ChannelMessageRemove channel_message_remove = 9;
inline bool Envelope::_internal_has_channel_message_remove() const {
  return message_case() == kChannelMessageRemove;
}
inline bool Envelope::has_channel_message_remove() const {
  return _internal_has_channel_message_remove();
}
inline void Envelope::set_has_channel_message_remove() {
  _oneof_case_[0] = kChannelMessageRemove;
}
inline void Envelope::clear_channel_message_remove() {
  if (_internal_has_channel_message_remove()) {
    if (GetArena() == nullptr) {
      delete message_.channel_message_remove_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::ChannelMessageRemove* Envelope::release_channel_message_remove() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.channel_message_remove)
  if (_internal_has_channel_message_remove()) {
    clear_has_message();
      ::nakama::realtime::ChannelMessageRemove* temp = message_.channel_message_remove_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.channel_message_remove_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::ChannelMessageRemove& Envelope::_internal_channel_message_remove() const {
  return _internal_has_channel_message_remove()
      ? *message_.channel_message_remove_
      : reinterpret_cast< ::nakama::realtime::ChannelMessageRemove&>(::nakama::realtime::_ChannelMessageRemove_default_instance_);
}
inline const ::nakama::realtime::ChannelMessageRemove& Envelope::channel_message_remove() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.channel_message_remove)
  return _internal_channel_message_remove();
}
inline ::nakama::realtime::ChannelMessageRemove* Envelope::unsafe_arena_release_channel_message_remove() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.channel_message_remove)
  if (_internal_has_channel_message_remove()) {
    clear_has_message();
    ::nakama::realtime::ChannelMessageRemove* temp = message_.channel_message_remove_;
    message_.channel_message_remove_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_channel_message_remove(::nakama::realtime::ChannelMessageRemove* channel_message_remove) {
  clear_message();
  if (channel_message_remove) {
    set_has_channel_message_remove();
    message_.channel_message_remove_ = channel_message_remove;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.channel_message_remove)
}
inline ::nakama::realtime::ChannelMessageRemove* Envelope::_internal_mutable_channel_message_remove() {
  if (!_internal_has_channel_message_remove()) {
    clear_message();
    set_has_channel_message_remove();
    message_.channel_message_remove_ = CreateMaybeMessage< ::nakama::realtime::ChannelMessageRemove >(GetArena());
  }
  return message_.channel_message_remove_;
}
inline ::nakama::realtime::ChannelMessageRemove* Envelope::mutable_channel_message_remove() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.channel_message_remove)
  return _internal_mutable_channel_message_remove();
}

// .nakama.realtime.ChannelPresenceEvent channel_presence_event = 10;
inline bool Envelope::_internal_has_channel_presence_event() const {
  return message_case() == kChannelPresenceEvent;
}
inline bool Envelope::has_channel_presence_event() const {
  return _internal_has_channel_presence_event();
}
inline void Envelope::set_has_channel_presence_event() {
  _oneof_case_[0] = kChannelPresenceEvent;
}
inline void Envelope::clear_channel_presence_event() {
  if (_internal_has_channel_presence_event()) {
    if (GetArena() == nullptr) {
      delete message_.channel_presence_event_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::ChannelPresenceEvent* Envelope::release_channel_presence_event() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.channel_presence_event)
  if (_internal_has_channel_presence_event()) {
    clear_has_message();
      ::nakama::realtime::ChannelPresenceEvent* temp = message_.channel_presence_event_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.channel_presence_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::ChannelPresenceEvent& Envelope::_internal_channel_presence_event() const {
  return _internal_has_channel_presence_event()
      ? *message_.channel_presence_event_
      : reinterpret_cast< ::nakama::realtime::ChannelPresenceEvent&>(::nakama::realtime::_ChannelPresenceEvent_default_instance_);
}
inline const ::nakama::realtime::ChannelPresenceEvent& Envelope::channel_presence_event() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.channel_presence_event)
  return _internal_channel_presence_event();
}
inline ::nakama::realtime::ChannelPresenceEvent* Envelope::unsafe_arena_release_channel_presence_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.channel_presence_event)
  if (_internal_has_channel_presence_event()) {
    clear_has_message();
    ::nakama::realtime::ChannelPresenceEvent* temp = message_.channel_presence_event_;
    message_.channel_presence_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_channel_presence_event(::nakama::realtime::ChannelPresenceEvent* channel_presence_event) {
  clear_message();
  if (channel_presence_event) {
    set_has_channel_presence_event();
    message_.channel_presence_event_ = channel_presence_event;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.channel_presence_event)
}
inline ::nakama::realtime::ChannelPresenceEvent* Envelope::_internal_mutable_channel_presence_event() {
  if (!_internal_has_channel_presence_event()) {
    clear_message();
    set_has_channel_presence_event();
    message_.channel_presence_event_ = CreateMaybeMessage< ::nakama::realtime::ChannelPresenceEvent >(GetArena());
  }
  return message_.channel_presence_event_;
}
inline ::nakama::realtime::ChannelPresenceEvent* Envelope::mutable_channel_presence_event() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.channel_presence_event)
  return _internal_mutable_channel_presence_event();
}

// .nakama.realtime.Error error = 11;
inline bool Envelope::_internal_has_error() const {
  return message_case() == kError;
}
inline bool Envelope::has_error() const {
  return _internal_has_error();
}
inline void Envelope::set_has_error() {
  _oneof_case_[0] = kError;
}
inline void Envelope::clear_error() {
  if (_internal_has_error()) {
    if (GetArena() == nullptr) {
      delete message_.error_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::Error* Envelope::release_error() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.error)
  if (_internal_has_error()) {
    clear_has_message();
      ::nakama::realtime::Error* temp = message_.error_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::Error& Envelope::_internal_error() const {
  return _internal_has_error()
      ? *message_.error_
      : reinterpret_cast< ::nakama::realtime::Error&>(::nakama::realtime::_Error_default_instance_);
}
inline const ::nakama::realtime::Error& Envelope::error() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.error)
  return _internal_error();
}
inline ::nakama::realtime::Error* Envelope::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.error)
  if (_internal_has_error()) {
    clear_has_message();
    ::nakama::realtime::Error* temp = message_.error_;
    message_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_error(::nakama::realtime::Error* error) {
  clear_message();
  if (error) {
    set_has_error();
    message_.error_ = error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.error)
}
inline ::nakama::realtime::Error* Envelope::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_message();
    set_has_error();
    message_.error_ = CreateMaybeMessage< ::nakama::realtime::Error >(GetArena());
  }
  return message_.error_;
}
inline ::nakama::realtime::Error* Envelope::mutable_error() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.error)
  return _internal_mutable_error();
}

// .nakama.realtime.Match match = 12;
inline bool Envelope::_internal_has_match() const {
  return message_case() == kMatch;
}
inline bool Envelope::has_match() const {
  return _internal_has_match();
}
inline void Envelope::set_has_match() {
  _oneof_case_[0] = kMatch;
}
inline void Envelope::clear_match() {
  if (_internal_has_match()) {
    if (GetArena() == nullptr) {
      delete message_.match_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::Match* Envelope::release_match() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.match)
  if (_internal_has_match()) {
    clear_has_message();
      ::nakama::realtime::Match* temp = message_.match_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.match_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::Match& Envelope::_internal_match() const {
  return _internal_has_match()
      ? *message_.match_
      : reinterpret_cast< ::nakama::realtime::Match&>(::nakama::realtime::_Match_default_instance_);
}
inline const ::nakama::realtime::Match& Envelope::match() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.match)
  return _internal_match();
}
inline ::nakama::realtime::Match* Envelope::unsafe_arena_release_match() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.match)
  if (_internal_has_match()) {
    clear_has_message();
    ::nakama::realtime::Match* temp = message_.match_;
    message_.match_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_match(::nakama::realtime::Match* match) {
  clear_message();
  if (match) {
    set_has_match();
    message_.match_ = match;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.match)
}
inline ::nakama::realtime::Match* Envelope::_internal_mutable_match() {
  if (!_internal_has_match()) {
    clear_message();
    set_has_match();
    message_.match_ = CreateMaybeMessage< ::nakama::realtime::Match >(GetArena());
  }
  return message_.match_;
}
inline ::nakama::realtime::Match* Envelope::mutable_match() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.match)
  return _internal_mutable_match();
}

// .nakama.realtime.MatchCreate match_create = 13;
inline bool Envelope::_internal_has_match_create() const {
  return message_case() == kMatchCreate;
}
inline bool Envelope::has_match_create() const {
  return _internal_has_match_create();
}
inline void Envelope::set_has_match_create() {
  _oneof_case_[0] = kMatchCreate;
}
inline void Envelope::clear_match_create() {
  if (_internal_has_match_create()) {
    if (GetArena() == nullptr) {
      delete message_.match_create_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::MatchCreate* Envelope::release_match_create() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.match_create)
  if (_internal_has_match_create()) {
    clear_has_message();
      ::nakama::realtime::MatchCreate* temp = message_.match_create_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.match_create_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::MatchCreate& Envelope::_internal_match_create() const {
  return _internal_has_match_create()
      ? *message_.match_create_
      : reinterpret_cast< ::nakama::realtime::MatchCreate&>(::nakama::realtime::_MatchCreate_default_instance_);
}
inline const ::nakama::realtime::MatchCreate& Envelope::match_create() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.match_create)
  return _internal_match_create();
}
inline ::nakama::realtime::MatchCreate* Envelope::unsafe_arena_release_match_create() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.match_create)
  if (_internal_has_match_create()) {
    clear_has_message();
    ::nakama::realtime::MatchCreate* temp = message_.match_create_;
    message_.match_create_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_match_create(::nakama::realtime::MatchCreate* match_create) {
  clear_message();
  if (match_create) {
    set_has_match_create();
    message_.match_create_ = match_create;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.match_create)
}
inline ::nakama::realtime::MatchCreate* Envelope::_internal_mutable_match_create() {
  if (!_internal_has_match_create()) {
    clear_message();
    set_has_match_create();
    message_.match_create_ = CreateMaybeMessage< ::nakama::realtime::MatchCreate >(GetArena());
  }
  return message_.match_create_;
}
inline ::nakama::realtime::MatchCreate* Envelope::mutable_match_create() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.match_create)
  return _internal_mutable_match_create();
}

// .nakama.realtime.MatchData match_data = 14;
inline bool Envelope::_internal_has_match_data() const {
  return message_case() == kMatchData;
}
inline bool Envelope::has_match_data() const {
  return _internal_has_match_data();
}
inline void Envelope::set_has_match_data() {
  _oneof_case_[0] = kMatchData;
}
inline void Envelope::clear_match_data() {
  if (_internal_has_match_data()) {
    if (GetArena() == nullptr) {
      delete message_.match_data_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::MatchData* Envelope::release_match_data() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.match_data)
  if (_internal_has_match_data()) {
    clear_has_message();
      ::nakama::realtime::MatchData* temp = message_.match_data_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.match_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::MatchData& Envelope::_internal_match_data() const {
  return _internal_has_match_data()
      ? *message_.match_data_
      : reinterpret_cast< ::nakama::realtime::MatchData&>(::nakama::realtime::_MatchData_default_instance_);
}
inline const ::nakama::realtime::MatchData& Envelope::match_data() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.match_data)
  return _internal_match_data();
}
inline ::nakama::realtime::MatchData* Envelope::unsafe_arena_release_match_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.match_data)
  if (_internal_has_match_data()) {
    clear_has_message();
    ::nakama::realtime::MatchData* temp = message_.match_data_;
    message_.match_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_match_data(::nakama::realtime::MatchData* match_data) {
  clear_message();
  if (match_data) {
    set_has_match_data();
    message_.match_data_ = match_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.match_data)
}
inline ::nakama::realtime::MatchData* Envelope::_internal_mutable_match_data() {
  if (!_internal_has_match_data()) {
    clear_message();
    set_has_match_data();
    message_.match_data_ = CreateMaybeMessage< ::nakama::realtime::MatchData >(GetArena());
  }
  return message_.match_data_;
}
inline ::nakama::realtime::MatchData* Envelope::mutable_match_data() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.match_data)
  return _internal_mutable_match_data();
}

// .nakama.realtime.MatchDataSend match_data_send = 15;
inline bool Envelope::_internal_has_match_data_send() const {
  return message_case() == kMatchDataSend;
}
inline bool Envelope::has_match_data_send() const {
  return _internal_has_match_data_send();
}
inline void Envelope::set_has_match_data_send() {
  _oneof_case_[0] = kMatchDataSend;
}
inline void Envelope::clear_match_data_send() {
  if (_internal_has_match_data_send()) {
    if (GetArena() == nullptr) {
      delete message_.match_data_send_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::MatchDataSend* Envelope::release_match_data_send() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.match_data_send)
  if (_internal_has_match_data_send()) {
    clear_has_message();
      ::nakama::realtime::MatchDataSend* temp = message_.match_data_send_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.match_data_send_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::MatchDataSend& Envelope::_internal_match_data_send() const {
  return _internal_has_match_data_send()
      ? *message_.match_data_send_
      : reinterpret_cast< ::nakama::realtime::MatchDataSend&>(::nakama::realtime::_MatchDataSend_default_instance_);
}
inline const ::nakama::realtime::MatchDataSend& Envelope::match_data_send() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.match_data_send)
  return _internal_match_data_send();
}
inline ::nakama::realtime::MatchDataSend* Envelope::unsafe_arena_release_match_data_send() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.match_data_send)
  if (_internal_has_match_data_send()) {
    clear_has_message();
    ::nakama::realtime::MatchDataSend* temp = message_.match_data_send_;
    message_.match_data_send_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_match_data_send(::nakama::realtime::MatchDataSend* match_data_send) {
  clear_message();
  if (match_data_send) {
    set_has_match_data_send();
    message_.match_data_send_ = match_data_send;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.match_data_send)
}
inline ::nakama::realtime::MatchDataSend* Envelope::_internal_mutable_match_data_send() {
  if (!_internal_has_match_data_send()) {
    clear_message();
    set_has_match_data_send();
    message_.match_data_send_ = CreateMaybeMessage< ::nakama::realtime::MatchDataSend >(GetArena());
  }
  return message_.match_data_send_;
}
inline ::nakama::realtime::MatchDataSend* Envelope::mutable_match_data_send() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.match_data_send)
  return _internal_mutable_match_data_send();
}

// .nakama.realtime.MatchJoin match_join = 16;
inline bool Envelope::_internal_has_match_join() const {
  return message_case() == kMatchJoin;
}
inline bool Envelope::has_match_join() const {
  return _internal_has_match_join();
}
inline void Envelope::set_has_match_join() {
  _oneof_case_[0] = kMatchJoin;
}
inline void Envelope::clear_match_join() {
  if (_internal_has_match_join()) {
    if (GetArena() == nullptr) {
      delete message_.match_join_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::MatchJoin* Envelope::release_match_join() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.match_join)
  if (_internal_has_match_join()) {
    clear_has_message();
      ::nakama::realtime::MatchJoin* temp = message_.match_join_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.match_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::MatchJoin& Envelope::_internal_match_join() const {
  return _internal_has_match_join()
      ? *message_.match_join_
      : reinterpret_cast< ::nakama::realtime::MatchJoin&>(::nakama::realtime::_MatchJoin_default_instance_);
}
inline const ::nakama::realtime::MatchJoin& Envelope::match_join() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.match_join)
  return _internal_match_join();
}
inline ::nakama::realtime::MatchJoin* Envelope::unsafe_arena_release_match_join() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.match_join)
  if (_internal_has_match_join()) {
    clear_has_message();
    ::nakama::realtime::MatchJoin* temp = message_.match_join_;
    message_.match_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_match_join(::nakama::realtime::MatchJoin* match_join) {
  clear_message();
  if (match_join) {
    set_has_match_join();
    message_.match_join_ = match_join;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.match_join)
}
inline ::nakama::realtime::MatchJoin* Envelope::_internal_mutable_match_join() {
  if (!_internal_has_match_join()) {
    clear_message();
    set_has_match_join();
    message_.match_join_ = CreateMaybeMessage< ::nakama::realtime::MatchJoin >(GetArena());
  }
  return message_.match_join_;
}
inline ::nakama::realtime::MatchJoin* Envelope::mutable_match_join() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.match_join)
  return _internal_mutable_match_join();
}

// .nakama.realtime.MatchLeave match_leave = 17;
inline bool Envelope::_internal_has_match_leave() const {
  return message_case() == kMatchLeave;
}
inline bool Envelope::has_match_leave() const {
  return _internal_has_match_leave();
}
inline void Envelope::set_has_match_leave() {
  _oneof_case_[0] = kMatchLeave;
}
inline void Envelope::clear_match_leave() {
  if (_internal_has_match_leave()) {
    if (GetArena() == nullptr) {
      delete message_.match_leave_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::MatchLeave* Envelope::release_match_leave() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.match_leave)
  if (_internal_has_match_leave()) {
    clear_has_message();
      ::nakama::realtime::MatchLeave* temp = message_.match_leave_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.match_leave_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::MatchLeave& Envelope::_internal_match_leave() const {
  return _internal_has_match_leave()
      ? *message_.match_leave_
      : reinterpret_cast< ::nakama::realtime::MatchLeave&>(::nakama::realtime::_MatchLeave_default_instance_);
}
inline const ::nakama::realtime::MatchLeave& Envelope::match_leave() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.match_leave)
  return _internal_match_leave();
}
inline ::nakama::realtime::MatchLeave* Envelope::unsafe_arena_release_match_leave() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.match_leave)
  if (_internal_has_match_leave()) {
    clear_has_message();
    ::nakama::realtime::MatchLeave* temp = message_.match_leave_;
    message_.match_leave_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_match_leave(::nakama::realtime::MatchLeave* match_leave) {
  clear_message();
  if (match_leave) {
    set_has_match_leave();
    message_.match_leave_ = match_leave;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.match_leave)
}
inline ::nakama::realtime::MatchLeave* Envelope::_internal_mutable_match_leave() {
  if (!_internal_has_match_leave()) {
    clear_message();
    set_has_match_leave();
    message_.match_leave_ = CreateMaybeMessage< ::nakama::realtime::MatchLeave >(GetArena());
  }
  return message_.match_leave_;
}
inline ::nakama::realtime::MatchLeave* Envelope::mutable_match_leave() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.match_leave)
  return _internal_mutable_match_leave();
}

// .nakama.realtime.MatchPresenceEvent match_presence_event = 18;
inline bool Envelope::_internal_has_match_presence_event() const {
  return message_case() == kMatchPresenceEvent;
}
inline bool Envelope::has_match_presence_event() const {
  return _internal_has_match_presence_event();
}
inline void Envelope::set_has_match_presence_event() {
  _oneof_case_[0] = kMatchPresenceEvent;
}
inline void Envelope::clear_match_presence_event() {
  if (_internal_has_match_presence_event()) {
    if (GetArena() == nullptr) {
      delete message_.match_presence_event_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::MatchPresenceEvent* Envelope::release_match_presence_event() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.match_presence_event)
  if (_internal_has_match_presence_event()) {
    clear_has_message();
      ::nakama::realtime::MatchPresenceEvent* temp = message_.match_presence_event_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.match_presence_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::MatchPresenceEvent& Envelope::_internal_match_presence_event() const {
  return _internal_has_match_presence_event()
      ? *message_.match_presence_event_
      : reinterpret_cast< ::nakama::realtime::MatchPresenceEvent&>(::nakama::realtime::_MatchPresenceEvent_default_instance_);
}
inline const ::nakama::realtime::MatchPresenceEvent& Envelope::match_presence_event() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.match_presence_event)
  return _internal_match_presence_event();
}
inline ::nakama::realtime::MatchPresenceEvent* Envelope::unsafe_arena_release_match_presence_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.match_presence_event)
  if (_internal_has_match_presence_event()) {
    clear_has_message();
    ::nakama::realtime::MatchPresenceEvent* temp = message_.match_presence_event_;
    message_.match_presence_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_match_presence_event(::nakama::realtime::MatchPresenceEvent* match_presence_event) {
  clear_message();
  if (match_presence_event) {
    set_has_match_presence_event();
    message_.match_presence_event_ = match_presence_event;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.match_presence_event)
}
inline ::nakama::realtime::MatchPresenceEvent* Envelope::_internal_mutable_match_presence_event() {
  if (!_internal_has_match_presence_event()) {
    clear_message();
    set_has_match_presence_event();
    message_.match_presence_event_ = CreateMaybeMessage< ::nakama::realtime::MatchPresenceEvent >(GetArena());
  }
  return message_.match_presence_event_;
}
inline ::nakama::realtime::MatchPresenceEvent* Envelope::mutable_match_presence_event() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.match_presence_event)
  return _internal_mutable_match_presence_event();
}

// .nakama.realtime.MatchmakerAdd matchmaker_add = 19;
inline bool Envelope::_internal_has_matchmaker_add() const {
  return message_case() == kMatchmakerAdd;
}
inline bool Envelope::has_matchmaker_add() const {
  return _internal_has_matchmaker_add();
}
inline void Envelope::set_has_matchmaker_add() {
  _oneof_case_[0] = kMatchmakerAdd;
}
inline void Envelope::clear_matchmaker_add() {
  if (_internal_has_matchmaker_add()) {
    if (GetArena() == nullptr) {
      delete message_.matchmaker_add_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::MatchmakerAdd* Envelope::release_matchmaker_add() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.matchmaker_add)
  if (_internal_has_matchmaker_add()) {
    clear_has_message();
      ::nakama::realtime::MatchmakerAdd* temp = message_.matchmaker_add_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.matchmaker_add_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::MatchmakerAdd& Envelope::_internal_matchmaker_add() const {
  return _internal_has_matchmaker_add()
      ? *message_.matchmaker_add_
      : reinterpret_cast< ::nakama::realtime::MatchmakerAdd&>(::nakama::realtime::_MatchmakerAdd_default_instance_);
}
inline const ::nakama::realtime::MatchmakerAdd& Envelope::matchmaker_add() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.matchmaker_add)
  return _internal_matchmaker_add();
}
inline ::nakama::realtime::MatchmakerAdd* Envelope::unsafe_arena_release_matchmaker_add() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.matchmaker_add)
  if (_internal_has_matchmaker_add()) {
    clear_has_message();
    ::nakama::realtime::MatchmakerAdd* temp = message_.matchmaker_add_;
    message_.matchmaker_add_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_matchmaker_add(::nakama::realtime::MatchmakerAdd* matchmaker_add) {
  clear_message();
  if (matchmaker_add) {
    set_has_matchmaker_add();
    message_.matchmaker_add_ = matchmaker_add;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.matchmaker_add)
}
inline ::nakama::realtime::MatchmakerAdd* Envelope::_internal_mutable_matchmaker_add() {
  if (!_internal_has_matchmaker_add()) {
    clear_message();
    set_has_matchmaker_add();
    message_.matchmaker_add_ = CreateMaybeMessage< ::nakama::realtime::MatchmakerAdd >(GetArena());
  }
  return message_.matchmaker_add_;
}
inline ::nakama::realtime::MatchmakerAdd* Envelope::mutable_matchmaker_add() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.matchmaker_add)
  return _internal_mutable_matchmaker_add();
}

// .nakama.realtime.MatchmakerMatched matchmaker_matched = 20;
inline bool Envelope::_internal_has_matchmaker_matched() const {
  return message_case() == kMatchmakerMatched;
}
inline bool Envelope::has_matchmaker_matched() const {
  return _internal_has_matchmaker_matched();
}
inline void Envelope::set_has_matchmaker_matched() {
  _oneof_case_[0] = kMatchmakerMatched;
}
inline void Envelope::clear_matchmaker_matched() {
  if (_internal_has_matchmaker_matched()) {
    if (GetArena() == nullptr) {
      delete message_.matchmaker_matched_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::MatchmakerMatched* Envelope::release_matchmaker_matched() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.matchmaker_matched)
  if (_internal_has_matchmaker_matched()) {
    clear_has_message();
      ::nakama::realtime::MatchmakerMatched* temp = message_.matchmaker_matched_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.matchmaker_matched_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::MatchmakerMatched& Envelope::_internal_matchmaker_matched() const {
  return _internal_has_matchmaker_matched()
      ? *message_.matchmaker_matched_
      : reinterpret_cast< ::nakama::realtime::MatchmakerMatched&>(::nakama::realtime::_MatchmakerMatched_default_instance_);
}
inline const ::nakama::realtime::MatchmakerMatched& Envelope::matchmaker_matched() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.matchmaker_matched)
  return _internal_matchmaker_matched();
}
inline ::nakama::realtime::MatchmakerMatched* Envelope::unsafe_arena_release_matchmaker_matched() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.matchmaker_matched)
  if (_internal_has_matchmaker_matched()) {
    clear_has_message();
    ::nakama::realtime::MatchmakerMatched* temp = message_.matchmaker_matched_;
    message_.matchmaker_matched_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_matchmaker_matched(::nakama::realtime::MatchmakerMatched* matchmaker_matched) {
  clear_message();
  if (matchmaker_matched) {
    set_has_matchmaker_matched();
    message_.matchmaker_matched_ = matchmaker_matched;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.matchmaker_matched)
}
inline ::nakama::realtime::MatchmakerMatched* Envelope::_internal_mutable_matchmaker_matched() {
  if (!_internal_has_matchmaker_matched()) {
    clear_message();
    set_has_matchmaker_matched();
    message_.matchmaker_matched_ = CreateMaybeMessage< ::nakama::realtime::MatchmakerMatched >(GetArena());
  }
  return message_.matchmaker_matched_;
}
inline ::nakama::realtime::MatchmakerMatched* Envelope::mutable_matchmaker_matched() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.matchmaker_matched)
  return _internal_mutable_matchmaker_matched();
}

// .nakama.realtime.MatchmakerRemove matchmaker_remove = 21;
inline bool Envelope::_internal_has_matchmaker_remove() const {
  return message_case() == kMatchmakerRemove;
}
inline bool Envelope::has_matchmaker_remove() const {
  return _internal_has_matchmaker_remove();
}
inline void Envelope::set_has_matchmaker_remove() {
  _oneof_case_[0] = kMatchmakerRemove;
}
inline void Envelope::clear_matchmaker_remove() {
  if (_internal_has_matchmaker_remove()) {
    if (GetArena() == nullptr) {
      delete message_.matchmaker_remove_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::MatchmakerRemove* Envelope::release_matchmaker_remove() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.matchmaker_remove)
  if (_internal_has_matchmaker_remove()) {
    clear_has_message();
      ::nakama::realtime::MatchmakerRemove* temp = message_.matchmaker_remove_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.matchmaker_remove_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::MatchmakerRemove& Envelope::_internal_matchmaker_remove() const {
  return _internal_has_matchmaker_remove()
      ? *message_.matchmaker_remove_
      : reinterpret_cast< ::nakama::realtime::MatchmakerRemove&>(::nakama::realtime::_MatchmakerRemove_default_instance_);
}
inline const ::nakama::realtime::MatchmakerRemove& Envelope::matchmaker_remove() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.matchmaker_remove)
  return _internal_matchmaker_remove();
}
inline ::nakama::realtime::MatchmakerRemove* Envelope::unsafe_arena_release_matchmaker_remove() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.matchmaker_remove)
  if (_internal_has_matchmaker_remove()) {
    clear_has_message();
    ::nakama::realtime::MatchmakerRemove* temp = message_.matchmaker_remove_;
    message_.matchmaker_remove_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_matchmaker_remove(::nakama::realtime::MatchmakerRemove* matchmaker_remove) {
  clear_message();
  if (matchmaker_remove) {
    set_has_matchmaker_remove();
    message_.matchmaker_remove_ = matchmaker_remove;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.matchmaker_remove)
}
inline ::nakama::realtime::MatchmakerRemove* Envelope::_internal_mutable_matchmaker_remove() {
  if (!_internal_has_matchmaker_remove()) {
    clear_message();
    set_has_matchmaker_remove();
    message_.matchmaker_remove_ = CreateMaybeMessage< ::nakama::realtime::MatchmakerRemove >(GetArena());
  }
  return message_.matchmaker_remove_;
}
inline ::nakama::realtime::MatchmakerRemove* Envelope::mutable_matchmaker_remove() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.matchmaker_remove)
  return _internal_mutable_matchmaker_remove();
}

// .nakama.realtime.MatchmakerTicket matchmaker_ticket = 22;
inline bool Envelope::_internal_has_matchmaker_ticket() const {
  return message_case() == kMatchmakerTicket;
}
inline bool Envelope::has_matchmaker_ticket() const {
  return _internal_has_matchmaker_ticket();
}
inline void Envelope::set_has_matchmaker_ticket() {
  _oneof_case_[0] = kMatchmakerTicket;
}
inline void Envelope::clear_matchmaker_ticket() {
  if (_internal_has_matchmaker_ticket()) {
    if (GetArena() == nullptr) {
      delete message_.matchmaker_ticket_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::MatchmakerTicket* Envelope::release_matchmaker_ticket() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.matchmaker_ticket)
  if (_internal_has_matchmaker_ticket()) {
    clear_has_message();
      ::nakama::realtime::MatchmakerTicket* temp = message_.matchmaker_ticket_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.matchmaker_ticket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::MatchmakerTicket& Envelope::_internal_matchmaker_ticket() const {
  return _internal_has_matchmaker_ticket()
      ? *message_.matchmaker_ticket_
      : reinterpret_cast< ::nakama::realtime::MatchmakerTicket&>(::nakama::realtime::_MatchmakerTicket_default_instance_);
}
inline const ::nakama::realtime::MatchmakerTicket& Envelope::matchmaker_ticket() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.matchmaker_ticket)
  return _internal_matchmaker_ticket();
}
inline ::nakama::realtime::MatchmakerTicket* Envelope::unsafe_arena_release_matchmaker_ticket() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.matchmaker_ticket)
  if (_internal_has_matchmaker_ticket()) {
    clear_has_message();
    ::nakama::realtime::MatchmakerTicket* temp = message_.matchmaker_ticket_;
    message_.matchmaker_ticket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_matchmaker_ticket(::nakama::realtime::MatchmakerTicket* matchmaker_ticket) {
  clear_message();
  if (matchmaker_ticket) {
    set_has_matchmaker_ticket();
    message_.matchmaker_ticket_ = matchmaker_ticket;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.matchmaker_ticket)
}
inline ::nakama::realtime::MatchmakerTicket* Envelope::_internal_mutable_matchmaker_ticket() {
  if (!_internal_has_matchmaker_ticket()) {
    clear_message();
    set_has_matchmaker_ticket();
    message_.matchmaker_ticket_ = CreateMaybeMessage< ::nakama::realtime::MatchmakerTicket >(GetArena());
  }
  return message_.matchmaker_ticket_;
}
inline ::nakama::realtime::MatchmakerTicket* Envelope::mutable_matchmaker_ticket() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.matchmaker_ticket)
  return _internal_mutable_matchmaker_ticket();
}

// .nakama.realtime.Notifications notifications = 23;
inline bool Envelope::_internal_has_notifications() const {
  return message_case() == kNotifications;
}
inline bool Envelope::has_notifications() const {
  return _internal_has_notifications();
}
inline void Envelope::set_has_notifications() {
  _oneof_case_[0] = kNotifications;
}
inline void Envelope::clear_notifications() {
  if (_internal_has_notifications()) {
    if (GetArena() == nullptr) {
      delete message_.notifications_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::Notifications* Envelope::release_notifications() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.notifications)
  if (_internal_has_notifications()) {
    clear_has_message();
      ::nakama::realtime::Notifications* temp = message_.notifications_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.notifications_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::Notifications& Envelope::_internal_notifications() const {
  return _internal_has_notifications()
      ? *message_.notifications_
      : reinterpret_cast< ::nakama::realtime::Notifications&>(::nakama::realtime::_Notifications_default_instance_);
}
inline const ::nakama::realtime::Notifications& Envelope::notifications() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.notifications)
  return _internal_notifications();
}
inline ::nakama::realtime::Notifications* Envelope::unsafe_arena_release_notifications() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.notifications)
  if (_internal_has_notifications()) {
    clear_has_message();
    ::nakama::realtime::Notifications* temp = message_.notifications_;
    message_.notifications_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_notifications(::nakama::realtime::Notifications* notifications) {
  clear_message();
  if (notifications) {
    set_has_notifications();
    message_.notifications_ = notifications;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.notifications)
}
inline ::nakama::realtime::Notifications* Envelope::_internal_mutable_notifications() {
  if (!_internal_has_notifications()) {
    clear_message();
    set_has_notifications();
    message_.notifications_ = CreateMaybeMessage< ::nakama::realtime::Notifications >(GetArena());
  }
  return message_.notifications_;
}
inline ::nakama::realtime::Notifications* Envelope::mutable_notifications() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.notifications)
  return _internal_mutable_notifications();
}

// .nakama.api.Rpc rpc = 24;
inline bool Envelope::_internal_has_rpc() const {
  return message_case() == kRpc;
}
inline bool Envelope::has_rpc() const {
  return _internal_has_rpc();
}
inline void Envelope::set_has_rpc() {
  _oneof_case_[0] = kRpc;
}
inline ::nakama::api::Rpc* Envelope::release_rpc() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.rpc)
  if (_internal_has_rpc()) {
    clear_has_message();
      ::nakama::api::Rpc* temp = message_.rpc_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::api::Rpc& Envelope::_internal_rpc() const {
  return _internal_has_rpc()
      ? *message_.rpc_
      : reinterpret_cast< ::nakama::api::Rpc&>(::nakama::api::_Rpc_default_instance_);
}
inline const ::nakama::api::Rpc& Envelope::rpc() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.rpc)
  return _internal_rpc();
}
inline ::nakama::api::Rpc* Envelope::unsafe_arena_release_rpc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.rpc)
  if (_internal_has_rpc()) {
    clear_has_message();
    ::nakama::api::Rpc* temp = message_.rpc_;
    message_.rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_rpc(::nakama::api::Rpc* rpc) {
  clear_message();
  if (rpc) {
    set_has_rpc();
    message_.rpc_ = rpc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.rpc)
}
inline ::nakama::api::Rpc* Envelope::_internal_mutable_rpc() {
  if (!_internal_has_rpc()) {
    clear_message();
    set_has_rpc();
    message_.rpc_ = CreateMaybeMessage< ::nakama::api::Rpc >(GetArena());
  }
  return message_.rpc_;
}
inline ::nakama::api::Rpc* Envelope::mutable_rpc() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.rpc)
  return _internal_mutable_rpc();
}

// .nakama.realtime.Status status = 25;
inline bool Envelope::_internal_has_status() const {
  return message_case() == kStatus;
}
inline bool Envelope::has_status() const {
  return _internal_has_status();
}
inline void Envelope::set_has_status() {
  _oneof_case_[0] = kStatus;
}
inline void Envelope::clear_status() {
  if (_internal_has_status()) {
    if (GetArena() == nullptr) {
      delete message_.status_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::Status* Envelope::release_status() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.status)
  if (_internal_has_status()) {
    clear_has_message();
      ::nakama::realtime::Status* temp = message_.status_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::Status& Envelope::_internal_status() const {
  return _internal_has_status()
      ? *message_.status_
      : reinterpret_cast< ::nakama::realtime::Status&>(::nakama::realtime::_Status_default_instance_);
}
inline const ::nakama::realtime::Status& Envelope::status() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.status)
  return _internal_status();
}
inline ::nakama::realtime::Status* Envelope::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.status)
  if (_internal_has_status()) {
    clear_has_message();
    ::nakama::realtime::Status* temp = message_.status_;
    message_.status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_status(::nakama::realtime::Status* status) {
  clear_message();
  if (status) {
    set_has_status();
    message_.status_ = status;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.status)
}
inline ::nakama::realtime::Status* Envelope::_internal_mutable_status() {
  if (!_internal_has_status()) {
    clear_message();
    set_has_status();
    message_.status_ = CreateMaybeMessage< ::nakama::realtime::Status >(GetArena());
  }
  return message_.status_;
}
inline ::nakama::realtime::Status* Envelope::mutable_status() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.status)
  return _internal_mutable_status();
}

// .nakama.realtime.StatusFollow status_follow = 26;
inline bool Envelope::_internal_has_status_follow() const {
  return message_case() == kStatusFollow;
}
inline bool Envelope::has_status_follow() const {
  return _internal_has_status_follow();
}
inline void Envelope::set_has_status_follow() {
  _oneof_case_[0] = kStatusFollow;
}
inline void Envelope::clear_status_follow() {
  if (_internal_has_status_follow()) {
    if (GetArena() == nullptr) {
      delete message_.status_follow_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::StatusFollow* Envelope::release_status_follow() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.status_follow)
  if (_internal_has_status_follow()) {
    clear_has_message();
      ::nakama::realtime::StatusFollow* temp = message_.status_follow_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.status_follow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::StatusFollow& Envelope::_internal_status_follow() const {
  return _internal_has_status_follow()
      ? *message_.status_follow_
      : reinterpret_cast< ::nakama::realtime::StatusFollow&>(::nakama::realtime::_StatusFollow_default_instance_);
}
inline const ::nakama::realtime::StatusFollow& Envelope::status_follow() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.status_follow)
  return _internal_status_follow();
}
inline ::nakama::realtime::StatusFollow* Envelope::unsafe_arena_release_status_follow() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.status_follow)
  if (_internal_has_status_follow()) {
    clear_has_message();
    ::nakama::realtime::StatusFollow* temp = message_.status_follow_;
    message_.status_follow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_status_follow(::nakama::realtime::StatusFollow* status_follow) {
  clear_message();
  if (status_follow) {
    set_has_status_follow();
    message_.status_follow_ = status_follow;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.status_follow)
}
inline ::nakama::realtime::StatusFollow* Envelope::_internal_mutable_status_follow() {
  if (!_internal_has_status_follow()) {
    clear_message();
    set_has_status_follow();
    message_.status_follow_ = CreateMaybeMessage< ::nakama::realtime::StatusFollow >(GetArena());
  }
  return message_.status_follow_;
}
inline ::nakama::realtime::StatusFollow* Envelope::mutable_status_follow() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.status_follow)
  return _internal_mutable_status_follow();
}

// .nakama.realtime.StatusPresenceEvent status_presence_event = 27;
inline bool Envelope::_internal_has_status_presence_event() const {
  return message_case() == kStatusPresenceEvent;
}
inline bool Envelope::has_status_presence_event() const {
  return _internal_has_status_presence_event();
}
inline void Envelope::set_has_status_presence_event() {
  _oneof_case_[0] = kStatusPresenceEvent;
}
inline void Envelope::clear_status_presence_event() {
  if (_internal_has_status_presence_event()) {
    if (GetArena() == nullptr) {
      delete message_.status_presence_event_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::StatusPresenceEvent* Envelope::release_status_presence_event() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.status_presence_event)
  if (_internal_has_status_presence_event()) {
    clear_has_message();
      ::nakama::realtime::StatusPresenceEvent* temp = message_.status_presence_event_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.status_presence_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::StatusPresenceEvent& Envelope::_internal_status_presence_event() const {
  return _internal_has_status_presence_event()
      ? *message_.status_presence_event_
      : reinterpret_cast< ::nakama::realtime::StatusPresenceEvent&>(::nakama::realtime::_StatusPresenceEvent_default_instance_);
}
inline const ::nakama::realtime::StatusPresenceEvent& Envelope::status_presence_event() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.status_presence_event)
  return _internal_status_presence_event();
}
inline ::nakama::realtime::StatusPresenceEvent* Envelope::unsafe_arena_release_status_presence_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.status_presence_event)
  if (_internal_has_status_presence_event()) {
    clear_has_message();
    ::nakama::realtime::StatusPresenceEvent* temp = message_.status_presence_event_;
    message_.status_presence_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_status_presence_event(::nakama::realtime::StatusPresenceEvent* status_presence_event) {
  clear_message();
  if (status_presence_event) {
    set_has_status_presence_event();
    message_.status_presence_event_ = status_presence_event;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.status_presence_event)
}
inline ::nakama::realtime::StatusPresenceEvent* Envelope::_internal_mutable_status_presence_event() {
  if (!_internal_has_status_presence_event()) {
    clear_message();
    set_has_status_presence_event();
    message_.status_presence_event_ = CreateMaybeMessage< ::nakama::realtime::StatusPresenceEvent >(GetArena());
  }
  return message_.status_presence_event_;
}
inline ::nakama::realtime::StatusPresenceEvent* Envelope::mutable_status_presence_event() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.status_presence_event)
  return _internal_mutable_status_presence_event();
}

// .nakama.realtime.StatusUnfollow status_unfollow = 28;
inline bool Envelope::_internal_has_status_unfollow() const {
  return message_case() == kStatusUnfollow;
}
inline bool Envelope::has_status_unfollow() const {
  return _internal_has_status_unfollow();
}
inline void Envelope::set_has_status_unfollow() {
  _oneof_case_[0] = kStatusUnfollow;
}
inline void Envelope::clear_status_unfollow() {
  if (_internal_has_status_unfollow()) {
    if (GetArena() == nullptr) {
      delete message_.status_unfollow_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::StatusUnfollow* Envelope::release_status_unfollow() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.status_unfollow)
  if (_internal_has_status_unfollow()) {
    clear_has_message();
      ::nakama::realtime::StatusUnfollow* temp = message_.status_unfollow_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.status_unfollow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::StatusUnfollow& Envelope::_internal_status_unfollow() const {
  return _internal_has_status_unfollow()
      ? *message_.status_unfollow_
      : reinterpret_cast< ::nakama::realtime::StatusUnfollow&>(::nakama::realtime::_StatusUnfollow_default_instance_);
}
inline const ::nakama::realtime::StatusUnfollow& Envelope::status_unfollow() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.status_unfollow)
  return _internal_status_unfollow();
}
inline ::nakama::realtime::StatusUnfollow* Envelope::unsafe_arena_release_status_unfollow() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.status_unfollow)
  if (_internal_has_status_unfollow()) {
    clear_has_message();
    ::nakama::realtime::StatusUnfollow* temp = message_.status_unfollow_;
    message_.status_unfollow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_status_unfollow(::nakama::realtime::StatusUnfollow* status_unfollow) {
  clear_message();
  if (status_unfollow) {
    set_has_status_unfollow();
    message_.status_unfollow_ = status_unfollow;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.status_unfollow)
}
inline ::nakama::realtime::StatusUnfollow* Envelope::_internal_mutable_status_unfollow() {
  if (!_internal_has_status_unfollow()) {
    clear_message();
    set_has_status_unfollow();
    message_.status_unfollow_ = CreateMaybeMessage< ::nakama::realtime::StatusUnfollow >(GetArena());
  }
  return message_.status_unfollow_;
}
inline ::nakama::realtime::StatusUnfollow* Envelope::mutable_status_unfollow() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.status_unfollow)
  return _internal_mutable_status_unfollow();
}

// .nakama.realtime.StatusUpdate status_update = 29;
inline bool Envelope::_internal_has_status_update() const {
  return message_case() == kStatusUpdate;
}
inline bool Envelope::has_status_update() const {
  return _internal_has_status_update();
}
inline void Envelope::set_has_status_update() {
  _oneof_case_[0] = kStatusUpdate;
}
inline void Envelope::clear_status_update() {
  if (_internal_has_status_update()) {
    if (GetArena() == nullptr) {
      delete message_.status_update_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::StatusUpdate* Envelope::release_status_update() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.status_update)
  if (_internal_has_status_update()) {
    clear_has_message();
      ::nakama::realtime::StatusUpdate* temp = message_.status_update_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.status_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::StatusUpdate& Envelope::_internal_status_update() const {
  return _internal_has_status_update()
      ? *message_.status_update_
      : reinterpret_cast< ::nakama::realtime::StatusUpdate&>(::nakama::realtime::_StatusUpdate_default_instance_);
}
inline const ::nakama::realtime::StatusUpdate& Envelope::status_update() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.status_update)
  return _internal_status_update();
}
inline ::nakama::realtime::StatusUpdate* Envelope::unsafe_arena_release_status_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.status_update)
  if (_internal_has_status_update()) {
    clear_has_message();
    ::nakama::realtime::StatusUpdate* temp = message_.status_update_;
    message_.status_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_status_update(::nakama::realtime::StatusUpdate* status_update) {
  clear_message();
  if (status_update) {
    set_has_status_update();
    message_.status_update_ = status_update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.status_update)
}
inline ::nakama::realtime::StatusUpdate* Envelope::_internal_mutable_status_update() {
  if (!_internal_has_status_update()) {
    clear_message();
    set_has_status_update();
    message_.status_update_ = CreateMaybeMessage< ::nakama::realtime::StatusUpdate >(GetArena());
  }
  return message_.status_update_;
}
inline ::nakama::realtime::StatusUpdate* Envelope::mutable_status_update() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.status_update)
  return _internal_mutable_status_update();
}

// .nakama.realtime.StreamData stream_data = 30;
inline bool Envelope::_internal_has_stream_data() const {
  return message_case() == kStreamData;
}
inline bool Envelope::has_stream_data() const {
  return _internal_has_stream_data();
}
inline void Envelope::set_has_stream_data() {
  _oneof_case_[0] = kStreamData;
}
inline void Envelope::clear_stream_data() {
  if (_internal_has_stream_data()) {
    if (GetArena() == nullptr) {
      delete message_.stream_data_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::StreamData* Envelope::release_stream_data() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.stream_data)
  if (_internal_has_stream_data()) {
    clear_has_message();
      ::nakama::realtime::StreamData* temp = message_.stream_data_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.stream_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::StreamData& Envelope::_internal_stream_data() const {
  return _internal_has_stream_data()
      ? *message_.stream_data_
      : reinterpret_cast< ::nakama::realtime::StreamData&>(::nakama::realtime::_StreamData_default_instance_);
}
inline const ::nakama::realtime::StreamData& Envelope::stream_data() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.stream_data)
  return _internal_stream_data();
}
inline ::nakama::realtime::StreamData* Envelope::unsafe_arena_release_stream_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.stream_data)
  if (_internal_has_stream_data()) {
    clear_has_message();
    ::nakama::realtime::StreamData* temp = message_.stream_data_;
    message_.stream_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_stream_data(::nakama::realtime::StreamData* stream_data) {
  clear_message();
  if (stream_data) {
    set_has_stream_data();
    message_.stream_data_ = stream_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.stream_data)
}
inline ::nakama::realtime::StreamData* Envelope::_internal_mutable_stream_data() {
  if (!_internal_has_stream_data()) {
    clear_message();
    set_has_stream_data();
    message_.stream_data_ = CreateMaybeMessage< ::nakama::realtime::StreamData >(GetArena());
  }
  return message_.stream_data_;
}
inline ::nakama::realtime::StreamData* Envelope::mutable_stream_data() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.stream_data)
  return _internal_mutable_stream_data();
}

// .nakama.realtime.StreamPresenceEvent stream_presence_event = 31;
inline bool Envelope::_internal_has_stream_presence_event() const {
  return message_case() == kStreamPresenceEvent;
}
inline bool Envelope::has_stream_presence_event() const {
  return _internal_has_stream_presence_event();
}
inline void Envelope::set_has_stream_presence_event() {
  _oneof_case_[0] = kStreamPresenceEvent;
}
inline void Envelope::clear_stream_presence_event() {
  if (_internal_has_stream_presence_event()) {
    if (GetArena() == nullptr) {
      delete message_.stream_presence_event_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::StreamPresenceEvent* Envelope::release_stream_presence_event() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.stream_presence_event)
  if (_internal_has_stream_presence_event()) {
    clear_has_message();
      ::nakama::realtime::StreamPresenceEvent* temp = message_.stream_presence_event_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.stream_presence_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::StreamPresenceEvent& Envelope::_internal_stream_presence_event() const {
  return _internal_has_stream_presence_event()
      ? *message_.stream_presence_event_
      : reinterpret_cast< ::nakama::realtime::StreamPresenceEvent&>(::nakama::realtime::_StreamPresenceEvent_default_instance_);
}
inline const ::nakama::realtime::StreamPresenceEvent& Envelope::stream_presence_event() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.stream_presence_event)
  return _internal_stream_presence_event();
}
inline ::nakama::realtime::StreamPresenceEvent* Envelope::unsafe_arena_release_stream_presence_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.stream_presence_event)
  if (_internal_has_stream_presence_event()) {
    clear_has_message();
    ::nakama::realtime::StreamPresenceEvent* temp = message_.stream_presence_event_;
    message_.stream_presence_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_stream_presence_event(::nakama::realtime::StreamPresenceEvent* stream_presence_event) {
  clear_message();
  if (stream_presence_event) {
    set_has_stream_presence_event();
    message_.stream_presence_event_ = stream_presence_event;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.stream_presence_event)
}
inline ::nakama::realtime::StreamPresenceEvent* Envelope::_internal_mutable_stream_presence_event() {
  if (!_internal_has_stream_presence_event()) {
    clear_message();
    set_has_stream_presence_event();
    message_.stream_presence_event_ = CreateMaybeMessage< ::nakama::realtime::StreamPresenceEvent >(GetArena());
  }
  return message_.stream_presence_event_;
}
inline ::nakama::realtime::StreamPresenceEvent* Envelope::mutable_stream_presence_event() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.stream_presence_event)
  return _internal_mutable_stream_presence_event();
}

// .nakama.realtime.Ping ping = 32;
inline bool Envelope::_internal_has_ping() const {
  return message_case() == kPing;
}
inline bool Envelope::has_ping() const {
  return _internal_has_ping();
}
inline void Envelope::set_has_ping() {
  _oneof_case_[0] = kPing;
}
inline void Envelope::clear_ping() {
  if (_internal_has_ping()) {
    if (GetArena() == nullptr) {
      delete message_.ping_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::Ping* Envelope::release_ping() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.ping)
  if (_internal_has_ping()) {
    clear_has_message();
      ::nakama::realtime::Ping* temp = message_.ping_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.ping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::Ping& Envelope::_internal_ping() const {
  return _internal_has_ping()
      ? *message_.ping_
      : reinterpret_cast< ::nakama::realtime::Ping&>(::nakama::realtime::_Ping_default_instance_);
}
inline const ::nakama::realtime::Ping& Envelope::ping() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.ping)
  return _internal_ping();
}
inline ::nakama::realtime::Ping* Envelope::unsafe_arena_release_ping() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.ping)
  if (_internal_has_ping()) {
    clear_has_message();
    ::nakama::realtime::Ping* temp = message_.ping_;
    message_.ping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_ping(::nakama::realtime::Ping* ping) {
  clear_message();
  if (ping) {
    set_has_ping();
    message_.ping_ = ping;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.ping)
}
inline ::nakama::realtime::Ping* Envelope::_internal_mutable_ping() {
  if (!_internal_has_ping()) {
    clear_message();
    set_has_ping();
    message_.ping_ = CreateMaybeMessage< ::nakama::realtime::Ping >(GetArena());
  }
  return message_.ping_;
}
inline ::nakama::realtime::Ping* Envelope::mutable_ping() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.ping)
  return _internal_mutable_ping();
}

// .nakama.realtime.Pong pong = 33;
inline bool Envelope::_internal_has_pong() const {
  return message_case() == kPong;
}
inline bool Envelope::has_pong() const {
  return _internal_has_pong();
}
inline void Envelope::set_has_pong() {
  _oneof_case_[0] = kPong;
}
inline void Envelope::clear_pong() {
  if (_internal_has_pong()) {
    if (GetArena() == nullptr) {
      delete message_.pong_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::Pong* Envelope::release_pong() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.pong)
  if (_internal_has_pong()) {
    clear_has_message();
      ::nakama::realtime::Pong* temp = message_.pong_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.pong_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::Pong& Envelope::_internal_pong() const {
  return _internal_has_pong()
      ? *message_.pong_
      : reinterpret_cast< ::nakama::realtime::Pong&>(::nakama::realtime::_Pong_default_instance_);
}
inline const ::nakama::realtime::Pong& Envelope::pong() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.pong)
  return _internal_pong();
}
inline ::nakama::realtime::Pong* Envelope::unsafe_arena_release_pong() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.pong)
  if (_internal_has_pong()) {
    clear_has_message();
    ::nakama::realtime::Pong* temp = message_.pong_;
    message_.pong_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_pong(::nakama::realtime::Pong* pong) {
  clear_message();
  if (pong) {
    set_has_pong();
    message_.pong_ = pong;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.pong)
}
inline ::nakama::realtime::Pong* Envelope::_internal_mutable_pong() {
  if (!_internal_has_pong()) {
    clear_message();
    set_has_pong();
    message_.pong_ = CreateMaybeMessage< ::nakama::realtime::Pong >(GetArena());
  }
  return message_.pong_;
}
inline ::nakama::realtime::Pong* Envelope::mutable_pong() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.pong)
  return _internal_mutable_pong();
}

// .nakama.realtime.Party party = 34;
inline bool Envelope::_internal_has_party() const {
  return message_case() == kParty;
}
inline bool Envelope::has_party() const {
  return _internal_has_party();
}
inline void Envelope::set_has_party() {
  _oneof_case_[0] = kParty;
}
inline void Envelope::clear_party() {
  if (_internal_has_party()) {
    if (GetArena() == nullptr) {
      delete message_.party_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::Party* Envelope::release_party() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.party)
  if (_internal_has_party()) {
    clear_has_message();
      ::nakama::realtime::Party* temp = message_.party_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.party_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::Party& Envelope::_internal_party() const {
  return _internal_has_party()
      ? *message_.party_
      : reinterpret_cast< ::nakama::realtime::Party&>(::nakama::realtime::_Party_default_instance_);
}
inline const ::nakama::realtime::Party& Envelope::party() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.party)
  return _internal_party();
}
inline ::nakama::realtime::Party* Envelope::unsafe_arena_release_party() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.party)
  if (_internal_has_party()) {
    clear_has_message();
    ::nakama::realtime::Party* temp = message_.party_;
    message_.party_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_party(::nakama::realtime::Party* party) {
  clear_message();
  if (party) {
    set_has_party();
    message_.party_ = party;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.party)
}
inline ::nakama::realtime::Party* Envelope::_internal_mutable_party() {
  if (!_internal_has_party()) {
    clear_message();
    set_has_party();
    message_.party_ = CreateMaybeMessage< ::nakama::realtime::Party >(GetArena());
  }
  return message_.party_;
}
inline ::nakama::realtime::Party* Envelope::mutable_party() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.party)
  return _internal_mutable_party();
}

// .nakama.realtime.PartyCreate party_create = 35;
inline bool Envelope::_internal_has_party_create() const {
  return message_case() == kPartyCreate;
}
inline bool Envelope::has_party_create() const {
  return _internal_has_party_create();
}
inline void Envelope::set_has_party_create() {
  _oneof_case_[0] = kPartyCreate;
}
inline void Envelope::clear_party_create() {
  if (_internal_has_party_create()) {
    if (GetArena() == nullptr) {
      delete message_.party_create_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::PartyCreate* Envelope::release_party_create() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.party_create)
  if (_internal_has_party_create()) {
    clear_has_message();
      ::nakama::realtime::PartyCreate* temp = message_.party_create_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.party_create_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::PartyCreate& Envelope::_internal_party_create() const {
  return _internal_has_party_create()
      ? *message_.party_create_
      : reinterpret_cast< ::nakama::realtime::PartyCreate&>(::nakama::realtime::_PartyCreate_default_instance_);
}
inline const ::nakama::realtime::PartyCreate& Envelope::party_create() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.party_create)
  return _internal_party_create();
}
inline ::nakama::realtime::PartyCreate* Envelope::unsafe_arena_release_party_create() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.party_create)
  if (_internal_has_party_create()) {
    clear_has_message();
    ::nakama::realtime::PartyCreate* temp = message_.party_create_;
    message_.party_create_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_party_create(::nakama::realtime::PartyCreate* party_create) {
  clear_message();
  if (party_create) {
    set_has_party_create();
    message_.party_create_ = party_create;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.party_create)
}
inline ::nakama::realtime::PartyCreate* Envelope::_internal_mutable_party_create() {
  if (!_internal_has_party_create()) {
    clear_message();
    set_has_party_create();
    message_.party_create_ = CreateMaybeMessage< ::nakama::realtime::PartyCreate >(GetArena());
  }
  return message_.party_create_;
}
inline ::nakama::realtime::PartyCreate* Envelope::mutable_party_create() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.party_create)
  return _internal_mutable_party_create();
}

// .nakama.realtime.PartyJoin party_join = 36;
inline bool Envelope::_internal_has_party_join() const {
  return message_case() == kPartyJoin;
}
inline bool Envelope::has_party_join() const {
  return _internal_has_party_join();
}
inline void Envelope::set_has_party_join() {
  _oneof_case_[0] = kPartyJoin;
}
inline void Envelope::clear_party_join() {
  if (_internal_has_party_join()) {
    if (GetArena() == nullptr) {
      delete message_.party_join_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::PartyJoin* Envelope::release_party_join() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.party_join)
  if (_internal_has_party_join()) {
    clear_has_message();
      ::nakama::realtime::PartyJoin* temp = message_.party_join_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.party_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::PartyJoin& Envelope::_internal_party_join() const {
  return _internal_has_party_join()
      ? *message_.party_join_
      : reinterpret_cast< ::nakama::realtime::PartyJoin&>(::nakama::realtime::_PartyJoin_default_instance_);
}
inline const ::nakama::realtime::PartyJoin& Envelope::party_join() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.party_join)
  return _internal_party_join();
}
inline ::nakama::realtime::PartyJoin* Envelope::unsafe_arena_release_party_join() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.party_join)
  if (_internal_has_party_join()) {
    clear_has_message();
    ::nakama::realtime::PartyJoin* temp = message_.party_join_;
    message_.party_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_party_join(::nakama::realtime::PartyJoin* party_join) {
  clear_message();
  if (party_join) {
    set_has_party_join();
    message_.party_join_ = party_join;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.party_join)
}
inline ::nakama::realtime::PartyJoin* Envelope::_internal_mutable_party_join() {
  if (!_internal_has_party_join()) {
    clear_message();
    set_has_party_join();
    message_.party_join_ = CreateMaybeMessage< ::nakama::realtime::PartyJoin >(GetArena());
  }
  return message_.party_join_;
}
inline ::nakama::realtime::PartyJoin* Envelope::mutable_party_join() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.party_join)
  return _internal_mutable_party_join();
}

// .nakama.realtime.PartyLeave party_leave = 37;
inline bool Envelope::_internal_has_party_leave() const {
  return message_case() == kPartyLeave;
}
inline bool Envelope::has_party_leave() const {
  return _internal_has_party_leave();
}
inline void Envelope::set_has_party_leave() {
  _oneof_case_[0] = kPartyLeave;
}
inline void Envelope::clear_party_leave() {
  if (_internal_has_party_leave()) {
    if (GetArena() == nullptr) {
      delete message_.party_leave_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::PartyLeave* Envelope::release_party_leave() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.party_leave)
  if (_internal_has_party_leave()) {
    clear_has_message();
      ::nakama::realtime::PartyLeave* temp = message_.party_leave_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.party_leave_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::PartyLeave& Envelope::_internal_party_leave() const {
  return _internal_has_party_leave()
      ? *message_.party_leave_
      : reinterpret_cast< ::nakama::realtime::PartyLeave&>(::nakama::realtime::_PartyLeave_default_instance_);
}
inline const ::nakama::realtime::PartyLeave& Envelope::party_leave() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.party_leave)
  return _internal_party_leave();
}
inline ::nakama::realtime::PartyLeave* Envelope::unsafe_arena_release_party_leave() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.party_leave)
  if (_internal_has_party_leave()) {
    clear_has_message();
    ::nakama::realtime::PartyLeave* temp = message_.party_leave_;
    message_.party_leave_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_party_leave(::nakama::realtime::PartyLeave* party_leave) {
  clear_message();
  if (party_leave) {
    set_has_party_leave();
    message_.party_leave_ = party_leave;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.party_leave)
}
inline ::nakama::realtime::PartyLeave* Envelope::_internal_mutable_party_leave() {
  if (!_internal_has_party_leave()) {
    clear_message();
    set_has_party_leave();
    message_.party_leave_ = CreateMaybeMessage< ::nakama::realtime::PartyLeave >(GetArena());
  }
  return message_.party_leave_;
}
inline ::nakama::realtime::PartyLeave* Envelope::mutable_party_leave() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.party_leave)
  return _internal_mutable_party_leave();
}

// .nakama.realtime.PartyPromote party_promote = 38;
inline bool Envelope::_internal_has_party_promote() const {
  return message_case() == kPartyPromote;
}
inline bool Envelope::has_party_promote() const {
  return _internal_has_party_promote();
}
inline void Envelope::set_has_party_promote() {
  _oneof_case_[0] = kPartyPromote;
}
inline void Envelope::clear_party_promote() {
  if (_internal_has_party_promote()) {
    if (GetArena() == nullptr) {
      delete message_.party_promote_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::PartyPromote* Envelope::release_party_promote() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.party_promote)
  if (_internal_has_party_promote()) {
    clear_has_message();
      ::nakama::realtime::PartyPromote* temp = message_.party_promote_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.party_promote_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::PartyPromote& Envelope::_internal_party_promote() const {
  return _internal_has_party_promote()
      ? *message_.party_promote_
      : reinterpret_cast< ::nakama::realtime::PartyPromote&>(::nakama::realtime::_PartyPromote_default_instance_);
}
inline const ::nakama::realtime::PartyPromote& Envelope::party_promote() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.party_promote)
  return _internal_party_promote();
}
inline ::nakama::realtime::PartyPromote* Envelope::unsafe_arena_release_party_promote() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.party_promote)
  if (_internal_has_party_promote()) {
    clear_has_message();
    ::nakama::realtime::PartyPromote* temp = message_.party_promote_;
    message_.party_promote_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_party_promote(::nakama::realtime::PartyPromote* party_promote) {
  clear_message();
  if (party_promote) {
    set_has_party_promote();
    message_.party_promote_ = party_promote;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.party_promote)
}
inline ::nakama::realtime::PartyPromote* Envelope::_internal_mutable_party_promote() {
  if (!_internal_has_party_promote()) {
    clear_message();
    set_has_party_promote();
    message_.party_promote_ = CreateMaybeMessage< ::nakama::realtime::PartyPromote >(GetArena());
  }
  return message_.party_promote_;
}
inline ::nakama::realtime::PartyPromote* Envelope::mutable_party_promote() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.party_promote)
  return _internal_mutable_party_promote();
}

// .nakama.realtime.PartyLeader party_leader = 39;
inline bool Envelope::_internal_has_party_leader() const {
  return message_case() == kPartyLeader;
}
inline bool Envelope::has_party_leader() const {
  return _internal_has_party_leader();
}
inline void Envelope::set_has_party_leader() {
  _oneof_case_[0] = kPartyLeader;
}
inline void Envelope::clear_party_leader() {
  if (_internal_has_party_leader()) {
    if (GetArena() == nullptr) {
      delete message_.party_leader_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::PartyLeader* Envelope::release_party_leader() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.party_leader)
  if (_internal_has_party_leader()) {
    clear_has_message();
      ::nakama::realtime::PartyLeader* temp = message_.party_leader_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.party_leader_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::PartyLeader& Envelope::_internal_party_leader() const {
  return _internal_has_party_leader()
      ? *message_.party_leader_
      : reinterpret_cast< ::nakama::realtime::PartyLeader&>(::nakama::realtime::_PartyLeader_default_instance_);
}
inline const ::nakama::realtime::PartyLeader& Envelope::party_leader() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.party_leader)
  return _internal_party_leader();
}
inline ::nakama::realtime::PartyLeader* Envelope::unsafe_arena_release_party_leader() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.party_leader)
  if (_internal_has_party_leader()) {
    clear_has_message();
    ::nakama::realtime::PartyLeader* temp = message_.party_leader_;
    message_.party_leader_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_party_leader(::nakama::realtime::PartyLeader* party_leader) {
  clear_message();
  if (party_leader) {
    set_has_party_leader();
    message_.party_leader_ = party_leader;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.party_leader)
}
inline ::nakama::realtime::PartyLeader* Envelope::_internal_mutable_party_leader() {
  if (!_internal_has_party_leader()) {
    clear_message();
    set_has_party_leader();
    message_.party_leader_ = CreateMaybeMessage< ::nakama::realtime::PartyLeader >(GetArena());
  }
  return message_.party_leader_;
}
inline ::nakama::realtime::PartyLeader* Envelope::mutable_party_leader() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.party_leader)
  return _internal_mutable_party_leader();
}

// .nakama.realtime.PartyAccept party_accept = 40;
inline bool Envelope::_internal_has_party_accept() const {
  return message_case() == kPartyAccept;
}
inline bool Envelope::has_party_accept() const {
  return _internal_has_party_accept();
}
inline void Envelope::set_has_party_accept() {
  _oneof_case_[0] = kPartyAccept;
}
inline void Envelope::clear_party_accept() {
  if (_internal_has_party_accept()) {
    if (GetArena() == nullptr) {
      delete message_.party_accept_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::PartyAccept* Envelope::release_party_accept() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.party_accept)
  if (_internal_has_party_accept()) {
    clear_has_message();
      ::nakama::realtime::PartyAccept* temp = message_.party_accept_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.party_accept_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::PartyAccept& Envelope::_internal_party_accept() const {
  return _internal_has_party_accept()
      ? *message_.party_accept_
      : reinterpret_cast< ::nakama::realtime::PartyAccept&>(::nakama::realtime::_PartyAccept_default_instance_);
}
inline const ::nakama::realtime::PartyAccept& Envelope::party_accept() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.party_accept)
  return _internal_party_accept();
}
inline ::nakama::realtime::PartyAccept* Envelope::unsafe_arena_release_party_accept() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.party_accept)
  if (_internal_has_party_accept()) {
    clear_has_message();
    ::nakama::realtime::PartyAccept* temp = message_.party_accept_;
    message_.party_accept_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_party_accept(::nakama::realtime::PartyAccept* party_accept) {
  clear_message();
  if (party_accept) {
    set_has_party_accept();
    message_.party_accept_ = party_accept;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.party_accept)
}
inline ::nakama::realtime::PartyAccept* Envelope::_internal_mutable_party_accept() {
  if (!_internal_has_party_accept()) {
    clear_message();
    set_has_party_accept();
    message_.party_accept_ = CreateMaybeMessage< ::nakama::realtime::PartyAccept >(GetArena());
  }
  return message_.party_accept_;
}
inline ::nakama::realtime::PartyAccept* Envelope::mutable_party_accept() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.party_accept)
  return _internal_mutable_party_accept();
}

// .nakama.realtime.PartyRemove party_remove = 41;
inline bool Envelope::_internal_has_party_remove() const {
  return message_case() == kPartyRemove;
}
inline bool Envelope::has_party_remove() const {
  return _internal_has_party_remove();
}
inline void Envelope::set_has_party_remove() {
  _oneof_case_[0] = kPartyRemove;
}
inline void Envelope::clear_party_remove() {
  if (_internal_has_party_remove()) {
    if (GetArena() == nullptr) {
      delete message_.party_remove_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::PartyRemove* Envelope::release_party_remove() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.party_remove)
  if (_internal_has_party_remove()) {
    clear_has_message();
      ::nakama::realtime::PartyRemove* temp = message_.party_remove_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.party_remove_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::PartyRemove& Envelope::_internal_party_remove() const {
  return _internal_has_party_remove()
      ? *message_.party_remove_
      : reinterpret_cast< ::nakama::realtime::PartyRemove&>(::nakama::realtime::_PartyRemove_default_instance_);
}
inline const ::nakama::realtime::PartyRemove& Envelope::party_remove() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.party_remove)
  return _internal_party_remove();
}
inline ::nakama::realtime::PartyRemove* Envelope::unsafe_arena_release_party_remove() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.party_remove)
  if (_internal_has_party_remove()) {
    clear_has_message();
    ::nakama::realtime::PartyRemove* temp = message_.party_remove_;
    message_.party_remove_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_party_remove(::nakama::realtime::PartyRemove* party_remove) {
  clear_message();
  if (party_remove) {
    set_has_party_remove();
    message_.party_remove_ = party_remove;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.party_remove)
}
inline ::nakama::realtime::PartyRemove* Envelope::_internal_mutable_party_remove() {
  if (!_internal_has_party_remove()) {
    clear_message();
    set_has_party_remove();
    message_.party_remove_ = CreateMaybeMessage< ::nakama::realtime::PartyRemove >(GetArena());
  }
  return message_.party_remove_;
}
inline ::nakama::realtime::PartyRemove* Envelope::mutable_party_remove() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.party_remove)
  return _internal_mutable_party_remove();
}

// .nakama.realtime.PartyClose party_close = 42;
inline bool Envelope::_internal_has_party_close() const {
  return message_case() == kPartyClose;
}
inline bool Envelope::has_party_close() const {
  return _internal_has_party_close();
}
inline void Envelope::set_has_party_close() {
  _oneof_case_[0] = kPartyClose;
}
inline void Envelope::clear_party_close() {
  if (_internal_has_party_close()) {
    if (GetArena() == nullptr) {
      delete message_.party_close_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::PartyClose* Envelope::release_party_close() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.party_close)
  if (_internal_has_party_close()) {
    clear_has_message();
      ::nakama::realtime::PartyClose* temp = message_.party_close_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.party_close_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::PartyClose& Envelope::_internal_party_close() const {
  return _internal_has_party_close()
      ? *message_.party_close_
      : reinterpret_cast< ::nakama::realtime::PartyClose&>(::nakama::realtime::_PartyClose_default_instance_);
}
inline const ::nakama::realtime::PartyClose& Envelope::party_close() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.party_close)
  return _internal_party_close();
}
inline ::nakama::realtime::PartyClose* Envelope::unsafe_arena_release_party_close() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.party_close)
  if (_internal_has_party_close()) {
    clear_has_message();
    ::nakama::realtime::PartyClose* temp = message_.party_close_;
    message_.party_close_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_party_close(::nakama::realtime::PartyClose* party_close) {
  clear_message();
  if (party_close) {
    set_has_party_close();
    message_.party_close_ = party_close;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.party_close)
}
inline ::nakama::realtime::PartyClose* Envelope::_internal_mutable_party_close() {
  if (!_internal_has_party_close()) {
    clear_message();
    set_has_party_close();
    message_.party_close_ = CreateMaybeMessage< ::nakama::realtime::PartyClose >(GetArena());
  }
  return message_.party_close_;
}
inline ::nakama::realtime::PartyClose* Envelope::mutable_party_close() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.party_close)
  return _internal_mutable_party_close();
}

// .nakama.realtime.PartyJoinRequestList party_join_request_list = 43;
inline bool Envelope::_internal_has_party_join_request_list() const {
  return message_case() == kPartyJoinRequestList;
}
inline bool Envelope::has_party_join_request_list() const {
  return _internal_has_party_join_request_list();
}
inline void Envelope::set_has_party_join_request_list() {
  _oneof_case_[0] = kPartyJoinRequestList;
}
inline void Envelope::clear_party_join_request_list() {
  if (_internal_has_party_join_request_list()) {
    if (GetArena() == nullptr) {
      delete message_.party_join_request_list_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::PartyJoinRequestList* Envelope::release_party_join_request_list() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.party_join_request_list)
  if (_internal_has_party_join_request_list()) {
    clear_has_message();
      ::nakama::realtime::PartyJoinRequestList* temp = message_.party_join_request_list_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.party_join_request_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::PartyJoinRequestList& Envelope::_internal_party_join_request_list() const {
  return _internal_has_party_join_request_list()
      ? *message_.party_join_request_list_
      : reinterpret_cast< ::nakama::realtime::PartyJoinRequestList&>(::nakama::realtime::_PartyJoinRequestList_default_instance_);
}
inline const ::nakama::realtime::PartyJoinRequestList& Envelope::party_join_request_list() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.party_join_request_list)
  return _internal_party_join_request_list();
}
inline ::nakama::realtime::PartyJoinRequestList* Envelope::unsafe_arena_release_party_join_request_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.party_join_request_list)
  if (_internal_has_party_join_request_list()) {
    clear_has_message();
    ::nakama::realtime::PartyJoinRequestList* temp = message_.party_join_request_list_;
    message_.party_join_request_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_party_join_request_list(::nakama::realtime::PartyJoinRequestList* party_join_request_list) {
  clear_message();
  if (party_join_request_list) {
    set_has_party_join_request_list();
    message_.party_join_request_list_ = party_join_request_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.party_join_request_list)
}
inline ::nakama::realtime::PartyJoinRequestList* Envelope::_internal_mutable_party_join_request_list() {
  if (!_internal_has_party_join_request_list()) {
    clear_message();
    set_has_party_join_request_list();
    message_.party_join_request_list_ = CreateMaybeMessage< ::nakama::realtime::PartyJoinRequestList >(GetArena());
  }
  return message_.party_join_request_list_;
}
inline ::nakama::realtime::PartyJoinRequestList* Envelope::mutable_party_join_request_list() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.party_join_request_list)
  return _internal_mutable_party_join_request_list();
}

// .nakama.realtime.PartyJoinRequest party_join_request = 44;
inline bool Envelope::_internal_has_party_join_request() const {
  return message_case() == kPartyJoinRequest;
}
inline bool Envelope::has_party_join_request() const {
  return _internal_has_party_join_request();
}
inline void Envelope::set_has_party_join_request() {
  _oneof_case_[0] = kPartyJoinRequest;
}
inline void Envelope::clear_party_join_request() {
  if (_internal_has_party_join_request()) {
    if (GetArena() == nullptr) {
      delete message_.party_join_request_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::PartyJoinRequest* Envelope::release_party_join_request() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.party_join_request)
  if (_internal_has_party_join_request()) {
    clear_has_message();
      ::nakama::realtime::PartyJoinRequest* temp = message_.party_join_request_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.party_join_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::PartyJoinRequest& Envelope::_internal_party_join_request() const {
  return _internal_has_party_join_request()
      ? *message_.party_join_request_
      : reinterpret_cast< ::nakama::realtime::PartyJoinRequest&>(::nakama::realtime::_PartyJoinRequest_default_instance_);
}
inline const ::nakama::realtime::PartyJoinRequest& Envelope::party_join_request() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.party_join_request)
  return _internal_party_join_request();
}
inline ::nakama::realtime::PartyJoinRequest* Envelope::unsafe_arena_release_party_join_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.party_join_request)
  if (_internal_has_party_join_request()) {
    clear_has_message();
    ::nakama::realtime::PartyJoinRequest* temp = message_.party_join_request_;
    message_.party_join_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_party_join_request(::nakama::realtime::PartyJoinRequest* party_join_request) {
  clear_message();
  if (party_join_request) {
    set_has_party_join_request();
    message_.party_join_request_ = party_join_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.party_join_request)
}
inline ::nakama::realtime::PartyJoinRequest* Envelope::_internal_mutable_party_join_request() {
  if (!_internal_has_party_join_request()) {
    clear_message();
    set_has_party_join_request();
    message_.party_join_request_ = CreateMaybeMessage< ::nakama::realtime::PartyJoinRequest >(GetArena());
  }
  return message_.party_join_request_;
}
inline ::nakama::realtime::PartyJoinRequest* Envelope::mutable_party_join_request() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.party_join_request)
  return _internal_mutable_party_join_request();
}

// .nakama.realtime.PartyMatchmakerAdd party_matchmaker_add = 45;
inline bool Envelope::_internal_has_party_matchmaker_add() const {
  return message_case() == kPartyMatchmakerAdd;
}
inline bool Envelope::has_party_matchmaker_add() const {
  return _internal_has_party_matchmaker_add();
}
inline void Envelope::set_has_party_matchmaker_add() {
  _oneof_case_[0] = kPartyMatchmakerAdd;
}
inline void Envelope::clear_party_matchmaker_add() {
  if (_internal_has_party_matchmaker_add()) {
    if (GetArena() == nullptr) {
      delete message_.party_matchmaker_add_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::PartyMatchmakerAdd* Envelope::release_party_matchmaker_add() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.party_matchmaker_add)
  if (_internal_has_party_matchmaker_add()) {
    clear_has_message();
      ::nakama::realtime::PartyMatchmakerAdd* temp = message_.party_matchmaker_add_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.party_matchmaker_add_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::PartyMatchmakerAdd& Envelope::_internal_party_matchmaker_add() const {
  return _internal_has_party_matchmaker_add()
      ? *message_.party_matchmaker_add_
      : reinterpret_cast< ::nakama::realtime::PartyMatchmakerAdd&>(::nakama::realtime::_PartyMatchmakerAdd_default_instance_);
}
inline const ::nakama::realtime::PartyMatchmakerAdd& Envelope::party_matchmaker_add() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.party_matchmaker_add)
  return _internal_party_matchmaker_add();
}
inline ::nakama::realtime::PartyMatchmakerAdd* Envelope::unsafe_arena_release_party_matchmaker_add() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.party_matchmaker_add)
  if (_internal_has_party_matchmaker_add()) {
    clear_has_message();
    ::nakama::realtime::PartyMatchmakerAdd* temp = message_.party_matchmaker_add_;
    message_.party_matchmaker_add_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_party_matchmaker_add(::nakama::realtime::PartyMatchmakerAdd* party_matchmaker_add) {
  clear_message();
  if (party_matchmaker_add) {
    set_has_party_matchmaker_add();
    message_.party_matchmaker_add_ = party_matchmaker_add;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.party_matchmaker_add)
}
inline ::nakama::realtime::PartyMatchmakerAdd* Envelope::_internal_mutable_party_matchmaker_add() {
  if (!_internal_has_party_matchmaker_add()) {
    clear_message();
    set_has_party_matchmaker_add();
    message_.party_matchmaker_add_ = CreateMaybeMessage< ::nakama::realtime::PartyMatchmakerAdd >(GetArena());
  }
  return message_.party_matchmaker_add_;
}
inline ::nakama::realtime::PartyMatchmakerAdd* Envelope::mutable_party_matchmaker_add() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.party_matchmaker_add)
  return _internal_mutable_party_matchmaker_add();
}

// .nakama.realtime.PartyMatchmakerRemove party_matchmaker_remove = 46;
inline bool Envelope::_internal_has_party_matchmaker_remove() const {
  return message_case() == kPartyMatchmakerRemove;
}
inline bool Envelope::has_party_matchmaker_remove() const {
  return _internal_has_party_matchmaker_remove();
}
inline void Envelope::set_has_party_matchmaker_remove() {
  _oneof_case_[0] = kPartyMatchmakerRemove;
}
inline void Envelope::clear_party_matchmaker_remove() {
  if (_internal_has_party_matchmaker_remove()) {
    if (GetArena() == nullptr) {
      delete message_.party_matchmaker_remove_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::PartyMatchmakerRemove* Envelope::release_party_matchmaker_remove() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.party_matchmaker_remove)
  if (_internal_has_party_matchmaker_remove()) {
    clear_has_message();
      ::nakama::realtime::PartyMatchmakerRemove* temp = message_.party_matchmaker_remove_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.party_matchmaker_remove_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::PartyMatchmakerRemove& Envelope::_internal_party_matchmaker_remove() const {
  return _internal_has_party_matchmaker_remove()
      ? *message_.party_matchmaker_remove_
      : reinterpret_cast< ::nakama::realtime::PartyMatchmakerRemove&>(::nakama::realtime::_PartyMatchmakerRemove_default_instance_);
}
inline const ::nakama::realtime::PartyMatchmakerRemove& Envelope::party_matchmaker_remove() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.party_matchmaker_remove)
  return _internal_party_matchmaker_remove();
}
inline ::nakama::realtime::PartyMatchmakerRemove* Envelope::unsafe_arena_release_party_matchmaker_remove() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.party_matchmaker_remove)
  if (_internal_has_party_matchmaker_remove()) {
    clear_has_message();
    ::nakama::realtime::PartyMatchmakerRemove* temp = message_.party_matchmaker_remove_;
    message_.party_matchmaker_remove_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_party_matchmaker_remove(::nakama::realtime::PartyMatchmakerRemove* party_matchmaker_remove) {
  clear_message();
  if (party_matchmaker_remove) {
    set_has_party_matchmaker_remove();
    message_.party_matchmaker_remove_ = party_matchmaker_remove;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.party_matchmaker_remove)
}
inline ::nakama::realtime::PartyMatchmakerRemove* Envelope::_internal_mutable_party_matchmaker_remove() {
  if (!_internal_has_party_matchmaker_remove()) {
    clear_message();
    set_has_party_matchmaker_remove();
    message_.party_matchmaker_remove_ = CreateMaybeMessage< ::nakama::realtime::PartyMatchmakerRemove >(GetArena());
  }
  return message_.party_matchmaker_remove_;
}
inline ::nakama::realtime::PartyMatchmakerRemove* Envelope::mutable_party_matchmaker_remove() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.party_matchmaker_remove)
  return _internal_mutable_party_matchmaker_remove();
}

// .nakama.realtime.PartyMatchmakerTicket party_matchmaker_ticket = 47;
inline bool Envelope::_internal_has_party_matchmaker_ticket() const {
  return message_case() == kPartyMatchmakerTicket;
}
inline bool Envelope::has_party_matchmaker_ticket() const {
  return _internal_has_party_matchmaker_ticket();
}
inline void Envelope::set_has_party_matchmaker_ticket() {
  _oneof_case_[0] = kPartyMatchmakerTicket;
}
inline void Envelope::clear_party_matchmaker_ticket() {
  if (_internal_has_party_matchmaker_ticket()) {
    if (GetArena() == nullptr) {
      delete message_.party_matchmaker_ticket_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::PartyMatchmakerTicket* Envelope::release_party_matchmaker_ticket() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.party_matchmaker_ticket)
  if (_internal_has_party_matchmaker_ticket()) {
    clear_has_message();
      ::nakama::realtime::PartyMatchmakerTicket* temp = message_.party_matchmaker_ticket_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.party_matchmaker_ticket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::PartyMatchmakerTicket& Envelope::_internal_party_matchmaker_ticket() const {
  return _internal_has_party_matchmaker_ticket()
      ? *message_.party_matchmaker_ticket_
      : reinterpret_cast< ::nakama::realtime::PartyMatchmakerTicket&>(::nakama::realtime::_PartyMatchmakerTicket_default_instance_);
}
inline const ::nakama::realtime::PartyMatchmakerTicket& Envelope::party_matchmaker_ticket() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.party_matchmaker_ticket)
  return _internal_party_matchmaker_ticket();
}
inline ::nakama::realtime::PartyMatchmakerTicket* Envelope::unsafe_arena_release_party_matchmaker_ticket() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.party_matchmaker_ticket)
  if (_internal_has_party_matchmaker_ticket()) {
    clear_has_message();
    ::nakama::realtime::PartyMatchmakerTicket* temp = message_.party_matchmaker_ticket_;
    message_.party_matchmaker_ticket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_party_matchmaker_ticket(::nakama::realtime::PartyMatchmakerTicket* party_matchmaker_ticket) {
  clear_message();
  if (party_matchmaker_ticket) {
    set_has_party_matchmaker_ticket();
    message_.party_matchmaker_ticket_ = party_matchmaker_ticket;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.party_matchmaker_ticket)
}
inline ::nakama::realtime::PartyMatchmakerTicket* Envelope::_internal_mutable_party_matchmaker_ticket() {
  if (!_internal_has_party_matchmaker_ticket()) {
    clear_message();
    set_has_party_matchmaker_ticket();
    message_.party_matchmaker_ticket_ = CreateMaybeMessage< ::nakama::realtime::PartyMatchmakerTicket >(GetArena());
  }
  return message_.party_matchmaker_ticket_;
}
inline ::nakama::realtime::PartyMatchmakerTicket* Envelope::mutable_party_matchmaker_ticket() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.party_matchmaker_ticket)
  return _internal_mutable_party_matchmaker_ticket();
}

// .nakama.realtime.PartyData party_data = 48;
inline bool Envelope::_internal_has_party_data() const {
  return message_case() == kPartyData;
}
inline bool Envelope::has_party_data() const {
  return _internal_has_party_data();
}
inline void Envelope::set_has_party_data() {
  _oneof_case_[0] = kPartyData;
}
inline void Envelope::clear_party_data() {
  if (_internal_has_party_data()) {
    if (GetArena() == nullptr) {
      delete message_.party_data_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::PartyData* Envelope::release_party_data() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.party_data)
  if (_internal_has_party_data()) {
    clear_has_message();
      ::nakama::realtime::PartyData* temp = message_.party_data_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.party_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::PartyData& Envelope::_internal_party_data() const {
  return _internal_has_party_data()
      ? *message_.party_data_
      : reinterpret_cast< ::nakama::realtime::PartyData&>(::nakama::realtime::_PartyData_default_instance_);
}
inline const ::nakama::realtime::PartyData& Envelope::party_data() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.party_data)
  return _internal_party_data();
}
inline ::nakama::realtime::PartyData* Envelope::unsafe_arena_release_party_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.party_data)
  if (_internal_has_party_data()) {
    clear_has_message();
    ::nakama::realtime::PartyData* temp = message_.party_data_;
    message_.party_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_party_data(::nakama::realtime::PartyData* party_data) {
  clear_message();
  if (party_data) {
    set_has_party_data();
    message_.party_data_ = party_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.party_data)
}
inline ::nakama::realtime::PartyData* Envelope::_internal_mutable_party_data() {
  if (!_internal_has_party_data()) {
    clear_message();
    set_has_party_data();
    message_.party_data_ = CreateMaybeMessage< ::nakama::realtime::PartyData >(GetArena());
  }
  return message_.party_data_;
}
inline ::nakama::realtime::PartyData* Envelope::mutable_party_data() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.party_data)
  return _internal_mutable_party_data();
}

// .nakama.realtime.PartyDataSend party_data_send = 49;
inline bool Envelope::_internal_has_party_data_send() const {
  return message_case() == kPartyDataSend;
}
inline bool Envelope::has_party_data_send() const {
  return _internal_has_party_data_send();
}
inline void Envelope::set_has_party_data_send() {
  _oneof_case_[0] = kPartyDataSend;
}
inline void Envelope::clear_party_data_send() {
  if (_internal_has_party_data_send()) {
    if (GetArena() == nullptr) {
      delete message_.party_data_send_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::PartyDataSend* Envelope::release_party_data_send() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.party_data_send)
  if (_internal_has_party_data_send()) {
    clear_has_message();
      ::nakama::realtime::PartyDataSend* temp = message_.party_data_send_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.party_data_send_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::PartyDataSend& Envelope::_internal_party_data_send() const {
  return _internal_has_party_data_send()
      ? *message_.party_data_send_
      : reinterpret_cast< ::nakama::realtime::PartyDataSend&>(::nakama::realtime::_PartyDataSend_default_instance_);
}
inline const ::nakama::realtime::PartyDataSend& Envelope::party_data_send() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.party_data_send)
  return _internal_party_data_send();
}
inline ::nakama::realtime::PartyDataSend* Envelope::unsafe_arena_release_party_data_send() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.party_data_send)
  if (_internal_has_party_data_send()) {
    clear_has_message();
    ::nakama::realtime::PartyDataSend* temp = message_.party_data_send_;
    message_.party_data_send_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_party_data_send(::nakama::realtime::PartyDataSend* party_data_send) {
  clear_message();
  if (party_data_send) {
    set_has_party_data_send();
    message_.party_data_send_ = party_data_send;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.party_data_send)
}
inline ::nakama::realtime::PartyDataSend* Envelope::_internal_mutable_party_data_send() {
  if (!_internal_has_party_data_send()) {
    clear_message();
    set_has_party_data_send();
    message_.party_data_send_ = CreateMaybeMessage< ::nakama::realtime::PartyDataSend >(GetArena());
  }
  return message_.party_data_send_;
}
inline ::nakama::realtime::PartyDataSend* Envelope::mutable_party_data_send() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.party_data_send)
  return _internal_mutable_party_data_send();
}

// .nakama.realtime.PartyPresenceEvent party_presence_event = 50;
inline bool Envelope::_internal_has_party_presence_event() const {
  return message_case() == kPartyPresenceEvent;
}
inline bool Envelope::has_party_presence_event() const {
  return _internal_has_party_presence_event();
}
inline void Envelope::set_has_party_presence_event() {
  _oneof_case_[0] = kPartyPresenceEvent;
}
inline void Envelope::clear_party_presence_event() {
  if (_internal_has_party_presence_event()) {
    if (GetArena() == nullptr) {
      delete message_.party_presence_event_;
    }
    clear_has_message();
  }
}
inline ::nakama::realtime::PartyPresenceEvent* Envelope::release_party_presence_event() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.party_presence_event)
  if (_internal_has_party_presence_event()) {
    clear_has_message();
      ::nakama::realtime::PartyPresenceEvent* temp = message_.party_presence_event_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.party_presence_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nakama::realtime::PartyPresenceEvent& Envelope::_internal_party_presence_event() const {
  return _internal_has_party_presence_event()
      ? *message_.party_presence_event_
      : reinterpret_cast< ::nakama::realtime::PartyPresenceEvent&>(::nakama::realtime::_PartyPresenceEvent_default_instance_);
}
inline const ::nakama::realtime::PartyPresenceEvent& Envelope::party_presence_event() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.party_presence_event)
  return _internal_party_presence_event();
}
inline ::nakama::realtime::PartyPresenceEvent* Envelope::unsafe_arena_release_party_presence_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nakama.realtime.Envelope.party_presence_event)
  if (_internal_has_party_presence_event()) {
    clear_has_message();
    ::nakama::realtime::PartyPresenceEvent* temp = message_.party_presence_event_;
    message_.party_presence_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_party_presence_event(::nakama::realtime::PartyPresenceEvent* party_presence_event) {
  clear_message();
  if (party_presence_event) {
    set_has_party_presence_event();
    message_.party_presence_event_ = party_presence_event;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Envelope.party_presence_event)
}
inline ::nakama::realtime::PartyPresenceEvent* Envelope::_internal_mutable_party_presence_event() {
  if (!_internal_has_party_presence_event()) {
    clear_message();
    set_has_party_presence_event();
    message_.party_presence_event_ = CreateMaybeMessage< ::nakama::realtime::PartyPresenceEvent >(GetArena());
  }
  return message_.party_presence_event_;
}
inline ::nakama::realtime::PartyPresenceEvent* Envelope::mutable_party_presence_event() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.party_presence_event)
  return _internal_mutable_party_presence_event();
}

inline bool Envelope::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void Envelope::clear_has_message() {
  _oneof_case_[0] = MESSAGE_NOT_SET;
}
inline Envelope::MessageCase Envelope::message_case() const {
  return Envelope::MessageCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Channel

// string id = 1;
inline void Channel::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Channel::id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Channel.id)
  return _internal_id();
}
inline void Channel::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.Channel.id)
}
inline std::string* Channel::mutable_id() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Channel.id)
  return _internal_mutable_id();
}
inline const std::string& Channel::_internal_id() const {
  return id_.Get();
}
inline void Channel::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Channel::set_id(std::string&& value) {
  
  id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.Channel.id)
}
inline void Channel::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.Channel.id)
}
inline void Channel::set_id(const char* value,
    size_t size) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.Channel.id)
}
inline std::string* Channel::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Channel::release_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Channel.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Channel::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.Channel.id)
}

// repeated .nakama.realtime.UserPresence presences = 2;
inline int Channel::_internal_presences_size() const {
  return presences_.size();
}
inline int Channel::presences_size() const {
  return _internal_presences_size();
}
inline void Channel::clear_presences() {
  presences_.Clear();
}
inline ::nakama::realtime::UserPresence* Channel::mutable_presences(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Channel.presences)
  return presences_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >*
Channel::mutable_presences() {
  // @@protoc_insertion_point(field_mutable_list:nakama.realtime.Channel.presences)
  return &presences_;
}
inline const ::nakama::realtime::UserPresence& Channel::_internal_presences(int index) const {
  return presences_.Get(index);
}
inline const ::nakama::realtime::UserPresence& Channel::presences(int index) const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Channel.presences)
  return _internal_presences(index);
}
inline ::nakama::realtime::UserPresence* Channel::_internal_add_presences() {
  return presences_.Add();
}
inline ::nakama::realtime::UserPresence* Channel::add_presences() {
  // @@protoc_insertion_point(field_add:nakama.realtime.Channel.presences)
  return _internal_add_presences();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >&
Channel::presences() const {
  // @@protoc_insertion_point(field_list:nakama.realtime.Channel.presences)
  return presences_;
}

// .nakama.realtime.UserPresence self = 3;
inline bool Channel::_internal_has_self() const {
  return this != internal_default_instance() && self_ != nullptr;
}
inline bool Channel::has_self() const {
  return _internal_has_self();
}
inline void Channel::clear_self() {
  if (GetArena() == nullptr && self_ != nullptr) {
    delete self_;
  }
  self_ = nullptr;
}
inline const ::nakama::realtime::UserPresence& Channel::_internal_self() const {
  const ::nakama::realtime::UserPresence* p = self_;
  return p != nullptr ? *p : reinterpret_cast<const ::nakama::realtime::UserPresence&>(
      ::nakama::realtime::_UserPresence_default_instance_);
}
inline const ::nakama::realtime::UserPresence& Channel::self() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Channel.self)
  return _internal_self();
}
inline void Channel::unsafe_arena_set_allocated_self(
    ::nakama::realtime::UserPresence* self) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(self_);
  }
  self_ = self;
  if (self) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Channel.self)
}
inline ::nakama::realtime::UserPresence* Channel::release_self() {
  
  ::nakama::realtime::UserPresence* temp = self_;
  self_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::nakama::realtime::UserPresence* Channel::unsafe_arena_release_self() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Channel.self)
  
  ::nakama::realtime::UserPresence* temp = self_;
  self_ = nullptr;
  return temp;
}
inline ::nakama::realtime::UserPresence* Channel::_internal_mutable_self() {
  
  if (self_ == nullptr) {
    auto* p = CreateMaybeMessage<::nakama::realtime::UserPresence>(GetArena());
    self_ = p;
  }
  return self_;
}
inline ::nakama::realtime::UserPresence* Channel::mutable_self() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Channel.self)
  return _internal_mutable_self();
}
inline void Channel::set_allocated_self(::nakama::realtime::UserPresence* self) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete self_;
  }
  if (self) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(self);
    if (message_arena != submessage_arena) {
      self = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, self, submessage_arena);
    }
    
  } else {
    
  }
  self_ = self;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.Channel.self)
}

// string room_name = 4;
inline void Channel::clear_room_name() {
  room_name_.ClearToEmpty();
}
inline const std::string& Channel::room_name() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Channel.room_name)
  return _internal_room_name();
}
inline void Channel::set_room_name(const std::string& value) {
  _internal_set_room_name(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.Channel.room_name)
}
inline std::string* Channel::mutable_room_name() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Channel.room_name)
  return _internal_mutable_room_name();
}
inline const std::string& Channel::_internal_room_name() const {
  return room_name_.Get();
}
inline void Channel::_internal_set_room_name(const std::string& value) {
  
  room_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Channel::set_room_name(std::string&& value) {
  
  room_name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.Channel.room_name)
}
inline void Channel::set_room_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  room_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.Channel.room_name)
}
inline void Channel::set_room_name(const char* value,
    size_t size) {
  
  room_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.Channel.room_name)
}
inline std::string* Channel::_internal_mutable_room_name() {
  
  return room_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Channel::release_room_name() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Channel.room_name)
  return room_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Channel::set_allocated_room_name(std::string* room_name) {
  if (room_name != nullptr) {
    
  } else {
    
  }
  room_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), room_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.Channel.room_name)
}

// string group_id = 5;
inline void Channel::clear_group_id() {
  group_id_.ClearToEmpty();
}
inline const std::string& Channel::group_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Channel.group_id)
  return _internal_group_id();
}
inline void Channel::set_group_id(const std::string& value) {
  _internal_set_group_id(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.Channel.group_id)
}
inline std::string* Channel::mutable_group_id() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Channel.group_id)
  return _internal_mutable_group_id();
}
inline const std::string& Channel::_internal_group_id() const {
  return group_id_.Get();
}
inline void Channel::_internal_set_group_id(const std::string& value) {
  
  group_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Channel::set_group_id(std::string&& value) {
  
  group_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.Channel.group_id)
}
inline void Channel::set_group_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  group_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.Channel.group_id)
}
inline void Channel::set_group_id(const char* value,
    size_t size) {
  
  group_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.Channel.group_id)
}
inline std::string* Channel::_internal_mutable_group_id() {
  
  return group_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Channel::release_group_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Channel.group_id)
  return group_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Channel::set_allocated_group_id(std::string* group_id) {
  if (group_id != nullptr) {
    
  } else {
    
  }
  group_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), group_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.Channel.group_id)
}

// string user_id_one = 6;
inline void Channel::clear_user_id_one() {
  user_id_one_.ClearToEmpty();
}
inline const std::string& Channel::user_id_one() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Channel.user_id_one)
  return _internal_user_id_one();
}
inline void Channel::set_user_id_one(const std::string& value) {
  _internal_set_user_id_one(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.Channel.user_id_one)
}
inline std::string* Channel::mutable_user_id_one() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Channel.user_id_one)
  return _internal_mutable_user_id_one();
}
inline const std::string& Channel::_internal_user_id_one() const {
  return user_id_one_.Get();
}
inline void Channel::_internal_set_user_id_one(const std::string& value) {
  
  user_id_one_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Channel::set_user_id_one(std::string&& value) {
  
  user_id_one_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.Channel.user_id_one)
}
inline void Channel::set_user_id_one(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  user_id_one_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.Channel.user_id_one)
}
inline void Channel::set_user_id_one(const char* value,
    size_t size) {
  
  user_id_one_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.Channel.user_id_one)
}
inline std::string* Channel::_internal_mutable_user_id_one() {
  
  return user_id_one_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Channel::release_user_id_one() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Channel.user_id_one)
  return user_id_one_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Channel::set_allocated_user_id_one(std::string* user_id_one) {
  if (user_id_one != nullptr) {
    
  } else {
    
  }
  user_id_one_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id_one,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.Channel.user_id_one)
}

// string user_id_two = 7;
inline void Channel::clear_user_id_two() {
  user_id_two_.ClearToEmpty();
}
inline const std::string& Channel::user_id_two() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Channel.user_id_two)
  return _internal_user_id_two();
}
inline void Channel::set_user_id_two(const std::string& value) {
  _internal_set_user_id_two(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.Channel.user_id_two)
}
inline std::string* Channel::mutable_user_id_two() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Channel.user_id_two)
  return _internal_mutable_user_id_two();
}
inline const std::string& Channel::_internal_user_id_two() const {
  return user_id_two_.Get();
}
inline void Channel::_internal_set_user_id_two(const std::string& value) {
  
  user_id_two_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Channel::set_user_id_two(std::string&& value) {
  
  user_id_two_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.Channel.user_id_two)
}
inline void Channel::set_user_id_two(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  user_id_two_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.Channel.user_id_two)
}
inline void Channel::set_user_id_two(const char* value,
    size_t size) {
  
  user_id_two_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.Channel.user_id_two)
}
inline std::string* Channel::_internal_mutable_user_id_two() {
  
  return user_id_two_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Channel::release_user_id_two() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Channel.user_id_two)
  return user_id_two_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Channel::set_allocated_user_id_two(std::string* user_id_two) {
  if (user_id_two != nullptr) {
    
  } else {
    
  }
  user_id_two_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id_two,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.Channel.user_id_two)
}

// -------------------------------------------------------------------

// ChannelJoin

// string target = 1;
inline void ChannelJoin::clear_target() {
  target_.ClearToEmpty();
}
inline const std::string& ChannelJoin::target() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelJoin.target)
  return _internal_target();
}
inline void ChannelJoin::set_target(const std::string& value) {
  _internal_set_target(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.ChannelJoin.target)
}
inline std::string* ChannelJoin::mutable_target() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelJoin.target)
  return _internal_mutable_target();
}
inline const std::string& ChannelJoin::_internal_target() const {
  return target_.Get();
}
inline void ChannelJoin::_internal_set_target(const std::string& value) {
  
  target_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ChannelJoin::set_target(std::string&& value) {
  
  target_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.ChannelJoin.target)
}
inline void ChannelJoin::set_target(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  target_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.ChannelJoin.target)
}
inline void ChannelJoin::set_target(const char* value,
    size_t size) {
  
  target_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.ChannelJoin.target)
}
inline std::string* ChannelJoin::_internal_mutable_target() {
  
  return target_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ChannelJoin::release_target() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelJoin.target)
  return target_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ChannelJoin::set_allocated_target(std::string* target) {
  if (target != nullptr) {
    
  } else {
    
  }
  target_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), target,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelJoin.target)
}

// int32 type = 2;
inline void ChannelJoin::clear_type() {
  type_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ChannelJoin::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ChannelJoin::type() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelJoin.type)
  return _internal_type();
}
inline void ChannelJoin::_internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  type_ = value;
}
inline void ChannelJoin::set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.ChannelJoin.type)
}

// .google.protobuf.BoolValue persistence = 3;
inline bool ChannelJoin::_internal_has_persistence() const {
  return this != internal_default_instance() && persistence_ != nullptr;
}
inline bool ChannelJoin::has_persistence() const {
  return _internal_has_persistence();
}
inline const PROTOBUF_NAMESPACE_ID::BoolValue& ChannelJoin::_internal_persistence() const {
  const PROTOBUF_NAMESPACE_ID::BoolValue* p = persistence_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::BoolValue&>(
      PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::BoolValue& ChannelJoin::persistence() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelJoin.persistence)
  return _internal_persistence();
}
inline void ChannelJoin::unsafe_arena_set_allocated_persistence(
    PROTOBUF_NAMESPACE_ID::BoolValue* persistence) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(persistence_);
  }
  persistence_ = persistence;
  if (persistence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.ChannelJoin.persistence)
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* ChannelJoin::release_persistence() {
  
  PROTOBUF_NAMESPACE_ID::BoolValue* temp = persistence_;
  persistence_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* ChannelJoin::unsafe_arena_release_persistence() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelJoin.persistence)
  
  PROTOBUF_NAMESPACE_ID::BoolValue* temp = persistence_;
  persistence_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* ChannelJoin::_internal_mutable_persistence() {
  
  if (persistence_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::BoolValue>(GetArena());
    persistence_ = p;
  }
  return persistence_;
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* ChannelJoin::mutable_persistence() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelJoin.persistence)
  return _internal_mutable_persistence();
}
inline void ChannelJoin::set_allocated_persistence(PROTOBUF_NAMESPACE_ID::BoolValue* persistence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(persistence_);
  }
  if (persistence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(persistence)->GetArena();
    if (message_arena != submessage_arena) {
      persistence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, persistence, submessage_arena);
    }
    
  } else {
    
  }
  persistence_ = persistence;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelJoin.persistence)
}

// .google.protobuf.BoolValue hidden = 4;
inline bool ChannelJoin::_internal_has_hidden() const {
  return this != internal_default_instance() && hidden_ != nullptr;
}
inline bool ChannelJoin::has_hidden() const {
  return _internal_has_hidden();
}
inline const PROTOBUF_NAMESPACE_ID::BoolValue& ChannelJoin::_internal_hidden() const {
  const PROTOBUF_NAMESPACE_ID::BoolValue* p = hidden_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::BoolValue&>(
      PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::BoolValue& ChannelJoin::hidden() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelJoin.hidden)
  return _internal_hidden();
}
inline void ChannelJoin::unsafe_arena_set_allocated_hidden(
    PROTOBUF_NAMESPACE_ID::BoolValue* hidden) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hidden_);
  }
  hidden_ = hidden;
  if (hidden) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.ChannelJoin.hidden)
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* ChannelJoin::release_hidden() {
  
  PROTOBUF_NAMESPACE_ID::BoolValue* temp = hidden_;
  hidden_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* ChannelJoin::unsafe_arena_release_hidden() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelJoin.hidden)
  
  PROTOBUF_NAMESPACE_ID::BoolValue* temp = hidden_;
  hidden_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* ChannelJoin::_internal_mutable_hidden() {
  
  if (hidden_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::BoolValue>(GetArena());
    hidden_ = p;
  }
  return hidden_;
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* ChannelJoin::mutable_hidden() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelJoin.hidden)
  return _internal_mutable_hidden();
}
inline void ChannelJoin::set_allocated_hidden(PROTOBUF_NAMESPACE_ID::BoolValue* hidden) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(hidden_);
  }
  if (hidden) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hidden)->GetArena();
    if (message_arena != submessage_arena) {
      hidden = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hidden, submessage_arena);
    }
    
  } else {
    
  }
  hidden_ = hidden;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelJoin.hidden)
}

// -------------------------------------------------------------------

// ChannelLeave

// string channel_id = 1;
inline void ChannelLeave::clear_channel_id() {
  channel_id_.ClearToEmpty();
}
inline const std::string& ChannelLeave::channel_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelLeave.channel_id)
  return _internal_channel_id();
}
inline void ChannelLeave::set_channel_id(const std::string& value) {
  _internal_set_channel_id(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.ChannelLeave.channel_id)
}
inline std::string* ChannelLeave::mutable_channel_id() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelLeave.channel_id)
  return _internal_mutable_channel_id();
}
inline const std::string& ChannelLeave::_internal_channel_id() const {
  return channel_id_.Get();
}
inline void ChannelLeave::_internal_set_channel_id(const std::string& value) {
  
  channel_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ChannelLeave::set_channel_id(std::string&& value) {
  
  channel_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.ChannelLeave.channel_id)
}
inline void ChannelLeave::set_channel_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  channel_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.ChannelLeave.channel_id)
}
inline void ChannelLeave::set_channel_id(const char* value,
    size_t size) {
  
  channel_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.ChannelLeave.channel_id)
}
inline std::string* ChannelLeave::_internal_mutable_channel_id() {
  
  return channel_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ChannelLeave::release_channel_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelLeave.channel_id)
  return channel_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ChannelLeave::set_allocated_channel_id(std::string* channel_id) {
  if (channel_id != nullptr) {
    
  } else {
    
  }
  channel_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), channel_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelLeave.channel_id)
}

// -------------------------------------------------------------------

// ChannelMessageAck

// string channel_id = 1;
inline void ChannelMessageAck::clear_channel_id() {
  channel_id_.ClearToEmpty();
}
inline const std::string& ChannelMessageAck::channel_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelMessageAck.channel_id)
  return _internal_channel_id();
}
inline void ChannelMessageAck::set_channel_id(const std::string& value) {
  _internal_set_channel_id(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.ChannelMessageAck.channel_id)
}
inline std::string* ChannelMessageAck::mutable_channel_id() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelMessageAck.channel_id)
  return _internal_mutable_channel_id();
}
inline const std::string& ChannelMessageAck::_internal_channel_id() const {
  return channel_id_.Get();
}
inline void ChannelMessageAck::_internal_set_channel_id(const std::string& value) {
  
  channel_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ChannelMessageAck::set_channel_id(std::string&& value) {
  
  channel_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.ChannelMessageAck.channel_id)
}
inline void ChannelMessageAck::set_channel_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  channel_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.ChannelMessageAck.channel_id)
}
inline void ChannelMessageAck::set_channel_id(const char* value,
    size_t size) {
  
  channel_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.ChannelMessageAck.channel_id)
}
inline std::string* ChannelMessageAck::_internal_mutable_channel_id() {
  
  return channel_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ChannelMessageAck::release_channel_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelMessageAck.channel_id)
  return channel_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ChannelMessageAck::set_allocated_channel_id(std::string* channel_id) {
  if (channel_id != nullptr) {
    
  } else {
    
  }
  channel_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), channel_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelMessageAck.channel_id)
}

// string message_id = 2;
inline void ChannelMessageAck::clear_message_id() {
  message_id_.ClearToEmpty();
}
inline const std::string& ChannelMessageAck::message_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelMessageAck.message_id)
  return _internal_message_id();
}
inline void ChannelMessageAck::set_message_id(const std::string& value) {
  _internal_set_message_id(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.ChannelMessageAck.message_id)
}
inline std::string* ChannelMessageAck::mutable_message_id() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelMessageAck.message_id)
  return _internal_mutable_message_id();
}
inline const std::string& ChannelMessageAck::_internal_message_id() const {
  return message_id_.Get();
}
inline void ChannelMessageAck::_internal_set_message_id(const std::string& value) {
  
  message_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ChannelMessageAck::set_message_id(std::string&& value) {
  
  message_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.ChannelMessageAck.message_id)
}
inline void ChannelMessageAck::set_message_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.ChannelMessageAck.message_id)
}
inline void ChannelMessageAck::set_message_id(const char* value,
    size_t size) {
  
  message_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.ChannelMessageAck.message_id)
}
inline std::string* ChannelMessageAck::_internal_mutable_message_id() {
  
  return message_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ChannelMessageAck::release_message_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelMessageAck.message_id)
  return message_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ChannelMessageAck::set_allocated_message_id(std::string* message_id) {
  if (message_id != nullptr) {
    
  } else {
    
  }
  message_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelMessageAck.message_id)
}

// .google.protobuf.Int32Value code = 3;
inline bool ChannelMessageAck::_internal_has_code() const {
  return this != internal_default_instance() && code_ != nullptr;
}
inline bool ChannelMessageAck::has_code() const {
  return _internal_has_code();
}
inline const PROTOBUF_NAMESPACE_ID::Int32Value& ChannelMessageAck::_internal_code() const {
  const PROTOBUF_NAMESPACE_ID::Int32Value* p = code_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Int32Value&>(
      PROTOBUF_NAMESPACE_ID::_Int32Value_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Int32Value& ChannelMessageAck::code() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelMessageAck.code)
  return _internal_code();
}
inline void ChannelMessageAck::unsafe_arena_set_allocated_code(
    PROTOBUF_NAMESPACE_ID::Int32Value* code) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(code_);
  }
  code_ = code;
  if (code) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.ChannelMessageAck.code)
}
inline PROTOBUF_NAMESPACE_ID::Int32Value* ChannelMessageAck::release_code() {
  
  PROTOBUF_NAMESPACE_ID::Int32Value* temp = code_;
  code_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Int32Value* ChannelMessageAck::unsafe_arena_release_code() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelMessageAck.code)
  
  PROTOBUF_NAMESPACE_ID::Int32Value* temp = code_;
  code_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Int32Value* ChannelMessageAck::_internal_mutable_code() {
  
  if (code_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Int32Value>(GetArena());
    code_ = p;
  }
  return code_;
}
inline PROTOBUF_NAMESPACE_ID::Int32Value* ChannelMessageAck::mutable_code() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelMessageAck.code)
  return _internal_mutable_code();
}
inline void ChannelMessageAck::set_allocated_code(PROTOBUF_NAMESPACE_ID::Int32Value* code) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(code_);
  }
  if (code) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(code)->GetArena();
    if (message_arena != submessage_arena) {
      code = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, code, submessage_arena);
    }
    
  } else {
    
  }
  code_ = code;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelMessageAck.code)
}

// string username = 4;
inline void ChannelMessageAck::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& ChannelMessageAck::username() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelMessageAck.username)
  return _internal_username();
}
inline void ChannelMessageAck::set_username(const std::string& value) {
  _internal_set_username(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.ChannelMessageAck.username)
}
inline std::string* ChannelMessageAck::mutable_username() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelMessageAck.username)
  return _internal_mutable_username();
}
inline const std::string& ChannelMessageAck::_internal_username() const {
  return username_.Get();
}
inline void ChannelMessageAck::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ChannelMessageAck::set_username(std::string&& value) {
  
  username_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.ChannelMessageAck.username)
}
inline void ChannelMessageAck::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.ChannelMessageAck.username)
}
inline void ChannelMessageAck::set_username(const char* value,
    size_t size) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.ChannelMessageAck.username)
}
inline std::string* ChannelMessageAck::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ChannelMessageAck::release_username() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelMessageAck.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ChannelMessageAck::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelMessageAck.username)
}

// .google.protobuf.Timestamp create_time = 5;
inline bool ChannelMessageAck::_internal_has_create_time() const {
  return this != internal_default_instance() && create_time_ != nullptr;
}
inline bool ChannelMessageAck::has_create_time() const {
  return _internal_has_create_time();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ChannelMessageAck::_internal_create_time() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = create_time_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp&>(
      PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ChannelMessageAck::create_time() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelMessageAck.create_time)
  return _internal_create_time();
}
inline void ChannelMessageAck::unsafe_arena_set_allocated_create_time(
    PROTOBUF_NAMESPACE_ID::Timestamp* create_time) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(create_time_);
  }
  create_time_ = create_time;
  if (create_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.ChannelMessageAck.create_time)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ChannelMessageAck::release_create_time() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = create_time_;
  create_time_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ChannelMessageAck::unsafe_arena_release_create_time() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelMessageAck.create_time)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = create_time_;
  create_time_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ChannelMessageAck::_internal_mutable_create_time() {
  
  if (create_time_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    create_time_ = p;
  }
  return create_time_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ChannelMessageAck::mutable_create_time() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelMessageAck.create_time)
  return _internal_mutable_create_time();
}
inline void ChannelMessageAck::set_allocated_create_time(PROTOBUF_NAMESPACE_ID::Timestamp* create_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(create_time_);
  }
  if (create_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(create_time)->GetArena();
    if (message_arena != submessage_arena) {
      create_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, create_time, submessage_arena);
    }
    
  } else {
    
  }
  create_time_ = create_time;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelMessageAck.create_time)
}

// .google.protobuf.Timestamp update_time = 6;
inline bool ChannelMessageAck::_internal_has_update_time() const {
  return this != internal_default_instance() && update_time_ != nullptr;
}
inline bool ChannelMessageAck::has_update_time() const {
  return _internal_has_update_time();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ChannelMessageAck::_internal_update_time() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = update_time_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp&>(
      PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ChannelMessageAck::update_time() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelMessageAck.update_time)
  return _internal_update_time();
}
inline void ChannelMessageAck::unsafe_arena_set_allocated_update_time(
    PROTOBUF_NAMESPACE_ID::Timestamp* update_time) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_time_);
  }
  update_time_ = update_time;
  if (update_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.ChannelMessageAck.update_time)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ChannelMessageAck::release_update_time() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = update_time_;
  update_time_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ChannelMessageAck::unsafe_arena_release_update_time() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelMessageAck.update_time)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = update_time_;
  update_time_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ChannelMessageAck::_internal_mutable_update_time() {
  
  if (update_time_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    update_time_ = p;
  }
  return update_time_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ChannelMessageAck::mutable_update_time() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelMessageAck.update_time)
  return _internal_mutable_update_time();
}
inline void ChannelMessageAck::set_allocated_update_time(PROTOBUF_NAMESPACE_ID::Timestamp* update_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_time_);
  }
  if (update_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_time)->GetArena();
    if (message_arena != submessage_arena) {
      update_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_time, submessage_arena);
    }
    
  } else {
    
  }
  update_time_ = update_time;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelMessageAck.update_time)
}

// .google.protobuf.BoolValue persistent = 7;
inline bool ChannelMessageAck::_internal_has_persistent() const {
  return this != internal_default_instance() && persistent_ != nullptr;
}
inline bool ChannelMessageAck::has_persistent() const {
  return _internal_has_persistent();
}
inline const PROTOBUF_NAMESPACE_ID::BoolValue& ChannelMessageAck::_internal_persistent() const {
  const PROTOBUF_NAMESPACE_ID::BoolValue* p = persistent_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::BoolValue&>(
      PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::BoolValue& ChannelMessageAck::persistent() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelMessageAck.persistent)
  return _internal_persistent();
}
inline void ChannelMessageAck::unsafe_arena_set_allocated_persistent(
    PROTOBUF_NAMESPACE_ID::BoolValue* persistent) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(persistent_);
  }
  persistent_ = persistent;
  if (persistent) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.ChannelMessageAck.persistent)
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* ChannelMessageAck::release_persistent() {
  
  PROTOBUF_NAMESPACE_ID::BoolValue* temp = persistent_;
  persistent_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* ChannelMessageAck::unsafe_arena_release_persistent() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelMessageAck.persistent)
  
  PROTOBUF_NAMESPACE_ID::BoolValue* temp = persistent_;
  persistent_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* ChannelMessageAck::_internal_mutable_persistent() {
  
  if (persistent_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::BoolValue>(GetArena());
    persistent_ = p;
  }
  return persistent_;
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* ChannelMessageAck::mutable_persistent() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelMessageAck.persistent)
  return _internal_mutable_persistent();
}
inline void ChannelMessageAck::set_allocated_persistent(PROTOBUF_NAMESPACE_ID::BoolValue* persistent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(persistent_);
  }
  if (persistent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(persistent)->GetArena();
    if (message_arena != submessage_arena) {
      persistent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, persistent, submessage_arena);
    }
    
  } else {
    
  }
  persistent_ = persistent;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelMessageAck.persistent)
}

// string room_name = 8;
inline void ChannelMessageAck::clear_room_name() {
  room_name_.ClearToEmpty();
}
inline const std::string& ChannelMessageAck::room_name() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelMessageAck.room_name)
  return _internal_room_name();
}
inline void ChannelMessageAck::set_room_name(const std::string& value) {
  _internal_set_room_name(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.ChannelMessageAck.room_name)
}
inline std::string* ChannelMessageAck::mutable_room_name() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelMessageAck.room_name)
  return _internal_mutable_room_name();
}
inline const std::string& ChannelMessageAck::_internal_room_name() const {
  return room_name_.Get();
}
inline void ChannelMessageAck::_internal_set_room_name(const std::string& value) {
  
  room_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ChannelMessageAck::set_room_name(std::string&& value) {
  
  room_name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.ChannelMessageAck.room_name)
}
inline void ChannelMessageAck::set_room_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  room_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.ChannelMessageAck.room_name)
}
inline void ChannelMessageAck::set_room_name(const char* value,
    size_t size) {
  
  room_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.ChannelMessageAck.room_name)
}
inline std::string* ChannelMessageAck::_internal_mutable_room_name() {
  
  return room_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ChannelMessageAck::release_room_name() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelMessageAck.room_name)
  return room_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ChannelMessageAck::set_allocated_room_name(std::string* room_name) {
  if (room_name != nullptr) {
    
  } else {
    
  }
  room_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), room_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelMessageAck.room_name)
}

// string group_id = 9;
inline void ChannelMessageAck::clear_group_id() {
  group_id_.ClearToEmpty();
}
inline const std::string& ChannelMessageAck::group_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelMessageAck.group_id)
  return _internal_group_id();
}
inline void ChannelMessageAck::set_group_id(const std::string& value) {
  _internal_set_group_id(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.ChannelMessageAck.group_id)
}
inline std::string* ChannelMessageAck::mutable_group_id() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelMessageAck.group_id)
  return _internal_mutable_group_id();
}
inline const std::string& ChannelMessageAck::_internal_group_id() const {
  return group_id_.Get();
}
inline void ChannelMessageAck::_internal_set_group_id(const std::string& value) {
  
  group_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ChannelMessageAck::set_group_id(std::string&& value) {
  
  group_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.ChannelMessageAck.group_id)
}
inline void ChannelMessageAck::set_group_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  group_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.ChannelMessageAck.group_id)
}
inline void ChannelMessageAck::set_group_id(const char* value,
    size_t size) {
  
  group_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.ChannelMessageAck.group_id)
}
inline std::string* ChannelMessageAck::_internal_mutable_group_id() {
  
  return group_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ChannelMessageAck::release_group_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelMessageAck.group_id)
  return group_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ChannelMessageAck::set_allocated_group_id(std::string* group_id) {
  if (group_id != nullptr) {
    
  } else {
    
  }
  group_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), group_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelMessageAck.group_id)
}

// string user_id_one = 10;
inline void ChannelMessageAck::clear_user_id_one() {
  user_id_one_.ClearToEmpty();
}
inline const std::string& ChannelMessageAck::user_id_one() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelMessageAck.user_id_one)
  return _internal_user_id_one();
}
inline void ChannelMessageAck::set_user_id_one(const std::string& value) {
  _internal_set_user_id_one(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.ChannelMessageAck.user_id_one)
}
inline std::string* ChannelMessageAck::mutable_user_id_one() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelMessageAck.user_id_one)
  return _internal_mutable_user_id_one();
}
inline const std::string& ChannelMessageAck::_internal_user_id_one() const {
  return user_id_one_.Get();
}
inline void ChannelMessageAck::_internal_set_user_id_one(const std::string& value) {
  
  user_id_one_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ChannelMessageAck::set_user_id_one(std::string&& value) {
  
  user_id_one_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.ChannelMessageAck.user_id_one)
}
inline void ChannelMessageAck::set_user_id_one(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  user_id_one_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.ChannelMessageAck.user_id_one)
}
inline void ChannelMessageAck::set_user_id_one(const char* value,
    size_t size) {
  
  user_id_one_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.ChannelMessageAck.user_id_one)
}
inline std::string* ChannelMessageAck::_internal_mutable_user_id_one() {
  
  return user_id_one_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ChannelMessageAck::release_user_id_one() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelMessageAck.user_id_one)
  return user_id_one_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ChannelMessageAck::set_allocated_user_id_one(std::string* user_id_one) {
  if (user_id_one != nullptr) {
    
  } else {
    
  }
  user_id_one_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id_one,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelMessageAck.user_id_one)
}

// string user_id_two = 11;
inline void ChannelMessageAck::clear_user_id_two() {
  user_id_two_.ClearToEmpty();
}
inline const std::string& ChannelMessageAck::user_id_two() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelMessageAck.user_id_two)
  return _internal_user_id_two();
}
inline void ChannelMessageAck::set_user_id_two(const std::string& value) {
  _internal_set_user_id_two(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.ChannelMessageAck.user_id_two)
}
inline std::string* ChannelMessageAck::mutable_user_id_two() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelMessageAck.user_id_two)
  return _internal_mutable_user_id_two();
}
inline const std::string& ChannelMessageAck::_internal_user_id_two() const {
  return user_id_two_.Get();
}
inline void ChannelMessageAck::_internal_set_user_id_two(const std::string& value) {
  
  user_id_two_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ChannelMessageAck::set_user_id_two(std::string&& value) {
  
  user_id_two_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.ChannelMessageAck.user_id_two)
}
inline void ChannelMessageAck::set_user_id_two(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  user_id_two_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.ChannelMessageAck.user_id_two)
}
inline void ChannelMessageAck::set_user_id_two(const char* value,
    size_t size) {
  
  user_id_two_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.ChannelMessageAck.user_id_two)
}
inline std::string* ChannelMessageAck::_internal_mutable_user_id_two() {
  
  return user_id_two_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ChannelMessageAck::release_user_id_two() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelMessageAck.user_id_two)
  return user_id_two_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ChannelMessageAck::set_allocated_user_id_two(std::string* user_id_two) {
  if (user_id_two != nullptr) {
    
  } else {
    
  }
  user_id_two_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id_two,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelMessageAck.user_id_two)
}

// -------------------------------------------------------------------

// ChannelMessageSend

// string channel_id = 1;
inline void ChannelMessageSend::clear_channel_id() {
  channel_id_.ClearToEmpty();
}
inline const std::string& ChannelMessageSend::channel_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelMessageSend.channel_id)
  return _internal_channel_id();
}
inline void ChannelMessageSend::set_channel_id(const std::string& value) {
  _internal_set_channel_id(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.ChannelMessageSend.channel_id)
}
inline std::string* ChannelMessageSend::mutable_channel_id() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelMessageSend.channel_id)
  return _internal_mutable_channel_id();
}
inline const std::string& ChannelMessageSend::_internal_channel_id() const {
  return channel_id_.Get();
}
inline void ChannelMessageSend::_internal_set_channel_id(const std::string& value) {
  
  channel_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ChannelMessageSend::set_channel_id(std::string&& value) {
  
  channel_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.ChannelMessageSend.channel_id)
}
inline void ChannelMessageSend::set_channel_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  channel_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.ChannelMessageSend.channel_id)
}
inline void ChannelMessageSend::set_channel_id(const char* value,
    size_t size) {
  
  channel_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.ChannelMessageSend.channel_id)
}
inline std::string* ChannelMessageSend::_internal_mutable_channel_id() {
  
  return channel_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ChannelMessageSend::release_channel_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelMessageSend.channel_id)
  return channel_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ChannelMessageSend::set_allocated_channel_id(std::string* channel_id) {
  if (channel_id != nullptr) {
    
  } else {
    
  }
  channel_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), channel_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelMessageSend.channel_id)
}

// string content = 2;
inline void ChannelMessageSend::clear_content() {
  content_.ClearToEmpty();
}
inline const std::string& ChannelMessageSend::content() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelMessageSend.content)
  return _internal_content();
}
inline void ChannelMessageSend::set_content(const std::string& value) {
  _internal_set_content(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.ChannelMessageSend.content)
}
inline std::string* ChannelMessageSend::mutable_content() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelMessageSend.content)
  return _internal_mutable_content();
}
inline const std::string& ChannelMessageSend::_internal_content() const {
  return content_.Get();
}
inline void ChannelMessageSend::_internal_set_content(const std::string& value) {
  
  content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ChannelMessageSend::set_content(std::string&& value) {
  
  content_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.ChannelMessageSend.content)
}
inline void ChannelMessageSend::set_content(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.ChannelMessageSend.content)
}
inline void ChannelMessageSend::set_content(const char* value,
    size_t size) {
  
  content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.ChannelMessageSend.content)
}
inline std::string* ChannelMessageSend::_internal_mutable_content() {
  
  return content_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ChannelMessageSend::release_content() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelMessageSend.content)
  return content_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ChannelMessageSend::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  content_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), content,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelMessageSend.content)
}

// -------------------------------------------------------------------

// ChannelMessageUpdate

// string channel_id = 1;
inline void ChannelMessageUpdate::clear_channel_id() {
  channel_id_.ClearToEmpty();
}
inline const std::string& ChannelMessageUpdate::channel_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelMessageUpdate.channel_id)
  return _internal_channel_id();
}
inline void ChannelMessageUpdate::set_channel_id(const std::string& value) {
  _internal_set_channel_id(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.ChannelMessageUpdate.channel_id)
}
inline std::string* ChannelMessageUpdate::mutable_channel_id() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelMessageUpdate.channel_id)
  return _internal_mutable_channel_id();
}
inline const std::string& ChannelMessageUpdate::_internal_channel_id() const {
  return channel_id_.Get();
}
inline void ChannelMessageUpdate::_internal_set_channel_id(const std::string& value) {
  
  channel_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ChannelMessageUpdate::set_channel_id(std::string&& value) {
  
  channel_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.ChannelMessageUpdate.channel_id)
}
inline void ChannelMessageUpdate::set_channel_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  channel_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.ChannelMessageUpdate.channel_id)
}
inline void ChannelMessageUpdate::set_channel_id(const char* value,
    size_t size) {
  
  channel_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.ChannelMessageUpdate.channel_id)
}
inline std::string* ChannelMessageUpdate::_internal_mutable_channel_id() {
  
  return channel_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ChannelMessageUpdate::release_channel_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelMessageUpdate.channel_id)
  return channel_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ChannelMessageUpdate::set_allocated_channel_id(std::string* channel_id) {
  if (channel_id != nullptr) {
    
  } else {
    
  }
  channel_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), channel_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelMessageUpdate.channel_id)
}

// string message_id = 2;
inline void ChannelMessageUpdate::clear_message_id() {
  message_id_.ClearToEmpty();
}
inline const std::string& ChannelMessageUpdate::message_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelMessageUpdate.message_id)
  return _internal_message_id();
}
inline void ChannelMessageUpdate::set_message_id(const std::string& value) {
  _internal_set_message_id(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.ChannelMessageUpdate.message_id)
}
inline std::string* ChannelMessageUpdate::mutable_message_id() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelMessageUpdate.message_id)
  return _internal_mutable_message_id();
}
inline const std::string& ChannelMessageUpdate::_internal_message_id() const {
  return message_id_.Get();
}
inline void ChannelMessageUpdate::_internal_set_message_id(const std::string& value) {
  
  message_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ChannelMessageUpdate::set_message_id(std::string&& value) {
  
  message_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.ChannelMessageUpdate.message_id)
}
inline void ChannelMessageUpdate::set_message_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.ChannelMessageUpdate.message_id)
}
inline void ChannelMessageUpdate::set_message_id(const char* value,
    size_t size) {
  
  message_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.ChannelMessageUpdate.message_id)
}
inline std::string* ChannelMessageUpdate::_internal_mutable_message_id() {
  
  return message_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ChannelMessageUpdate::release_message_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelMessageUpdate.message_id)
  return message_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ChannelMessageUpdate::set_allocated_message_id(std::string* message_id) {
  if (message_id != nullptr) {
    
  } else {
    
  }
  message_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelMessageUpdate.message_id)
}

// string content = 3;
inline void ChannelMessageUpdate::clear_content() {
  content_.ClearToEmpty();
}
inline const std::string& ChannelMessageUpdate::content() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelMessageUpdate.content)
  return _internal_content();
}
inline void ChannelMessageUpdate::set_content(const std::string& value) {
  _internal_set_content(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.ChannelMessageUpdate.content)
}
inline std::string* ChannelMessageUpdate::mutable_content() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelMessageUpdate.content)
  return _internal_mutable_content();
}
inline const std::string& ChannelMessageUpdate::_internal_content() const {
  return content_.Get();
}
inline void ChannelMessageUpdate::_internal_set_content(const std::string& value) {
  
  content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ChannelMessageUpdate::set_content(std::string&& value) {
  
  content_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.ChannelMessageUpdate.content)
}
inline void ChannelMessageUpdate::set_content(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.ChannelMessageUpdate.content)
}
inline void ChannelMessageUpdate::set_content(const char* value,
    size_t size) {
  
  content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.ChannelMessageUpdate.content)
}
inline std::string* ChannelMessageUpdate::_internal_mutable_content() {
  
  return content_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ChannelMessageUpdate::release_content() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelMessageUpdate.content)
  return content_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ChannelMessageUpdate::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  content_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), content,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelMessageUpdate.content)
}

// -------------------------------------------------------------------

// ChannelMessageRemove

// string channel_id = 1;
inline void ChannelMessageRemove::clear_channel_id() {
  channel_id_.ClearToEmpty();
}
inline const std::string& ChannelMessageRemove::channel_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelMessageRemove.channel_id)
  return _internal_channel_id();
}
inline void ChannelMessageRemove::set_channel_id(const std::string& value) {
  _internal_set_channel_id(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.ChannelMessageRemove.channel_id)
}
inline std::string* ChannelMessageRemove::mutable_channel_id() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelMessageRemove.channel_id)
  return _internal_mutable_channel_id();
}
inline const std::string& ChannelMessageRemove::_internal_channel_id() const {
  return channel_id_.Get();
}
inline void ChannelMessageRemove::_internal_set_channel_id(const std::string& value) {
  
  channel_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ChannelMessageRemove::set_channel_id(std::string&& value) {
  
  channel_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.ChannelMessageRemove.channel_id)
}
inline void ChannelMessageRemove::set_channel_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  channel_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.ChannelMessageRemove.channel_id)
}
inline void ChannelMessageRemove::set_channel_id(const char* value,
    size_t size) {
  
  channel_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.ChannelMessageRemove.channel_id)
}
inline std::string* ChannelMessageRemove::_internal_mutable_channel_id() {
  
  return channel_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ChannelMessageRemove::release_channel_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelMessageRemove.channel_id)
  return channel_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ChannelMessageRemove::set_allocated_channel_id(std::string* channel_id) {
  if (channel_id != nullptr) {
    
  } else {
    
  }
  channel_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), channel_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelMessageRemove.channel_id)
}

// string message_id = 2;
inline void ChannelMessageRemove::clear_message_id() {
  message_id_.ClearToEmpty();
}
inline const std::string& ChannelMessageRemove::message_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelMessageRemove.message_id)
  return _internal_message_id();
}
inline void ChannelMessageRemove::set_message_id(const std::string& value) {
  _internal_set_message_id(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.ChannelMessageRemove.message_id)
}
inline std::string* ChannelMessageRemove::mutable_message_id() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelMessageRemove.message_id)
  return _internal_mutable_message_id();
}
inline const std::string& ChannelMessageRemove::_internal_message_id() const {
  return message_id_.Get();
}
inline void ChannelMessageRemove::_internal_set_message_id(const std::string& value) {
  
  message_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ChannelMessageRemove::set_message_id(std::string&& value) {
  
  message_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.ChannelMessageRemove.message_id)
}
inline void ChannelMessageRemove::set_message_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.ChannelMessageRemove.message_id)
}
inline void ChannelMessageRemove::set_message_id(const char* value,
    size_t size) {
  
  message_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.ChannelMessageRemove.message_id)
}
inline std::string* ChannelMessageRemove::_internal_mutable_message_id() {
  
  return message_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ChannelMessageRemove::release_message_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelMessageRemove.message_id)
  return message_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ChannelMessageRemove::set_allocated_message_id(std::string* message_id) {
  if (message_id != nullptr) {
    
  } else {
    
  }
  message_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelMessageRemove.message_id)
}

// -------------------------------------------------------------------

// ChannelPresenceEvent

// string channel_id = 1;
inline void ChannelPresenceEvent::clear_channel_id() {
  channel_id_.ClearToEmpty();
}
inline const std::string& ChannelPresenceEvent::channel_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelPresenceEvent.channel_id)
  return _internal_channel_id();
}
inline void ChannelPresenceEvent::set_channel_id(const std::string& value) {
  _internal_set_channel_id(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.ChannelPresenceEvent.channel_id)
}
inline std::string* ChannelPresenceEvent::mutable_channel_id() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelPresenceEvent.channel_id)
  return _internal_mutable_channel_id();
}
inline const std::string& ChannelPresenceEvent::_internal_channel_id() const {
  return channel_id_.Get();
}
inline void ChannelPresenceEvent::_internal_set_channel_id(const std::string& value) {
  
  channel_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ChannelPresenceEvent::set_channel_id(std::string&& value) {
  
  channel_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.ChannelPresenceEvent.channel_id)
}
inline void ChannelPresenceEvent::set_channel_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  channel_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.ChannelPresenceEvent.channel_id)
}
inline void ChannelPresenceEvent::set_channel_id(const char* value,
    size_t size) {
  
  channel_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.ChannelPresenceEvent.channel_id)
}
inline std::string* ChannelPresenceEvent::_internal_mutable_channel_id() {
  
  return channel_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ChannelPresenceEvent::release_channel_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelPresenceEvent.channel_id)
  return channel_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ChannelPresenceEvent::set_allocated_channel_id(std::string* channel_id) {
  if (channel_id != nullptr) {
    
  } else {
    
  }
  channel_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), channel_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelPresenceEvent.channel_id)
}

// repeated .nakama.realtime.UserPresence joins = 2;
inline int ChannelPresenceEvent::_internal_joins_size() const {
  return joins_.size();
}
inline int ChannelPresenceEvent::joins_size() const {
  return _internal_joins_size();
}
inline void ChannelPresenceEvent::clear_joins() {
  joins_.Clear();
}
inline ::nakama::realtime::UserPresence* ChannelPresenceEvent::mutable_joins(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelPresenceEvent.joins)
  return joins_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >*
ChannelPresenceEvent::mutable_joins() {
  // @@protoc_insertion_point(field_mutable_list:nakama.realtime.ChannelPresenceEvent.joins)
  return &joins_;
}
inline const ::nakama::realtime::UserPresence& ChannelPresenceEvent::_internal_joins(int index) const {
  return joins_.Get(index);
}
inline const ::nakama::realtime::UserPresence& ChannelPresenceEvent::joins(int index) const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelPresenceEvent.joins)
  return _internal_joins(index);
}
inline ::nakama::realtime::UserPresence* ChannelPresenceEvent::_internal_add_joins() {
  return joins_.Add();
}
inline ::nakama::realtime::UserPresence* ChannelPresenceEvent::add_joins() {
  // @@protoc_insertion_point(field_add:nakama.realtime.ChannelPresenceEvent.joins)
  return _internal_add_joins();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >&
ChannelPresenceEvent::joins() const {
  // @@protoc_insertion_point(field_list:nakama.realtime.ChannelPresenceEvent.joins)
  return joins_;
}

// repeated .nakama.realtime.UserPresence leaves = 3;
inline int ChannelPresenceEvent::_internal_leaves_size() const {
  return leaves_.size();
}
inline int ChannelPresenceEvent::leaves_size() const {
  return _internal_leaves_size();
}
inline void ChannelPresenceEvent::clear_leaves() {
  leaves_.Clear();
}
inline ::nakama::realtime::UserPresence* ChannelPresenceEvent::mutable_leaves(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelPresenceEvent.leaves)
  return leaves_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >*
ChannelPresenceEvent::mutable_leaves() {
  // @@protoc_insertion_point(field_mutable_list:nakama.realtime.ChannelPresenceEvent.leaves)
  return &leaves_;
}
inline const ::nakama::realtime::UserPresence& ChannelPresenceEvent::_internal_leaves(int index) const {
  return leaves_.Get(index);
}
inline const ::nakama::realtime::UserPresence& ChannelPresenceEvent::leaves(int index) const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelPresenceEvent.leaves)
  return _internal_leaves(index);
}
inline ::nakama::realtime::UserPresence* ChannelPresenceEvent::_internal_add_leaves() {
  return leaves_.Add();
}
inline ::nakama::realtime::UserPresence* ChannelPresenceEvent::add_leaves() {
  // @@protoc_insertion_point(field_add:nakama.realtime.ChannelPresenceEvent.leaves)
  return _internal_add_leaves();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >&
ChannelPresenceEvent::leaves() const {
  // @@protoc_insertion_point(field_list:nakama.realtime.ChannelPresenceEvent.leaves)
  return leaves_;
}

// string room_name = 4;
inline void ChannelPresenceEvent::clear_room_name() {
  room_name_.ClearToEmpty();
}
inline const std::string& ChannelPresenceEvent::room_name() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelPresenceEvent.room_name)
  return _internal_room_name();
}
inline void ChannelPresenceEvent::set_room_name(const std::string& value) {
  _internal_set_room_name(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.ChannelPresenceEvent.room_name)
}
inline std::string* ChannelPresenceEvent::mutable_room_name() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelPresenceEvent.room_name)
  return _internal_mutable_room_name();
}
inline const std::string& ChannelPresenceEvent::_internal_room_name() const {
  return room_name_.Get();
}
inline void ChannelPresenceEvent::_internal_set_room_name(const std::string& value) {
  
  room_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ChannelPresenceEvent::set_room_name(std::string&& value) {
  
  room_name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.ChannelPresenceEvent.room_name)
}
inline void ChannelPresenceEvent::set_room_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  room_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.ChannelPresenceEvent.room_name)
}
inline void ChannelPresenceEvent::set_room_name(const char* value,
    size_t size) {
  
  room_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.ChannelPresenceEvent.room_name)
}
inline std::string* ChannelPresenceEvent::_internal_mutable_room_name() {
  
  return room_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ChannelPresenceEvent::release_room_name() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelPresenceEvent.room_name)
  return room_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ChannelPresenceEvent::set_allocated_room_name(std::string* room_name) {
  if (room_name != nullptr) {
    
  } else {
    
  }
  room_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), room_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelPresenceEvent.room_name)
}

// string group_id = 5;
inline void ChannelPresenceEvent::clear_group_id() {
  group_id_.ClearToEmpty();
}
inline const std::string& ChannelPresenceEvent::group_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelPresenceEvent.group_id)
  return _internal_group_id();
}
inline void ChannelPresenceEvent::set_group_id(const std::string& value) {
  _internal_set_group_id(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.ChannelPresenceEvent.group_id)
}
inline std::string* ChannelPresenceEvent::mutable_group_id() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelPresenceEvent.group_id)
  return _internal_mutable_group_id();
}
inline const std::string& ChannelPresenceEvent::_internal_group_id() const {
  return group_id_.Get();
}
inline void ChannelPresenceEvent::_internal_set_group_id(const std::string& value) {
  
  group_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ChannelPresenceEvent::set_group_id(std::string&& value) {
  
  group_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.ChannelPresenceEvent.group_id)
}
inline void ChannelPresenceEvent::set_group_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  group_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.ChannelPresenceEvent.group_id)
}
inline void ChannelPresenceEvent::set_group_id(const char* value,
    size_t size) {
  
  group_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.ChannelPresenceEvent.group_id)
}
inline std::string* ChannelPresenceEvent::_internal_mutable_group_id() {
  
  return group_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ChannelPresenceEvent::release_group_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelPresenceEvent.group_id)
  return group_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ChannelPresenceEvent::set_allocated_group_id(std::string* group_id) {
  if (group_id != nullptr) {
    
  } else {
    
  }
  group_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), group_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelPresenceEvent.group_id)
}

// string user_id_one = 6;
inline void ChannelPresenceEvent::clear_user_id_one() {
  user_id_one_.ClearToEmpty();
}
inline const std::string& ChannelPresenceEvent::user_id_one() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelPresenceEvent.user_id_one)
  return _internal_user_id_one();
}
inline void ChannelPresenceEvent::set_user_id_one(const std::string& value) {
  _internal_set_user_id_one(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.ChannelPresenceEvent.user_id_one)
}
inline std::string* ChannelPresenceEvent::mutable_user_id_one() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelPresenceEvent.user_id_one)
  return _internal_mutable_user_id_one();
}
inline const std::string& ChannelPresenceEvent::_internal_user_id_one() const {
  return user_id_one_.Get();
}
inline void ChannelPresenceEvent::_internal_set_user_id_one(const std::string& value) {
  
  user_id_one_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ChannelPresenceEvent::set_user_id_one(std::string&& value) {
  
  user_id_one_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.ChannelPresenceEvent.user_id_one)
}
inline void ChannelPresenceEvent::set_user_id_one(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  user_id_one_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.ChannelPresenceEvent.user_id_one)
}
inline void ChannelPresenceEvent::set_user_id_one(const char* value,
    size_t size) {
  
  user_id_one_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.ChannelPresenceEvent.user_id_one)
}
inline std::string* ChannelPresenceEvent::_internal_mutable_user_id_one() {
  
  return user_id_one_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ChannelPresenceEvent::release_user_id_one() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelPresenceEvent.user_id_one)
  return user_id_one_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ChannelPresenceEvent::set_allocated_user_id_one(std::string* user_id_one) {
  if (user_id_one != nullptr) {
    
  } else {
    
  }
  user_id_one_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id_one,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelPresenceEvent.user_id_one)
}

// string user_id_two = 7;
inline void ChannelPresenceEvent::clear_user_id_two() {
  user_id_two_.ClearToEmpty();
}
inline const std::string& ChannelPresenceEvent::user_id_two() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelPresenceEvent.user_id_two)
  return _internal_user_id_two();
}
inline void ChannelPresenceEvent::set_user_id_two(const std::string& value) {
  _internal_set_user_id_two(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.ChannelPresenceEvent.user_id_two)
}
inline std::string* ChannelPresenceEvent::mutable_user_id_two() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelPresenceEvent.user_id_two)
  return _internal_mutable_user_id_two();
}
inline const std::string& ChannelPresenceEvent::_internal_user_id_two() const {
  return user_id_two_.Get();
}
inline void ChannelPresenceEvent::_internal_set_user_id_two(const std::string& value) {
  
  user_id_two_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ChannelPresenceEvent::set_user_id_two(std::string&& value) {
  
  user_id_two_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.ChannelPresenceEvent.user_id_two)
}
inline void ChannelPresenceEvent::set_user_id_two(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  user_id_two_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.ChannelPresenceEvent.user_id_two)
}
inline void ChannelPresenceEvent::set_user_id_two(const char* value,
    size_t size) {
  
  user_id_two_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.ChannelPresenceEvent.user_id_two)
}
inline std::string* ChannelPresenceEvent::_internal_mutable_user_id_two() {
  
  return user_id_two_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ChannelPresenceEvent::release_user_id_two() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelPresenceEvent.user_id_two)
  return user_id_two_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ChannelPresenceEvent::set_allocated_user_id_two(std::string* user_id_two) {
  if (user_id_two != nullptr) {
    
  } else {
    
  }
  user_id_two_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id_two,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelPresenceEvent.user_id_two)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Error

// int32 code = 1;
inline void Error::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Error::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Error::code() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Error.code)
  return _internal_code();
}
inline void Error::_internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
}
inline void Error::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.Error.code)
}

// string message = 2;
inline void Error::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& Error::message() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Error.message)
  return _internal_message();
}
inline void Error::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.Error.message)
}
inline std::string* Error::mutable_message() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Error.message)
  return _internal_mutable_message();
}
inline const std::string& Error::_internal_message() const {
  return message_.Get();
}
inline void Error::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Error::set_message(std::string&& value) {
  
  message_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.Error.message)
}
inline void Error::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.Error.message)
}
inline void Error::set_message(const char* value,
    size_t size) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.Error.message)
}
inline std::string* Error::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Error::release_message() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Error.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Error::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.Error.message)
}

// map<string, string> context = 3;
inline int Error::_internal_context_size() const {
  return context_.size();
}
inline int Error::context_size() const {
  return _internal_context_size();
}
inline void Error::clear_context() {
  context_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Error::_internal_context() const {
  return context_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Error::context() const {
  // @@protoc_insertion_point(field_map:nakama.realtime.Error.context)
  return _internal_context();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Error::_internal_mutable_context() {
  return context_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Error::mutable_context() {
  // @@protoc_insertion_point(field_mutable_map:nakama.realtime.Error.context)
  return _internal_mutable_context();
}

// -------------------------------------------------------------------

// Match

// string match_id = 1;
inline void Match::clear_match_id() {
  match_id_.ClearToEmpty();
}
inline const std::string& Match::match_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Match.match_id)
  return _internal_match_id();
}
inline void Match::set_match_id(const std::string& value) {
  _internal_set_match_id(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.Match.match_id)
}
inline std::string* Match::mutable_match_id() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Match.match_id)
  return _internal_mutable_match_id();
}
inline const std::string& Match::_internal_match_id() const {
  return match_id_.Get();
}
inline void Match::_internal_set_match_id(const std::string& value) {
  
  match_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Match::set_match_id(std::string&& value) {
  
  match_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.Match.match_id)
}
inline void Match::set_match_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  match_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.Match.match_id)
}
inline void Match::set_match_id(const char* value,
    size_t size) {
  
  match_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.Match.match_id)
}
inline std::string* Match::_internal_mutable_match_id() {
  
  return match_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Match::release_match_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Match.match_id)
  return match_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Match::set_allocated_match_id(std::string* match_id) {
  if (match_id != nullptr) {
    
  } else {
    
  }
  match_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), match_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.Match.match_id)
}

// bool authoritative = 2;
inline void Match::clear_authoritative() {
  authoritative_ = false;
}
inline bool Match::_internal_authoritative() const {
  return authoritative_;
}
inline bool Match::authoritative() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Match.authoritative)
  return _internal_authoritative();
}
inline void Match::_internal_set_authoritative(bool value) {
  
  authoritative_ = value;
}
inline void Match::set_authoritative(bool value) {
  _internal_set_authoritative(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.Match.authoritative)
}

// .google.protobuf.StringValue label = 3;
inline bool Match::_internal_has_label() const {
  return this != internal_default_instance() && label_ != nullptr;
}
inline bool Match::has_label() const {
  return _internal_has_label();
}
inline const PROTOBUF_NAMESPACE_ID::StringValue& Match::_internal_label() const {
  const PROTOBUF_NAMESPACE_ID::StringValue* p = label_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::StringValue&>(
      PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::StringValue& Match::label() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Match.label)
  return _internal_label();
}
inline void Match::unsafe_arena_set_allocated_label(
    PROTOBUF_NAMESPACE_ID::StringValue* label) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(label_);
  }
  label_ = label;
  if (label) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Match.label)
}
inline PROTOBUF_NAMESPACE_ID::StringValue* Match::release_label() {
  
  PROTOBUF_NAMESPACE_ID::StringValue* temp = label_;
  label_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::StringValue* Match::unsafe_arena_release_label() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Match.label)
  
  PROTOBUF_NAMESPACE_ID::StringValue* temp = label_;
  label_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::StringValue* Match::_internal_mutable_label() {
  
  if (label_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::StringValue>(GetArena());
    label_ = p;
  }
  return label_;
}
inline PROTOBUF_NAMESPACE_ID::StringValue* Match::mutable_label() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Match.label)
  return _internal_mutable_label();
}
inline void Match::set_allocated_label(PROTOBUF_NAMESPACE_ID::StringValue* label) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(label_);
  }
  if (label) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(label)->GetArena();
    if (message_arena != submessage_arena) {
      label = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, label, submessage_arena);
    }
    
  } else {
    
  }
  label_ = label;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.Match.label)
}

// int32 size = 4;
inline void Match::clear_size() {
  size_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Match::_internal_size() const {
  return size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Match::size() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Match.size)
  return _internal_size();
}
inline void Match::_internal_set_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  size_ = value;
}
inline void Match::set_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.Match.size)
}

// repeated .nakama.realtime.UserPresence presences = 5;
inline int Match::_internal_presences_size() const {
  return presences_.size();
}
inline int Match::presences_size() const {
  return _internal_presences_size();
}
inline void Match::clear_presences() {
  presences_.Clear();
}
inline ::nakama::realtime::UserPresence* Match::mutable_presences(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Match.presences)
  return presences_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >*
Match::mutable_presences() {
  // @@protoc_insertion_point(field_mutable_list:nakama.realtime.Match.presences)
  return &presences_;
}
inline const ::nakama::realtime::UserPresence& Match::_internal_presences(int index) const {
  return presences_.Get(index);
}
inline const ::nakama::realtime::UserPresence& Match::presences(int index) const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Match.presences)
  return _internal_presences(index);
}
inline ::nakama::realtime::UserPresence* Match::_internal_add_presences() {
  return presences_.Add();
}
inline ::nakama::realtime::UserPresence* Match::add_presences() {
  // @@protoc_insertion_point(field_add:nakama.realtime.Match.presences)
  return _internal_add_presences();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >&
Match::presences() const {
  // @@protoc_insertion_point(field_list:nakama.realtime.Match.presences)
  return presences_;
}

// .nakama.realtime.UserPresence self = 6;
inline bool Match::_internal_has_self() const {
  return this != internal_default_instance() && self_ != nullptr;
}
inline bool Match::has_self() const {
  return _internal_has_self();
}
inline void Match::clear_self() {
  if (GetArena() == nullptr && self_ != nullptr) {
    delete self_;
  }
  self_ = nullptr;
}
inline const ::nakama::realtime::UserPresence& Match::_internal_self() const {
  const ::nakama::realtime::UserPresence* p = self_;
  return p != nullptr ? *p : reinterpret_cast<const ::nakama::realtime::UserPresence&>(
      ::nakama::realtime::_UserPresence_default_instance_);
}
inline const ::nakama::realtime::UserPresence& Match::self() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Match.self)
  return _internal_self();
}
inline void Match::unsafe_arena_set_allocated_self(
    ::nakama::realtime::UserPresence* self) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(self_);
  }
  self_ = self;
  if (self) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Match.self)
}
inline ::nakama::realtime::UserPresence* Match::release_self() {
  
  ::nakama::realtime::UserPresence* temp = self_;
  self_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::nakama::realtime::UserPresence* Match::unsafe_arena_release_self() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Match.self)
  
  ::nakama::realtime::UserPresence* temp = self_;
  self_ = nullptr;
  return temp;
}
inline ::nakama::realtime::UserPresence* Match::_internal_mutable_self() {
  
  if (self_ == nullptr) {
    auto* p = CreateMaybeMessage<::nakama::realtime::UserPresence>(GetArena());
    self_ = p;
  }
  return self_;
}
inline ::nakama::realtime::UserPresence* Match::mutable_self() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Match.self)
  return _internal_mutable_self();
}
inline void Match::set_allocated_self(::nakama::realtime::UserPresence* self) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete self_;
  }
  if (self) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(self);
    if (message_arena != submessage_arena) {
      self = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, self, submessage_arena);
    }
    
  } else {
    
  }
  self_ = self;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.Match.self)
}

// -------------------------------------------------------------------

// MatchCreate

// string name = 1;
inline void MatchCreate::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& MatchCreate::name() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchCreate.name)
  return _internal_name();
}
inline void MatchCreate::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchCreate.name)
}
inline std::string* MatchCreate::mutable_name() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchCreate.name)
  return _internal_mutable_name();
}
inline const std::string& MatchCreate::_internal_name() const {
  return name_.Get();
}
inline void MatchCreate::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void MatchCreate::set_name(std::string&& value) {
  
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.MatchCreate.name)
}
inline void MatchCreate::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.MatchCreate.name)
}
inline void MatchCreate::set_name(const char* value,
    size_t size) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.MatchCreate.name)
}
inline std::string* MatchCreate::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* MatchCreate::release_name() {
  // @@protoc_insertion_point(field_release:nakama.realtime.MatchCreate.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MatchCreate::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.MatchCreate.name)
}

// -------------------------------------------------------------------

// MatchData

// string match_id = 1;
inline void MatchData::clear_match_id() {
  match_id_.ClearToEmpty();
}
inline const std::string& MatchData::match_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchData.match_id)
  return _internal_match_id();
}
inline void MatchData::set_match_id(const std::string& value) {
  _internal_set_match_id(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchData.match_id)
}
inline std::string* MatchData::mutable_match_id() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchData.match_id)
  return _internal_mutable_match_id();
}
inline const std::string& MatchData::_internal_match_id() const {
  return match_id_.Get();
}
inline void MatchData::_internal_set_match_id(const std::string& value) {
  
  match_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void MatchData::set_match_id(std::string&& value) {
  
  match_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.MatchData.match_id)
}
inline void MatchData::set_match_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  match_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.MatchData.match_id)
}
inline void MatchData::set_match_id(const char* value,
    size_t size) {
  
  match_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.MatchData.match_id)
}
inline std::string* MatchData::_internal_mutable_match_id() {
  
  return match_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* MatchData::release_match_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.MatchData.match_id)
  return match_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MatchData::set_allocated_match_id(std::string* match_id) {
  if (match_id != nullptr) {
    
  } else {
    
  }
  match_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), match_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.MatchData.match_id)
}

// .nakama.realtime.UserPresence presence = 2;
inline bool MatchData::_internal_has_presence() const {
  return this != internal_default_instance() && presence_ != nullptr;
}
inline bool MatchData::has_presence() const {
  return _internal_has_presence();
}
inline void MatchData::clear_presence() {
  if (GetArena() == nullptr && presence_ != nullptr) {
    delete presence_;
  }
  presence_ = nullptr;
}
inline const ::nakama::realtime::UserPresence& MatchData::_internal_presence() const {
  const ::nakama::realtime::UserPresence* p = presence_;
  return p != nullptr ? *p : reinterpret_cast<const ::nakama::realtime::UserPresence&>(
      ::nakama::realtime::_UserPresence_default_instance_);
}
inline const ::nakama::realtime::UserPresence& MatchData::presence() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchData.presence)
  return _internal_presence();
}
inline void MatchData::unsafe_arena_set_allocated_presence(
    ::nakama::realtime::UserPresence* presence) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(presence_);
  }
  presence_ = presence;
  if (presence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.MatchData.presence)
}
inline ::nakama::realtime::UserPresence* MatchData::release_presence() {
  
  ::nakama::realtime::UserPresence* temp = presence_;
  presence_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::nakama::realtime::UserPresence* MatchData::unsafe_arena_release_presence() {
  // @@protoc_insertion_point(field_release:nakama.realtime.MatchData.presence)
  
  ::nakama::realtime::UserPresence* temp = presence_;
  presence_ = nullptr;
  return temp;
}
inline ::nakama::realtime::UserPresence* MatchData::_internal_mutable_presence() {
  
  if (presence_ == nullptr) {
    auto* p = CreateMaybeMessage<::nakama::realtime::UserPresence>(GetArena());
    presence_ = p;
  }
  return presence_;
}
inline ::nakama::realtime::UserPresence* MatchData::mutable_presence() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchData.presence)
  return _internal_mutable_presence();
}
inline void MatchData::set_allocated_presence(::nakama::realtime::UserPresence* presence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete presence_;
  }
  if (presence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(presence);
    if (message_arena != submessage_arena) {
      presence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, presence, submessage_arena);
    }
    
  } else {
    
  }
  presence_ = presence;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.MatchData.presence)
}

// int64 op_code = 3;
inline void MatchData::clear_op_code() {
  op_code_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MatchData::_internal_op_code() const {
  return op_code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MatchData::op_code() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchData.op_code)
  return _internal_op_code();
}
inline void MatchData::_internal_set_op_code(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  op_code_ = value;
}
inline void MatchData::set_op_code(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_op_code(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchData.op_code)
}

// bytes data = 4;
inline void MatchData::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& MatchData::data() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchData.data)
  return _internal_data();
}
inline void MatchData::set_data(const std::string& value) {
  _internal_set_data(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchData.data)
}
inline std::string* MatchData::mutable_data() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchData.data)
  return _internal_mutable_data();
}
inline const std::string& MatchData::_internal_data() const {
  return data_.Get();
}
inline void MatchData::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void MatchData::set_data(std::string&& value) {
  
  data_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.MatchData.data)
}
inline void MatchData::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.MatchData.data)
}
inline void MatchData::set_data(const void* value,
    size_t size) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.MatchData.data)
}
inline std::string* MatchData::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* MatchData::release_data() {
  // @@protoc_insertion_point(field_release:nakama.realtime.MatchData.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MatchData::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.MatchData.data)
}

// bool reliable = 5;
inline void MatchData::clear_reliable() {
  reliable_ = false;
}
inline bool MatchData::_internal_reliable() const {
  return reliable_;
}
inline bool MatchData::reliable() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchData.reliable)
  return _internal_reliable();
}
inline void MatchData::_internal_set_reliable(bool value) {
  
  reliable_ = value;
}
inline void MatchData::set_reliable(bool value) {
  _internal_set_reliable(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchData.reliable)
}

// -------------------------------------------------------------------

// MatchDataSend

// string match_id = 1;
inline void MatchDataSend::clear_match_id() {
  match_id_.ClearToEmpty();
}
inline const std::string& MatchDataSend::match_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchDataSend.match_id)
  return _internal_match_id();
}
inline void MatchDataSend::set_match_id(const std::string& value) {
  _internal_set_match_id(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchDataSend.match_id)
}
inline std::string* MatchDataSend::mutable_match_id() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchDataSend.match_id)
  return _internal_mutable_match_id();
}
inline const std::string& MatchDataSend::_internal_match_id() const {
  return match_id_.Get();
}
inline void MatchDataSend::_internal_set_match_id(const std::string& value) {
  
  match_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void MatchDataSend::set_match_id(std::string&& value) {
  
  match_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.MatchDataSend.match_id)
}
inline void MatchDataSend::set_match_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  match_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.MatchDataSend.match_id)
}
inline void MatchDataSend::set_match_id(const char* value,
    size_t size) {
  
  match_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.MatchDataSend.match_id)
}
inline std::string* MatchDataSend::_internal_mutable_match_id() {
  
  return match_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* MatchDataSend::release_match_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.MatchDataSend.match_id)
  return match_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MatchDataSend::set_allocated_match_id(std::string* match_id) {
  if (match_id != nullptr) {
    
  } else {
    
  }
  match_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), match_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.MatchDataSend.match_id)
}

// int64 op_code = 2;
inline void MatchDataSend::clear_op_code() {
  op_code_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MatchDataSend::_internal_op_code() const {
  return op_code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MatchDataSend::op_code() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchDataSend.op_code)
  return _internal_op_code();
}
inline void MatchDataSend::_internal_set_op_code(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  op_code_ = value;
}
inline void MatchDataSend::set_op_code(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_op_code(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchDataSend.op_code)
}

// bytes data = 3;
inline void MatchDataSend::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& MatchDataSend::data() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchDataSend.data)
  return _internal_data();
}
inline void MatchDataSend::set_data(const std::string& value) {
  _internal_set_data(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchDataSend.data)
}
inline std::string* MatchDataSend::mutable_data() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchDataSend.data)
  return _internal_mutable_data();
}
inline const std::string& MatchDataSend::_internal_data() const {
  return data_.Get();
}
inline void MatchDataSend::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void MatchDataSend::set_data(std::string&& value) {
  
  data_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.MatchDataSend.data)
}
inline void MatchDataSend::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.MatchDataSend.data)
}
inline void MatchDataSend::set_data(const void* value,
    size_t size) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.MatchDataSend.data)
}
inline std::string* MatchDataSend::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* MatchDataSend::release_data() {
  // @@protoc_insertion_point(field_release:nakama.realtime.MatchDataSend.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MatchDataSend::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.MatchDataSend.data)
}

// repeated .nakama.realtime.UserPresence presences = 4;
inline int MatchDataSend::_internal_presences_size() const {
  return presences_.size();
}
inline int MatchDataSend::presences_size() const {
  return _internal_presences_size();
}
inline void MatchDataSend::clear_presences() {
  presences_.Clear();
}
inline ::nakama::realtime::UserPresence* MatchDataSend::mutable_presences(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchDataSend.presences)
  return presences_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >*
MatchDataSend::mutable_presences() {
  // @@protoc_insertion_point(field_mutable_list:nakama.realtime.MatchDataSend.presences)
  return &presences_;
}
inline const ::nakama::realtime::UserPresence& MatchDataSend::_internal_presences(int index) const {
  return presences_.Get(index);
}
inline const ::nakama::realtime::UserPresence& MatchDataSend::presences(int index) const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchDataSend.presences)
  return _internal_presences(index);
}
inline ::nakama::realtime::UserPresence* MatchDataSend::_internal_add_presences() {
  return presences_.Add();
}
inline ::nakama::realtime::UserPresence* MatchDataSend::add_presences() {
  // @@protoc_insertion_point(field_add:nakama.realtime.MatchDataSend.presences)
  return _internal_add_presences();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >&
MatchDataSend::presences() const {
  // @@protoc_insertion_point(field_list:nakama.realtime.MatchDataSend.presences)
  return presences_;
}

// bool reliable = 5;
inline void MatchDataSend::clear_reliable() {
  reliable_ = false;
}
inline bool MatchDataSend::_internal_reliable() const {
  return reliable_;
}
inline bool MatchDataSend::reliable() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchDataSend.reliable)
  return _internal_reliable();
}
inline void MatchDataSend::_internal_set_reliable(bool value) {
  
  reliable_ = value;
}
inline void MatchDataSend::set_reliable(bool value) {
  _internal_set_reliable(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchDataSend.reliable)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MatchJoin

// string match_id = 1;
inline bool MatchJoin::_internal_has_match_id() const {
  return id_case() == kMatchId;
}
inline void MatchJoin::set_has_match_id() {
  _oneof_case_[0] = kMatchId;
}
inline void MatchJoin::clear_match_id() {
  if (_internal_has_match_id()) {
    id_.match_id_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
    clear_has_id();
  }
}
inline const std::string& MatchJoin::match_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchJoin.match_id)
  return _internal_match_id();
}
inline void MatchJoin::set_match_id(const std::string& value) {
  _internal_set_match_id(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchJoin.match_id)
}
inline std::string* MatchJoin::mutable_match_id() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchJoin.match_id)
  return _internal_mutable_match_id();
}
inline const std::string& MatchJoin::_internal_match_id() const {
  if (_internal_has_match_id()) {
    return id_.match_id_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void MatchJoin::_internal_set_match_id(const std::string& value) {
  if (!_internal_has_match_id()) {
    clear_id();
    set_has_match_id();
    id_.match_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  id_.match_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void MatchJoin::set_match_id(std::string&& value) {
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchJoin.match_id)
  if (!_internal_has_match_id()) {
    clear_id();
    set_has_match_id();
    id_.match_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  id_.match_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.MatchJoin.match_id)
}
inline void MatchJoin::set_match_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_match_id()) {
    clear_id();
    set_has_match_id();
    id_.match_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  id_.match_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.MatchJoin.match_id)
}
inline void MatchJoin::set_match_id(const char* value,
                             size_t size) {
  if (!_internal_has_match_id()) {
    clear_id();
    set_has_match_id();
    id_.match_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  id_.match_id_.Set(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.MatchJoin.match_id)
}
inline std::string* MatchJoin::_internal_mutable_match_id() {
  if (!_internal_has_match_id()) {
    clear_id();
    set_has_match_id();
    id_.match_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return id_.match_id_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* MatchJoin::release_match_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.MatchJoin.match_id)
  if (_internal_has_match_id()) {
    clear_has_id();
    return id_.match_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void MatchJoin::set_allocated_match_id(std::string* match_id) {
  if (has_id()) {
    clear_id();
  }
  if (match_id != nullptr) {
    set_has_match_id();
    id_.match_id_.UnsafeSetDefault(match_id);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena();
    if (arena != nullptr) {
      arena->Own(match_id);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.MatchJoin.match_id)
}

// string token = 2;
inline bool MatchJoin::_internal_has_token() const {
  return id_case() == kToken;
}
inline void MatchJoin::set_has_token() {
  _oneof_case_[0] = kToken;
}
inline void MatchJoin::clear_token() {
  if (_internal_has_token()) {
    id_.token_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
    clear_has_id();
  }
}
inline const std::string& MatchJoin::token() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchJoin.token)
  return _internal_token();
}
inline void MatchJoin::set_token(const std::string& value) {
  _internal_set_token(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchJoin.token)
}
inline std::string* MatchJoin::mutable_token() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchJoin.token)
  return _internal_mutable_token();
}
inline const std::string& MatchJoin::_internal_token() const {
  if (_internal_has_token()) {
    return id_.token_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void MatchJoin::_internal_set_token(const std::string& value) {
  if (!_internal_has_token()) {
    clear_id();
    set_has_token();
    id_.token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  id_.token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void MatchJoin::set_token(std::string&& value) {
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchJoin.token)
  if (!_internal_has_token()) {
    clear_id();
    set_has_token();
    id_.token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  id_.token_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.MatchJoin.token)
}
inline void MatchJoin::set_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_token()) {
    clear_id();
    set_has_token();
    id_.token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  id_.token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.MatchJoin.token)
}
inline void MatchJoin::set_token(const char* value,
                             size_t size) {
  if (!_internal_has_token()) {
    clear_id();
    set_has_token();
    id_.token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  id_.token_.Set(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.MatchJoin.token)
}
inline std::string* MatchJoin::_internal_mutable_token() {
  if (!_internal_has_token()) {
    clear_id();
    set_has_token();
    id_.token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return id_.token_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* MatchJoin::release_token() {
  // @@protoc_insertion_point(field_release:nakama.realtime.MatchJoin.token)
  if (_internal_has_token()) {
    clear_has_id();
    return id_.token_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void MatchJoin::set_allocated_token(std::string* token) {
  if (has_id()) {
    clear_id();
  }
  if (token != nullptr) {
    set_has_token();
    id_.token_.UnsafeSetDefault(token);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena();
    if (arena != nullptr) {
      arena->Own(token);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.MatchJoin.token)
}

// map<string, string> metadata = 3;
inline int MatchJoin::_internal_metadata_size() const {
  return metadata_.size();
}
inline int MatchJoin::metadata_size() const {
  return _internal_metadata_size();
}
inline void MatchJoin::clear_metadata() {
  metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
MatchJoin::_internal_metadata() const {
  return metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
MatchJoin::metadata() const {
  // @@protoc_insertion_point(field_map:nakama.realtime.MatchJoin.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
MatchJoin::_internal_mutable_metadata() {
  return metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
MatchJoin::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:nakama.realtime.MatchJoin.metadata)
  return _internal_mutable_metadata();
}

inline bool MatchJoin::has_id() const {
  return id_case() != ID_NOT_SET;
}
inline void MatchJoin::clear_has_id() {
  _oneof_case_[0] = ID_NOT_SET;
}
inline MatchJoin::IdCase MatchJoin::id_case() const {
  return MatchJoin::IdCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MatchLeave

// string match_id = 1;
inline void MatchLeave::clear_match_id() {
  match_id_.ClearToEmpty();
}
inline const std::string& MatchLeave::match_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchLeave.match_id)
  return _internal_match_id();
}
inline void MatchLeave::set_match_id(const std::string& value) {
  _internal_set_match_id(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchLeave.match_id)
}
inline std::string* MatchLeave::mutable_match_id() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchLeave.match_id)
  return _internal_mutable_match_id();
}
inline const std::string& MatchLeave::_internal_match_id() const {
  return match_id_.Get();
}
inline void MatchLeave::_internal_set_match_id(const std::string& value) {
  
  match_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void MatchLeave::set_match_id(std::string&& value) {
  
  match_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.MatchLeave.match_id)
}
inline void MatchLeave::set_match_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  match_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.MatchLeave.match_id)
}
inline void MatchLeave::set_match_id(const char* value,
    size_t size) {
  
  match_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.MatchLeave.match_id)
}
inline std::string* MatchLeave::_internal_mutable_match_id() {
  
  return match_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* MatchLeave::release_match_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.MatchLeave.match_id)
  return match_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MatchLeave::set_allocated_match_id(std::string* match_id) {
  if (match_id != nullptr) {
    
  } else {
    
  }
  match_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), match_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.MatchLeave.match_id)
}

// -------------------------------------------------------------------

// MatchPresenceEvent

// string match_id = 1;
inline void MatchPresenceEvent::clear_match_id() {
  match_id_.ClearToEmpty();
}
inline const std::string& MatchPresenceEvent::match_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchPresenceEvent.match_id)
  return _internal_match_id();
}
inline void MatchPresenceEvent::set_match_id(const std::string& value) {
  _internal_set_match_id(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchPresenceEvent.match_id)
}
inline std::string* MatchPresenceEvent::mutable_match_id() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchPresenceEvent.match_id)
  return _internal_mutable_match_id();
}
inline const std::string& MatchPresenceEvent::_internal_match_id() const {
  return match_id_.Get();
}
inline void MatchPresenceEvent::_internal_set_match_id(const std::string& value) {
  
  match_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void MatchPresenceEvent::set_match_id(std::string&& value) {
  
  match_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.MatchPresenceEvent.match_id)
}
inline void MatchPresenceEvent::set_match_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  match_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.MatchPresenceEvent.match_id)
}
inline void MatchPresenceEvent::set_match_id(const char* value,
    size_t size) {
  
  match_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.MatchPresenceEvent.match_id)
}
inline std::string* MatchPresenceEvent::_internal_mutable_match_id() {
  
  return match_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* MatchPresenceEvent::release_match_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.MatchPresenceEvent.match_id)
  return match_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MatchPresenceEvent::set_allocated_match_id(std::string* match_id) {
  if (match_id != nullptr) {
    
  } else {
    
  }
  match_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), match_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.MatchPresenceEvent.match_id)
}

// repeated .nakama.realtime.UserPresence joins = 2;
inline int MatchPresenceEvent::_internal_joins_size() const {
  return joins_.size();
}
inline int MatchPresenceEvent::joins_size() const {
  return _internal_joins_size();
}
inline void MatchPresenceEvent::clear_joins() {
  joins_.Clear();
}
inline ::nakama::realtime::UserPresence* MatchPresenceEvent::mutable_joins(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchPresenceEvent.joins)
  return joins_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >*
MatchPresenceEvent::mutable_joins() {
  // @@protoc_insertion_point(field_mutable_list:nakama.realtime.MatchPresenceEvent.joins)
  return &joins_;
}
inline const ::nakama::realtime::UserPresence& MatchPresenceEvent::_internal_joins(int index) const {
  return joins_.Get(index);
}
inline const ::nakama::realtime::UserPresence& MatchPresenceEvent::joins(int index) const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchPresenceEvent.joins)
  return _internal_joins(index);
}
inline ::nakama::realtime::UserPresence* MatchPresenceEvent::_internal_add_joins() {
  return joins_.Add();
}
inline ::nakama::realtime::UserPresence* MatchPresenceEvent::add_joins() {
  // @@protoc_insertion_point(field_add:nakama.realtime.MatchPresenceEvent.joins)
  return _internal_add_joins();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >&
MatchPresenceEvent::joins() const {
  // @@protoc_insertion_point(field_list:nakama.realtime.MatchPresenceEvent.joins)
  return joins_;
}

// repeated .nakama.realtime.UserPresence leaves = 3;
inline int MatchPresenceEvent::_internal_leaves_size() const {
  return leaves_.size();
}
inline int MatchPresenceEvent::leaves_size() const {
  return _internal_leaves_size();
}
inline void MatchPresenceEvent::clear_leaves() {
  leaves_.Clear();
}
inline ::nakama::realtime::UserPresence* MatchPresenceEvent::mutable_leaves(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchPresenceEvent.leaves)
  return leaves_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >*
MatchPresenceEvent::mutable_leaves() {
  // @@protoc_insertion_point(field_mutable_list:nakama.realtime.MatchPresenceEvent.leaves)
  return &leaves_;
}
inline const ::nakama::realtime::UserPresence& MatchPresenceEvent::_internal_leaves(int index) const {
  return leaves_.Get(index);
}
inline const ::nakama::realtime::UserPresence& MatchPresenceEvent::leaves(int index) const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchPresenceEvent.leaves)
  return _internal_leaves(index);
}
inline ::nakama::realtime::UserPresence* MatchPresenceEvent::_internal_add_leaves() {
  return leaves_.Add();
}
inline ::nakama::realtime::UserPresence* MatchPresenceEvent::add_leaves() {
  // @@protoc_insertion_point(field_add:nakama.realtime.MatchPresenceEvent.leaves)
  return _internal_add_leaves();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >&
MatchPresenceEvent::leaves() const {
  // @@protoc_insertion_point(field_list:nakama.realtime.MatchPresenceEvent.leaves)
  return leaves_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MatchmakerAdd

// int32 min_count = 1;
inline void MatchmakerAdd::clear_min_count() {
  min_count_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MatchmakerAdd::_internal_min_count() const {
  return min_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MatchmakerAdd::min_count() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchmakerAdd.min_count)
  return _internal_min_count();
}
inline void MatchmakerAdd::_internal_set_min_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  min_count_ = value;
}
inline void MatchmakerAdd::set_min_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_min_count(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchmakerAdd.min_count)
}

// int32 max_count = 2;
inline void MatchmakerAdd::clear_max_count() {
  max_count_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MatchmakerAdd::_internal_max_count() const {
  return max_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MatchmakerAdd::max_count() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchmakerAdd.max_count)
  return _internal_max_count();
}
inline void MatchmakerAdd::_internal_set_max_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  max_count_ = value;
}
inline void MatchmakerAdd::set_max_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_max_count(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchmakerAdd.max_count)
}

// string query = 3;
inline void MatchmakerAdd::clear_query() {
  query_.ClearToEmpty();
}
inline const std::string& MatchmakerAdd::query() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchmakerAdd.query)
  return _internal_query();
}
inline void MatchmakerAdd::set_query(const std::string& value) {
  _internal_set_query(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchmakerAdd.query)
}
inline std::string* MatchmakerAdd::mutable_query() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchmakerAdd.query)
  return _internal_mutable_query();
}
inline const std::string& MatchmakerAdd::_internal_query() const {
  return query_.Get();
}
inline void MatchmakerAdd::_internal_set_query(const std::string& value) {
  
  query_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void MatchmakerAdd::set_query(std::string&& value) {
  
  query_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.MatchmakerAdd.query)
}
inline void MatchmakerAdd::set_query(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  query_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.MatchmakerAdd.query)
}
inline void MatchmakerAdd::set_query(const char* value,
    size_t size) {
  
  query_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.MatchmakerAdd.query)
}
inline std::string* MatchmakerAdd::_internal_mutable_query() {
  
  return query_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* MatchmakerAdd::release_query() {
  // @@protoc_insertion_point(field_release:nakama.realtime.MatchmakerAdd.query)
  return query_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MatchmakerAdd::set_allocated_query(std::string* query) {
  if (query != nullptr) {
    
  } else {
    
  }
  query_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), query,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.MatchmakerAdd.query)
}

// map<string, string> string_properties = 4;
inline int MatchmakerAdd::_internal_string_properties_size() const {
  return string_properties_.size();
}
inline int MatchmakerAdd::string_properties_size() const {
  return _internal_string_properties_size();
}
inline void MatchmakerAdd::clear_string_properties() {
  string_properties_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
MatchmakerAdd::_internal_string_properties() const {
  return string_properties_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
MatchmakerAdd::string_properties() const {
  // @@protoc_insertion_point(field_map:nakama.realtime.MatchmakerAdd.string_properties)
  return _internal_string_properties();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
MatchmakerAdd::_internal_mutable_string_properties() {
  return string_properties_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
MatchmakerAdd::mutable_string_properties() {
  // @@protoc_insertion_point(field_mutable_map:nakama.realtime.MatchmakerAdd.string_properties)
  return _internal_mutable_string_properties();
}

// map<string, double> numeric_properties = 5;
inline int MatchmakerAdd::_internal_numeric_properties_size() const {
  return numeric_properties_.size();
}
inline int MatchmakerAdd::numeric_properties_size() const {
  return _internal_numeric_properties_size();
}
inline void MatchmakerAdd::clear_numeric_properties() {
  numeric_properties_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
MatchmakerAdd::_internal_numeric_properties() const {
  return numeric_properties_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
MatchmakerAdd::numeric_properties() const {
  // @@protoc_insertion_point(field_map:nakama.realtime.MatchmakerAdd.numeric_properties)
  return _internal_numeric_properties();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
MatchmakerAdd::_internal_mutable_numeric_properties() {
  return numeric_properties_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
MatchmakerAdd::mutable_numeric_properties() {
  // @@protoc_insertion_point(field_mutable_map:nakama.realtime.MatchmakerAdd.numeric_properties)
  return _internal_mutable_numeric_properties();
}

// .google.protobuf.Int32Value count_multiple = 6;
inline bool MatchmakerAdd::_internal_has_count_multiple() const {
  return this != internal_default_instance() && count_multiple_ != nullptr;
}
inline bool MatchmakerAdd::has_count_multiple() const {
  return _internal_has_count_multiple();
}
inline const PROTOBUF_NAMESPACE_ID::Int32Value& MatchmakerAdd::_internal_count_multiple() const {
  const PROTOBUF_NAMESPACE_ID::Int32Value* p = count_multiple_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Int32Value&>(
      PROTOBUF_NAMESPACE_ID::_Int32Value_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Int32Value& MatchmakerAdd::count_multiple() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchmakerAdd.count_multiple)
  return _internal_count_multiple();
}
inline void MatchmakerAdd::unsafe_arena_set_allocated_count_multiple(
    PROTOBUF_NAMESPACE_ID::Int32Value* count_multiple) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(count_multiple_);
  }
  count_multiple_ = count_multiple;
  if (count_multiple) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.MatchmakerAdd.count_multiple)
}
inline PROTOBUF_NAMESPACE_ID::Int32Value* MatchmakerAdd::release_count_multiple() {
  
  PROTOBUF_NAMESPACE_ID::Int32Value* temp = count_multiple_;
  count_multiple_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Int32Value* MatchmakerAdd::unsafe_arena_release_count_multiple() {
  // @@protoc_insertion_point(field_release:nakama.realtime.MatchmakerAdd.count_multiple)
  
  PROTOBUF_NAMESPACE_ID::Int32Value* temp = count_multiple_;
  count_multiple_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Int32Value* MatchmakerAdd::_internal_mutable_count_multiple() {
  
  if (count_multiple_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Int32Value>(GetArena());
    count_multiple_ = p;
  }
  return count_multiple_;
}
inline PROTOBUF_NAMESPACE_ID::Int32Value* MatchmakerAdd::mutable_count_multiple() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchmakerAdd.count_multiple)
  return _internal_mutable_count_multiple();
}
inline void MatchmakerAdd::set_allocated_count_multiple(PROTOBUF_NAMESPACE_ID::Int32Value* count_multiple) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(count_multiple_);
  }
  if (count_multiple) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(count_multiple)->GetArena();
    if (message_arena != submessage_arena) {
      count_multiple = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, count_multiple, submessage_arena);
    }
    
  } else {
    
  }
  count_multiple_ = count_multiple;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.MatchmakerAdd.count_multiple)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MatchmakerMatched_MatchmakerUser

// .nakama.realtime.UserPresence presence = 1;
inline bool MatchmakerMatched_MatchmakerUser::_internal_has_presence() const {
  return this != internal_default_instance() && presence_ != nullptr;
}
inline bool MatchmakerMatched_MatchmakerUser::has_presence() const {
  return _internal_has_presence();
}
inline void MatchmakerMatched_MatchmakerUser::clear_presence() {
  if (GetArena() == nullptr && presence_ != nullptr) {
    delete presence_;
  }
  presence_ = nullptr;
}
inline const ::nakama::realtime::UserPresence& MatchmakerMatched_MatchmakerUser::_internal_presence() const {
  const ::nakama::realtime::UserPresence* p = presence_;
  return p != nullptr ? *p : reinterpret_cast<const ::nakama::realtime::UserPresence&>(
      ::nakama::realtime::_UserPresence_default_instance_);
}
inline const ::nakama::realtime::UserPresence& MatchmakerMatched_MatchmakerUser::presence() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchmakerMatched.MatchmakerUser.presence)
  return _internal_presence();
}
inline void MatchmakerMatched_MatchmakerUser::unsafe_arena_set_allocated_presence(
    ::nakama::realtime::UserPresence* presence) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(presence_);
  }
  presence_ = presence;
  if (presence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.MatchmakerMatched.MatchmakerUser.presence)
}
inline ::nakama::realtime::UserPresence* MatchmakerMatched_MatchmakerUser::release_presence() {
  
  ::nakama::realtime::UserPresence* temp = presence_;
  presence_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::nakama::realtime::UserPresence* MatchmakerMatched_MatchmakerUser::unsafe_arena_release_presence() {
  // @@protoc_insertion_point(field_release:nakama.realtime.MatchmakerMatched.MatchmakerUser.presence)
  
  ::nakama::realtime::UserPresence* temp = presence_;
  presence_ = nullptr;
  return temp;
}
inline ::nakama::realtime::UserPresence* MatchmakerMatched_MatchmakerUser::_internal_mutable_presence() {
  
  if (presence_ == nullptr) {
    auto* p = CreateMaybeMessage<::nakama::realtime::UserPresence>(GetArena());
    presence_ = p;
  }
  return presence_;
}
inline ::nakama::realtime::UserPresence* MatchmakerMatched_MatchmakerUser::mutable_presence() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchmakerMatched.MatchmakerUser.presence)
  return _internal_mutable_presence();
}
inline void MatchmakerMatched_MatchmakerUser::set_allocated_presence(::nakama::realtime::UserPresence* presence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete presence_;
  }
  if (presence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(presence);
    if (message_arena != submessage_arena) {
      presence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, presence, submessage_arena);
    }
    
  } else {
    
  }
  presence_ = presence;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.MatchmakerMatched.MatchmakerUser.presence)
}

// string party_id = 2;
inline void MatchmakerMatched_MatchmakerUser::clear_party_id() {
  party_id_.ClearToEmpty();
}
inline const std::string& MatchmakerMatched_MatchmakerUser::party_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchmakerMatched.MatchmakerUser.party_id)
  return _internal_party_id();
}
inline void MatchmakerMatched_MatchmakerUser::set_party_id(const std::string& value) {
  _internal_set_party_id(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchmakerMatched.MatchmakerUser.party_id)
}
inline std::string* MatchmakerMatched_MatchmakerUser::mutable_party_id() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchmakerMatched.MatchmakerUser.party_id)
  return _internal_mutable_party_id();
}
inline const std::string& MatchmakerMatched_MatchmakerUser::_internal_party_id() const {
  return party_id_.Get();
}
inline void MatchmakerMatched_MatchmakerUser::_internal_set_party_id(const std::string& value) {
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void MatchmakerMatched_MatchmakerUser::set_party_id(std::string&& value) {
  
  party_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.MatchmakerMatched.MatchmakerUser.party_id)
}
inline void MatchmakerMatched_MatchmakerUser::set_party_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.MatchmakerMatched.MatchmakerUser.party_id)
}
inline void MatchmakerMatched_MatchmakerUser::set_party_id(const char* value,
    size_t size) {
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.MatchmakerMatched.MatchmakerUser.party_id)
}
inline std::string* MatchmakerMatched_MatchmakerUser::_internal_mutable_party_id() {
  
  return party_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* MatchmakerMatched_MatchmakerUser::release_party_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.MatchmakerMatched.MatchmakerUser.party_id)
  return party_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MatchmakerMatched_MatchmakerUser::set_allocated_party_id(std::string* party_id) {
  if (party_id != nullptr) {
    
  } else {
    
  }
  party_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), party_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.MatchmakerMatched.MatchmakerUser.party_id)
}

// map<string, string> string_properties = 5;
inline int MatchmakerMatched_MatchmakerUser::_internal_string_properties_size() const {
  return string_properties_.size();
}
inline int MatchmakerMatched_MatchmakerUser::string_properties_size() const {
  return _internal_string_properties_size();
}
inline void MatchmakerMatched_MatchmakerUser::clear_string_properties() {
  string_properties_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
MatchmakerMatched_MatchmakerUser::_internal_string_properties() const {
  return string_properties_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
MatchmakerMatched_MatchmakerUser::string_properties() const {
  // @@protoc_insertion_point(field_map:nakama.realtime.MatchmakerMatched.MatchmakerUser.string_properties)
  return _internal_string_properties();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
MatchmakerMatched_MatchmakerUser::_internal_mutable_string_properties() {
  return string_properties_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
MatchmakerMatched_MatchmakerUser::mutable_string_properties() {
  // @@protoc_insertion_point(field_mutable_map:nakama.realtime.MatchmakerMatched.MatchmakerUser.string_properties)
  return _internal_mutable_string_properties();
}

// map<string, double> numeric_properties = 6;
inline int MatchmakerMatched_MatchmakerUser::_internal_numeric_properties_size() const {
  return numeric_properties_.size();
}
inline int MatchmakerMatched_MatchmakerUser::numeric_properties_size() const {
  return _internal_numeric_properties_size();
}
inline void MatchmakerMatched_MatchmakerUser::clear_numeric_properties() {
  numeric_properties_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
MatchmakerMatched_MatchmakerUser::_internal_numeric_properties() const {
  return numeric_properties_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
MatchmakerMatched_MatchmakerUser::numeric_properties() const {
  // @@protoc_insertion_point(field_map:nakama.realtime.MatchmakerMatched.MatchmakerUser.numeric_properties)
  return _internal_numeric_properties();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
MatchmakerMatched_MatchmakerUser::_internal_mutable_numeric_properties() {
  return numeric_properties_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
MatchmakerMatched_MatchmakerUser::mutable_numeric_properties() {
  // @@protoc_insertion_point(field_mutable_map:nakama.realtime.MatchmakerMatched.MatchmakerUser.numeric_properties)
  return _internal_mutable_numeric_properties();
}

// -------------------------------------------------------------------

// MatchmakerMatched

// string ticket = 1;
inline void MatchmakerMatched::clear_ticket() {
  ticket_.ClearToEmpty();
}
inline const std::string& MatchmakerMatched::ticket() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchmakerMatched.ticket)
  return _internal_ticket();
}
inline void MatchmakerMatched::set_ticket(const std::string& value) {
  _internal_set_ticket(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchmakerMatched.ticket)
}
inline std::string* MatchmakerMatched::mutable_ticket() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchmakerMatched.ticket)
  return _internal_mutable_ticket();
}
inline const std::string& MatchmakerMatched::_internal_ticket() const {
  return ticket_.Get();
}
inline void MatchmakerMatched::_internal_set_ticket(const std::string& value) {
  
  ticket_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void MatchmakerMatched::set_ticket(std::string&& value) {
  
  ticket_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.MatchmakerMatched.ticket)
}
inline void MatchmakerMatched::set_ticket(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  ticket_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.MatchmakerMatched.ticket)
}
inline void MatchmakerMatched::set_ticket(const char* value,
    size_t size) {
  
  ticket_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.MatchmakerMatched.ticket)
}
inline std::string* MatchmakerMatched::_internal_mutable_ticket() {
  
  return ticket_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* MatchmakerMatched::release_ticket() {
  // @@protoc_insertion_point(field_release:nakama.realtime.MatchmakerMatched.ticket)
  return ticket_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MatchmakerMatched::set_allocated_ticket(std::string* ticket) {
  if (ticket != nullptr) {
    
  } else {
    
  }
  ticket_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ticket,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.MatchmakerMatched.ticket)
}

// string match_id = 2;
inline bool MatchmakerMatched::_internal_has_match_id() const {
  return id_case() == kMatchId;
}
inline void MatchmakerMatched::set_has_match_id() {
  _oneof_case_[0] = kMatchId;
}
inline void MatchmakerMatched::clear_match_id() {
  if (_internal_has_match_id()) {
    id_.match_id_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
    clear_has_id();
  }
}
inline const std::string& MatchmakerMatched::match_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchmakerMatched.match_id)
  return _internal_match_id();
}
inline void MatchmakerMatched::set_match_id(const std::string& value) {
  _internal_set_match_id(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchmakerMatched.match_id)
}
inline std::string* MatchmakerMatched::mutable_match_id() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchmakerMatched.match_id)
  return _internal_mutable_match_id();
}
inline const std::string& MatchmakerMatched::_internal_match_id() const {
  if (_internal_has_match_id()) {
    return id_.match_id_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void MatchmakerMatched::_internal_set_match_id(const std::string& value) {
  if (!_internal_has_match_id()) {
    clear_id();
    set_has_match_id();
    id_.match_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  id_.match_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void MatchmakerMatched::set_match_id(std::string&& value) {
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchmakerMatched.match_id)
  if (!_internal_has_match_id()) {
    clear_id();
    set_has_match_id();
    id_.match_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  id_.match_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.MatchmakerMatched.match_id)
}
inline void MatchmakerMatched::set_match_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_match_id()) {
    clear_id();
    set_has_match_id();
    id_.match_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  id_.match_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.MatchmakerMatched.match_id)
}
inline void MatchmakerMatched::set_match_id(const char* value,
                             size_t size) {
  if (!_internal_has_match_id()) {
    clear_id();
    set_has_match_id();
    id_.match_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  id_.match_id_.Set(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.MatchmakerMatched.match_id)
}
inline std::string* MatchmakerMatched::_internal_mutable_match_id() {
  if (!_internal_has_match_id()) {
    clear_id();
    set_has_match_id();
    id_.match_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return id_.match_id_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* MatchmakerMatched::release_match_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.MatchmakerMatched.match_id)
  if (_internal_has_match_id()) {
    clear_has_id();
    return id_.match_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void MatchmakerMatched::set_allocated_match_id(std::string* match_id) {
  if (has_id()) {
    clear_id();
  }
  if (match_id != nullptr) {
    set_has_match_id();
    id_.match_id_.UnsafeSetDefault(match_id);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena();
    if (arena != nullptr) {
      arena->Own(match_id);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.MatchmakerMatched.match_id)
}

// string token = 3;
inline bool MatchmakerMatched::_internal_has_token() const {
  return id_case() == kToken;
}
inline void MatchmakerMatched::set_has_token() {
  _oneof_case_[0] = kToken;
}
inline void MatchmakerMatched::clear_token() {
  if (_internal_has_token()) {
    id_.token_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
    clear_has_id();
  }
}
inline const std::string& MatchmakerMatched::token() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchmakerMatched.token)
  return _internal_token();
}
inline void MatchmakerMatched::set_token(const std::string& value) {
  _internal_set_token(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchmakerMatched.token)
}
inline std::string* MatchmakerMatched::mutable_token() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchmakerMatched.token)
  return _internal_mutable_token();
}
inline const std::string& MatchmakerMatched::_internal_token() const {
  if (_internal_has_token()) {
    return id_.token_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void MatchmakerMatched::_internal_set_token(const std::string& value) {
  if (!_internal_has_token()) {
    clear_id();
    set_has_token();
    id_.token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  id_.token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void MatchmakerMatched::set_token(std::string&& value) {
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchmakerMatched.token)
  if (!_internal_has_token()) {
    clear_id();
    set_has_token();
    id_.token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  id_.token_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.MatchmakerMatched.token)
}
inline void MatchmakerMatched::set_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_token()) {
    clear_id();
    set_has_token();
    id_.token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  id_.token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.MatchmakerMatched.token)
}
inline void MatchmakerMatched::set_token(const char* value,
                             size_t size) {
  if (!_internal_has_token()) {
    clear_id();
    set_has_token();
    id_.token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  id_.token_.Set(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.MatchmakerMatched.token)
}
inline std::string* MatchmakerMatched::_internal_mutable_token() {
  if (!_internal_has_token()) {
    clear_id();
    set_has_token();
    id_.token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return id_.token_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* MatchmakerMatched::release_token() {
  // @@protoc_insertion_point(field_release:nakama.realtime.MatchmakerMatched.token)
  if (_internal_has_token()) {
    clear_has_id();
    return id_.token_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void MatchmakerMatched::set_allocated_token(std::string* token) {
  if (has_id()) {
    clear_id();
  }
  if (token != nullptr) {
    set_has_token();
    id_.token_.UnsafeSetDefault(token);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena();
    if (arena != nullptr) {
      arena->Own(token);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.MatchmakerMatched.token)
}

// repeated .nakama.realtime.MatchmakerMatched.MatchmakerUser users = 4;
inline int MatchmakerMatched::_internal_users_size() const {
  return users_.size();
}
inline int MatchmakerMatched::users_size() const {
  return _internal_users_size();
}
inline void MatchmakerMatched::clear_users() {
  users_.Clear();
}
inline ::nakama::realtime::MatchmakerMatched_MatchmakerUser* MatchmakerMatched::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchmakerMatched.users)
  return users_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::MatchmakerMatched_MatchmakerUser >*
MatchmakerMatched::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:nakama.realtime.MatchmakerMatched.users)
  return &users_;
}
inline const ::nakama::realtime::MatchmakerMatched_MatchmakerUser& MatchmakerMatched::_internal_users(int index) const {
  return users_.Get(index);
}
inline const ::nakama::realtime::MatchmakerMatched_MatchmakerUser& MatchmakerMatched::users(int index) const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchmakerMatched.users)
  return _internal_users(index);
}
inline ::nakama::realtime::MatchmakerMatched_MatchmakerUser* MatchmakerMatched::_internal_add_users() {
  return users_.Add();
}
inline ::nakama::realtime::MatchmakerMatched_MatchmakerUser* MatchmakerMatched::add_users() {
  // @@protoc_insertion_point(field_add:nakama.realtime.MatchmakerMatched.users)
  return _internal_add_users();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::MatchmakerMatched_MatchmakerUser >&
MatchmakerMatched::users() const {
  // @@protoc_insertion_point(field_list:nakama.realtime.MatchmakerMatched.users)
  return users_;
}

// .nakama.realtime.MatchmakerMatched.MatchmakerUser self = 5;
inline bool MatchmakerMatched::_internal_has_self() const {
  return this != internal_default_instance() && self_ != nullptr;
}
inline bool MatchmakerMatched::has_self() const {
  return _internal_has_self();
}
inline void MatchmakerMatched::clear_self() {
  if (GetArena() == nullptr && self_ != nullptr) {
    delete self_;
  }
  self_ = nullptr;
}
inline const ::nakama::realtime::MatchmakerMatched_MatchmakerUser& MatchmakerMatched::_internal_self() const {
  const ::nakama::realtime::MatchmakerMatched_MatchmakerUser* p = self_;
  return p != nullptr ? *p : reinterpret_cast<const ::nakama::realtime::MatchmakerMatched_MatchmakerUser&>(
      ::nakama::realtime::_MatchmakerMatched_MatchmakerUser_default_instance_);
}
inline const ::nakama::realtime::MatchmakerMatched_MatchmakerUser& MatchmakerMatched::self() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchmakerMatched.self)
  return _internal_self();
}
inline void MatchmakerMatched::unsafe_arena_set_allocated_self(
    ::nakama::realtime::MatchmakerMatched_MatchmakerUser* self) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(self_);
  }
  self_ = self;
  if (self) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.MatchmakerMatched.self)
}
inline ::nakama::realtime::MatchmakerMatched_MatchmakerUser* MatchmakerMatched::release_self() {
  
  ::nakama::realtime::MatchmakerMatched_MatchmakerUser* temp = self_;
  self_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::nakama::realtime::MatchmakerMatched_MatchmakerUser* MatchmakerMatched::unsafe_arena_release_self() {
  // @@protoc_insertion_point(field_release:nakama.realtime.MatchmakerMatched.self)
  
  ::nakama::realtime::MatchmakerMatched_MatchmakerUser* temp = self_;
  self_ = nullptr;
  return temp;
}
inline ::nakama::realtime::MatchmakerMatched_MatchmakerUser* MatchmakerMatched::_internal_mutable_self() {
  
  if (self_ == nullptr) {
    auto* p = CreateMaybeMessage<::nakama::realtime::MatchmakerMatched_MatchmakerUser>(GetArena());
    self_ = p;
  }
  return self_;
}
inline ::nakama::realtime::MatchmakerMatched_MatchmakerUser* MatchmakerMatched::mutable_self() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchmakerMatched.self)
  return _internal_mutable_self();
}
inline void MatchmakerMatched::set_allocated_self(::nakama::realtime::MatchmakerMatched_MatchmakerUser* self) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete self_;
  }
  if (self) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(self);
    if (message_arena != submessage_arena) {
      self = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, self, submessage_arena);
    }
    
  } else {
    
  }
  self_ = self;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.MatchmakerMatched.self)
}

inline bool MatchmakerMatched::has_id() const {
  return id_case() != ID_NOT_SET;
}
inline void MatchmakerMatched::clear_has_id() {
  _oneof_case_[0] = ID_NOT_SET;
}
inline MatchmakerMatched::IdCase MatchmakerMatched::id_case() const {
  return MatchmakerMatched::IdCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MatchmakerRemove

// string ticket = 1;
inline void MatchmakerRemove::clear_ticket() {
  ticket_.ClearToEmpty();
}
inline const std::string& MatchmakerRemove::ticket() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchmakerRemove.ticket)
  return _internal_ticket();
}
inline void MatchmakerRemove::set_ticket(const std::string& value) {
  _internal_set_ticket(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchmakerRemove.ticket)
}
inline std::string* MatchmakerRemove::mutable_ticket() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchmakerRemove.ticket)
  return _internal_mutable_ticket();
}
inline const std::string& MatchmakerRemove::_internal_ticket() const {
  return ticket_.Get();
}
inline void MatchmakerRemove::_internal_set_ticket(const std::string& value) {
  
  ticket_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void MatchmakerRemove::set_ticket(std::string&& value) {
  
  ticket_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.MatchmakerRemove.ticket)
}
inline void MatchmakerRemove::set_ticket(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  ticket_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.MatchmakerRemove.ticket)
}
inline void MatchmakerRemove::set_ticket(const char* value,
    size_t size) {
  
  ticket_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.MatchmakerRemove.ticket)
}
inline std::string* MatchmakerRemove::_internal_mutable_ticket() {
  
  return ticket_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* MatchmakerRemove::release_ticket() {
  // @@protoc_insertion_point(field_release:nakama.realtime.MatchmakerRemove.ticket)
  return ticket_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MatchmakerRemove::set_allocated_ticket(std::string* ticket) {
  if (ticket != nullptr) {
    
  } else {
    
  }
  ticket_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ticket,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.MatchmakerRemove.ticket)
}

// -------------------------------------------------------------------

// MatchmakerTicket

// string ticket = 1;
inline void MatchmakerTicket::clear_ticket() {
  ticket_.ClearToEmpty();
}
inline const std::string& MatchmakerTicket::ticket() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchmakerTicket.ticket)
  return _internal_ticket();
}
inline void MatchmakerTicket::set_ticket(const std::string& value) {
  _internal_set_ticket(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchmakerTicket.ticket)
}
inline std::string* MatchmakerTicket::mutable_ticket() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchmakerTicket.ticket)
  return _internal_mutable_ticket();
}
inline const std::string& MatchmakerTicket::_internal_ticket() const {
  return ticket_.Get();
}
inline void MatchmakerTicket::_internal_set_ticket(const std::string& value) {
  
  ticket_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void MatchmakerTicket::set_ticket(std::string&& value) {
  
  ticket_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.MatchmakerTicket.ticket)
}
inline void MatchmakerTicket::set_ticket(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  ticket_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.MatchmakerTicket.ticket)
}
inline void MatchmakerTicket::set_ticket(const char* value,
    size_t size) {
  
  ticket_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.MatchmakerTicket.ticket)
}
inline std::string* MatchmakerTicket::_internal_mutable_ticket() {
  
  return ticket_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* MatchmakerTicket::release_ticket() {
  // @@protoc_insertion_point(field_release:nakama.realtime.MatchmakerTicket.ticket)
  return ticket_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MatchmakerTicket::set_allocated_ticket(std::string* ticket) {
  if (ticket != nullptr) {
    
  } else {
    
  }
  ticket_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ticket,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.MatchmakerTicket.ticket)
}

// -------------------------------------------------------------------

// Notifications

// repeated .nakama.api.Notification notifications = 1;
inline int Notifications::_internal_notifications_size() const {
  return notifications_.size();
}
inline int Notifications::notifications_size() const {
  return _internal_notifications_size();
}
inline ::nakama::api::Notification* Notifications::mutable_notifications(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Notifications.notifications)
  return notifications_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::api::Notification >*
Notifications::mutable_notifications() {
  // @@protoc_insertion_point(field_mutable_list:nakama.realtime.Notifications.notifications)
  return &notifications_;
}
inline const ::nakama::api::Notification& Notifications::_internal_notifications(int index) const {
  return notifications_.Get(index);
}
inline const ::nakama::api::Notification& Notifications::notifications(int index) const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Notifications.notifications)
  return _internal_notifications(index);
}
inline ::nakama::api::Notification* Notifications::_internal_add_notifications() {
  return notifications_.Add();
}
inline ::nakama::api::Notification* Notifications::add_notifications() {
  // @@protoc_insertion_point(field_add:nakama.realtime.Notifications.notifications)
  return _internal_add_notifications();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::api::Notification >&
Notifications::notifications() const {
  // @@protoc_insertion_point(field_list:nakama.realtime.Notifications.notifications)
  return notifications_;
}

// -------------------------------------------------------------------

// Party

// string party_id = 1;
inline void Party::clear_party_id() {
  party_id_.ClearToEmpty();
}
inline const std::string& Party::party_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Party.party_id)
  return _internal_party_id();
}
inline void Party::set_party_id(const std::string& value) {
  _internal_set_party_id(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.Party.party_id)
}
inline std::string* Party::mutable_party_id() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Party.party_id)
  return _internal_mutable_party_id();
}
inline const std::string& Party::_internal_party_id() const {
  return party_id_.Get();
}
inline void Party::_internal_set_party_id(const std::string& value) {
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Party::set_party_id(std::string&& value) {
  
  party_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.Party.party_id)
}
inline void Party::set_party_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.Party.party_id)
}
inline void Party::set_party_id(const char* value,
    size_t size) {
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.Party.party_id)
}
inline std::string* Party::_internal_mutable_party_id() {
  
  return party_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Party::release_party_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Party.party_id)
  return party_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Party::set_allocated_party_id(std::string* party_id) {
  if (party_id != nullptr) {
    
  } else {
    
  }
  party_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), party_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.Party.party_id)
}

// bool open = 2;
inline void Party::clear_open() {
  open_ = false;
}
inline bool Party::_internal_open() const {
  return open_;
}
inline bool Party::open() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Party.open)
  return _internal_open();
}
inline void Party::_internal_set_open(bool value) {
  
  open_ = value;
}
inline void Party::set_open(bool value) {
  _internal_set_open(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.Party.open)
}

// int32 max_size = 3;
inline void Party::clear_max_size() {
  max_size_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Party::_internal_max_size() const {
  return max_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Party::max_size() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Party.max_size)
  return _internal_max_size();
}
inline void Party::_internal_set_max_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  max_size_ = value;
}
inline void Party::set_max_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_max_size(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.Party.max_size)
}

// .nakama.realtime.UserPresence self = 4;
inline bool Party::_internal_has_self() const {
  return this != internal_default_instance() && self_ != nullptr;
}
inline bool Party::has_self() const {
  return _internal_has_self();
}
inline void Party::clear_self() {
  if (GetArena() == nullptr && self_ != nullptr) {
    delete self_;
  }
  self_ = nullptr;
}
inline const ::nakama::realtime::UserPresence& Party::_internal_self() const {
  const ::nakama::realtime::UserPresence* p = self_;
  return p != nullptr ? *p : reinterpret_cast<const ::nakama::realtime::UserPresence&>(
      ::nakama::realtime::_UserPresence_default_instance_);
}
inline const ::nakama::realtime::UserPresence& Party::self() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Party.self)
  return _internal_self();
}
inline void Party::unsafe_arena_set_allocated_self(
    ::nakama::realtime::UserPresence* self) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(self_);
  }
  self_ = self;
  if (self) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Party.self)
}
inline ::nakama::realtime::UserPresence* Party::release_self() {
  
  ::nakama::realtime::UserPresence* temp = self_;
  self_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::nakama::realtime::UserPresence* Party::unsafe_arena_release_self() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Party.self)
  
  ::nakama::realtime::UserPresence* temp = self_;
  self_ = nullptr;
  return temp;
}
inline ::nakama::realtime::UserPresence* Party::_internal_mutable_self() {
  
  if (self_ == nullptr) {
    auto* p = CreateMaybeMessage<::nakama::realtime::UserPresence>(GetArena());
    self_ = p;
  }
  return self_;
}
inline ::nakama::realtime::UserPresence* Party::mutable_self() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Party.self)
  return _internal_mutable_self();
}
inline void Party::set_allocated_self(::nakama::realtime::UserPresence* self) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete self_;
  }
  if (self) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(self);
    if (message_arena != submessage_arena) {
      self = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, self, submessage_arena);
    }
    
  } else {
    
  }
  self_ = self;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.Party.self)
}

// .nakama.realtime.UserPresence leader = 5;
inline bool Party::_internal_has_leader() const {
  return this != internal_default_instance() && leader_ != nullptr;
}
inline bool Party::has_leader() const {
  return _internal_has_leader();
}
inline void Party::clear_leader() {
  if (GetArena() == nullptr && leader_ != nullptr) {
    delete leader_;
  }
  leader_ = nullptr;
}
inline const ::nakama::realtime::UserPresence& Party::_internal_leader() const {
  const ::nakama::realtime::UserPresence* p = leader_;
  return p != nullptr ? *p : reinterpret_cast<const ::nakama::realtime::UserPresence&>(
      ::nakama::realtime::_UserPresence_default_instance_);
}
inline const ::nakama::realtime::UserPresence& Party::leader() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Party.leader)
  return _internal_leader();
}
inline void Party::unsafe_arena_set_allocated_leader(
    ::nakama::realtime::UserPresence* leader) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(leader_);
  }
  leader_ = leader;
  if (leader) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.Party.leader)
}
inline ::nakama::realtime::UserPresence* Party::release_leader() {
  
  ::nakama::realtime::UserPresence* temp = leader_;
  leader_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::nakama::realtime::UserPresence* Party::unsafe_arena_release_leader() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Party.leader)
  
  ::nakama::realtime::UserPresence* temp = leader_;
  leader_ = nullptr;
  return temp;
}
inline ::nakama::realtime::UserPresence* Party::_internal_mutable_leader() {
  
  if (leader_ == nullptr) {
    auto* p = CreateMaybeMessage<::nakama::realtime::UserPresence>(GetArena());
    leader_ = p;
  }
  return leader_;
}
inline ::nakama::realtime::UserPresence* Party::mutable_leader() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Party.leader)
  return _internal_mutable_leader();
}
inline void Party::set_allocated_leader(::nakama::realtime::UserPresence* leader) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete leader_;
  }
  if (leader) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(leader);
    if (message_arena != submessage_arena) {
      leader = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, leader, submessage_arena);
    }
    
  } else {
    
  }
  leader_ = leader;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.Party.leader)
}

// repeated .nakama.realtime.UserPresence presences = 6;
inline int Party::_internal_presences_size() const {
  return presences_.size();
}
inline int Party::presences_size() const {
  return _internal_presences_size();
}
inline void Party::clear_presences() {
  presences_.Clear();
}
inline ::nakama::realtime::UserPresence* Party::mutable_presences(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Party.presences)
  return presences_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >*
Party::mutable_presences() {
  // @@protoc_insertion_point(field_mutable_list:nakama.realtime.Party.presences)
  return &presences_;
}
inline const ::nakama::realtime::UserPresence& Party::_internal_presences(int index) const {
  return presences_.Get(index);
}
inline const ::nakama::realtime::UserPresence& Party::presences(int index) const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Party.presences)
  return _internal_presences(index);
}
inline ::nakama::realtime::UserPresence* Party::_internal_add_presences() {
  return presences_.Add();
}
inline ::nakama::realtime::UserPresence* Party::add_presences() {
  // @@protoc_insertion_point(field_add:nakama.realtime.Party.presences)
  return _internal_add_presences();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >&
Party::presences() const {
  // @@protoc_insertion_point(field_list:nakama.realtime.Party.presences)
  return presences_;
}

// -------------------------------------------------------------------

// PartyCreate

// bool open = 1;
inline void PartyCreate::clear_open() {
  open_ = false;
}
inline bool PartyCreate::_internal_open() const {
  return open_;
}
inline bool PartyCreate::open() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.PartyCreate.open)
  return _internal_open();
}
inline void PartyCreate::_internal_set_open(bool value) {
  
  open_ = value;
}
inline void PartyCreate::set_open(bool value) {
  _internal_set_open(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.PartyCreate.open)
}

// int32 max_size = 2;
inline void PartyCreate::clear_max_size() {
  max_size_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PartyCreate::_internal_max_size() const {
  return max_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PartyCreate::max_size() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.PartyCreate.max_size)
  return _internal_max_size();
}
inline void PartyCreate::_internal_set_max_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  max_size_ = value;
}
inline void PartyCreate::set_max_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_max_size(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.PartyCreate.max_size)
}

// -------------------------------------------------------------------

// PartyJoin

// string party_id = 1;
inline void PartyJoin::clear_party_id() {
  party_id_.ClearToEmpty();
}
inline const std::string& PartyJoin::party_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.PartyJoin.party_id)
  return _internal_party_id();
}
inline void PartyJoin::set_party_id(const std::string& value) {
  _internal_set_party_id(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.PartyJoin.party_id)
}
inline std::string* PartyJoin::mutable_party_id() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.PartyJoin.party_id)
  return _internal_mutable_party_id();
}
inline const std::string& PartyJoin::_internal_party_id() const {
  return party_id_.Get();
}
inline void PartyJoin::_internal_set_party_id(const std::string& value) {
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PartyJoin::set_party_id(std::string&& value) {
  
  party_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.PartyJoin.party_id)
}
inline void PartyJoin::set_party_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.PartyJoin.party_id)
}
inline void PartyJoin::set_party_id(const char* value,
    size_t size) {
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.PartyJoin.party_id)
}
inline std::string* PartyJoin::_internal_mutable_party_id() {
  
  return party_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PartyJoin::release_party_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.PartyJoin.party_id)
  return party_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PartyJoin::set_allocated_party_id(std::string* party_id) {
  if (party_id != nullptr) {
    
  } else {
    
  }
  party_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), party_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.PartyJoin.party_id)
}

// -------------------------------------------------------------------

// PartyLeave

// string party_id = 1;
inline void PartyLeave::clear_party_id() {
  party_id_.ClearToEmpty();
}
inline const std::string& PartyLeave::party_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.PartyLeave.party_id)
  return _internal_party_id();
}
inline void PartyLeave::set_party_id(const std::string& value) {
  _internal_set_party_id(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.PartyLeave.party_id)
}
inline std::string* PartyLeave::mutable_party_id() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.PartyLeave.party_id)
  return _internal_mutable_party_id();
}
inline const std::string& PartyLeave::_internal_party_id() const {
  return party_id_.Get();
}
inline void PartyLeave::_internal_set_party_id(const std::string& value) {
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PartyLeave::set_party_id(std::string&& value) {
  
  party_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.PartyLeave.party_id)
}
inline void PartyLeave::set_party_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.PartyLeave.party_id)
}
inline void PartyLeave::set_party_id(const char* value,
    size_t size) {
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.PartyLeave.party_id)
}
inline std::string* PartyLeave::_internal_mutable_party_id() {
  
  return party_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PartyLeave::release_party_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.PartyLeave.party_id)
  return party_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PartyLeave::set_allocated_party_id(std::string* party_id) {
  if (party_id != nullptr) {
    
  } else {
    
  }
  party_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), party_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.PartyLeave.party_id)
}

// -------------------------------------------------------------------

// PartyPromote

// string party_id = 1;
inline void PartyPromote::clear_party_id() {
  party_id_.ClearToEmpty();
}
inline const std::string& PartyPromote::party_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.PartyPromote.party_id)
  return _internal_party_id();
}
inline void PartyPromote::set_party_id(const std::string& value) {
  _internal_set_party_id(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.PartyPromote.party_id)
}
inline std::string* PartyPromote::mutable_party_id() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.PartyPromote.party_id)
  return _internal_mutable_party_id();
}
inline const std::string& PartyPromote::_internal_party_id() const {
  return party_id_.Get();
}
inline void PartyPromote::_internal_set_party_id(const std::string& value) {
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PartyPromote::set_party_id(std::string&& value) {
  
  party_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.PartyPromote.party_id)
}
inline void PartyPromote::set_party_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.PartyPromote.party_id)
}
inline void PartyPromote::set_party_id(const char* value,
    size_t size) {
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.PartyPromote.party_id)
}
inline std::string* PartyPromote::_internal_mutable_party_id() {
  
  return party_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PartyPromote::release_party_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.PartyPromote.party_id)
  return party_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PartyPromote::set_allocated_party_id(std::string* party_id) {
  if (party_id != nullptr) {
    
  } else {
    
  }
  party_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), party_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.PartyPromote.party_id)
}

// .nakama.realtime.UserPresence presence = 2;
inline bool PartyPromote::_internal_has_presence() const {
  return this != internal_default_instance() && presence_ != nullptr;
}
inline bool PartyPromote::has_presence() const {
  return _internal_has_presence();
}
inline void PartyPromote::clear_presence() {
  if (GetArena() == nullptr && presence_ != nullptr) {
    delete presence_;
  }
  presence_ = nullptr;
}
inline const ::nakama::realtime::UserPresence& PartyPromote::_internal_presence() const {
  const ::nakama::realtime::UserPresence* p = presence_;
  return p != nullptr ? *p : reinterpret_cast<const ::nakama::realtime::UserPresence&>(
      ::nakama::realtime::_UserPresence_default_instance_);
}
inline const ::nakama::realtime::UserPresence& PartyPromote::presence() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.PartyPromote.presence)
  return _internal_presence();
}
inline void PartyPromote::unsafe_arena_set_allocated_presence(
    ::nakama::realtime::UserPresence* presence) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(presence_);
  }
  presence_ = presence;
  if (presence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.PartyPromote.presence)
}
inline ::nakama::realtime::UserPresence* PartyPromote::release_presence() {
  
  ::nakama::realtime::UserPresence* temp = presence_;
  presence_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::nakama::realtime::UserPresence* PartyPromote::unsafe_arena_release_presence() {
  // @@protoc_insertion_point(field_release:nakama.realtime.PartyPromote.presence)
  
  ::nakama::realtime::UserPresence* temp = presence_;
  presence_ = nullptr;
  return temp;
}
inline ::nakama::realtime::UserPresence* PartyPromote::_internal_mutable_presence() {
  
  if (presence_ == nullptr) {
    auto* p = CreateMaybeMessage<::nakama::realtime::UserPresence>(GetArena());
    presence_ = p;
  }
  return presence_;
}
inline ::nakama::realtime::UserPresence* PartyPromote::mutable_presence() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.PartyPromote.presence)
  return _internal_mutable_presence();
}
inline void PartyPromote::set_allocated_presence(::nakama::realtime::UserPresence* presence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete presence_;
  }
  if (presence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(presence);
    if (message_arena != submessage_arena) {
      presence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, presence, submessage_arena);
    }
    
  } else {
    
  }
  presence_ = presence;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.PartyPromote.presence)
}

// -------------------------------------------------------------------

// PartyLeader

// string party_id = 1;
inline void PartyLeader::clear_party_id() {
  party_id_.ClearToEmpty();
}
inline const std::string& PartyLeader::party_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.PartyLeader.party_id)
  return _internal_party_id();
}
inline void PartyLeader::set_party_id(const std::string& value) {
  _internal_set_party_id(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.PartyLeader.party_id)
}
inline std::string* PartyLeader::mutable_party_id() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.PartyLeader.party_id)
  return _internal_mutable_party_id();
}
inline const std::string& PartyLeader::_internal_party_id() const {
  return party_id_.Get();
}
inline void PartyLeader::_internal_set_party_id(const std::string& value) {
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PartyLeader::set_party_id(std::string&& value) {
  
  party_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.PartyLeader.party_id)
}
inline void PartyLeader::set_party_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.PartyLeader.party_id)
}
inline void PartyLeader::set_party_id(const char* value,
    size_t size) {
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.PartyLeader.party_id)
}
inline std::string* PartyLeader::_internal_mutable_party_id() {
  
  return party_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PartyLeader::release_party_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.PartyLeader.party_id)
  return party_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PartyLeader::set_allocated_party_id(std::string* party_id) {
  if (party_id != nullptr) {
    
  } else {
    
  }
  party_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), party_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.PartyLeader.party_id)
}

// .nakama.realtime.UserPresence presence = 2;
inline bool PartyLeader::_internal_has_presence() const {
  return this != internal_default_instance() && presence_ != nullptr;
}
inline bool PartyLeader::has_presence() const {
  return _internal_has_presence();
}
inline void PartyLeader::clear_presence() {
  if (GetArena() == nullptr && presence_ != nullptr) {
    delete presence_;
  }
  presence_ = nullptr;
}
inline const ::nakama::realtime::UserPresence& PartyLeader::_internal_presence() const {
  const ::nakama::realtime::UserPresence* p = presence_;
  return p != nullptr ? *p : reinterpret_cast<const ::nakama::realtime::UserPresence&>(
      ::nakama::realtime::_UserPresence_default_instance_);
}
inline const ::nakama::realtime::UserPresence& PartyLeader::presence() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.PartyLeader.presence)
  return _internal_presence();
}
inline void PartyLeader::unsafe_arena_set_allocated_presence(
    ::nakama::realtime::UserPresence* presence) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(presence_);
  }
  presence_ = presence;
  if (presence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.PartyLeader.presence)
}
inline ::nakama::realtime::UserPresence* PartyLeader::release_presence() {
  
  ::nakama::realtime::UserPresence* temp = presence_;
  presence_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::nakama::realtime::UserPresence* PartyLeader::unsafe_arena_release_presence() {
  // @@protoc_insertion_point(field_release:nakama.realtime.PartyLeader.presence)
  
  ::nakama::realtime::UserPresence* temp = presence_;
  presence_ = nullptr;
  return temp;
}
inline ::nakama::realtime::UserPresence* PartyLeader::_internal_mutable_presence() {
  
  if (presence_ == nullptr) {
    auto* p = CreateMaybeMessage<::nakama::realtime::UserPresence>(GetArena());
    presence_ = p;
  }
  return presence_;
}
inline ::nakama::realtime::UserPresence* PartyLeader::mutable_presence() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.PartyLeader.presence)
  return _internal_mutable_presence();
}
inline void PartyLeader::set_allocated_presence(::nakama::realtime::UserPresence* presence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete presence_;
  }
  if (presence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(presence);
    if (message_arena != submessage_arena) {
      presence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, presence, submessage_arena);
    }
    
  } else {
    
  }
  presence_ = presence;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.PartyLeader.presence)
}

// -------------------------------------------------------------------

// PartyAccept

// string party_id = 1;
inline void PartyAccept::clear_party_id() {
  party_id_.ClearToEmpty();
}
inline const std::string& PartyAccept::party_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.PartyAccept.party_id)
  return _internal_party_id();
}
inline void PartyAccept::set_party_id(const std::string& value) {
  _internal_set_party_id(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.PartyAccept.party_id)
}
inline std::string* PartyAccept::mutable_party_id() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.PartyAccept.party_id)
  return _internal_mutable_party_id();
}
inline const std::string& PartyAccept::_internal_party_id() const {
  return party_id_.Get();
}
inline void PartyAccept::_internal_set_party_id(const std::string& value) {
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PartyAccept::set_party_id(std::string&& value) {
  
  party_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.PartyAccept.party_id)
}
inline void PartyAccept::set_party_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.PartyAccept.party_id)
}
inline void PartyAccept::set_party_id(const char* value,
    size_t size) {
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.PartyAccept.party_id)
}
inline std::string* PartyAccept::_internal_mutable_party_id() {
  
  return party_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PartyAccept::release_party_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.PartyAccept.party_id)
  return party_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PartyAccept::set_allocated_party_id(std::string* party_id) {
  if (party_id != nullptr) {
    
  } else {
    
  }
  party_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), party_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.PartyAccept.party_id)
}

// .nakama.realtime.UserPresence presence = 2;
inline bool PartyAccept::_internal_has_presence() const {
  return this != internal_default_instance() && presence_ != nullptr;
}
inline bool PartyAccept::has_presence() const {
  return _internal_has_presence();
}
inline void PartyAccept::clear_presence() {
  if (GetArena() == nullptr && presence_ != nullptr) {
    delete presence_;
  }
  presence_ = nullptr;
}
inline const ::nakama::realtime::UserPresence& PartyAccept::_internal_presence() const {
  const ::nakama::realtime::UserPresence* p = presence_;
  return p != nullptr ? *p : reinterpret_cast<const ::nakama::realtime::UserPresence&>(
      ::nakama::realtime::_UserPresence_default_instance_);
}
inline const ::nakama::realtime::UserPresence& PartyAccept::presence() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.PartyAccept.presence)
  return _internal_presence();
}
inline void PartyAccept::unsafe_arena_set_allocated_presence(
    ::nakama::realtime::UserPresence* presence) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(presence_);
  }
  presence_ = presence;
  if (presence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.PartyAccept.presence)
}
inline ::nakama::realtime::UserPresence* PartyAccept::release_presence() {
  
  ::nakama::realtime::UserPresence* temp = presence_;
  presence_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::nakama::realtime::UserPresence* PartyAccept::unsafe_arena_release_presence() {
  // @@protoc_insertion_point(field_release:nakama.realtime.PartyAccept.presence)
  
  ::nakama::realtime::UserPresence* temp = presence_;
  presence_ = nullptr;
  return temp;
}
inline ::nakama::realtime::UserPresence* PartyAccept::_internal_mutable_presence() {
  
  if (presence_ == nullptr) {
    auto* p = CreateMaybeMessage<::nakama::realtime::UserPresence>(GetArena());
    presence_ = p;
  }
  return presence_;
}
inline ::nakama::realtime::UserPresence* PartyAccept::mutable_presence() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.PartyAccept.presence)
  return _internal_mutable_presence();
}
inline void PartyAccept::set_allocated_presence(::nakama::realtime::UserPresence* presence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete presence_;
  }
  if (presence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(presence);
    if (message_arena != submessage_arena) {
      presence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, presence, submessage_arena);
    }
    
  } else {
    
  }
  presence_ = presence;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.PartyAccept.presence)
}

// -------------------------------------------------------------------

// PartyRemove

// string party_id = 1;
inline void PartyRemove::clear_party_id() {
  party_id_.ClearToEmpty();
}
inline const std::string& PartyRemove::party_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.PartyRemove.party_id)
  return _internal_party_id();
}
inline void PartyRemove::set_party_id(const std::string& value) {
  _internal_set_party_id(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.PartyRemove.party_id)
}
inline std::string* PartyRemove::mutable_party_id() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.PartyRemove.party_id)
  return _internal_mutable_party_id();
}
inline const std::string& PartyRemove::_internal_party_id() const {
  return party_id_.Get();
}
inline void PartyRemove::_internal_set_party_id(const std::string& value) {
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PartyRemove::set_party_id(std::string&& value) {
  
  party_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.PartyRemove.party_id)
}
inline void PartyRemove::set_party_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.PartyRemove.party_id)
}
inline void PartyRemove::set_party_id(const char* value,
    size_t size) {
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.PartyRemove.party_id)
}
inline std::string* PartyRemove::_internal_mutable_party_id() {
  
  return party_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PartyRemove::release_party_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.PartyRemove.party_id)
  return party_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PartyRemove::set_allocated_party_id(std::string* party_id) {
  if (party_id != nullptr) {
    
  } else {
    
  }
  party_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), party_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.PartyRemove.party_id)
}

// .nakama.realtime.UserPresence presence = 2;
inline bool PartyRemove::_internal_has_presence() const {
  return this != internal_default_instance() && presence_ != nullptr;
}
inline bool PartyRemove::has_presence() const {
  return _internal_has_presence();
}
inline void PartyRemove::clear_presence() {
  if (GetArena() == nullptr && presence_ != nullptr) {
    delete presence_;
  }
  presence_ = nullptr;
}
inline const ::nakama::realtime::UserPresence& PartyRemove::_internal_presence() const {
  const ::nakama::realtime::UserPresence* p = presence_;
  return p != nullptr ? *p : reinterpret_cast<const ::nakama::realtime::UserPresence&>(
      ::nakama::realtime::_UserPresence_default_instance_);
}
inline const ::nakama::realtime::UserPresence& PartyRemove::presence() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.PartyRemove.presence)
  return _internal_presence();
}
inline void PartyRemove::unsafe_arena_set_allocated_presence(
    ::nakama::realtime::UserPresence* presence) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(presence_);
  }
  presence_ = presence;
  if (presence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.PartyRemove.presence)
}
inline ::nakama::realtime::UserPresence* PartyRemove::release_presence() {
  
  ::nakama::realtime::UserPresence* temp = presence_;
  presence_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::nakama::realtime::UserPresence* PartyRemove::unsafe_arena_release_presence() {
  // @@protoc_insertion_point(field_release:nakama.realtime.PartyRemove.presence)
  
  ::nakama::realtime::UserPresence* temp = presence_;
  presence_ = nullptr;
  return temp;
}
inline ::nakama::realtime::UserPresence* PartyRemove::_internal_mutable_presence() {
  
  if (presence_ == nullptr) {
    auto* p = CreateMaybeMessage<::nakama::realtime::UserPresence>(GetArena());
    presence_ = p;
  }
  return presence_;
}
inline ::nakama::realtime::UserPresence* PartyRemove::mutable_presence() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.PartyRemove.presence)
  return _internal_mutable_presence();
}
inline void PartyRemove::set_allocated_presence(::nakama::realtime::UserPresence* presence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete presence_;
  }
  if (presence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(presence);
    if (message_arena != submessage_arena) {
      presence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, presence, submessage_arena);
    }
    
  } else {
    
  }
  presence_ = presence;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.PartyRemove.presence)
}

// -------------------------------------------------------------------

// PartyClose

// string party_id = 1;
inline void PartyClose::clear_party_id() {
  party_id_.ClearToEmpty();
}
inline const std::string& PartyClose::party_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.PartyClose.party_id)
  return _internal_party_id();
}
inline void PartyClose::set_party_id(const std::string& value) {
  _internal_set_party_id(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.PartyClose.party_id)
}
inline std::string* PartyClose::mutable_party_id() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.PartyClose.party_id)
  return _internal_mutable_party_id();
}
inline const std::string& PartyClose::_internal_party_id() const {
  return party_id_.Get();
}
inline void PartyClose::_internal_set_party_id(const std::string& value) {
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PartyClose::set_party_id(std::string&& value) {
  
  party_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.PartyClose.party_id)
}
inline void PartyClose::set_party_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.PartyClose.party_id)
}
inline void PartyClose::set_party_id(const char* value,
    size_t size) {
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.PartyClose.party_id)
}
inline std::string* PartyClose::_internal_mutable_party_id() {
  
  return party_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PartyClose::release_party_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.PartyClose.party_id)
  return party_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PartyClose::set_allocated_party_id(std::string* party_id) {
  if (party_id != nullptr) {
    
  } else {
    
  }
  party_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), party_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.PartyClose.party_id)
}

// -------------------------------------------------------------------

// PartyJoinRequestList

// string party_id = 1;
inline void PartyJoinRequestList::clear_party_id() {
  party_id_.ClearToEmpty();
}
inline const std::string& PartyJoinRequestList::party_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.PartyJoinRequestList.party_id)
  return _internal_party_id();
}
inline void PartyJoinRequestList::set_party_id(const std::string& value) {
  _internal_set_party_id(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.PartyJoinRequestList.party_id)
}
inline std::string* PartyJoinRequestList::mutable_party_id() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.PartyJoinRequestList.party_id)
  return _internal_mutable_party_id();
}
inline const std::string& PartyJoinRequestList::_internal_party_id() const {
  return party_id_.Get();
}
inline void PartyJoinRequestList::_internal_set_party_id(const std::string& value) {
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PartyJoinRequestList::set_party_id(std::string&& value) {
  
  party_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.PartyJoinRequestList.party_id)
}
inline void PartyJoinRequestList::set_party_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.PartyJoinRequestList.party_id)
}
inline void PartyJoinRequestList::set_party_id(const char* value,
    size_t size) {
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.PartyJoinRequestList.party_id)
}
inline std::string* PartyJoinRequestList::_internal_mutable_party_id() {
  
  return party_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PartyJoinRequestList::release_party_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.PartyJoinRequestList.party_id)
  return party_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PartyJoinRequestList::set_allocated_party_id(std::string* party_id) {
  if (party_id != nullptr) {
    
  } else {
    
  }
  party_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), party_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.PartyJoinRequestList.party_id)
}

// -------------------------------------------------------------------

// PartyJoinRequest

// string party_id = 1;
inline void PartyJoinRequest::clear_party_id() {
  party_id_.ClearToEmpty();
}
inline const std::string& PartyJoinRequest::party_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.PartyJoinRequest.party_id)
  return _internal_party_id();
}
inline void PartyJoinRequest::set_party_id(const std::string& value) {
  _internal_set_party_id(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.PartyJoinRequest.party_id)
}
inline std::string* PartyJoinRequest::mutable_party_id() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.PartyJoinRequest.party_id)
  return _internal_mutable_party_id();
}
inline const std::string& PartyJoinRequest::_internal_party_id() const {
  return party_id_.Get();
}
inline void PartyJoinRequest::_internal_set_party_id(const std::string& value) {
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PartyJoinRequest::set_party_id(std::string&& value) {
  
  party_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.PartyJoinRequest.party_id)
}
inline void PartyJoinRequest::set_party_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.PartyJoinRequest.party_id)
}
inline void PartyJoinRequest::set_party_id(const char* value,
    size_t size) {
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.PartyJoinRequest.party_id)
}
inline std::string* PartyJoinRequest::_internal_mutable_party_id() {
  
  return party_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PartyJoinRequest::release_party_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.PartyJoinRequest.party_id)
  return party_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PartyJoinRequest::set_allocated_party_id(std::string* party_id) {
  if (party_id != nullptr) {
    
  } else {
    
  }
  party_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), party_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.PartyJoinRequest.party_id)
}

// repeated .nakama.realtime.UserPresence presences = 2;
inline int PartyJoinRequest::_internal_presences_size() const {
  return presences_.size();
}
inline int PartyJoinRequest::presences_size() const {
  return _internal_presences_size();
}
inline void PartyJoinRequest::clear_presences() {
  presences_.Clear();
}
inline ::nakama::realtime::UserPresence* PartyJoinRequest::mutable_presences(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.PartyJoinRequest.presences)
  return presences_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >*
PartyJoinRequest::mutable_presences() {
  // @@protoc_insertion_point(field_mutable_list:nakama.realtime.PartyJoinRequest.presences)
  return &presences_;
}
inline const ::nakama::realtime::UserPresence& PartyJoinRequest::_internal_presences(int index) const {
  return presences_.Get(index);
}
inline const ::nakama::realtime::UserPresence& PartyJoinRequest::presences(int index) const {
  // @@protoc_insertion_point(field_get:nakama.realtime.PartyJoinRequest.presences)
  return _internal_presences(index);
}
inline ::nakama::realtime::UserPresence* PartyJoinRequest::_internal_add_presences() {
  return presences_.Add();
}
inline ::nakama::realtime::UserPresence* PartyJoinRequest::add_presences() {
  // @@protoc_insertion_point(field_add:nakama.realtime.PartyJoinRequest.presences)
  return _internal_add_presences();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >&
PartyJoinRequest::presences() const {
  // @@protoc_insertion_point(field_list:nakama.realtime.PartyJoinRequest.presences)
  return presences_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PartyMatchmakerAdd

// string party_id = 1;
inline void PartyMatchmakerAdd::clear_party_id() {
  party_id_.ClearToEmpty();
}
inline const std::string& PartyMatchmakerAdd::party_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.PartyMatchmakerAdd.party_id)
  return _internal_party_id();
}
inline void PartyMatchmakerAdd::set_party_id(const std::string& value) {
  _internal_set_party_id(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.PartyMatchmakerAdd.party_id)
}
inline std::string* PartyMatchmakerAdd::mutable_party_id() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.PartyMatchmakerAdd.party_id)
  return _internal_mutable_party_id();
}
inline const std::string& PartyMatchmakerAdd::_internal_party_id() const {
  return party_id_.Get();
}
inline void PartyMatchmakerAdd::_internal_set_party_id(const std::string& value) {
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PartyMatchmakerAdd::set_party_id(std::string&& value) {
  
  party_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.PartyMatchmakerAdd.party_id)
}
inline void PartyMatchmakerAdd::set_party_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.PartyMatchmakerAdd.party_id)
}
inline void PartyMatchmakerAdd::set_party_id(const char* value,
    size_t size) {
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.PartyMatchmakerAdd.party_id)
}
inline std::string* PartyMatchmakerAdd::_internal_mutable_party_id() {
  
  return party_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PartyMatchmakerAdd::release_party_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.PartyMatchmakerAdd.party_id)
  return party_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PartyMatchmakerAdd::set_allocated_party_id(std::string* party_id) {
  if (party_id != nullptr) {
    
  } else {
    
  }
  party_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), party_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.PartyMatchmakerAdd.party_id)
}

// int32 min_count = 2;
inline void PartyMatchmakerAdd::clear_min_count() {
  min_count_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PartyMatchmakerAdd::_internal_min_count() const {
  return min_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PartyMatchmakerAdd::min_count() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.PartyMatchmakerAdd.min_count)
  return _internal_min_count();
}
inline void PartyMatchmakerAdd::_internal_set_min_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  min_count_ = value;
}
inline void PartyMatchmakerAdd::set_min_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_min_count(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.PartyMatchmakerAdd.min_count)
}

// int32 max_count = 3;
inline void PartyMatchmakerAdd::clear_max_count() {
  max_count_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PartyMatchmakerAdd::_internal_max_count() const {
  return max_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PartyMatchmakerAdd::max_count() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.PartyMatchmakerAdd.max_count)
  return _internal_max_count();
}
inline void PartyMatchmakerAdd::_internal_set_max_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  max_count_ = value;
}
inline void PartyMatchmakerAdd::set_max_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_max_count(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.PartyMatchmakerAdd.max_count)
}

// string query = 4;
inline void PartyMatchmakerAdd::clear_query() {
  query_.ClearToEmpty();
}
inline const std::string& PartyMatchmakerAdd::query() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.PartyMatchmakerAdd.query)
  return _internal_query();
}
inline void PartyMatchmakerAdd::set_query(const std::string& value) {
  _internal_set_query(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.PartyMatchmakerAdd.query)
}
inline std::string* PartyMatchmakerAdd::mutable_query() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.PartyMatchmakerAdd.query)
  return _internal_mutable_query();
}
inline const std::string& PartyMatchmakerAdd::_internal_query() const {
  return query_.Get();
}
inline void PartyMatchmakerAdd::_internal_set_query(const std::string& value) {
  
  query_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PartyMatchmakerAdd::set_query(std::string&& value) {
  
  query_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.PartyMatchmakerAdd.query)
}
inline void PartyMatchmakerAdd::set_query(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  query_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.PartyMatchmakerAdd.query)
}
inline void PartyMatchmakerAdd::set_query(const char* value,
    size_t size) {
  
  query_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.PartyMatchmakerAdd.query)
}
inline std::string* PartyMatchmakerAdd::_internal_mutable_query() {
  
  return query_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PartyMatchmakerAdd::release_query() {
  // @@protoc_insertion_point(field_release:nakama.realtime.PartyMatchmakerAdd.query)
  return query_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PartyMatchmakerAdd::set_allocated_query(std::string* query) {
  if (query != nullptr) {
    
  } else {
    
  }
  query_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), query,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.PartyMatchmakerAdd.query)
}

// map<string, string> string_properties = 5;
inline int PartyMatchmakerAdd::_internal_string_properties_size() const {
  return string_properties_.size();
}
inline int PartyMatchmakerAdd::string_properties_size() const {
  return _internal_string_properties_size();
}
inline void PartyMatchmakerAdd::clear_string_properties() {
  string_properties_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
PartyMatchmakerAdd::_internal_string_properties() const {
  return string_properties_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
PartyMatchmakerAdd::string_properties() const {
  // @@protoc_insertion_point(field_map:nakama.realtime.PartyMatchmakerAdd.string_properties)
  return _internal_string_properties();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
PartyMatchmakerAdd::_internal_mutable_string_properties() {
  return string_properties_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
PartyMatchmakerAdd::mutable_string_properties() {
  // @@protoc_insertion_point(field_mutable_map:nakama.realtime.PartyMatchmakerAdd.string_properties)
  return _internal_mutable_string_properties();
}

// map<string, double> numeric_properties = 6;
inline int PartyMatchmakerAdd::_internal_numeric_properties_size() const {
  return numeric_properties_.size();
}
inline int PartyMatchmakerAdd::numeric_properties_size() const {
  return _internal_numeric_properties_size();
}
inline void PartyMatchmakerAdd::clear_numeric_properties() {
  numeric_properties_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
PartyMatchmakerAdd::_internal_numeric_properties() const {
  return numeric_properties_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
PartyMatchmakerAdd::numeric_properties() const {
  // @@protoc_insertion_point(field_map:nakama.realtime.PartyMatchmakerAdd.numeric_properties)
  return _internal_numeric_properties();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
PartyMatchmakerAdd::_internal_mutable_numeric_properties() {
  return numeric_properties_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
PartyMatchmakerAdd::mutable_numeric_properties() {
  // @@protoc_insertion_point(field_mutable_map:nakama.realtime.PartyMatchmakerAdd.numeric_properties)
  return _internal_mutable_numeric_properties();
}

// .google.protobuf.Int32Value count_multiple = 7;
inline bool PartyMatchmakerAdd::_internal_has_count_multiple() const {
  return this != internal_default_instance() && count_multiple_ != nullptr;
}
inline bool PartyMatchmakerAdd::has_count_multiple() const {
  return _internal_has_count_multiple();
}
inline const PROTOBUF_NAMESPACE_ID::Int32Value& PartyMatchmakerAdd::_internal_count_multiple() const {
  const PROTOBUF_NAMESPACE_ID::Int32Value* p = count_multiple_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Int32Value&>(
      PROTOBUF_NAMESPACE_ID::_Int32Value_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Int32Value& PartyMatchmakerAdd::count_multiple() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.PartyMatchmakerAdd.count_multiple)
  return _internal_count_multiple();
}
inline void PartyMatchmakerAdd::unsafe_arena_set_allocated_count_multiple(
    PROTOBUF_NAMESPACE_ID::Int32Value* count_multiple) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(count_multiple_);
  }
  count_multiple_ = count_multiple;
  if (count_multiple) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.PartyMatchmakerAdd.count_multiple)
}
inline PROTOBUF_NAMESPACE_ID::Int32Value* PartyMatchmakerAdd::release_count_multiple() {
  
  PROTOBUF_NAMESPACE_ID::Int32Value* temp = count_multiple_;
  count_multiple_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Int32Value* PartyMatchmakerAdd::unsafe_arena_release_count_multiple() {
  // @@protoc_insertion_point(field_release:nakama.realtime.PartyMatchmakerAdd.count_multiple)
  
  PROTOBUF_NAMESPACE_ID::Int32Value* temp = count_multiple_;
  count_multiple_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Int32Value* PartyMatchmakerAdd::_internal_mutable_count_multiple() {
  
  if (count_multiple_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Int32Value>(GetArena());
    count_multiple_ = p;
  }
  return count_multiple_;
}
inline PROTOBUF_NAMESPACE_ID::Int32Value* PartyMatchmakerAdd::mutable_count_multiple() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.PartyMatchmakerAdd.count_multiple)
  return _internal_mutable_count_multiple();
}
inline void PartyMatchmakerAdd::set_allocated_count_multiple(PROTOBUF_NAMESPACE_ID::Int32Value* count_multiple) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(count_multiple_);
  }
  if (count_multiple) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(count_multiple)->GetArena();
    if (message_arena != submessage_arena) {
      count_multiple = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, count_multiple, submessage_arena);
    }
    
  } else {
    
  }
  count_multiple_ = count_multiple;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.PartyMatchmakerAdd.count_multiple)
}

// -------------------------------------------------------------------

// PartyMatchmakerRemove

// string party_id = 1;
inline void PartyMatchmakerRemove::clear_party_id() {
  party_id_.ClearToEmpty();
}
inline const std::string& PartyMatchmakerRemove::party_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.PartyMatchmakerRemove.party_id)
  return _internal_party_id();
}
inline void PartyMatchmakerRemove::set_party_id(const std::string& value) {
  _internal_set_party_id(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.PartyMatchmakerRemove.party_id)
}
inline std::string* PartyMatchmakerRemove::mutable_party_id() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.PartyMatchmakerRemove.party_id)
  return _internal_mutable_party_id();
}
inline const std::string& PartyMatchmakerRemove::_internal_party_id() const {
  return party_id_.Get();
}
inline void PartyMatchmakerRemove::_internal_set_party_id(const std::string& value) {
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PartyMatchmakerRemove::set_party_id(std::string&& value) {
  
  party_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.PartyMatchmakerRemove.party_id)
}
inline void PartyMatchmakerRemove::set_party_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.PartyMatchmakerRemove.party_id)
}
inline void PartyMatchmakerRemove::set_party_id(const char* value,
    size_t size) {
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.PartyMatchmakerRemove.party_id)
}
inline std::string* PartyMatchmakerRemove::_internal_mutable_party_id() {
  
  return party_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PartyMatchmakerRemove::release_party_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.PartyMatchmakerRemove.party_id)
  return party_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PartyMatchmakerRemove::set_allocated_party_id(std::string* party_id) {
  if (party_id != nullptr) {
    
  } else {
    
  }
  party_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), party_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.PartyMatchmakerRemove.party_id)
}

// string ticket = 2;
inline void PartyMatchmakerRemove::clear_ticket() {
  ticket_.ClearToEmpty();
}
inline const std::string& PartyMatchmakerRemove::ticket() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.PartyMatchmakerRemove.ticket)
  return _internal_ticket();
}
inline void PartyMatchmakerRemove::set_ticket(const std::string& value) {
  _internal_set_ticket(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.PartyMatchmakerRemove.ticket)
}
inline std::string* PartyMatchmakerRemove::mutable_ticket() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.PartyMatchmakerRemove.ticket)
  return _internal_mutable_ticket();
}
inline const std::string& PartyMatchmakerRemove::_internal_ticket() const {
  return ticket_.Get();
}
inline void PartyMatchmakerRemove::_internal_set_ticket(const std::string& value) {
  
  ticket_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PartyMatchmakerRemove::set_ticket(std::string&& value) {
  
  ticket_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.PartyMatchmakerRemove.ticket)
}
inline void PartyMatchmakerRemove::set_ticket(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  ticket_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.PartyMatchmakerRemove.ticket)
}
inline void PartyMatchmakerRemove::set_ticket(const char* value,
    size_t size) {
  
  ticket_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.PartyMatchmakerRemove.ticket)
}
inline std::string* PartyMatchmakerRemove::_internal_mutable_ticket() {
  
  return ticket_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PartyMatchmakerRemove::release_ticket() {
  // @@protoc_insertion_point(field_release:nakama.realtime.PartyMatchmakerRemove.ticket)
  return ticket_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PartyMatchmakerRemove::set_allocated_ticket(std::string* ticket) {
  if (ticket != nullptr) {
    
  } else {
    
  }
  ticket_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ticket,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.PartyMatchmakerRemove.ticket)
}

// -------------------------------------------------------------------

// PartyMatchmakerTicket

// string party_id = 1;
inline void PartyMatchmakerTicket::clear_party_id() {
  party_id_.ClearToEmpty();
}
inline const std::string& PartyMatchmakerTicket::party_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.PartyMatchmakerTicket.party_id)
  return _internal_party_id();
}
inline void PartyMatchmakerTicket::set_party_id(const std::string& value) {
  _internal_set_party_id(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.PartyMatchmakerTicket.party_id)
}
inline std::string* PartyMatchmakerTicket::mutable_party_id() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.PartyMatchmakerTicket.party_id)
  return _internal_mutable_party_id();
}
inline const std::string& PartyMatchmakerTicket::_internal_party_id() const {
  return party_id_.Get();
}
inline void PartyMatchmakerTicket::_internal_set_party_id(const std::string& value) {
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PartyMatchmakerTicket::set_party_id(std::string&& value) {
  
  party_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.PartyMatchmakerTicket.party_id)
}
inline void PartyMatchmakerTicket::set_party_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.PartyMatchmakerTicket.party_id)
}
inline void PartyMatchmakerTicket::set_party_id(const char* value,
    size_t size) {
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.PartyMatchmakerTicket.party_id)
}
inline std::string* PartyMatchmakerTicket::_internal_mutable_party_id() {
  
  return party_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PartyMatchmakerTicket::release_party_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.PartyMatchmakerTicket.party_id)
  return party_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PartyMatchmakerTicket::set_allocated_party_id(std::string* party_id) {
  if (party_id != nullptr) {
    
  } else {
    
  }
  party_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), party_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.PartyMatchmakerTicket.party_id)
}

// string ticket = 2;
inline void PartyMatchmakerTicket::clear_ticket() {
  ticket_.ClearToEmpty();
}
inline const std::string& PartyMatchmakerTicket::ticket() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.PartyMatchmakerTicket.ticket)
  return _internal_ticket();
}
inline void PartyMatchmakerTicket::set_ticket(const std::string& value) {
  _internal_set_ticket(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.PartyMatchmakerTicket.ticket)
}
inline std::string* PartyMatchmakerTicket::mutable_ticket() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.PartyMatchmakerTicket.ticket)
  return _internal_mutable_ticket();
}
inline const std::string& PartyMatchmakerTicket::_internal_ticket() const {
  return ticket_.Get();
}
inline void PartyMatchmakerTicket::_internal_set_ticket(const std::string& value) {
  
  ticket_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PartyMatchmakerTicket::set_ticket(std::string&& value) {
  
  ticket_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.PartyMatchmakerTicket.ticket)
}
inline void PartyMatchmakerTicket::set_ticket(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  ticket_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.PartyMatchmakerTicket.ticket)
}
inline void PartyMatchmakerTicket::set_ticket(const char* value,
    size_t size) {
  
  ticket_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.PartyMatchmakerTicket.ticket)
}
inline std::string* PartyMatchmakerTicket::_internal_mutable_ticket() {
  
  return ticket_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PartyMatchmakerTicket::release_ticket() {
  // @@protoc_insertion_point(field_release:nakama.realtime.PartyMatchmakerTicket.ticket)
  return ticket_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PartyMatchmakerTicket::set_allocated_ticket(std::string* ticket) {
  if (ticket != nullptr) {
    
  } else {
    
  }
  ticket_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ticket,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.PartyMatchmakerTicket.ticket)
}

// -------------------------------------------------------------------

// PartyData

// string party_id = 1;
inline void PartyData::clear_party_id() {
  party_id_.ClearToEmpty();
}
inline const std::string& PartyData::party_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.PartyData.party_id)
  return _internal_party_id();
}
inline void PartyData::set_party_id(const std::string& value) {
  _internal_set_party_id(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.PartyData.party_id)
}
inline std::string* PartyData::mutable_party_id() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.PartyData.party_id)
  return _internal_mutable_party_id();
}
inline const std::string& PartyData::_internal_party_id() const {
  return party_id_.Get();
}
inline void PartyData::_internal_set_party_id(const std::string& value) {
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PartyData::set_party_id(std::string&& value) {
  
  party_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.PartyData.party_id)
}
inline void PartyData::set_party_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.PartyData.party_id)
}
inline void PartyData::set_party_id(const char* value,
    size_t size) {
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.PartyData.party_id)
}
inline std::string* PartyData::_internal_mutable_party_id() {
  
  return party_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PartyData::release_party_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.PartyData.party_id)
  return party_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PartyData::set_allocated_party_id(std::string* party_id) {
  if (party_id != nullptr) {
    
  } else {
    
  }
  party_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), party_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.PartyData.party_id)
}

// .nakama.realtime.UserPresence presence = 2;
inline bool PartyData::_internal_has_presence() const {
  return this != internal_default_instance() && presence_ != nullptr;
}
inline bool PartyData::has_presence() const {
  return _internal_has_presence();
}
inline void PartyData::clear_presence() {
  if (GetArena() == nullptr && presence_ != nullptr) {
    delete presence_;
  }
  presence_ = nullptr;
}
inline const ::nakama::realtime::UserPresence& PartyData::_internal_presence() const {
  const ::nakama::realtime::UserPresence* p = presence_;
  return p != nullptr ? *p : reinterpret_cast<const ::nakama::realtime::UserPresence&>(
      ::nakama::realtime::_UserPresence_default_instance_);
}
inline const ::nakama::realtime::UserPresence& PartyData::presence() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.PartyData.presence)
  return _internal_presence();
}
inline void PartyData::unsafe_arena_set_allocated_presence(
    ::nakama::realtime::UserPresence* presence) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(presence_);
  }
  presence_ = presence;
  if (presence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.PartyData.presence)
}
inline ::nakama::realtime::UserPresence* PartyData::release_presence() {
  
  ::nakama::realtime::UserPresence* temp = presence_;
  presence_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::nakama::realtime::UserPresence* PartyData::unsafe_arena_release_presence() {
  // @@protoc_insertion_point(field_release:nakama.realtime.PartyData.presence)
  
  ::nakama::realtime::UserPresence* temp = presence_;
  presence_ = nullptr;
  return temp;
}
inline ::nakama::realtime::UserPresence* PartyData::_internal_mutable_presence() {
  
  if (presence_ == nullptr) {
    auto* p = CreateMaybeMessage<::nakama::realtime::UserPresence>(GetArena());
    presence_ = p;
  }
  return presence_;
}
inline ::nakama::realtime::UserPresence* PartyData::mutable_presence() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.PartyData.presence)
  return _internal_mutable_presence();
}
inline void PartyData::set_allocated_presence(::nakama::realtime::UserPresence* presence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete presence_;
  }
  if (presence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(presence);
    if (message_arena != submessage_arena) {
      presence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, presence, submessage_arena);
    }
    
  } else {
    
  }
  presence_ = presence;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.PartyData.presence)
}

// int64 op_code = 3;
inline void PartyData::clear_op_code() {
  op_code_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PartyData::_internal_op_code() const {
  return op_code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PartyData::op_code() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.PartyData.op_code)
  return _internal_op_code();
}
inline void PartyData::_internal_set_op_code(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  op_code_ = value;
}
inline void PartyData::set_op_code(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_op_code(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.PartyData.op_code)
}

// bytes data = 4;
inline void PartyData::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& PartyData::data() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.PartyData.data)
  return _internal_data();
}
inline void PartyData::set_data(const std::string& value) {
  _internal_set_data(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.PartyData.data)
}
inline std::string* PartyData::mutable_data() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.PartyData.data)
  return _internal_mutable_data();
}
inline const std::string& PartyData::_internal_data() const {
  return data_.Get();
}
inline void PartyData::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PartyData::set_data(std::string&& value) {
  
  data_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.PartyData.data)
}
inline void PartyData::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.PartyData.data)
}
inline void PartyData::set_data(const void* value,
    size_t size) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.PartyData.data)
}
inline std::string* PartyData::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PartyData::release_data() {
  // @@protoc_insertion_point(field_release:nakama.realtime.PartyData.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PartyData::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.PartyData.data)
}

// -------------------------------------------------------------------

// PartyDataSend

// string party_id = 1;
inline void PartyDataSend::clear_party_id() {
  party_id_.ClearToEmpty();
}
inline const std::string& PartyDataSend::party_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.PartyDataSend.party_id)
  return _internal_party_id();
}
inline void PartyDataSend::set_party_id(const std::string& value) {
  _internal_set_party_id(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.PartyDataSend.party_id)
}
inline std::string* PartyDataSend::mutable_party_id() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.PartyDataSend.party_id)
  return _internal_mutable_party_id();
}
inline const std::string& PartyDataSend::_internal_party_id() const {
  return party_id_.Get();
}
inline void PartyDataSend::_internal_set_party_id(const std::string& value) {
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PartyDataSend::set_party_id(std::string&& value) {
  
  party_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.PartyDataSend.party_id)
}
inline void PartyDataSend::set_party_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.PartyDataSend.party_id)
}
inline void PartyDataSend::set_party_id(const char* value,
    size_t size) {
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.PartyDataSend.party_id)
}
inline std::string* PartyDataSend::_internal_mutable_party_id() {
  
  return party_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PartyDataSend::release_party_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.PartyDataSend.party_id)
  return party_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PartyDataSend::set_allocated_party_id(std::string* party_id) {
  if (party_id != nullptr) {
    
  } else {
    
  }
  party_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), party_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.PartyDataSend.party_id)
}

// int64 op_code = 2;
inline void PartyDataSend::clear_op_code() {
  op_code_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PartyDataSend::_internal_op_code() const {
  return op_code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PartyDataSend::op_code() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.PartyDataSend.op_code)
  return _internal_op_code();
}
inline void PartyDataSend::_internal_set_op_code(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  op_code_ = value;
}
inline void PartyDataSend::set_op_code(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_op_code(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.PartyDataSend.op_code)
}

// bytes data = 3;
inline void PartyDataSend::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& PartyDataSend::data() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.PartyDataSend.data)
  return _internal_data();
}
inline void PartyDataSend::set_data(const std::string& value) {
  _internal_set_data(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.PartyDataSend.data)
}
inline std::string* PartyDataSend::mutable_data() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.PartyDataSend.data)
  return _internal_mutable_data();
}
inline const std::string& PartyDataSend::_internal_data() const {
  return data_.Get();
}
inline void PartyDataSend::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PartyDataSend::set_data(std::string&& value) {
  
  data_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.PartyDataSend.data)
}
inline void PartyDataSend::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.PartyDataSend.data)
}
inline void PartyDataSend::set_data(const void* value,
    size_t size) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.PartyDataSend.data)
}
inline std::string* PartyDataSend::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PartyDataSend::release_data() {
  // @@protoc_insertion_point(field_release:nakama.realtime.PartyDataSend.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PartyDataSend::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.PartyDataSend.data)
}

// -------------------------------------------------------------------

// PartyPresenceEvent

// string party_id = 1;
inline void PartyPresenceEvent::clear_party_id() {
  party_id_.ClearToEmpty();
}
inline const std::string& PartyPresenceEvent::party_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.PartyPresenceEvent.party_id)
  return _internal_party_id();
}
inline void PartyPresenceEvent::set_party_id(const std::string& value) {
  _internal_set_party_id(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.PartyPresenceEvent.party_id)
}
inline std::string* PartyPresenceEvent::mutable_party_id() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.PartyPresenceEvent.party_id)
  return _internal_mutable_party_id();
}
inline const std::string& PartyPresenceEvent::_internal_party_id() const {
  return party_id_.Get();
}
inline void PartyPresenceEvent::_internal_set_party_id(const std::string& value) {
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PartyPresenceEvent::set_party_id(std::string&& value) {
  
  party_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.PartyPresenceEvent.party_id)
}
inline void PartyPresenceEvent::set_party_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.PartyPresenceEvent.party_id)
}
inline void PartyPresenceEvent::set_party_id(const char* value,
    size_t size) {
  
  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.PartyPresenceEvent.party_id)
}
inline std::string* PartyPresenceEvent::_internal_mutable_party_id() {
  
  return party_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PartyPresenceEvent::release_party_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.PartyPresenceEvent.party_id)
  return party_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PartyPresenceEvent::set_allocated_party_id(std::string* party_id) {
  if (party_id != nullptr) {
    
  } else {
    
  }
  party_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), party_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.PartyPresenceEvent.party_id)
}

// repeated .nakama.realtime.UserPresence joins = 2;
inline int PartyPresenceEvent::_internal_joins_size() const {
  return joins_.size();
}
inline int PartyPresenceEvent::joins_size() const {
  return _internal_joins_size();
}
inline void PartyPresenceEvent::clear_joins() {
  joins_.Clear();
}
inline ::nakama::realtime::UserPresence* PartyPresenceEvent::mutable_joins(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.PartyPresenceEvent.joins)
  return joins_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >*
PartyPresenceEvent::mutable_joins() {
  // @@protoc_insertion_point(field_mutable_list:nakama.realtime.PartyPresenceEvent.joins)
  return &joins_;
}
inline const ::nakama::realtime::UserPresence& PartyPresenceEvent::_internal_joins(int index) const {
  return joins_.Get(index);
}
inline const ::nakama::realtime::UserPresence& PartyPresenceEvent::joins(int index) const {
  // @@protoc_insertion_point(field_get:nakama.realtime.PartyPresenceEvent.joins)
  return _internal_joins(index);
}
inline ::nakama::realtime::UserPresence* PartyPresenceEvent::_internal_add_joins() {
  return joins_.Add();
}
inline ::nakama::realtime::UserPresence* PartyPresenceEvent::add_joins() {
  // @@protoc_insertion_point(field_add:nakama.realtime.PartyPresenceEvent.joins)
  return _internal_add_joins();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >&
PartyPresenceEvent::joins() const {
  // @@protoc_insertion_point(field_list:nakama.realtime.PartyPresenceEvent.joins)
  return joins_;
}

// repeated .nakama.realtime.UserPresence leaves = 3;
inline int PartyPresenceEvent::_internal_leaves_size() const {
  return leaves_.size();
}
inline int PartyPresenceEvent::leaves_size() const {
  return _internal_leaves_size();
}
inline void PartyPresenceEvent::clear_leaves() {
  leaves_.Clear();
}
inline ::nakama::realtime::UserPresence* PartyPresenceEvent::mutable_leaves(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.PartyPresenceEvent.leaves)
  return leaves_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >*
PartyPresenceEvent::mutable_leaves() {
  // @@protoc_insertion_point(field_mutable_list:nakama.realtime.PartyPresenceEvent.leaves)
  return &leaves_;
}
inline const ::nakama::realtime::UserPresence& PartyPresenceEvent::_internal_leaves(int index) const {
  return leaves_.Get(index);
}
inline const ::nakama::realtime::UserPresence& PartyPresenceEvent::leaves(int index) const {
  // @@protoc_insertion_point(field_get:nakama.realtime.PartyPresenceEvent.leaves)
  return _internal_leaves(index);
}
inline ::nakama::realtime::UserPresence* PartyPresenceEvent::_internal_add_leaves() {
  return leaves_.Add();
}
inline ::nakama::realtime::UserPresence* PartyPresenceEvent::add_leaves() {
  // @@protoc_insertion_point(field_add:nakama.realtime.PartyPresenceEvent.leaves)
  return _internal_add_leaves();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >&
PartyPresenceEvent::leaves() const {
  // @@protoc_insertion_point(field_list:nakama.realtime.PartyPresenceEvent.leaves)
  return leaves_;
}

// -------------------------------------------------------------------

// Ping

// -------------------------------------------------------------------

// Pong

// -------------------------------------------------------------------

// Status

// repeated .nakama.realtime.UserPresence presences = 1;
inline int Status::_internal_presences_size() const {
  return presences_.size();
}
inline int Status::presences_size() const {
  return _internal_presences_size();
}
inline void Status::clear_presences() {
  presences_.Clear();
}
inline ::nakama::realtime::UserPresence* Status::mutable_presences(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Status.presences)
  return presences_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >*
Status::mutable_presences() {
  // @@protoc_insertion_point(field_mutable_list:nakama.realtime.Status.presences)
  return &presences_;
}
inline const ::nakama::realtime::UserPresence& Status::_internal_presences(int index) const {
  return presences_.Get(index);
}
inline const ::nakama::realtime::UserPresence& Status::presences(int index) const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Status.presences)
  return _internal_presences(index);
}
inline ::nakama::realtime::UserPresence* Status::_internal_add_presences() {
  return presences_.Add();
}
inline ::nakama::realtime::UserPresence* Status::add_presences() {
  // @@protoc_insertion_point(field_add:nakama.realtime.Status.presences)
  return _internal_add_presences();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >&
Status::presences() const {
  // @@protoc_insertion_point(field_list:nakama.realtime.Status.presences)
  return presences_;
}

// -------------------------------------------------------------------

// StatusFollow

// repeated string user_ids = 1;
inline int StatusFollow::_internal_user_ids_size() const {
  return user_ids_.size();
}
inline int StatusFollow::user_ids_size() const {
  return _internal_user_ids_size();
}
inline void StatusFollow::clear_user_ids() {
  user_ids_.Clear();
}
inline std::string* StatusFollow::add_user_ids() {
  // @@protoc_insertion_point(field_add_mutable:nakama.realtime.StatusFollow.user_ids)
  return _internal_add_user_ids();
}
inline const std::string& StatusFollow::_internal_user_ids(int index) const {
  return user_ids_.Get(index);
}
inline const std::string& StatusFollow::user_ids(int index) const {
  // @@protoc_insertion_point(field_get:nakama.realtime.StatusFollow.user_ids)
  return _internal_user_ids(index);
}
inline std::string* StatusFollow::mutable_user_ids(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.StatusFollow.user_ids)
  return user_ids_.Mutable(index);
}
inline void StatusFollow::set_user_ids(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:nakama.realtime.StatusFollow.user_ids)
  user_ids_.Mutable(index)->assign(value);
}
inline void StatusFollow::set_user_ids(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:nakama.realtime.StatusFollow.user_ids)
  user_ids_.Mutable(index)->assign(std::move(value));
}
inline void StatusFollow::set_user_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  user_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nakama.realtime.StatusFollow.user_ids)
}
inline void StatusFollow::set_user_ids(int index, const char* value, size_t size) {
  user_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.StatusFollow.user_ids)
}
inline std::string* StatusFollow::_internal_add_user_ids() {
  return user_ids_.Add();
}
inline void StatusFollow::add_user_ids(const std::string& value) {
  user_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:nakama.realtime.StatusFollow.user_ids)
}
inline void StatusFollow::add_user_ids(std::string&& value) {
  user_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:nakama.realtime.StatusFollow.user_ids)
}
inline void StatusFollow::add_user_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  user_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nakama.realtime.StatusFollow.user_ids)
}
inline void StatusFollow::add_user_ids(const char* value, size_t size) {
  user_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nakama.realtime.StatusFollow.user_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StatusFollow::user_ids() const {
  // @@protoc_insertion_point(field_list:nakama.realtime.StatusFollow.user_ids)
  return user_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StatusFollow::mutable_user_ids() {
  // @@protoc_insertion_point(field_mutable_list:nakama.realtime.StatusFollow.user_ids)
  return &user_ids_;
}

// repeated string usernames = 2;
inline int StatusFollow::_internal_usernames_size() const {
  return usernames_.size();
}
inline int StatusFollow::usernames_size() const {
  return _internal_usernames_size();
}
inline void StatusFollow::clear_usernames() {
  usernames_.Clear();
}
inline std::string* StatusFollow::add_usernames() {
  // @@protoc_insertion_point(field_add_mutable:nakama.realtime.StatusFollow.usernames)
  return _internal_add_usernames();
}
inline const std::string& StatusFollow::_internal_usernames(int index) const {
  return usernames_.Get(index);
}
inline const std::string& StatusFollow::usernames(int index) const {
  // @@protoc_insertion_point(field_get:nakama.realtime.StatusFollow.usernames)
  return _internal_usernames(index);
}
inline std::string* StatusFollow::mutable_usernames(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.StatusFollow.usernames)
  return usernames_.Mutable(index);
}
inline void StatusFollow::set_usernames(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:nakama.realtime.StatusFollow.usernames)
  usernames_.Mutable(index)->assign(value);
}
inline void StatusFollow::set_usernames(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:nakama.realtime.StatusFollow.usernames)
  usernames_.Mutable(index)->assign(std::move(value));
}
inline void StatusFollow::set_usernames(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  usernames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nakama.realtime.StatusFollow.usernames)
}
inline void StatusFollow::set_usernames(int index, const char* value, size_t size) {
  usernames_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.StatusFollow.usernames)
}
inline std::string* StatusFollow::_internal_add_usernames() {
  return usernames_.Add();
}
inline void StatusFollow::add_usernames(const std::string& value) {
  usernames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:nakama.realtime.StatusFollow.usernames)
}
inline void StatusFollow::add_usernames(std::string&& value) {
  usernames_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:nakama.realtime.StatusFollow.usernames)
}
inline void StatusFollow::add_usernames(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  usernames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nakama.realtime.StatusFollow.usernames)
}
inline void StatusFollow::add_usernames(const char* value, size_t size) {
  usernames_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nakama.realtime.StatusFollow.usernames)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StatusFollow::usernames() const {
  // @@protoc_insertion_point(field_list:nakama.realtime.StatusFollow.usernames)
  return usernames_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StatusFollow::mutable_usernames() {
  // @@protoc_insertion_point(field_mutable_list:nakama.realtime.StatusFollow.usernames)
  return &usernames_;
}

// -------------------------------------------------------------------

// StatusPresenceEvent

// repeated .nakama.realtime.UserPresence joins = 2;
inline int StatusPresenceEvent::_internal_joins_size() const {
  return joins_.size();
}
inline int StatusPresenceEvent::joins_size() const {
  return _internal_joins_size();
}
inline void StatusPresenceEvent::clear_joins() {
  joins_.Clear();
}
inline ::nakama::realtime::UserPresence* StatusPresenceEvent::mutable_joins(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.StatusPresenceEvent.joins)
  return joins_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >*
StatusPresenceEvent::mutable_joins() {
  // @@protoc_insertion_point(field_mutable_list:nakama.realtime.StatusPresenceEvent.joins)
  return &joins_;
}
inline const ::nakama::realtime::UserPresence& StatusPresenceEvent::_internal_joins(int index) const {
  return joins_.Get(index);
}
inline const ::nakama::realtime::UserPresence& StatusPresenceEvent::joins(int index) const {
  // @@protoc_insertion_point(field_get:nakama.realtime.StatusPresenceEvent.joins)
  return _internal_joins(index);
}
inline ::nakama::realtime::UserPresence* StatusPresenceEvent::_internal_add_joins() {
  return joins_.Add();
}
inline ::nakama::realtime::UserPresence* StatusPresenceEvent::add_joins() {
  // @@protoc_insertion_point(field_add:nakama.realtime.StatusPresenceEvent.joins)
  return _internal_add_joins();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >&
StatusPresenceEvent::joins() const {
  // @@protoc_insertion_point(field_list:nakama.realtime.StatusPresenceEvent.joins)
  return joins_;
}

// repeated .nakama.realtime.UserPresence leaves = 3;
inline int StatusPresenceEvent::_internal_leaves_size() const {
  return leaves_.size();
}
inline int StatusPresenceEvent::leaves_size() const {
  return _internal_leaves_size();
}
inline void StatusPresenceEvent::clear_leaves() {
  leaves_.Clear();
}
inline ::nakama::realtime::UserPresence* StatusPresenceEvent::mutable_leaves(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.StatusPresenceEvent.leaves)
  return leaves_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >*
StatusPresenceEvent::mutable_leaves() {
  // @@protoc_insertion_point(field_mutable_list:nakama.realtime.StatusPresenceEvent.leaves)
  return &leaves_;
}
inline const ::nakama::realtime::UserPresence& StatusPresenceEvent::_internal_leaves(int index) const {
  return leaves_.Get(index);
}
inline const ::nakama::realtime::UserPresence& StatusPresenceEvent::leaves(int index) const {
  // @@protoc_insertion_point(field_get:nakama.realtime.StatusPresenceEvent.leaves)
  return _internal_leaves(index);
}
inline ::nakama::realtime::UserPresence* StatusPresenceEvent::_internal_add_leaves() {
  return leaves_.Add();
}
inline ::nakama::realtime::UserPresence* StatusPresenceEvent::add_leaves() {
  // @@protoc_insertion_point(field_add:nakama.realtime.StatusPresenceEvent.leaves)
  return _internal_add_leaves();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >&
StatusPresenceEvent::leaves() const {
  // @@protoc_insertion_point(field_list:nakama.realtime.StatusPresenceEvent.leaves)
  return leaves_;
}

// -------------------------------------------------------------------

// StatusUnfollow

// repeated string user_ids = 1;
inline int StatusUnfollow::_internal_user_ids_size() const {
  return user_ids_.size();
}
inline int StatusUnfollow::user_ids_size() const {
  return _internal_user_ids_size();
}
inline void StatusUnfollow::clear_user_ids() {
  user_ids_.Clear();
}
inline std::string* StatusUnfollow::add_user_ids() {
  // @@protoc_insertion_point(field_add_mutable:nakama.realtime.StatusUnfollow.user_ids)
  return _internal_add_user_ids();
}
inline const std::string& StatusUnfollow::_internal_user_ids(int index) const {
  return user_ids_.Get(index);
}
inline const std::string& StatusUnfollow::user_ids(int index) const {
  // @@protoc_insertion_point(field_get:nakama.realtime.StatusUnfollow.user_ids)
  return _internal_user_ids(index);
}
inline std::string* StatusUnfollow::mutable_user_ids(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.StatusUnfollow.user_ids)
  return user_ids_.Mutable(index);
}
inline void StatusUnfollow::set_user_ids(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:nakama.realtime.StatusUnfollow.user_ids)
  user_ids_.Mutable(index)->assign(value);
}
inline void StatusUnfollow::set_user_ids(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:nakama.realtime.StatusUnfollow.user_ids)
  user_ids_.Mutable(index)->assign(std::move(value));
}
inline void StatusUnfollow::set_user_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  user_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nakama.realtime.StatusUnfollow.user_ids)
}
inline void StatusUnfollow::set_user_ids(int index, const char* value, size_t size) {
  user_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.StatusUnfollow.user_ids)
}
inline std::string* StatusUnfollow::_internal_add_user_ids() {
  return user_ids_.Add();
}
inline void StatusUnfollow::add_user_ids(const std::string& value) {
  user_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:nakama.realtime.StatusUnfollow.user_ids)
}
inline void StatusUnfollow::add_user_ids(std::string&& value) {
  user_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:nakama.realtime.StatusUnfollow.user_ids)
}
inline void StatusUnfollow::add_user_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  user_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nakama.realtime.StatusUnfollow.user_ids)
}
inline void StatusUnfollow::add_user_ids(const char* value, size_t size) {
  user_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nakama.realtime.StatusUnfollow.user_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StatusUnfollow::user_ids() const {
  // @@protoc_insertion_point(field_list:nakama.realtime.StatusUnfollow.user_ids)
  return user_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StatusUnfollow::mutable_user_ids() {
  // @@protoc_insertion_point(field_mutable_list:nakama.realtime.StatusUnfollow.user_ids)
  return &user_ids_;
}

// -------------------------------------------------------------------

// StatusUpdate

// .google.protobuf.StringValue status = 1;
inline bool StatusUpdate::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool StatusUpdate::has_status() const {
  return _internal_has_status();
}
inline const PROTOBUF_NAMESPACE_ID::StringValue& StatusUpdate::_internal_status() const {
  const PROTOBUF_NAMESPACE_ID::StringValue* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::StringValue&>(
      PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::StringValue& StatusUpdate::status() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.StatusUpdate.status)
  return _internal_status();
}
inline void StatusUpdate::unsafe_arena_set_allocated_status(
    PROTOBUF_NAMESPACE_ID::StringValue* status) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.StatusUpdate.status)
}
inline PROTOBUF_NAMESPACE_ID::StringValue* StatusUpdate::release_status() {
  
  PROTOBUF_NAMESPACE_ID::StringValue* temp = status_;
  status_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::StringValue* StatusUpdate::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:nakama.realtime.StatusUpdate.status)
  
  PROTOBUF_NAMESPACE_ID::StringValue* temp = status_;
  status_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::StringValue* StatusUpdate::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::StringValue>(GetArena());
    status_ = p;
  }
  return status_;
}
inline PROTOBUF_NAMESPACE_ID::StringValue* StatusUpdate::mutable_status() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.StatusUpdate.status)
  return _internal_mutable_status();
}
inline void StatusUpdate::set_allocated_status(PROTOBUF_NAMESPACE_ID::StringValue* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status)->GetArena();
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.StatusUpdate.status)
}

// -------------------------------------------------------------------

// Stream

// int32 mode = 1;
inline void Stream::clear_mode() {
  mode_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Stream::_internal_mode() const {
  return mode_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Stream::mode() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Stream.mode)
  return _internal_mode();
}
inline void Stream::_internal_set_mode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  mode_ = value;
}
inline void Stream::set_mode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.Stream.mode)
}

// string subject = 2;
inline void Stream::clear_subject() {
  subject_.ClearToEmpty();
}
inline const std::string& Stream::subject() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Stream.subject)
  return _internal_subject();
}
inline void Stream::set_subject(const std::string& value) {
  _internal_set_subject(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.Stream.subject)
}
inline std::string* Stream::mutable_subject() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Stream.subject)
  return _internal_mutable_subject();
}
inline const std::string& Stream::_internal_subject() const {
  return subject_.Get();
}
inline void Stream::_internal_set_subject(const std::string& value) {
  
  subject_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Stream::set_subject(std::string&& value) {
  
  subject_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.Stream.subject)
}
inline void Stream::set_subject(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  subject_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.Stream.subject)
}
inline void Stream::set_subject(const char* value,
    size_t size) {
  
  subject_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.Stream.subject)
}
inline std::string* Stream::_internal_mutable_subject() {
  
  return subject_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Stream::release_subject() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Stream.subject)
  return subject_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Stream::set_allocated_subject(std::string* subject) {
  if (subject != nullptr) {
    
  } else {
    
  }
  subject_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), subject,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.Stream.subject)
}

// string subcontext = 3;
inline void Stream::clear_subcontext() {
  subcontext_.ClearToEmpty();
}
inline const std::string& Stream::subcontext() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Stream.subcontext)
  return _internal_subcontext();
}
inline void Stream::set_subcontext(const std::string& value) {
  _internal_set_subcontext(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.Stream.subcontext)
}
inline std::string* Stream::mutable_subcontext() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Stream.subcontext)
  return _internal_mutable_subcontext();
}
inline const std::string& Stream::_internal_subcontext() const {
  return subcontext_.Get();
}
inline void Stream::_internal_set_subcontext(const std::string& value) {
  
  subcontext_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Stream::set_subcontext(std::string&& value) {
  
  subcontext_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.Stream.subcontext)
}
inline void Stream::set_subcontext(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  subcontext_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.Stream.subcontext)
}
inline void Stream::set_subcontext(const char* value,
    size_t size) {
  
  subcontext_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.Stream.subcontext)
}
inline std::string* Stream::_internal_mutable_subcontext() {
  
  return subcontext_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Stream::release_subcontext() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Stream.subcontext)
  return subcontext_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Stream::set_allocated_subcontext(std::string* subcontext) {
  if (subcontext != nullptr) {
    
  } else {
    
  }
  subcontext_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), subcontext,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.Stream.subcontext)
}

// string label = 4;
inline void Stream::clear_label() {
  label_.ClearToEmpty();
}
inline const std::string& Stream::label() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Stream.label)
  return _internal_label();
}
inline void Stream::set_label(const std::string& value) {
  _internal_set_label(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.Stream.label)
}
inline std::string* Stream::mutable_label() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Stream.label)
  return _internal_mutable_label();
}
inline const std::string& Stream::_internal_label() const {
  return label_.Get();
}
inline void Stream::_internal_set_label(const std::string& value) {
  
  label_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Stream::set_label(std::string&& value) {
  
  label_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.Stream.label)
}
inline void Stream::set_label(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  label_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.Stream.label)
}
inline void Stream::set_label(const char* value,
    size_t size) {
  
  label_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.Stream.label)
}
inline std::string* Stream::_internal_mutable_label() {
  
  return label_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Stream::release_label() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Stream.label)
  return label_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Stream::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    
  } else {
    
  }
  label_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), label,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.Stream.label)
}

// -------------------------------------------------------------------

// StreamData

// .nakama.realtime.Stream stream = 1;
inline bool StreamData::_internal_has_stream() const {
  return this != internal_default_instance() && stream_ != nullptr;
}
inline bool StreamData::has_stream() const {
  return _internal_has_stream();
}
inline void StreamData::clear_stream() {
  if (GetArena() == nullptr && stream_ != nullptr) {
    delete stream_;
  }
  stream_ = nullptr;
}
inline const ::nakama::realtime::Stream& StreamData::_internal_stream() const {
  const ::nakama::realtime::Stream* p = stream_;
  return p != nullptr ? *p : reinterpret_cast<const ::nakama::realtime::Stream&>(
      ::nakama::realtime::_Stream_default_instance_);
}
inline const ::nakama::realtime::Stream& StreamData::stream() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.StreamData.stream)
  return _internal_stream();
}
inline void StreamData::unsafe_arena_set_allocated_stream(
    ::nakama::realtime::Stream* stream) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stream_);
  }
  stream_ = stream;
  if (stream) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.StreamData.stream)
}
inline ::nakama::realtime::Stream* StreamData::release_stream() {
  
  ::nakama::realtime::Stream* temp = stream_;
  stream_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::nakama::realtime::Stream* StreamData::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_release:nakama.realtime.StreamData.stream)
  
  ::nakama::realtime::Stream* temp = stream_;
  stream_ = nullptr;
  return temp;
}
inline ::nakama::realtime::Stream* StreamData::_internal_mutable_stream() {
  
  if (stream_ == nullptr) {
    auto* p = CreateMaybeMessage<::nakama::realtime::Stream>(GetArena());
    stream_ = p;
  }
  return stream_;
}
inline ::nakama::realtime::Stream* StreamData::mutable_stream() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.StreamData.stream)
  return _internal_mutable_stream();
}
inline void StreamData::set_allocated_stream(::nakama::realtime::Stream* stream) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete stream_;
  }
  if (stream) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(stream);
    if (message_arena != submessage_arena) {
      stream = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    
  } else {
    
  }
  stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.StreamData.stream)
}

// .nakama.realtime.UserPresence sender = 2;
inline bool StreamData::_internal_has_sender() const {
  return this != internal_default_instance() && sender_ != nullptr;
}
inline bool StreamData::has_sender() const {
  return _internal_has_sender();
}
inline void StreamData::clear_sender() {
  if (GetArena() == nullptr && sender_ != nullptr) {
    delete sender_;
  }
  sender_ = nullptr;
}
inline const ::nakama::realtime::UserPresence& StreamData::_internal_sender() const {
  const ::nakama::realtime::UserPresence* p = sender_;
  return p != nullptr ? *p : reinterpret_cast<const ::nakama::realtime::UserPresence&>(
      ::nakama::realtime::_UserPresence_default_instance_);
}
inline const ::nakama::realtime::UserPresence& StreamData::sender() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.StreamData.sender)
  return _internal_sender();
}
inline void StreamData::unsafe_arena_set_allocated_sender(
    ::nakama::realtime::UserPresence* sender) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sender_);
  }
  sender_ = sender;
  if (sender) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.StreamData.sender)
}
inline ::nakama::realtime::UserPresence* StreamData::release_sender() {
  
  ::nakama::realtime::UserPresence* temp = sender_;
  sender_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::nakama::realtime::UserPresence* StreamData::unsafe_arena_release_sender() {
  // @@protoc_insertion_point(field_release:nakama.realtime.StreamData.sender)
  
  ::nakama::realtime::UserPresence* temp = sender_;
  sender_ = nullptr;
  return temp;
}
inline ::nakama::realtime::UserPresence* StreamData::_internal_mutable_sender() {
  
  if (sender_ == nullptr) {
    auto* p = CreateMaybeMessage<::nakama::realtime::UserPresence>(GetArena());
    sender_ = p;
  }
  return sender_;
}
inline ::nakama::realtime::UserPresence* StreamData::mutable_sender() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.StreamData.sender)
  return _internal_mutable_sender();
}
inline void StreamData::set_allocated_sender(::nakama::realtime::UserPresence* sender) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete sender_;
  }
  if (sender) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(sender);
    if (message_arena != submessage_arena) {
      sender = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sender, submessage_arena);
    }
    
  } else {
    
  }
  sender_ = sender;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.StreamData.sender)
}

// string data = 3;
inline void StreamData::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& StreamData::data() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.StreamData.data)
  return _internal_data();
}
inline void StreamData::set_data(const std::string& value) {
  _internal_set_data(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.StreamData.data)
}
inline std::string* StreamData::mutable_data() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.StreamData.data)
  return _internal_mutable_data();
}
inline const std::string& StreamData::_internal_data() const {
  return data_.Get();
}
inline void StreamData::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void StreamData::set_data(std::string&& value) {
  
  data_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.StreamData.data)
}
inline void StreamData::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.StreamData.data)
}
inline void StreamData::set_data(const char* value,
    size_t size) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.StreamData.data)
}
inline std::string* StreamData::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* StreamData::release_data() {
  // @@protoc_insertion_point(field_release:nakama.realtime.StreamData.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void StreamData::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.StreamData.data)
}

// bool reliable = 4;
inline void StreamData::clear_reliable() {
  reliable_ = false;
}
inline bool StreamData::_internal_reliable() const {
  return reliable_;
}
inline bool StreamData::reliable() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.StreamData.reliable)
  return _internal_reliable();
}
inline void StreamData::_internal_set_reliable(bool value) {
  
  reliable_ = value;
}
inline void StreamData::set_reliable(bool value) {
  _internal_set_reliable(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.StreamData.reliable)
}

// -------------------------------------------------------------------

// StreamPresenceEvent

// .nakama.realtime.Stream stream = 1;
inline bool StreamPresenceEvent::_internal_has_stream() const {
  return this != internal_default_instance() && stream_ != nullptr;
}
inline bool StreamPresenceEvent::has_stream() const {
  return _internal_has_stream();
}
inline void StreamPresenceEvent::clear_stream() {
  if (GetArena() == nullptr && stream_ != nullptr) {
    delete stream_;
  }
  stream_ = nullptr;
}
inline const ::nakama::realtime::Stream& StreamPresenceEvent::_internal_stream() const {
  const ::nakama::realtime::Stream* p = stream_;
  return p != nullptr ? *p : reinterpret_cast<const ::nakama::realtime::Stream&>(
      ::nakama::realtime::_Stream_default_instance_);
}
inline const ::nakama::realtime::Stream& StreamPresenceEvent::stream() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.StreamPresenceEvent.stream)
  return _internal_stream();
}
inline void StreamPresenceEvent::unsafe_arena_set_allocated_stream(
    ::nakama::realtime::Stream* stream) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stream_);
  }
  stream_ = stream;
  if (stream) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.StreamPresenceEvent.stream)
}
inline ::nakama::realtime::Stream* StreamPresenceEvent::release_stream() {
  
  ::nakama::realtime::Stream* temp = stream_;
  stream_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::nakama::realtime::Stream* StreamPresenceEvent::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_release:nakama.realtime.StreamPresenceEvent.stream)
  
  ::nakama::realtime::Stream* temp = stream_;
  stream_ = nullptr;
  return temp;
}
inline ::nakama::realtime::Stream* StreamPresenceEvent::_internal_mutable_stream() {
  
  if (stream_ == nullptr) {
    auto* p = CreateMaybeMessage<::nakama::realtime::Stream>(GetArena());
    stream_ = p;
  }
  return stream_;
}
inline ::nakama::realtime::Stream* StreamPresenceEvent::mutable_stream() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.StreamPresenceEvent.stream)
  return _internal_mutable_stream();
}
inline void StreamPresenceEvent::set_allocated_stream(::nakama::realtime::Stream* stream) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete stream_;
  }
  if (stream) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(stream);
    if (message_arena != submessage_arena) {
      stream = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    
  } else {
    
  }
  stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.StreamPresenceEvent.stream)
}

// repeated .nakama.realtime.UserPresence joins = 2;
inline int StreamPresenceEvent::_internal_joins_size() const {
  return joins_.size();
}
inline int StreamPresenceEvent::joins_size() const {
  return _internal_joins_size();
}
inline void StreamPresenceEvent::clear_joins() {
  joins_.Clear();
}
inline ::nakama::realtime::UserPresence* StreamPresenceEvent::mutable_joins(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.StreamPresenceEvent.joins)
  return joins_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >*
StreamPresenceEvent::mutable_joins() {
  // @@protoc_insertion_point(field_mutable_list:nakama.realtime.StreamPresenceEvent.joins)
  return &joins_;
}
inline const ::nakama::realtime::UserPresence& StreamPresenceEvent::_internal_joins(int index) const {
  return joins_.Get(index);
}
inline const ::nakama::realtime::UserPresence& StreamPresenceEvent::joins(int index) const {
  // @@protoc_insertion_point(field_get:nakama.realtime.StreamPresenceEvent.joins)
  return _internal_joins(index);
}
inline ::nakama::realtime::UserPresence* StreamPresenceEvent::_internal_add_joins() {
  return joins_.Add();
}
inline ::nakama::realtime::UserPresence* StreamPresenceEvent::add_joins() {
  // @@protoc_insertion_point(field_add:nakama.realtime.StreamPresenceEvent.joins)
  return _internal_add_joins();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >&
StreamPresenceEvent::joins() const {
  // @@protoc_insertion_point(field_list:nakama.realtime.StreamPresenceEvent.joins)
  return joins_;
}

// repeated .nakama.realtime.UserPresence leaves = 3;
inline int StreamPresenceEvent::_internal_leaves_size() const {
  return leaves_.size();
}
inline int StreamPresenceEvent::leaves_size() const {
  return _internal_leaves_size();
}
inline void StreamPresenceEvent::clear_leaves() {
  leaves_.Clear();
}
inline ::nakama::realtime::UserPresence* StreamPresenceEvent::mutable_leaves(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.StreamPresenceEvent.leaves)
  return leaves_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >*
StreamPresenceEvent::mutable_leaves() {
  // @@protoc_insertion_point(field_mutable_list:nakama.realtime.StreamPresenceEvent.leaves)
  return &leaves_;
}
inline const ::nakama::realtime::UserPresence& StreamPresenceEvent::_internal_leaves(int index) const {
  return leaves_.Get(index);
}
inline const ::nakama::realtime::UserPresence& StreamPresenceEvent::leaves(int index) const {
  // @@protoc_insertion_point(field_get:nakama.realtime.StreamPresenceEvent.leaves)
  return _internal_leaves(index);
}
inline ::nakama::realtime::UserPresence* StreamPresenceEvent::_internal_add_leaves() {
  return leaves_.Add();
}
inline ::nakama::realtime::UserPresence* StreamPresenceEvent::add_leaves() {
  // @@protoc_insertion_point(field_add:nakama.realtime.StreamPresenceEvent.leaves)
  return _internal_add_leaves();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nakama::realtime::UserPresence >&
StreamPresenceEvent::leaves() const {
  // @@protoc_insertion_point(field_list:nakama.realtime.StreamPresenceEvent.leaves)
  return leaves_;
}

// -------------------------------------------------------------------

// UserPresence

// string user_id = 1;
inline void UserPresence::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& UserPresence::user_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.UserPresence.user_id)
  return _internal_user_id();
}
inline void UserPresence::set_user_id(const std::string& value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.UserPresence.user_id)
}
inline std::string* UserPresence::mutable_user_id() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.UserPresence.user_id)
  return _internal_mutable_user_id();
}
inline const std::string& UserPresence::_internal_user_id() const {
  return user_id_.Get();
}
inline void UserPresence::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void UserPresence::set_user_id(std::string&& value) {
  
  user_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.UserPresence.user_id)
}
inline void UserPresence::set_user_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.UserPresence.user_id)
}
inline void UserPresence::set_user_id(const char* value,
    size_t size) {
  
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.UserPresence.user_id)
}
inline std::string* UserPresence::_internal_mutable_user_id() {
  
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* UserPresence::release_user_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.UserPresence.user_id)
  return user_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UserPresence::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.UserPresence.user_id)
}

// string session_id = 2;
inline void UserPresence::clear_session_id() {
  session_id_.ClearToEmpty();
}
inline const std::string& UserPresence::session_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.UserPresence.session_id)
  return _internal_session_id();
}
inline void UserPresence::set_session_id(const std::string& value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.UserPresence.session_id)
}
inline std::string* UserPresence::mutable_session_id() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.UserPresence.session_id)
  return _internal_mutable_session_id();
}
inline const std::string& UserPresence::_internal_session_id() const {
  return session_id_.Get();
}
inline void UserPresence::_internal_set_session_id(const std::string& value) {
  
  session_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void UserPresence::set_session_id(std::string&& value) {
  
  session_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.UserPresence.session_id)
}
inline void UserPresence::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  session_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.UserPresence.session_id)
}
inline void UserPresence::set_session_id(const char* value,
    size_t size) {
  
  session_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.UserPresence.session_id)
}
inline std::string* UserPresence::_internal_mutable_session_id() {
  
  return session_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* UserPresence::release_session_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.UserPresence.session_id)
  return session_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UserPresence::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  session_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), session_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.UserPresence.session_id)
}

// string username = 3;
inline void UserPresence::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& UserPresence::username() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.UserPresence.username)
  return _internal_username();
}
inline void UserPresence::set_username(const std::string& value) {
  _internal_set_username(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.UserPresence.username)
}
inline std::string* UserPresence::mutable_username() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.UserPresence.username)
  return _internal_mutable_username();
}
inline const std::string& UserPresence::_internal_username() const {
  return username_.Get();
}
inline void UserPresence::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void UserPresence::set_username(std::string&& value) {
  
  username_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.UserPresence.username)
}
inline void UserPresence::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nakama.realtime.UserPresence.username)
}
inline void UserPresence::set_username(const char* value,
    size_t size) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.UserPresence.username)
}
inline std::string* UserPresence::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* UserPresence::release_username() {
  // @@protoc_insertion_point(field_release:nakama.realtime.UserPresence.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UserPresence::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.UserPresence.username)
}

// bool persistence = 4;
inline void UserPresence::clear_persistence() {
  persistence_ = false;
}
inline bool UserPresence::_internal_persistence() const {
  return persistence_;
}
inline bool UserPresence::persistence() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.UserPresence.persistence)
  return _internal_persistence();
}
inline void UserPresence::_internal_set_persistence(bool value) {
  
  persistence_ = value;
}
inline void UserPresence::set_persistence(bool value) {
  _internal_set_persistence(value);
  // @@protoc_insertion_point(field_set:nakama.realtime.UserPresence.persistence)
}

// .google.protobuf.StringValue status = 5;
inline bool UserPresence::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool UserPresence::has_status() const {
  return _internal_has_status();
}
inline const PROTOBUF_NAMESPACE_ID::StringValue& UserPresence::_internal_status() const {
  const PROTOBUF_NAMESPACE_ID::StringValue* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::StringValue&>(
      PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::StringValue& UserPresence::status() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.UserPresence.status)
  return _internal_status();
}
inline void UserPresence::unsafe_arena_set_allocated_status(
    PROTOBUF_NAMESPACE_ID::StringValue* status) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nakama.realtime.UserPresence.status)
}
inline PROTOBUF_NAMESPACE_ID::StringValue* UserPresence::release_status() {
  
  PROTOBUF_NAMESPACE_ID::StringValue* temp = status_;
  status_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::StringValue* UserPresence::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:nakama.realtime.UserPresence.status)
  
  PROTOBUF_NAMESPACE_ID::StringValue* temp = status_;
  status_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::StringValue* UserPresence::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::StringValue>(GetArena());
    status_ = p;
  }
  return status_;
}
inline PROTOBUF_NAMESPACE_ID::StringValue* UserPresence::mutable_status() {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.UserPresence.status)
  return _internal_mutable_status();
}
inline void UserPresence::set_allocated_status(PROTOBUF_NAMESPACE_ID::StringValue* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status)->GetArena();
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.UserPresence.status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace realtime
}  // namespace nakama

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::nakama::realtime::ChannelJoin_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nakama::realtime::ChannelJoin_Type>() {
  return ::nakama::realtime::ChannelJoin_Type_descriptor();
}
template <> struct is_proto_enum< ::nakama::realtime::Error_Code> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nakama::realtime::Error_Code>() {
  return ::nakama::realtime::Error_Code_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_github_2ecom_2fheroiclabs_2fnakama_2dcommon_2frtapi_2frealtime_2eproto
