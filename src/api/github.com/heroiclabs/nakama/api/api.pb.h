// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: github.com/heroiclabs/nakama/api/api.proto

#ifndef PROTOBUF_INCLUDED_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto
#define PROTOBUF_INCLUDED_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/wrappers.pb.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto 

namespace protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[83];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto
namespace nakama {
namespace api {
class Account;
class AccountDefaultTypeInternal;
extern AccountDefaultTypeInternal _Account_default_instance_;
class AccountCustom;
class AccountCustomDefaultTypeInternal;
extern AccountCustomDefaultTypeInternal _AccountCustom_default_instance_;
class AccountDevice;
class AccountDeviceDefaultTypeInternal;
extern AccountDeviceDefaultTypeInternal _AccountDevice_default_instance_;
class AccountEmail;
class AccountEmailDefaultTypeInternal;
extern AccountEmailDefaultTypeInternal _AccountEmail_default_instance_;
class AccountFacebook;
class AccountFacebookDefaultTypeInternal;
extern AccountFacebookDefaultTypeInternal _AccountFacebook_default_instance_;
class AccountGameCenter;
class AccountGameCenterDefaultTypeInternal;
extern AccountGameCenterDefaultTypeInternal _AccountGameCenter_default_instance_;
class AccountGoogle;
class AccountGoogleDefaultTypeInternal;
extern AccountGoogleDefaultTypeInternal _AccountGoogle_default_instance_;
class AccountSteam;
class AccountSteamDefaultTypeInternal;
extern AccountSteamDefaultTypeInternal _AccountSteam_default_instance_;
class AddFriendsRequest;
class AddFriendsRequestDefaultTypeInternal;
extern AddFriendsRequestDefaultTypeInternal _AddFriendsRequest_default_instance_;
class AddGroupUsersRequest;
class AddGroupUsersRequestDefaultTypeInternal;
extern AddGroupUsersRequestDefaultTypeInternal _AddGroupUsersRequest_default_instance_;
class AuthenticateCustomRequest;
class AuthenticateCustomRequestDefaultTypeInternal;
extern AuthenticateCustomRequestDefaultTypeInternal _AuthenticateCustomRequest_default_instance_;
class AuthenticateDeviceRequest;
class AuthenticateDeviceRequestDefaultTypeInternal;
extern AuthenticateDeviceRequestDefaultTypeInternal _AuthenticateDeviceRequest_default_instance_;
class AuthenticateEmailRequest;
class AuthenticateEmailRequestDefaultTypeInternal;
extern AuthenticateEmailRequestDefaultTypeInternal _AuthenticateEmailRequest_default_instance_;
class AuthenticateFacebookRequest;
class AuthenticateFacebookRequestDefaultTypeInternal;
extern AuthenticateFacebookRequestDefaultTypeInternal _AuthenticateFacebookRequest_default_instance_;
class AuthenticateGameCenterRequest;
class AuthenticateGameCenterRequestDefaultTypeInternal;
extern AuthenticateGameCenterRequestDefaultTypeInternal _AuthenticateGameCenterRequest_default_instance_;
class AuthenticateGoogleRequest;
class AuthenticateGoogleRequestDefaultTypeInternal;
extern AuthenticateGoogleRequestDefaultTypeInternal _AuthenticateGoogleRequest_default_instance_;
class AuthenticateSteamRequest;
class AuthenticateSteamRequestDefaultTypeInternal;
extern AuthenticateSteamRequestDefaultTypeInternal _AuthenticateSteamRequest_default_instance_;
class BlockFriendsRequest;
class BlockFriendsRequestDefaultTypeInternal;
extern BlockFriendsRequestDefaultTypeInternal _BlockFriendsRequest_default_instance_;
class ChannelMessage;
class ChannelMessageDefaultTypeInternal;
extern ChannelMessageDefaultTypeInternal _ChannelMessage_default_instance_;
class ChannelMessageList;
class ChannelMessageListDefaultTypeInternal;
extern ChannelMessageListDefaultTypeInternal _ChannelMessageList_default_instance_;
class CreateGroupRequest;
class CreateGroupRequestDefaultTypeInternal;
extern CreateGroupRequestDefaultTypeInternal _CreateGroupRequest_default_instance_;
class DeleteFriendsRequest;
class DeleteFriendsRequestDefaultTypeInternal;
extern DeleteFriendsRequestDefaultTypeInternal _DeleteFriendsRequest_default_instance_;
class DeleteGroupRequest;
class DeleteGroupRequestDefaultTypeInternal;
extern DeleteGroupRequestDefaultTypeInternal _DeleteGroupRequest_default_instance_;
class DeleteLeaderboardRecordRequest;
class DeleteLeaderboardRecordRequestDefaultTypeInternal;
extern DeleteLeaderboardRecordRequestDefaultTypeInternal _DeleteLeaderboardRecordRequest_default_instance_;
class DeleteNotificationsRequest;
class DeleteNotificationsRequestDefaultTypeInternal;
extern DeleteNotificationsRequestDefaultTypeInternal _DeleteNotificationsRequest_default_instance_;
class DeleteStorageObjectId;
class DeleteStorageObjectIdDefaultTypeInternal;
extern DeleteStorageObjectIdDefaultTypeInternal _DeleteStorageObjectId_default_instance_;
class DeleteStorageObjectsRequest;
class DeleteStorageObjectsRequestDefaultTypeInternal;
extern DeleteStorageObjectsRequestDefaultTypeInternal _DeleteStorageObjectsRequest_default_instance_;
class Friend;
class FriendDefaultTypeInternal;
extern FriendDefaultTypeInternal _Friend_default_instance_;
class Friends;
class FriendsDefaultTypeInternal;
extern FriendsDefaultTypeInternal _Friends_default_instance_;
class GetUsersRequest;
class GetUsersRequestDefaultTypeInternal;
extern GetUsersRequestDefaultTypeInternal _GetUsersRequest_default_instance_;
class Group;
class GroupDefaultTypeInternal;
extern GroupDefaultTypeInternal _Group_default_instance_;
class GroupList;
class GroupListDefaultTypeInternal;
extern GroupListDefaultTypeInternal _GroupList_default_instance_;
class GroupUserList;
class GroupUserListDefaultTypeInternal;
extern GroupUserListDefaultTypeInternal _GroupUserList_default_instance_;
class GroupUserList_GroupUser;
class GroupUserList_GroupUserDefaultTypeInternal;
extern GroupUserList_GroupUserDefaultTypeInternal _GroupUserList_GroupUser_default_instance_;
class ImportFacebookFriendsRequest;
class ImportFacebookFriendsRequestDefaultTypeInternal;
extern ImportFacebookFriendsRequestDefaultTypeInternal _ImportFacebookFriendsRequest_default_instance_;
class JoinGroupRequest;
class JoinGroupRequestDefaultTypeInternal;
extern JoinGroupRequestDefaultTypeInternal _JoinGroupRequest_default_instance_;
class JoinTournamentRequest;
class JoinTournamentRequestDefaultTypeInternal;
extern JoinTournamentRequestDefaultTypeInternal _JoinTournamentRequest_default_instance_;
class KickGroupUsersRequest;
class KickGroupUsersRequestDefaultTypeInternal;
extern KickGroupUsersRequestDefaultTypeInternal _KickGroupUsersRequest_default_instance_;
class LeaderboardRecord;
class LeaderboardRecordDefaultTypeInternal;
extern LeaderboardRecordDefaultTypeInternal _LeaderboardRecord_default_instance_;
class LeaderboardRecordList;
class LeaderboardRecordListDefaultTypeInternal;
extern LeaderboardRecordListDefaultTypeInternal _LeaderboardRecordList_default_instance_;
class LeaveGroupRequest;
class LeaveGroupRequestDefaultTypeInternal;
extern LeaveGroupRequestDefaultTypeInternal _LeaveGroupRequest_default_instance_;
class LinkFacebookRequest;
class LinkFacebookRequestDefaultTypeInternal;
extern LinkFacebookRequestDefaultTypeInternal _LinkFacebookRequest_default_instance_;
class ListChannelMessagesRequest;
class ListChannelMessagesRequestDefaultTypeInternal;
extern ListChannelMessagesRequestDefaultTypeInternal _ListChannelMessagesRequest_default_instance_;
class ListGroupUsersRequest;
class ListGroupUsersRequestDefaultTypeInternal;
extern ListGroupUsersRequestDefaultTypeInternal _ListGroupUsersRequest_default_instance_;
class ListGroupsRequest;
class ListGroupsRequestDefaultTypeInternal;
extern ListGroupsRequestDefaultTypeInternal _ListGroupsRequest_default_instance_;
class ListLeaderboardRecordsAroundOwnerRequest;
class ListLeaderboardRecordsAroundOwnerRequestDefaultTypeInternal;
extern ListLeaderboardRecordsAroundOwnerRequestDefaultTypeInternal _ListLeaderboardRecordsAroundOwnerRequest_default_instance_;
class ListLeaderboardRecordsRequest;
class ListLeaderboardRecordsRequestDefaultTypeInternal;
extern ListLeaderboardRecordsRequestDefaultTypeInternal _ListLeaderboardRecordsRequest_default_instance_;
class ListMatchesRequest;
class ListMatchesRequestDefaultTypeInternal;
extern ListMatchesRequestDefaultTypeInternal _ListMatchesRequest_default_instance_;
class ListNotificationsRequest;
class ListNotificationsRequestDefaultTypeInternal;
extern ListNotificationsRequestDefaultTypeInternal _ListNotificationsRequest_default_instance_;
class ListStorageObjectsRequest;
class ListStorageObjectsRequestDefaultTypeInternal;
extern ListStorageObjectsRequestDefaultTypeInternal _ListStorageObjectsRequest_default_instance_;
class ListTournamentRecordsAroundOwnerRequest;
class ListTournamentRecordsAroundOwnerRequestDefaultTypeInternal;
extern ListTournamentRecordsAroundOwnerRequestDefaultTypeInternal _ListTournamentRecordsAroundOwnerRequest_default_instance_;
class ListTournamentRecordsRequest;
class ListTournamentRecordsRequestDefaultTypeInternal;
extern ListTournamentRecordsRequestDefaultTypeInternal _ListTournamentRecordsRequest_default_instance_;
class ListTournamentsRequest;
class ListTournamentsRequestDefaultTypeInternal;
extern ListTournamentsRequestDefaultTypeInternal _ListTournamentsRequest_default_instance_;
class ListUserGroupsRequest;
class ListUserGroupsRequestDefaultTypeInternal;
extern ListUserGroupsRequestDefaultTypeInternal _ListUserGroupsRequest_default_instance_;
class Match;
class MatchDefaultTypeInternal;
extern MatchDefaultTypeInternal _Match_default_instance_;
class MatchList;
class MatchListDefaultTypeInternal;
extern MatchListDefaultTypeInternal _MatchList_default_instance_;
class Notification;
class NotificationDefaultTypeInternal;
extern NotificationDefaultTypeInternal _Notification_default_instance_;
class NotificationList;
class NotificationListDefaultTypeInternal;
extern NotificationListDefaultTypeInternal _NotificationList_default_instance_;
class PromoteGroupUsersRequest;
class PromoteGroupUsersRequestDefaultTypeInternal;
extern PromoteGroupUsersRequestDefaultTypeInternal _PromoteGroupUsersRequest_default_instance_;
class ReadStorageObjectId;
class ReadStorageObjectIdDefaultTypeInternal;
extern ReadStorageObjectIdDefaultTypeInternal _ReadStorageObjectId_default_instance_;
class ReadStorageObjectsRequest;
class ReadStorageObjectsRequestDefaultTypeInternal;
extern ReadStorageObjectsRequestDefaultTypeInternal _ReadStorageObjectsRequest_default_instance_;
class Rpc;
class RpcDefaultTypeInternal;
extern RpcDefaultTypeInternal _Rpc_default_instance_;
class Session;
class SessionDefaultTypeInternal;
extern SessionDefaultTypeInternal _Session_default_instance_;
class StorageObject;
class StorageObjectDefaultTypeInternal;
extern StorageObjectDefaultTypeInternal _StorageObject_default_instance_;
class StorageObjectAck;
class StorageObjectAckDefaultTypeInternal;
extern StorageObjectAckDefaultTypeInternal _StorageObjectAck_default_instance_;
class StorageObjectAcks;
class StorageObjectAcksDefaultTypeInternal;
extern StorageObjectAcksDefaultTypeInternal _StorageObjectAcks_default_instance_;
class StorageObjectList;
class StorageObjectListDefaultTypeInternal;
extern StorageObjectListDefaultTypeInternal _StorageObjectList_default_instance_;
class StorageObjects;
class StorageObjectsDefaultTypeInternal;
extern StorageObjectsDefaultTypeInternal _StorageObjects_default_instance_;
class Tournament;
class TournamentDefaultTypeInternal;
extern TournamentDefaultTypeInternal _Tournament_default_instance_;
class TournamentList;
class TournamentListDefaultTypeInternal;
extern TournamentListDefaultTypeInternal _TournamentList_default_instance_;
class TournamentRecordList;
class TournamentRecordListDefaultTypeInternal;
extern TournamentRecordListDefaultTypeInternal _TournamentRecordList_default_instance_;
class UpdateAccountRequest;
class UpdateAccountRequestDefaultTypeInternal;
extern UpdateAccountRequestDefaultTypeInternal _UpdateAccountRequest_default_instance_;
class UpdateGroupRequest;
class UpdateGroupRequestDefaultTypeInternal;
extern UpdateGroupRequestDefaultTypeInternal _UpdateGroupRequest_default_instance_;
class User;
class UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
class UserGroupList;
class UserGroupListDefaultTypeInternal;
extern UserGroupListDefaultTypeInternal _UserGroupList_default_instance_;
class UserGroupList_UserGroup;
class UserGroupList_UserGroupDefaultTypeInternal;
extern UserGroupList_UserGroupDefaultTypeInternal _UserGroupList_UserGroup_default_instance_;
class Users;
class UsersDefaultTypeInternal;
extern UsersDefaultTypeInternal _Users_default_instance_;
class WriteLeaderboardRecordRequest;
class WriteLeaderboardRecordRequestDefaultTypeInternal;
extern WriteLeaderboardRecordRequestDefaultTypeInternal _WriteLeaderboardRecordRequest_default_instance_;
class WriteLeaderboardRecordRequest_LeaderboardRecordWrite;
class WriteLeaderboardRecordRequest_LeaderboardRecordWriteDefaultTypeInternal;
extern WriteLeaderboardRecordRequest_LeaderboardRecordWriteDefaultTypeInternal _WriteLeaderboardRecordRequest_LeaderboardRecordWrite_default_instance_;
class WriteStorageObject;
class WriteStorageObjectDefaultTypeInternal;
extern WriteStorageObjectDefaultTypeInternal _WriteStorageObject_default_instance_;
class WriteStorageObjectsRequest;
class WriteStorageObjectsRequestDefaultTypeInternal;
extern WriteStorageObjectsRequestDefaultTypeInternal _WriteStorageObjectsRequest_default_instance_;
class WriteTournamentRecordRequest;
class WriteTournamentRecordRequestDefaultTypeInternal;
extern WriteTournamentRecordRequestDefaultTypeInternal _WriteTournamentRecordRequest_default_instance_;
class WriteTournamentRecordRequest_TournamentRecordWrite;
class WriteTournamentRecordRequest_TournamentRecordWriteDefaultTypeInternal;
extern WriteTournamentRecordRequest_TournamentRecordWriteDefaultTypeInternal _WriteTournamentRecordRequest_TournamentRecordWrite_default_instance_;
}  // namespace api
}  // namespace nakama
namespace google {
namespace protobuf {
template<> ::nakama::api::Account* Arena::CreateMaybeMessage<::nakama::api::Account>(Arena*);
template<> ::nakama::api::AccountCustom* Arena::CreateMaybeMessage<::nakama::api::AccountCustom>(Arena*);
template<> ::nakama::api::AccountDevice* Arena::CreateMaybeMessage<::nakama::api::AccountDevice>(Arena*);
template<> ::nakama::api::AccountEmail* Arena::CreateMaybeMessage<::nakama::api::AccountEmail>(Arena*);
template<> ::nakama::api::AccountFacebook* Arena::CreateMaybeMessage<::nakama::api::AccountFacebook>(Arena*);
template<> ::nakama::api::AccountGameCenter* Arena::CreateMaybeMessage<::nakama::api::AccountGameCenter>(Arena*);
template<> ::nakama::api::AccountGoogle* Arena::CreateMaybeMessage<::nakama::api::AccountGoogle>(Arena*);
template<> ::nakama::api::AccountSteam* Arena::CreateMaybeMessage<::nakama::api::AccountSteam>(Arena*);
template<> ::nakama::api::AddFriendsRequest* Arena::CreateMaybeMessage<::nakama::api::AddFriendsRequest>(Arena*);
template<> ::nakama::api::AddGroupUsersRequest* Arena::CreateMaybeMessage<::nakama::api::AddGroupUsersRequest>(Arena*);
template<> ::nakama::api::AuthenticateCustomRequest* Arena::CreateMaybeMessage<::nakama::api::AuthenticateCustomRequest>(Arena*);
template<> ::nakama::api::AuthenticateDeviceRequest* Arena::CreateMaybeMessage<::nakama::api::AuthenticateDeviceRequest>(Arena*);
template<> ::nakama::api::AuthenticateEmailRequest* Arena::CreateMaybeMessage<::nakama::api::AuthenticateEmailRequest>(Arena*);
template<> ::nakama::api::AuthenticateFacebookRequest* Arena::CreateMaybeMessage<::nakama::api::AuthenticateFacebookRequest>(Arena*);
template<> ::nakama::api::AuthenticateGameCenterRequest* Arena::CreateMaybeMessage<::nakama::api::AuthenticateGameCenterRequest>(Arena*);
template<> ::nakama::api::AuthenticateGoogleRequest* Arena::CreateMaybeMessage<::nakama::api::AuthenticateGoogleRequest>(Arena*);
template<> ::nakama::api::AuthenticateSteamRequest* Arena::CreateMaybeMessage<::nakama::api::AuthenticateSteamRequest>(Arena*);
template<> ::nakama::api::BlockFriendsRequest* Arena::CreateMaybeMessage<::nakama::api::BlockFriendsRequest>(Arena*);
template<> ::nakama::api::ChannelMessage* Arena::CreateMaybeMessage<::nakama::api::ChannelMessage>(Arena*);
template<> ::nakama::api::ChannelMessageList* Arena::CreateMaybeMessage<::nakama::api::ChannelMessageList>(Arena*);
template<> ::nakama::api::CreateGroupRequest* Arena::CreateMaybeMessage<::nakama::api::CreateGroupRequest>(Arena*);
template<> ::nakama::api::DeleteFriendsRequest* Arena::CreateMaybeMessage<::nakama::api::DeleteFriendsRequest>(Arena*);
template<> ::nakama::api::DeleteGroupRequest* Arena::CreateMaybeMessage<::nakama::api::DeleteGroupRequest>(Arena*);
template<> ::nakama::api::DeleteLeaderboardRecordRequest* Arena::CreateMaybeMessage<::nakama::api::DeleteLeaderboardRecordRequest>(Arena*);
template<> ::nakama::api::DeleteNotificationsRequest* Arena::CreateMaybeMessage<::nakama::api::DeleteNotificationsRequest>(Arena*);
template<> ::nakama::api::DeleteStorageObjectId* Arena::CreateMaybeMessage<::nakama::api::DeleteStorageObjectId>(Arena*);
template<> ::nakama::api::DeleteStorageObjectsRequest* Arena::CreateMaybeMessage<::nakama::api::DeleteStorageObjectsRequest>(Arena*);
template<> ::nakama::api::Friend* Arena::CreateMaybeMessage<::nakama::api::Friend>(Arena*);
template<> ::nakama::api::Friends* Arena::CreateMaybeMessage<::nakama::api::Friends>(Arena*);
template<> ::nakama::api::GetUsersRequest* Arena::CreateMaybeMessage<::nakama::api::GetUsersRequest>(Arena*);
template<> ::nakama::api::Group* Arena::CreateMaybeMessage<::nakama::api::Group>(Arena*);
template<> ::nakama::api::GroupList* Arena::CreateMaybeMessage<::nakama::api::GroupList>(Arena*);
template<> ::nakama::api::GroupUserList* Arena::CreateMaybeMessage<::nakama::api::GroupUserList>(Arena*);
template<> ::nakama::api::GroupUserList_GroupUser* Arena::CreateMaybeMessage<::nakama::api::GroupUserList_GroupUser>(Arena*);
template<> ::nakama::api::ImportFacebookFriendsRequest* Arena::CreateMaybeMessage<::nakama::api::ImportFacebookFriendsRequest>(Arena*);
template<> ::nakama::api::JoinGroupRequest* Arena::CreateMaybeMessage<::nakama::api::JoinGroupRequest>(Arena*);
template<> ::nakama::api::JoinTournamentRequest* Arena::CreateMaybeMessage<::nakama::api::JoinTournamentRequest>(Arena*);
template<> ::nakama::api::KickGroupUsersRequest* Arena::CreateMaybeMessage<::nakama::api::KickGroupUsersRequest>(Arena*);
template<> ::nakama::api::LeaderboardRecord* Arena::CreateMaybeMessage<::nakama::api::LeaderboardRecord>(Arena*);
template<> ::nakama::api::LeaderboardRecordList* Arena::CreateMaybeMessage<::nakama::api::LeaderboardRecordList>(Arena*);
template<> ::nakama::api::LeaveGroupRequest* Arena::CreateMaybeMessage<::nakama::api::LeaveGroupRequest>(Arena*);
template<> ::nakama::api::LinkFacebookRequest* Arena::CreateMaybeMessage<::nakama::api::LinkFacebookRequest>(Arena*);
template<> ::nakama::api::ListChannelMessagesRequest* Arena::CreateMaybeMessage<::nakama::api::ListChannelMessagesRequest>(Arena*);
template<> ::nakama::api::ListGroupUsersRequest* Arena::CreateMaybeMessage<::nakama::api::ListGroupUsersRequest>(Arena*);
template<> ::nakama::api::ListGroupsRequest* Arena::CreateMaybeMessage<::nakama::api::ListGroupsRequest>(Arena*);
template<> ::nakama::api::ListLeaderboardRecordsAroundOwnerRequest* Arena::CreateMaybeMessage<::nakama::api::ListLeaderboardRecordsAroundOwnerRequest>(Arena*);
template<> ::nakama::api::ListLeaderboardRecordsRequest* Arena::CreateMaybeMessage<::nakama::api::ListLeaderboardRecordsRequest>(Arena*);
template<> ::nakama::api::ListMatchesRequest* Arena::CreateMaybeMessage<::nakama::api::ListMatchesRequest>(Arena*);
template<> ::nakama::api::ListNotificationsRequest* Arena::CreateMaybeMessage<::nakama::api::ListNotificationsRequest>(Arena*);
template<> ::nakama::api::ListStorageObjectsRequest* Arena::CreateMaybeMessage<::nakama::api::ListStorageObjectsRequest>(Arena*);
template<> ::nakama::api::ListTournamentRecordsAroundOwnerRequest* Arena::CreateMaybeMessage<::nakama::api::ListTournamentRecordsAroundOwnerRequest>(Arena*);
template<> ::nakama::api::ListTournamentRecordsRequest* Arena::CreateMaybeMessage<::nakama::api::ListTournamentRecordsRequest>(Arena*);
template<> ::nakama::api::ListTournamentsRequest* Arena::CreateMaybeMessage<::nakama::api::ListTournamentsRequest>(Arena*);
template<> ::nakama::api::ListUserGroupsRequest* Arena::CreateMaybeMessage<::nakama::api::ListUserGroupsRequest>(Arena*);
template<> ::nakama::api::Match* Arena::CreateMaybeMessage<::nakama::api::Match>(Arena*);
template<> ::nakama::api::MatchList* Arena::CreateMaybeMessage<::nakama::api::MatchList>(Arena*);
template<> ::nakama::api::Notification* Arena::CreateMaybeMessage<::nakama::api::Notification>(Arena*);
template<> ::nakama::api::NotificationList* Arena::CreateMaybeMessage<::nakama::api::NotificationList>(Arena*);
template<> ::nakama::api::PromoteGroupUsersRequest* Arena::CreateMaybeMessage<::nakama::api::PromoteGroupUsersRequest>(Arena*);
template<> ::nakama::api::ReadStorageObjectId* Arena::CreateMaybeMessage<::nakama::api::ReadStorageObjectId>(Arena*);
template<> ::nakama::api::ReadStorageObjectsRequest* Arena::CreateMaybeMessage<::nakama::api::ReadStorageObjectsRequest>(Arena*);
template<> ::nakama::api::Rpc* Arena::CreateMaybeMessage<::nakama::api::Rpc>(Arena*);
template<> ::nakama::api::Session* Arena::CreateMaybeMessage<::nakama::api::Session>(Arena*);
template<> ::nakama::api::StorageObject* Arena::CreateMaybeMessage<::nakama::api::StorageObject>(Arena*);
template<> ::nakama::api::StorageObjectAck* Arena::CreateMaybeMessage<::nakama::api::StorageObjectAck>(Arena*);
template<> ::nakama::api::StorageObjectAcks* Arena::CreateMaybeMessage<::nakama::api::StorageObjectAcks>(Arena*);
template<> ::nakama::api::StorageObjectList* Arena::CreateMaybeMessage<::nakama::api::StorageObjectList>(Arena*);
template<> ::nakama::api::StorageObjects* Arena::CreateMaybeMessage<::nakama::api::StorageObjects>(Arena*);
template<> ::nakama::api::Tournament* Arena::CreateMaybeMessage<::nakama::api::Tournament>(Arena*);
template<> ::nakama::api::TournamentList* Arena::CreateMaybeMessage<::nakama::api::TournamentList>(Arena*);
template<> ::nakama::api::TournamentRecordList* Arena::CreateMaybeMessage<::nakama::api::TournamentRecordList>(Arena*);
template<> ::nakama::api::UpdateAccountRequest* Arena::CreateMaybeMessage<::nakama::api::UpdateAccountRequest>(Arena*);
template<> ::nakama::api::UpdateGroupRequest* Arena::CreateMaybeMessage<::nakama::api::UpdateGroupRequest>(Arena*);
template<> ::nakama::api::User* Arena::CreateMaybeMessage<::nakama::api::User>(Arena*);
template<> ::nakama::api::UserGroupList* Arena::CreateMaybeMessage<::nakama::api::UserGroupList>(Arena*);
template<> ::nakama::api::UserGroupList_UserGroup* Arena::CreateMaybeMessage<::nakama::api::UserGroupList_UserGroup>(Arena*);
template<> ::nakama::api::Users* Arena::CreateMaybeMessage<::nakama::api::Users>(Arena*);
template<> ::nakama::api::WriteLeaderboardRecordRequest* Arena::CreateMaybeMessage<::nakama::api::WriteLeaderboardRecordRequest>(Arena*);
template<> ::nakama::api::WriteLeaderboardRecordRequest_LeaderboardRecordWrite* Arena::CreateMaybeMessage<::nakama::api::WriteLeaderboardRecordRequest_LeaderboardRecordWrite>(Arena*);
template<> ::nakama::api::WriteStorageObject* Arena::CreateMaybeMessage<::nakama::api::WriteStorageObject>(Arena*);
template<> ::nakama::api::WriteStorageObjectsRequest* Arena::CreateMaybeMessage<::nakama::api::WriteStorageObjectsRequest>(Arena*);
template<> ::nakama::api::WriteTournamentRecordRequest* Arena::CreateMaybeMessage<::nakama::api::WriteTournamentRecordRequest>(Arena*);
template<> ::nakama::api::WriteTournamentRecordRequest_TournamentRecordWrite* Arena::CreateMaybeMessage<::nakama::api::WriteTournamentRecordRequest_TournamentRecordWrite>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace nakama {
namespace api {

enum Friend_State {
  Friend_State_FRIEND = 0,
  Friend_State_INVITE_SENT = 1,
  Friend_State_INVITE_RECEIVED = 2,
  Friend_State_BLOCKED = 3,
  Friend_State_Friend_State_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Friend_State_Friend_State_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Friend_State_IsValid(int value);
const Friend_State Friend_State_State_MIN = Friend_State_FRIEND;
const Friend_State Friend_State_State_MAX = Friend_State_BLOCKED;
const int Friend_State_State_ARRAYSIZE = Friend_State_State_MAX + 1;

const ::google::protobuf::EnumDescriptor* Friend_State_descriptor();
inline const ::std::string& Friend_State_Name(Friend_State value) {
  return ::google::protobuf::internal::NameOfEnum(
    Friend_State_descriptor(), value);
}
inline bool Friend_State_Parse(
    const ::std::string& name, Friend_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Friend_State>(
    Friend_State_descriptor(), name, value);
}
enum GroupUserList_GroupUser_State {
  GroupUserList_GroupUser_State_SUPERADMIN = 0,
  GroupUserList_GroupUser_State_ADMIN = 1,
  GroupUserList_GroupUser_State_MEMBER = 2,
  GroupUserList_GroupUser_State_JOIN_REQUEST = 3,
  GroupUserList_GroupUser_State_GroupUserList_GroupUser_State_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  GroupUserList_GroupUser_State_GroupUserList_GroupUser_State_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool GroupUserList_GroupUser_State_IsValid(int value);
const GroupUserList_GroupUser_State GroupUserList_GroupUser_State_State_MIN = GroupUserList_GroupUser_State_SUPERADMIN;
const GroupUserList_GroupUser_State GroupUserList_GroupUser_State_State_MAX = GroupUserList_GroupUser_State_JOIN_REQUEST;
const int GroupUserList_GroupUser_State_State_ARRAYSIZE = GroupUserList_GroupUser_State_State_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupUserList_GroupUser_State_descriptor();
inline const ::std::string& GroupUserList_GroupUser_State_Name(GroupUserList_GroupUser_State value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupUserList_GroupUser_State_descriptor(), value);
}
inline bool GroupUserList_GroupUser_State_Parse(
    const ::std::string& name, GroupUserList_GroupUser_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupUserList_GroupUser_State>(
    GroupUserList_GroupUser_State_descriptor(), name, value);
}
enum UserGroupList_UserGroup_State {
  UserGroupList_UserGroup_State_SUPERADMIN = 0,
  UserGroupList_UserGroup_State_ADMIN = 1,
  UserGroupList_UserGroup_State_MEMBER = 2,
  UserGroupList_UserGroup_State_JOIN_REQUEST = 3,
  UserGroupList_UserGroup_State_UserGroupList_UserGroup_State_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  UserGroupList_UserGroup_State_UserGroupList_UserGroup_State_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool UserGroupList_UserGroup_State_IsValid(int value);
const UserGroupList_UserGroup_State UserGroupList_UserGroup_State_State_MIN = UserGroupList_UserGroup_State_SUPERADMIN;
const UserGroupList_UserGroup_State UserGroupList_UserGroup_State_State_MAX = UserGroupList_UserGroup_State_JOIN_REQUEST;
const int UserGroupList_UserGroup_State_State_ARRAYSIZE = UserGroupList_UserGroup_State_State_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserGroupList_UserGroup_State_descriptor();
inline const ::std::string& UserGroupList_UserGroup_State_Name(UserGroupList_UserGroup_State value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserGroupList_UserGroup_State_descriptor(), value);
}
inline bool UserGroupList_UserGroup_State_Parse(
    const ::std::string& name, UserGroupList_UserGroup_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserGroupList_UserGroup_State>(
    UserGroupList_UserGroup_State_descriptor(), name, value);
}
// ===================================================================

class Account : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.Account) */ {
 public:
  Account();
  virtual ~Account();

  Account(const Account& from);

  inline Account& operator=(const Account& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Account(Account&& from) noexcept
    : Account() {
    *this = ::std::move(from);
  }

  inline Account& operator=(Account&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Account& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Account* internal_default_instance() {
    return reinterpret_cast<const Account*>(
               &_Account_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Account* other);
  friend void swap(Account& a, Account& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Account* New() const final {
    return CreateMaybeMessage<Account>(NULL);
  }

  Account* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Account>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Account& from);
  void MergeFrom(const Account& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Account* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nakama.api.AccountDevice devices = 4;
  int devices_size() const;
  void clear_devices();
  static const int kDevicesFieldNumber = 4;
  ::nakama::api::AccountDevice* mutable_devices(int index);
  ::google::protobuf::RepeatedPtrField< ::nakama::api::AccountDevice >*
      mutable_devices();
  const ::nakama::api::AccountDevice& devices(int index) const;
  ::nakama::api::AccountDevice* add_devices();
  const ::google::protobuf::RepeatedPtrField< ::nakama::api::AccountDevice >&
      devices() const;

  // string wallet = 2;
  void clear_wallet();
  static const int kWalletFieldNumber = 2;
  const ::std::string& wallet() const;
  void set_wallet(const ::std::string& value);
  #if LANG_CXX11
  void set_wallet(::std::string&& value);
  #endif
  void set_wallet(const char* value);
  void set_wallet(const char* value, size_t size);
  ::std::string* mutable_wallet();
  ::std::string* release_wallet();
  void set_allocated_wallet(::std::string* wallet);

  // string email = 3;
  void clear_email();
  static const int kEmailFieldNumber = 3;
  const ::std::string& email() const;
  void set_email(const ::std::string& value);
  #if LANG_CXX11
  void set_email(::std::string&& value);
  #endif
  void set_email(const char* value);
  void set_email(const char* value, size_t size);
  ::std::string* mutable_email();
  ::std::string* release_email();
  void set_allocated_email(::std::string* email);

  // string custom_id = 5;
  void clear_custom_id();
  static const int kCustomIdFieldNumber = 5;
  const ::std::string& custom_id() const;
  void set_custom_id(const ::std::string& value);
  #if LANG_CXX11
  void set_custom_id(::std::string&& value);
  #endif
  void set_custom_id(const char* value);
  void set_custom_id(const char* value, size_t size);
  ::std::string* mutable_custom_id();
  ::std::string* release_custom_id();
  void set_allocated_custom_id(::std::string* custom_id);

  // .nakama.api.User user = 1;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 1;
  private:
  const ::nakama::api::User& _internal_user() const;
  public:
  const ::nakama::api::User& user() const;
  ::nakama::api::User* release_user();
  ::nakama::api::User* mutable_user();
  void set_allocated_user(::nakama::api::User* user);

  // .google.protobuf.Timestamp verify_time = 6;
  bool has_verify_time() const;
  void clear_verify_time();
  static const int kVerifyTimeFieldNumber = 6;
  private:
  const ::google::protobuf::Timestamp& _internal_verify_time() const;
  public:
  const ::google::protobuf::Timestamp& verify_time() const;
  ::google::protobuf::Timestamp* release_verify_time();
  ::google::protobuf::Timestamp* mutable_verify_time();
  void set_allocated_verify_time(::google::protobuf::Timestamp* verify_time);

  // @@protoc_insertion_point(class_scope:nakama.api.Account)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::nakama::api::AccountDevice > devices_;
  ::google::protobuf::internal::ArenaStringPtr wallet_;
  ::google::protobuf::internal::ArenaStringPtr email_;
  ::google::protobuf::internal::ArenaStringPtr custom_id_;
  ::nakama::api::User* user_;
  ::google::protobuf::Timestamp* verify_time_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccountCustom : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.AccountCustom) */ {
 public:
  AccountCustom();
  virtual ~AccountCustom();

  AccountCustom(const AccountCustom& from);

  inline AccountCustom& operator=(const AccountCustom& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccountCustom(AccountCustom&& from) noexcept
    : AccountCustom() {
    *this = ::std::move(from);
  }

  inline AccountCustom& operator=(AccountCustom&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountCustom& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccountCustom* internal_default_instance() {
    return reinterpret_cast<const AccountCustom*>(
               &_AccountCustom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(AccountCustom* other);
  friend void swap(AccountCustom& a, AccountCustom& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccountCustom* New() const final {
    return CreateMaybeMessage<AccountCustom>(NULL);
  }

  AccountCustom* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccountCustom>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccountCustom& from);
  void MergeFrom(const AccountCustom& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountCustom* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:nakama.api.AccountCustom)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccountDevice : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.AccountDevice) */ {
 public:
  AccountDevice();
  virtual ~AccountDevice();

  AccountDevice(const AccountDevice& from);

  inline AccountDevice& operator=(const AccountDevice& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccountDevice(AccountDevice&& from) noexcept
    : AccountDevice() {
    *this = ::std::move(from);
  }

  inline AccountDevice& operator=(AccountDevice&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountDevice& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccountDevice* internal_default_instance() {
    return reinterpret_cast<const AccountDevice*>(
               &_AccountDevice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(AccountDevice* other);
  friend void swap(AccountDevice& a, AccountDevice& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccountDevice* New() const final {
    return CreateMaybeMessage<AccountDevice>(NULL);
  }

  AccountDevice* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccountDevice>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccountDevice& from);
  void MergeFrom(const AccountDevice& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountDevice* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:nakama.api.AccountDevice)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccountEmail : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.AccountEmail) */ {
 public:
  AccountEmail();
  virtual ~AccountEmail();

  AccountEmail(const AccountEmail& from);

  inline AccountEmail& operator=(const AccountEmail& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccountEmail(AccountEmail&& from) noexcept
    : AccountEmail() {
    *this = ::std::move(from);
  }

  inline AccountEmail& operator=(AccountEmail&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountEmail& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccountEmail* internal_default_instance() {
    return reinterpret_cast<const AccountEmail*>(
               &_AccountEmail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(AccountEmail* other);
  friend void swap(AccountEmail& a, AccountEmail& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccountEmail* New() const final {
    return CreateMaybeMessage<AccountEmail>(NULL);
  }

  AccountEmail* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccountEmail>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccountEmail& from);
  void MergeFrom(const AccountEmail& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountEmail* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string email = 1;
  void clear_email();
  static const int kEmailFieldNumber = 1;
  const ::std::string& email() const;
  void set_email(const ::std::string& value);
  #if LANG_CXX11
  void set_email(::std::string&& value);
  #endif
  void set_email(const char* value);
  void set_email(const char* value, size_t size);
  ::std::string* mutable_email();
  ::std::string* release_email();
  void set_allocated_email(::std::string* email);

  // string password = 2;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:nakama.api.AccountEmail)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr email_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccountFacebook : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.AccountFacebook) */ {
 public:
  AccountFacebook();
  virtual ~AccountFacebook();

  AccountFacebook(const AccountFacebook& from);

  inline AccountFacebook& operator=(const AccountFacebook& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccountFacebook(AccountFacebook&& from) noexcept
    : AccountFacebook() {
    *this = ::std::move(from);
  }

  inline AccountFacebook& operator=(AccountFacebook&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountFacebook& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccountFacebook* internal_default_instance() {
    return reinterpret_cast<const AccountFacebook*>(
               &_AccountFacebook_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(AccountFacebook* other);
  friend void swap(AccountFacebook& a, AccountFacebook& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccountFacebook* New() const final {
    return CreateMaybeMessage<AccountFacebook>(NULL);
  }

  AccountFacebook* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccountFacebook>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccountFacebook& from);
  void MergeFrom(const AccountFacebook& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountFacebook* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string token = 1;
  void clear_token();
  static const int kTokenFieldNumber = 1;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  #if LANG_CXX11
  void set_token(::std::string&& value);
  #endif
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:nakama.api.AccountFacebook)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccountGameCenter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.AccountGameCenter) */ {
 public:
  AccountGameCenter();
  virtual ~AccountGameCenter();

  AccountGameCenter(const AccountGameCenter& from);

  inline AccountGameCenter& operator=(const AccountGameCenter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccountGameCenter(AccountGameCenter&& from) noexcept
    : AccountGameCenter() {
    *this = ::std::move(from);
  }

  inline AccountGameCenter& operator=(AccountGameCenter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountGameCenter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccountGameCenter* internal_default_instance() {
    return reinterpret_cast<const AccountGameCenter*>(
               &_AccountGameCenter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(AccountGameCenter* other);
  friend void swap(AccountGameCenter& a, AccountGameCenter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccountGameCenter* New() const final {
    return CreateMaybeMessage<AccountGameCenter>(NULL);
  }

  AccountGameCenter* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccountGameCenter>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccountGameCenter& from);
  void MergeFrom(const AccountGameCenter& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountGameCenter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string player_id = 1;
  void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  const ::std::string& player_id() const;
  void set_player_id(const ::std::string& value);
  #if LANG_CXX11
  void set_player_id(::std::string&& value);
  #endif
  void set_player_id(const char* value);
  void set_player_id(const char* value, size_t size);
  ::std::string* mutable_player_id();
  ::std::string* release_player_id();
  void set_allocated_player_id(::std::string* player_id);

  // string bundle_id = 2;
  void clear_bundle_id();
  static const int kBundleIdFieldNumber = 2;
  const ::std::string& bundle_id() const;
  void set_bundle_id(const ::std::string& value);
  #if LANG_CXX11
  void set_bundle_id(::std::string&& value);
  #endif
  void set_bundle_id(const char* value);
  void set_bundle_id(const char* value, size_t size);
  ::std::string* mutable_bundle_id();
  ::std::string* release_bundle_id();
  void set_allocated_bundle_id(::std::string* bundle_id);

  // string salt = 4;
  void clear_salt();
  static const int kSaltFieldNumber = 4;
  const ::std::string& salt() const;
  void set_salt(const ::std::string& value);
  #if LANG_CXX11
  void set_salt(::std::string&& value);
  #endif
  void set_salt(const char* value);
  void set_salt(const char* value, size_t size);
  ::std::string* mutable_salt();
  ::std::string* release_salt();
  void set_allocated_salt(::std::string* salt);

  // string signature = 5;
  void clear_signature();
  static const int kSignatureFieldNumber = 5;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_signature(::std::string&& value);
  #endif
  void set_signature(const char* value);
  void set_signature(const char* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // string public_key_url = 6;
  void clear_public_key_url();
  static const int kPublicKeyUrlFieldNumber = 6;
  const ::std::string& public_key_url() const;
  void set_public_key_url(const ::std::string& value);
  #if LANG_CXX11
  void set_public_key_url(::std::string&& value);
  #endif
  void set_public_key_url(const char* value);
  void set_public_key_url(const char* value, size_t size);
  ::std::string* mutable_public_key_url();
  ::std::string* release_public_key_url();
  void set_allocated_public_key_url(::std::string* public_key_url);

  // int64 timestamp_seconds = 3;
  void clear_timestamp_seconds();
  static const int kTimestampSecondsFieldNumber = 3;
  ::google::protobuf::int64 timestamp_seconds() const;
  void set_timestamp_seconds(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:nakama.api.AccountGameCenter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr player_id_;
  ::google::protobuf::internal::ArenaStringPtr bundle_id_;
  ::google::protobuf::internal::ArenaStringPtr salt_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  ::google::protobuf::internal::ArenaStringPtr public_key_url_;
  ::google::protobuf::int64 timestamp_seconds_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccountGoogle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.AccountGoogle) */ {
 public:
  AccountGoogle();
  virtual ~AccountGoogle();

  AccountGoogle(const AccountGoogle& from);

  inline AccountGoogle& operator=(const AccountGoogle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccountGoogle(AccountGoogle&& from) noexcept
    : AccountGoogle() {
    *this = ::std::move(from);
  }

  inline AccountGoogle& operator=(AccountGoogle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountGoogle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccountGoogle* internal_default_instance() {
    return reinterpret_cast<const AccountGoogle*>(
               &_AccountGoogle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(AccountGoogle* other);
  friend void swap(AccountGoogle& a, AccountGoogle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccountGoogle* New() const final {
    return CreateMaybeMessage<AccountGoogle>(NULL);
  }

  AccountGoogle* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccountGoogle>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccountGoogle& from);
  void MergeFrom(const AccountGoogle& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountGoogle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string token = 1;
  void clear_token();
  static const int kTokenFieldNumber = 1;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  #if LANG_CXX11
  void set_token(::std::string&& value);
  #endif
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:nakama.api.AccountGoogle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccountSteam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.AccountSteam) */ {
 public:
  AccountSteam();
  virtual ~AccountSteam();

  AccountSteam(const AccountSteam& from);

  inline AccountSteam& operator=(const AccountSteam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccountSteam(AccountSteam&& from) noexcept
    : AccountSteam() {
    *this = ::std::move(from);
  }

  inline AccountSteam& operator=(AccountSteam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountSteam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccountSteam* internal_default_instance() {
    return reinterpret_cast<const AccountSteam*>(
               &_AccountSteam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(AccountSteam* other);
  friend void swap(AccountSteam& a, AccountSteam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccountSteam* New() const final {
    return CreateMaybeMessage<AccountSteam>(NULL);
  }

  AccountSteam* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccountSteam>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccountSteam& from);
  void MergeFrom(const AccountSteam& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountSteam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string token = 1;
  void clear_token();
  static const int kTokenFieldNumber = 1;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  #if LANG_CXX11
  void set_token(::std::string&& value);
  #endif
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:nakama.api.AccountSteam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddFriendsRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.AddFriendsRequest) */ {
 public:
  AddFriendsRequest();
  virtual ~AddFriendsRequest();

  AddFriendsRequest(const AddFriendsRequest& from);

  inline AddFriendsRequest& operator=(const AddFriendsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddFriendsRequest(AddFriendsRequest&& from) noexcept
    : AddFriendsRequest() {
    *this = ::std::move(from);
  }

  inline AddFriendsRequest& operator=(AddFriendsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddFriendsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddFriendsRequest* internal_default_instance() {
    return reinterpret_cast<const AddFriendsRequest*>(
               &_AddFriendsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(AddFriendsRequest* other);
  friend void swap(AddFriendsRequest& a, AddFriendsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddFriendsRequest* New() const final {
    return CreateMaybeMessage<AddFriendsRequest>(NULL);
  }

  AddFriendsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddFriendsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AddFriendsRequest& from);
  void MergeFrom(const AddFriendsRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddFriendsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string ids = 1;
  int ids_size() const;
  void clear_ids();
  static const int kIdsFieldNumber = 1;
  const ::std::string& ids(int index) const;
  ::std::string* mutable_ids(int index);
  void set_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_ids(int index, ::std::string&& value);
  #endif
  void set_ids(int index, const char* value);
  void set_ids(int index, const char* value, size_t size);
  ::std::string* add_ids();
  void add_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_ids(::std::string&& value);
  #endif
  void add_ids(const char* value);
  void add_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ids();

  // repeated string usernames = 2;
  int usernames_size() const;
  void clear_usernames();
  static const int kUsernamesFieldNumber = 2;
  const ::std::string& usernames(int index) const;
  ::std::string* mutable_usernames(int index);
  void set_usernames(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_usernames(int index, ::std::string&& value);
  #endif
  void set_usernames(int index, const char* value);
  void set_usernames(int index, const char* value, size_t size);
  ::std::string* add_usernames();
  void add_usernames(const ::std::string& value);
  #if LANG_CXX11
  void add_usernames(::std::string&& value);
  #endif
  void add_usernames(const char* value);
  void add_usernames(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& usernames() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_usernames();

  // @@protoc_insertion_point(class_scope:nakama.api.AddFriendsRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ids_;
  ::google::protobuf::RepeatedPtrField< ::std::string> usernames_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddGroupUsersRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.AddGroupUsersRequest) */ {
 public:
  AddGroupUsersRequest();
  virtual ~AddGroupUsersRequest();

  AddGroupUsersRequest(const AddGroupUsersRequest& from);

  inline AddGroupUsersRequest& operator=(const AddGroupUsersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddGroupUsersRequest(AddGroupUsersRequest&& from) noexcept
    : AddGroupUsersRequest() {
    *this = ::std::move(from);
  }

  inline AddGroupUsersRequest& operator=(AddGroupUsersRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddGroupUsersRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddGroupUsersRequest* internal_default_instance() {
    return reinterpret_cast<const AddGroupUsersRequest*>(
               &_AddGroupUsersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(AddGroupUsersRequest* other);
  friend void swap(AddGroupUsersRequest& a, AddGroupUsersRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddGroupUsersRequest* New() const final {
    return CreateMaybeMessage<AddGroupUsersRequest>(NULL);
  }

  AddGroupUsersRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddGroupUsersRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AddGroupUsersRequest& from);
  void MergeFrom(const AddGroupUsersRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddGroupUsersRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string user_ids = 2;
  int user_ids_size() const;
  void clear_user_ids();
  static const int kUserIdsFieldNumber = 2;
  const ::std::string& user_ids(int index) const;
  ::std::string* mutable_user_ids(int index);
  void set_user_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_user_ids(int index, ::std::string&& value);
  #endif
  void set_user_ids(int index, const char* value);
  void set_user_ids(int index, const char* value, size_t size);
  ::std::string* add_user_ids();
  void add_user_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_user_ids(::std::string&& value);
  #endif
  void add_user_ids(const char* value);
  void add_user_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& user_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_user_ids();

  // string group_id = 1;
  void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  const ::std::string& group_id() const;
  void set_group_id(const ::std::string& value);
  #if LANG_CXX11
  void set_group_id(::std::string&& value);
  #endif
  void set_group_id(const char* value);
  void set_group_id(const char* value, size_t size);
  ::std::string* mutable_group_id();
  ::std::string* release_group_id();
  void set_allocated_group_id(::std::string* group_id);

  // @@protoc_insertion_point(class_scope:nakama.api.AddGroupUsersRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> user_ids_;
  ::google::protobuf::internal::ArenaStringPtr group_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AuthenticateCustomRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.AuthenticateCustomRequest) */ {
 public:
  AuthenticateCustomRequest();
  virtual ~AuthenticateCustomRequest();

  AuthenticateCustomRequest(const AuthenticateCustomRequest& from);

  inline AuthenticateCustomRequest& operator=(const AuthenticateCustomRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AuthenticateCustomRequest(AuthenticateCustomRequest&& from) noexcept
    : AuthenticateCustomRequest() {
    *this = ::std::move(from);
  }

  inline AuthenticateCustomRequest& operator=(AuthenticateCustomRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthenticateCustomRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AuthenticateCustomRequest* internal_default_instance() {
    return reinterpret_cast<const AuthenticateCustomRequest*>(
               &_AuthenticateCustomRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(AuthenticateCustomRequest* other);
  friend void swap(AuthenticateCustomRequest& a, AuthenticateCustomRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AuthenticateCustomRequest* New() const final {
    return CreateMaybeMessage<AuthenticateCustomRequest>(NULL);
  }

  AuthenticateCustomRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AuthenticateCustomRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AuthenticateCustomRequest& from);
  void MergeFrom(const AuthenticateCustomRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticateCustomRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 3;
  void clear_username();
  static const int kUsernameFieldNumber = 3;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // .nakama.api.AccountCustom account = 1;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  private:
  const ::nakama::api::AccountCustom& _internal_account() const;
  public:
  const ::nakama::api::AccountCustom& account() const;
  ::nakama::api::AccountCustom* release_account();
  ::nakama::api::AccountCustom* mutable_account();
  void set_allocated_account(::nakama::api::AccountCustom* account);

  // .google.protobuf.BoolValue create = 2;
  bool has_create() const;
  void clear_create();
  static const int kCreateFieldNumber = 2;
  private:
  const ::google::protobuf::BoolValue& _internal_create() const;
  public:
  const ::google::protobuf::BoolValue& create() const;
  ::google::protobuf::BoolValue* release_create();
  ::google::protobuf::BoolValue* mutable_create();
  void set_allocated_create(::google::protobuf::BoolValue* create);

  // @@protoc_insertion_point(class_scope:nakama.api.AuthenticateCustomRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::nakama::api::AccountCustom* account_;
  ::google::protobuf::BoolValue* create_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AuthenticateDeviceRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.AuthenticateDeviceRequest) */ {
 public:
  AuthenticateDeviceRequest();
  virtual ~AuthenticateDeviceRequest();

  AuthenticateDeviceRequest(const AuthenticateDeviceRequest& from);

  inline AuthenticateDeviceRequest& operator=(const AuthenticateDeviceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AuthenticateDeviceRequest(AuthenticateDeviceRequest&& from) noexcept
    : AuthenticateDeviceRequest() {
    *this = ::std::move(from);
  }

  inline AuthenticateDeviceRequest& operator=(AuthenticateDeviceRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthenticateDeviceRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AuthenticateDeviceRequest* internal_default_instance() {
    return reinterpret_cast<const AuthenticateDeviceRequest*>(
               &_AuthenticateDeviceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(AuthenticateDeviceRequest* other);
  friend void swap(AuthenticateDeviceRequest& a, AuthenticateDeviceRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AuthenticateDeviceRequest* New() const final {
    return CreateMaybeMessage<AuthenticateDeviceRequest>(NULL);
  }

  AuthenticateDeviceRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AuthenticateDeviceRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AuthenticateDeviceRequest& from);
  void MergeFrom(const AuthenticateDeviceRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticateDeviceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 3;
  void clear_username();
  static const int kUsernameFieldNumber = 3;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // .nakama.api.AccountDevice account = 1;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  private:
  const ::nakama::api::AccountDevice& _internal_account() const;
  public:
  const ::nakama::api::AccountDevice& account() const;
  ::nakama::api::AccountDevice* release_account();
  ::nakama::api::AccountDevice* mutable_account();
  void set_allocated_account(::nakama::api::AccountDevice* account);

  // .google.protobuf.BoolValue create = 2;
  bool has_create() const;
  void clear_create();
  static const int kCreateFieldNumber = 2;
  private:
  const ::google::protobuf::BoolValue& _internal_create() const;
  public:
  const ::google::protobuf::BoolValue& create() const;
  ::google::protobuf::BoolValue* release_create();
  ::google::protobuf::BoolValue* mutable_create();
  void set_allocated_create(::google::protobuf::BoolValue* create);

  // @@protoc_insertion_point(class_scope:nakama.api.AuthenticateDeviceRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::nakama::api::AccountDevice* account_;
  ::google::protobuf::BoolValue* create_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AuthenticateEmailRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.AuthenticateEmailRequest) */ {
 public:
  AuthenticateEmailRequest();
  virtual ~AuthenticateEmailRequest();

  AuthenticateEmailRequest(const AuthenticateEmailRequest& from);

  inline AuthenticateEmailRequest& operator=(const AuthenticateEmailRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AuthenticateEmailRequest(AuthenticateEmailRequest&& from) noexcept
    : AuthenticateEmailRequest() {
    *this = ::std::move(from);
  }

  inline AuthenticateEmailRequest& operator=(AuthenticateEmailRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthenticateEmailRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AuthenticateEmailRequest* internal_default_instance() {
    return reinterpret_cast<const AuthenticateEmailRequest*>(
               &_AuthenticateEmailRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(AuthenticateEmailRequest* other);
  friend void swap(AuthenticateEmailRequest& a, AuthenticateEmailRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AuthenticateEmailRequest* New() const final {
    return CreateMaybeMessage<AuthenticateEmailRequest>(NULL);
  }

  AuthenticateEmailRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AuthenticateEmailRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AuthenticateEmailRequest& from);
  void MergeFrom(const AuthenticateEmailRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticateEmailRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 3;
  void clear_username();
  static const int kUsernameFieldNumber = 3;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // .nakama.api.AccountEmail account = 1;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  private:
  const ::nakama::api::AccountEmail& _internal_account() const;
  public:
  const ::nakama::api::AccountEmail& account() const;
  ::nakama::api::AccountEmail* release_account();
  ::nakama::api::AccountEmail* mutable_account();
  void set_allocated_account(::nakama::api::AccountEmail* account);

  // .google.protobuf.BoolValue create = 2;
  bool has_create() const;
  void clear_create();
  static const int kCreateFieldNumber = 2;
  private:
  const ::google::protobuf::BoolValue& _internal_create() const;
  public:
  const ::google::protobuf::BoolValue& create() const;
  ::google::protobuf::BoolValue* release_create();
  ::google::protobuf::BoolValue* mutable_create();
  void set_allocated_create(::google::protobuf::BoolValue* create);

  // @@protoc_insertion_point(class_scope:nakama.api.AuthenticateEmailRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::nakama::api::AccountEmail* account_;
  ::google::protobuf::BoolValue* create_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AuthenticateFacebookRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.AuthenticateFacebookRequest) */ {
 public:
  AuthenticateFacebookRequest();
  virtual ~AuthenticateFacebookRequest();

  AuthenticateFacebookRequest(const AuthenticateFacebookRequest& from);

  inline AuthenticateFacebookRequest& operator=(const AuthenticateFacebookRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AuthenticateFacebookRequest(AuthenticateFacebookRequest&& from) noexcept
    : AuthenticateFacebookRequest() {
    *this = ::std::move(from);
  }

  inline AuthenticateFacebookRequest& operator=(AuthenticateFacebookRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthenticateFacebookRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AuthenticateFacebookRequest* internal_default_instance() {
    return reinterpret_cast<const AuthenticateFacebookRequest*>(
               &_AuthenticateFacebookRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(AuthenticateFacebookRequest* other);
  friend void swap(AuthenticateFacebookRequest& a, AuthenticateFacebookRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AuthenticateFacebookRequest* New() const final {
    return CreateMaybeMessage<AuthenticateFacebookRequest>(NULL);
  }

  AuthenticateFacebookRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AuthenticateFacebookRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AuthenticateFacebookRequest& from);
  void MergeFrom(const AuthenticateFacebookRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticateFacebookRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 3;
  void clear_username();
  static const int kUsernameFieldNumber = 3;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // .nakama.api.AccountFacebook account = 1;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  private:
  const ::nakama::api::AccountFacebook& _internal_account() const;
  public:
  const ::nakama::api::AccountFacebook& account() const;
  ::nakama::api::AccountFacebook* release_account();
  ::nakama::api::AccountFacebook* mutable_account();
  void set_allocated_account(::nakama::api::AccountFacebook* account);

  // .google.protobuf.BoolValue create = 2;
  bool has_create() const;
  void clear_create();
  static const int kCreateFieldNumber = 2;
  private:
  const ::google::protobuf::BoolValue& _internal_create() const;
  public:
  const ::google::protobuf::BoolValue& create() const;
  ::google::protobuf::BoolValue* release_create();
  ::google::protobuf::BoolValue* mutable_create();
  void set_allocated_create(::google::protobuf::BoolValue* create);

  // .google.protobuf.BoolValue import = 4;
  bool has_import() const;
  void clear_import();
  static const int kImportFieldNumber = 4;
  private:
  const ::google::protobuf::BoolValue& _internal_import() const;
  public:
  const ::google::protobuf::BoolValue& import() const;
  ::google::protobuf::BoolValue* release_import();
  ::google::protobuf::BoolValue* mutable_import();
  void set_allocated_import(::google::protobuf::BoolValue* import);

  // @@protoc_insertion_point(class_scope:nakama.api.AuthenticateFacebookRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::nakama::api::AccountFacebook* account_;
  ::google::protobuf::BoolValue* create_;
  ::google::protobuf::BoolValue* import_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AuthenticateGameCenterRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.AuthenticateGameCenterRequest) */ {
 public:
  AuthenticateGameCenterRequest();
  virtual ~AuthenticateGameCenterRequest();

  AuthenticateGameCenterRequest(const AuthenticateGameCenterRequest& from);

  inline AuthenticateGameCenterRequest& operator=(const AuthenticateGameCenterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AuthenticateGameCenterRequest(AuthenticateGameCenterRequest&& from) noexcept
    : AuthenticateGameCenterRequest() {
    *this = ::std::move(from);
  }

  inline AuthenticateGameCenterRequest& operator=(AuthenticateGameCenterRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthenticateGameCenterRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AuthenticateGameCenterRequest* internal_default_instance() {
    return reinterpret_cast<const AuthenticateGameCenterRequest*>(
               &_AuthenticateGameCenterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(AuthenticateGameCenterRequest* other);
  friend void swap(AuthenticateGameCenterRequest& a, AuthenticateGameCenterRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AuthenticateGameCenterRequest* New() const final {
    return CreateMaybeMessage<AuthenticateGameCenterRequest>(NULL);
  }

  AuthenticateGameCenterRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AuthenticateGameCenterRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AuthenticateGameCenterRequest& from);
  void MergeFrom(const AuthenticateGameCenterRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticateGameCenterRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 3;
  void clear_username();
  static const int kUsernameFieldNumber = 3;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // .nakama.api.AccountGameCenter account = 1;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  private:
  const ::nakama::api::AccountGameCenter& _internal_account() const;
  public:
  const ::nakama::api::AccountGameCenter& account() const;
  ::nakama::api::AccountGameCenter* release_account();
  ::nakama::api::AccountGameCenter* mutable_account();
  void set_allocated_account(::nakama::api::AccountGameCenter* account);

  // .google.protobuf.BoolValue create = 2;
  bool has_create() const;
  void clear_create();
  static const int kCreateFieldNumber = 2;
  private:
  const ::google::protobuf::BoolValue& _internal_create() const;
  public:
  const ::google::protobuf::BoolValue& create() const;
  ::google::protobuf::BoolValue* release_create();
  ::google::protobuf::BoolValue* mutable_create();
  void set_allocated_create(::google::protobuf::BoolValue* create);

  // @@protoc_insertion_point(class_scope:nakama.api.AuthenticateGameCenterRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::nakama::api::AccountGameCenter* account_;
  ::google::protobuf::BoolValue* create_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AuthenticateGoogleRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.AuthenticateGoogleRequest) */ {
 public:
  AuthenticateGoogleRequest();
  virtual ~AuthenticateGoogleRequest();

  AuthenticateGoogleRequest(const AuthenticateGoogleRequest& from);

  inline AuthenticateGoogleRequest& operator=(const AuthenticateGoogleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AuthenticateGoogleRequest(AuthenticateGoogleRequest&& from) noexcept
    : AuthenticateGoogleRequest() {
    *this = ::std::move(from);
  }

  inline AuthenticateGoogleRequest& operator=(AuthenticateGoogleRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthenticateGoogleRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AuthenticateGoogleRequest* internal_default_instance() {
    return reinterpret_cast<const AuthenticateGoogleRequest*>(
               &_AuthenticateGoogleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(AuthenticateGoogleRequest* other);
  friend void swap(AuthenticateGoogleRequest& a, AuthenticateGoogleRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AuthenticateGoogleRequest* New() const final {
    return CreateMaybeMessage<AuthenticateGoogleRequest>(NULL);
  }

  AuthenticateGoogleRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AuthenticateGoogleRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AuthenticateGoogleRequest& from);
  void MergeFrom(const AuthenticateGoogleRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticateGoogleRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 3;
  void clear_username();
  static const int kUsernameFieldNumber = 3;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // .nakama.api.AccountGoogle account = 1;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  private:
  const ::nakama::api::AccountGoogle& _internal_account() const;
  public:
  const ::nakama::api::AccountGoogle& account() const;
  ::nakama::api::AccountGoogle* release_account();
  ::nakama::api::AccountGoogle* mutable_account();
  void set_allocated_account(::nakama::api::AccountGoogle* account);

  // .google.protobuf.BoolValue create = 2;
  bool has_create() const;
  void clear_create();
  static const int kCreateFieldNumber = 2;
  private:
  const ::google::protobuf::BoolValue& _internal_create() const;
  public:
  const ::google::protobuf::BoolValue& create() const;
  ::google::protobuf::BoolValue* release_create();
  ::google::protobuf::BoolValue* mutable_create();
  void set_allocated_create(::google::protobuf::BoolValue* create);

  // @@protoc_insertion_point(class_scope:nakama.api.AuthenticateGoogleRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::nakama::api::AccountGoogle* account_;
  ::google::protobuf::BoolValue* create_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AuthenticateSteamRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.AuthenticateSteamRequest) */ {
 public:
  AuthenticateSteamRequest();
  virtual ~AuthenticateSteamRequest();

  AuthenticateSteamRequest(const AuthenticateSteamRequest& from);

  inline AuthenticateSteamRequest& operator=(const AuthenticateSteamRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AuthenticateSteamRequest(AuthenticateSteamRequest&& from) noexcept
    : AuthenticateSteamRequest() {
    *this = ::std::move(from);
  }

  inline AuthenticateSteamRequest& operator=(AuthenticateSteamRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthenticateSteamRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AuthenticateSteamRequest* internal_default_instance() {
    return reinterpret_cast<const AuthenticateSteamRequest*>(
               &_AuthenticateSteamRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(AuthenticateSteamRequest* other);
  friend void swap(AuthenticateSteamRequest& a, AuthenticateSteamRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AuthenticateSteamRequest* New() const final {
    return CreateMaybeMessage<AuthenticateSteamRequest>(NULL);
  }

  AuthenticateSteamRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AuthenticateSteamRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AuthenticateSteamRequest& from);
  void MergeFrom(const AuthenticateSteamRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticateSteamRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 3;
  void clear_username();
  static const int kUsernameFieldNumber = 3;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // .nakama.api.AccountSteam account = 1;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  private:
  const ::nakama::api::AccountSteam& _internal_account() const;
  public:
  const ::nakama::api::AccountSteam& account() const;
  ::nakama::api::AccountSteam* release_account();
  ::nakama::api::AccountSteam* mutable_account();
  void set_allocated_account(::nakama::api::AccountSteam* account);

  // .google.protobuf.BoolValue create = 2;
  bool has_create() const;
  void clear_create();
  static const int kCreateFieldNumber = 2;
  private:
  const ::google::protobuf::BoolValue& _internal_create() const;
  public:
  const ::google::protobuf::BoolValue& create() const;
  ::google::protobuf::BoolValue* release_create();
  ::google::protobuf::BoolValue* mutable_create();
  void set_allocated_create(::google::protobuf::BoolValue* create);

  // @@protoc_insertion_point(class_scope:nakama.api.AuthenticateSteamRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::nakama::api::AccountSteam* account_;
  ::google::protobuf::BoolValue* create_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BlockFriendsRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.BlockFriendsRequest) */ {
 public:
  BlockFriendsRequest();
  virtual ~BlockFriendsRequest();

  BlockFriendsRequest(const BlockFriendsRequest& from);

  inline BlockFriendsRequest& operator=(const BlockFriendsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlockFriendsRequest(BlockFriendsRequest&& from) noexcept
    : BlockFriendsRequest() {
    *this = ::std::move(from);
  }

  inline BlockFriendsRequest& operator=(BlockFriendsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockFriendsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlockFriendsRequest* internal_default_instance() {
    return reinterpret_cast<const BlockFriendsRequest*>(
               &_BlockFriendsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(BlockFriendsRequest* other);
  friend void swap(BlockFriendsRequest& a, BlockFriendsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlockFriendsRequest* New() const final {
    return CreateMaybeMessage<BlockFriendsRequest>(NULL);
  }

  BlockFriendsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BlockFriendsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BlockFriendsRequest& from);
  void MergeFrom(const BlockFriendsRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockFriendsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string ids = 1;
  int ids_size() const;
  void clear_ids();
  static const int kIdsFieldNumber = 1;
  const ::std::string& ids(int index) const;
  ::std::string* mutable_ids(int index);
  void set_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_ids(int index, ::std::string&& value);
  #endif
  void set_ids(int index, const char* value);
  void set_ids(int index, const char* value, size_t size);
  ::std::string* add_ids();
  void add_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_ids(::std::string&& value);
  #endif
  void add_ids(const char* value);
  void add_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ids();

  // repeated string usernames = 2;
  int usernames_size() const;
  void clear_usernames();
  static const int kUsernamesFieldNumber = 2;
  const ::std::string& usernames(int index) const;
  ::std::string* mutable_usernames(int index);
  void set_usernames(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_usernames(int index, ::std::string&& value);
  #endif
  void set_usernames(int index, const char* value);
  void set_usernames(int index, const char* value, size_t size);
  ::std::string* add_usernames();
  void add_usernames(const ::std::string& value);
  #if LANG_CXX11
  void add_usernames(::std::string&& value);
  #endif
  void add_usernames(const char* value);
  void add_usernames(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& usernames() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_usernames();

  // @@protoc_insertion_point(class_scope:nakama.api.BlockFriendsRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ids_;
  ::google::protobuf::RepeatedPtrField< ::std::string> usernames_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ChannelMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.ChannelMessage) */ {
 public:
  ChannelMessage();
  virtual ~ChannelMessage();

  ChannelMessage(const ChannelMessage& from);

  inline ChannelMessage& operator=(const ChannelMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChannelMessage(ChannelMessage&& from) noexcept
    : ChannelMessage() {
    *this = ::std::move(from);
  }

  inline ChannelMessage& operator=(ChannelMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChannelMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChannelMessage* internal_default_instance() {
    return reinterpret_cast<const ChannelMessage*>(
               &_ChannelMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(ChannelMessage* other);
  friend void swap(ChannelMessage& a, ChannelMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChannelMessage* New() const final {
    return CreateMaybeMessage<ChannelMessage>(NULL);
  }

  ChannelMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChannelMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ChannelMessage& from);
  void MergeFrom(const ChannelMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string channel_id = 1;
  void clear_channel_id();
  static const int kChannelIdFieldNumber = 1;
  const ::std::string& channel_id() const;
  void set_channel_id(const ::std::string& value);
  #if LANG_CXX11
  void set_channel_id(::std::string&& value);
  #endif
  void set_channel_id(const char* value);
  void set_channel_id(const char* value, size_t size);
  ::std::string* mutable_channel_id();
  ::std::string* release_channel_id();
  void set_allocated_channel_id(::std::string* channel_id);

  // string message_id = 2;
  void clear_message_id();
  static const int kMessageIdFieldNumber = 2;
  const ::std::string& message_id() const;
  void set_message_id(const ::std::string& value);
  #if LANG_CXX11
  void set_message_id(::std::string&& value);
  #endif
  void set_message_id(const char* value);
  void set_message_id(const char* value, size_t size);
  ::std::string* mutable_message_id();
  ::std::string* release_message_id();
  void set_allocated_message_id(::std::string* message_id);

  // string sender_id = 4;
  void clear_sender_id();
  static const int kSenderIdFieldNumber = 4;
  const ::std::string& sender_id() const;
  void set_sender_id(const ::std::string& value);
  #if LANG_CXX11
  void set_sender_id(::std::string&& value);
  #endif
  void set_sender_id(const char* value);
  void set_sender_id(const char* value, size_t size);
  ::std::string* mutable_sender_id();
  ::std::string* release_sender_id();
  void set_allocated_sender_id(::std::string* sender_id);

  // string username = 5;
  void clear_username();
  static const int kUsernameFieldNumber = 5;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // string content = 6;
  void clear_content();
  static const int kContentFieldNumber = 6;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  #if LANG_CXX11
  void set_content(::std::string&& value);
  #endif
  void set_content(const char* value);
  void set_content(const char* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // .google.protobuf.Int32Value code = 3;
  bool has_code() const;
  void clear_code();
  static const int kCodeFieldNumber = 3;
  private:
  const ::google::protobuf::Int32Value& _internal_code() const;
  public:
  const ::google::protobuf::Int32Value& code() const;
  ::google::protobuf::Int32Value* release_code();
  ::google::protobuf::Int32Value* mutable_code();
  void set_allocated_code(::google::protobuf::Int32Value* code);

  // .google.protobuf.Timestamp create_time = 7;
  bool has_create_time() const;
  void clear_create_time();
  static const int kCreateTimeFieldNumber = 7;
  private:
  const ::google::protobuf::Timestamp& _internal_create_time() const;
  public:
  const ::google::protobuf::Timestamp& create_time() const;
  ::google::protobuf::Timestamp* release_create_time();
  ::google::protobuf::Timestamp* mutable_create_time();
  void set_allocated_create_time(::google::protobuf::Timestamp* create_time);

  // .google.protobuf.Timestamp update_time = 8;
  bool has_update_time() const;
  void clear_update_time();
  static const int kUpdateTimeFieldNumber = 8;
  private:
  const ::google::protobuf::Timestamp& _internal_update_time() const;
  public:
  const ::google::protobuf::Timestamp& update_time() const;
  ::google::protobuf::Timestamp* release_update_time();
  ::google::protobuf::Timestamp* mutable_update_time();
  void set_allocated_update_time(::google::protobuf::Timestamp* update_time);

  // .google.protobuf.BoolValue persistent = 9;
  bool has_persistent() const;
  void clear_persistent();
  static const int kPersistentFieldNumber = 9;
  private:
  const ::google::protobuf::BoolValue& _internal_persistent() const;
  public:
  const ::google::protobuf::BoolValue& persistent() const;
  ::google::protobuf::BoolValue* release_persistent();
  ::google::protobuf::BoolValue* mutable_persistent();
  void set_allocated_persistent(::google::protobuf::BoolValue* persistent);

  // @@protoc_insertion_point(class_scope:nakama.api.ChannelMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr channel_id_;
  ::google::protobuf::internal::ArenaStringPtr message_id_;
  ::google::protobuf::internal::ArenaStringPtr sender_id_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  ::google::protobuf::Int32Value* code_;
  ::google::protobuf::Timestamp* create_time_;
  ::google::protobuf::Timestamp* update_time_;
  ::google::protobuf::BoolValue* persistent_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ChannelMessageList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.ChannelMessageList) */ {
 public:
  ChannelMessageList();
  virtual ~ChannelMessageList();

  ChannelMessageList(const ChannelMessageList& from);

  inline ChannelMessageList& operator=(const ChannelMessageList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChannelMessageList(ChannelMessageList&& from) noexcept
    : ChannelMessageList() {
    *this = ::std::move(from);
  }

  inline ChannelMessageList& operator=(ChannelMessageList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChannelMessageList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChannelMessageList* internal_default_instance() {
    return reinterpret_cast<const ChannelMessageList*>(
               &_ChannelMessageList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(ChannelMessageList* other);
  friend void swap(ChannelMessageList& a, ChannelMessageList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChannelMessageList* New() const final {
    return CreateMaybeMessage<ChannelMessageList>(NULL);
  }

  ChannelMessageList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChannelMessageList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ChannelMessageList& from);
  void MergeFrom(const ChannelMessageList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelMessageList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nakama.api.ChannelMessage messages = 1;
  int messages_size() const;
  void clear_messages();
  static const int kMessagesFieldNumber = 1;
  ::nakama::api::ChannelMessage* mutable_messages(int index);
  ::google::protobuf::RepeatedPtrField< ::nakama::api::ChannelMessage >*
      mutable_messages();
  const ::nakama::api::ChannelMessage& messages(int index) const;
  ::nakama::api::ChannelMessage* add_messages();
  const ::google::protobuf::RepeatedPtrField< ::nakama::api::ChannelMessage >&
      messages() const;

  // string next_cursor = 2;
  void clear_next_cursor();
  static const int kNextCursorFieldNumber = 2;
  const ::std::string& next_cursor() const;
  void set_next_cursor(const ::std::string& value);
  #if LANG_CXX11
  void set_next_cursor(::std::string&& value);
  #endif
  void set_next_cursor(const char* value);
  void set_next_cursor(const char* value, size_t size);
  ::std::string* mutable_next_cursor();
  ::std::string* release_next_cursor();
  void set_allocated_next_cursor(::std::string* next_cursor);

  // string prev_cursor = 3;
  void clear_prev_cursor();
  static const int kPrevCursorFieldNumber = 3;
  const ::std::string& prev_cursor() const;
  void set_prev_cursor(const ::std::string& value);
  #if LANG_CXX11
  void set_prev_cursor(::std::string&& value);
  #endif
  void set_prev_cursor(const char* value);
  void set_prev_cursor(const char* value, size_t size);
  ::std::string* mutable_prev_cursor();
  ::std::string* release_prev_cursor();
  void set_allocated_prev_cursor(::std::string* prev_cursor);

  // @@protoc_insertion_point(class_scope:nakama.api.ChannelMessageList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::nakama::api::ChannelMessage > messages_;
  ::google::protobuf::internal::ArenaStringPtr next_cursor_;
  ::google::protobuf::internal::ArenaStringPtr prev_cursor_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CreateGroupRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.CreateGroupRequest) */ {
 public:
  CreateGroupRequest();
  virtual ~CreateGroupRequest();

  CreateGroupRequest(const CreateGroupRequest& from);

  inline CreateGroupRequest& operator=(const CreateGroupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateGroupRequest(CreateGroupRequest&& from) noexcept
    : CreateGroupRequest() {
    *this = ::std::move(from);
  }

  inline CreateGroupRequest& operator=(CreateGroupRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateGroupRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateGroupRequest* internal_default_instance() {
    return reinterpret_cast<const CreateGroupRequest*>(
               &_CreateGroupRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(CreateGroupRequest* other);
  friend void swap(CreateGroupRequest& a, CreateGroupRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateGroupRequest* New() const final {
    return CreateMaybeMessage<CreateGroupRequest>(NULL);
  }

  CreateGroupRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CreateGroupRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CreateGroupRequest& from);
  void MergeFrom(const CreateGroupRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateGroupRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string description = 2;
  void clear_description();
  static const int kDescriptionFieldNumber = 2;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // string lang_tag = 3;
  void clear_lang_tag();
  static const int kLangTagFieldNumber = 3;
  const ::std::string& lang_tag() const;
  void set_lang_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_lang_tag(::std::string&& value);
  #endif
  void set_lang_tag(const char* value);
  void set_lang_tag(const char* value, size_t size);
  ::std::string* mutable_lang_tag();
  ::std::string* release_lang_tag();
  void set_allocated_lang_tag(::std::string* lang_tag);

  // string avatar_url = 4;
  void clear_avatar_url();
  static const int kAvatarUrlFieldNumber = 4;
  const ::std::string& avatar_url() const;
  void set_avatar_url(const ::std::string& value);
  #if LANG_CXX11
  void set_avatar_url(::std::string&& value);
  #endif
  void set_avatar_url(const char* value);
  void set_avatar_url(const char* value, size_t size);
  ::std::string* mutable_avatar_url();
  ::std::string* release_avatar_url();
  void set_allocated_avatar_url(::std::string* avatar_url);

  // bool open = 5;
  void clear_open();
  static const int kOpenFieldNumber = 5;
  bool open() const;
  void set_open(bool value);

  // @@protoc_insertion_point(class_scope:nakama.api.CreateGroupRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr lang_tag_;
  ::google::protobuf::internal::ArenaStringPtr avatar_url_;
  bool open_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeleteFriendsRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.DeleteFriendsRequest) */ {
 public:
  DeleteFriendsRequest();
  virtual ~DeleteFriendsRequest();

  DeleteFriendsRequest(const DeleteFriendsRequest& from);

  inline DeleteFriendsRequest& operator=(const DeleteFriendsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteFriendsRequest(DeleteFriendsRequest&& from) noexcept
    : DeleteFriendsRequest() {
    *this = ::std::move(from);
  }

  inline DeleteFriendsRequest& operator=(DeleteFriendsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteFriendsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteFriendsRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteFriendsRequest*>(
               &_DeleteFriendsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(DeleteFriendsRequest* other);
  friend void swap(DeleteFriendsRequest& a, DeleteFriendsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteFriendsRequest* New() const final {
    return CreateMaybeMessage<DeleteFriendsRequest>(NULL);
  }

  DeleteFriendsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeleteFriendsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeleteFriendsRequest& from);
  void MergeFrom(const DeleteFriendsRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteFriendsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string ids = 1;
  int ids_size() const;
  void clear_ids();
  static const int kIdsFieldNumber = 1;
  const ::std::string& ids(int index) const;
  ::std::string* mutable_ids(int index);
  void set_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_ids(int index, ::std::string&& value);
  #endif
  void set_ids(int index, const char* value);
  void set_ids(int index, const char* value, size_t size);
  ::std::string* add_ids();
  void add_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_ids(::std::string&& value);
  #endif
  void add_ids(const char* value);
  void add_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ids();

  // repeated string usernames = 2;
  int usernames_size() const;
  void clear_usernames();
  static const int kUsernamesFieldNumber = 2;
  const ::std::string& usernames(int index) const;
  ::std::string* mutable_usernames(int index);
  void set_usernames(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_usernames(int index, ::std::string&& value);
  #endif
  void set_usernames(int index, const char* value);
  void set_usernames(int index, const char* value, size_t size);
  ::std::string* add_usernames();
  void add_usernames(const ::std::string& value);
  #if LANG_CXX11
  void add_usernames(::std::string&& value);
  #endif
  void add_usernames(const char* value);
  void add_usernames(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& usernames() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_usernames();

  // @@protoc_insertion_point(class_scope:nakama.api.DeleteFriendsRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ids_;
  ::google::protobuf::RepeatedPtrField< ::std::string> usernames_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeleteGroupRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.DeleteGroupRequest) */ {
 public:
  DeleteGroupRequest();
  virtual ~DeleteGroupRequest();

  DeleteGroupRequest(const DeleteGroupRequest& from);

  inline DeleteGroupRequest& operator=(const DeleteGroupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteGroupRequest(DeleteGroupRequest&& from) noexcept
    : DeleteGroupRequest() {
    *this = ::std::move(from);
  }

  inline DeleteGroupRequest& operator=(DeleteGroupRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteGroupRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteGroupRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteGroupRequest*>(
               &_DeleteGroupRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(DeleteGroupRequest* other);
  friend void swap(DeleteGroupRequest& a, DeleteGroupRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteGroupRequest* New() const final {
    return CreateMaybeMessage<DeleteGroupRequest>(NULL);
  }

  DeleteGroupRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeleteGroupRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeleteGroupRequest& from);
  void MergeFrom(const DeleteGroupRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteGroupRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string group_id = 1;
  void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  const ::std::string& group_id() const;
  void set_group_id(const ::std::string& value);
  #if LANG_CXX11
  void set_group_id(::std::string&& value);
  #endif
  void set_group_id(const char* value);
  void set_group_id(const char* value, size_t size);
  ::std::string* mutable_group_id();
  ::std::string* release_group_id();
  void set_allocated_group_id(::std::string* group_id);

  // @@protoc_insertion_point(class_scope:nakama.api.DeleteGroupRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr group_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeleteLeaderboardRecordRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.DeleteLeaderboardRecordRequest) */ {
 public:
  DeleteLeaderboardRecordRequest();
  virtual ~DeleteLeaderboardRecordRequest();

  DeleteLeaderboardRecordRequest(const DeleteLeaderboardRecordRequest& from);

  inline DeleteLeaderboardRecordRequest& operator=(const DeleteLeaderboardRecordRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteLeaderboardRecordRequest(DeleteLeaderboardRecordRequest&& from) noexcept
    : DeleteLeaderboardRecordRequest() {
    *this = ::std::move(from);
  }

  inline DeleteLeaderboardRecordRequest& operator=(DeleteLeaderboardRecordRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteLeaderboardRecordRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteLeaderboardRecordRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteLeaderboardRecordRequest*>(
               &_DeleteLeaderboardRecordRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(DeleteLeaderboardRecordRequest* other);
  friend void swap(DeleteLeaderboardRecordRequest& a, DeleteLeaderboardRecordRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteLeaderboardRecordRequest* New() const final {
    return CreateMaybeMessage<DeleteLeaderboardRecordRequest>(NULL);
  }

  DeleteLeaderboardRecordRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeleteLeaderboardRecordRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeleteLeaderboardRecordRequest& from);
  void MergeFrom(const DeleteLeaderboardRecordRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteLeaderboardRecordRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string leaderboard_id = 1;
  void clear_leaderboard_id();
  static const int kLeaderboardIdFieldNumber = 1;
  const ::std::string& leaderboard_id() const;
  void set_leaderboard_id(const ::std::string& value);
  #if LANG_CXX11
  void set_leaderboard_id(::std::string&& value);
  #endif
  void set_leaderboard_id(const char* value);
  void set_leaderboard_id(const char* value, size_t size);
  ::std::string* mutable_leaderboard_id();
  ::std::string* release_leaderboard_id();
  void set_allocated_leaderboard_id(::std::string* leaderboard_id);

  // @@protoc_insertion_point(class_scope:nakama.api.DeleteLeaderboardRecordRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr leaderboard_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeleteNotificationsRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.DeleteNotificationsRequest) */ {
 public:
  DeleteNotificationsRequest();
  virtual ~DeleteNotificationsRequest();

  DeleteNotificationsRequest(const DeleteNotificationsRequest& from);

  inline DeleteNotificationsRequest& operator=(const DeleteNotificationsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteNotificationsRequest(DeleteNotificationsRequest&& from) noexcept
    : DeleteNotificationsRequest() {
    *this = ::std::move(from);
  }

  inline DeleteNotificationsRequest& operator=(DeleteNotificationsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteNotificationsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteNotificationsRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteNotificationsRequest*>(
               &_DeleteNotificationsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(DeleteNotificationsRequest* other);
  friend void swap(DeleteNotificationsRequest& a, DeleteNotificationsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteNotificationsRequest* New() const final {
    return CreateMaybeMessage<DeleteNotificationsRequest>(NULL);
  }

  DeleteNotificationsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeleteNotificationsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeleteNotificationsRequest& from);
  void MergeFrom(const DeleteNotificationsRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteNotificationsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string ids = 1;
  int ids_size() const;
  void clear_ids();
  static const int kIdsFieldNumber = 1;
  const ::std::string& ids(int index) const;
  ::std::string* mutable_ids(int index);
  void set_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_ids(int index, ::std::string&& value);
  #endif
  void set_ids(int index, const char* value);
  void set_ids(int index, const char* value, size_t size);
  ::std::string* add_ids();
  void add_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_ids(::std::string&& value);
  #endif
  void add_ids(const char* value);
  void add_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ids();

  // @@protoc_insertion_point(class_scope:nakama.api.DeleteNotificationsRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ids_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeleteStorageObjectId : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.DeleteStorageObjectId) */ {
 public:
  DeleteStorageObjectId();
  virtual ~DeleteStorageObjectId();

  DeleteStorageObjectId(const DeleteStorageObjectId& from);

  inline DeleteStorageObjectId& operator=(const DeleteStorageObjectId& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteStorageObjectId(DeleteStorageObjectId&& from) noexcept
    : DeleteStorageObjectId() {
    *this = ::std::move(from);
  }

  inline DeleteStorageObjectId& operator=(DeleteStorageObjectId&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteStorageObjectId& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteStorageObjectId* internal_default_instance() {
    return reinterpret_cast<const DeleteStorageObjectId*>(
               &_DeleteStorageObjectId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(DeleteStorageObjectId* other);
  friend void swap(DeleteStorageObjectId& a, DeleteStorageObjectId& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteStorageObjectId* New() const final {
    return CreateMaybeMessage<DeleteStorageObjectId>(NULL);
  }

  DeleteStorageObjectId* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeleteStorageObjectId>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeleteStorageObjectId& from);
  void MergeFrom(const DeleteStorageObjectId& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteStorageObjectId* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string collection = 1;
  void clear_collection();
  static const int kCollectionFieldNumber = 1;
  const ::std::string& collection() const;
  void set_collection(const ::std::string& value);
  #if LANG_CXX11
  void set_collection(::std::string&& value);
  #endif
  void set_collection(const char* value);
  void set_collection(const char* value, size_t size);
  ::std::string* mutable_collection();
  ::std::string* release_collection();
  void set_allocated_collection(::std::string* collection);

  // string key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string version = 3;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:nakama.api.DeleteStorageObjectId)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr collection_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeleteStorageObjectsRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.DeleteStorageObjectsRequest) */ {
 public:
  DeleteStorageObjectsRequest();
  virtual ~DeleteStorageObjectsRequest();

  DeleteStorageObjectsRequest(const DeleteStorageObjectsRequest& from);

  inline DeleteStorageObjectsRequest& operator=(const DeleteStorageObjectsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteStorageObjectsRequest(DeleteStorageObjectsRequest&& from) noexcept
    : DeleteStorageObjectsRequest() {
    *this = ::std::move(from);
  }

  inline DeleteStorageObjectsRequest& operator=(DeleteStorageObjectsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteStorageObjectsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteStorageObjectsRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteStorageObjectsRequest*>(
               &_DeleteStorageObjectsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(DeleteStorageObjectsRequest* other);
  friend void swap(DeleteStorageObjectsRequest& a, DeleteStorageObjectsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteStorageObjectsRequest* New() const final {
    return CreateMaybeMessage<DeleteStorageObjectsRequest>(NULL);
  }

  DeleteStorageObjectsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeleteStorageObjectsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeleteStorageObjectsRequest& from);
  void MergeFrom(const DeleteStorageObjectsRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteStorageObjectsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nakama.api.DeleteStorageObjectId object_ids = 1;
  int object_ids_size() const;
  void clear_object_ids();
  static const int kObjectIdsFieldNumber = 1;
  ::nakama::api::DeleteStorageObjectId* mutable_object_ids(int index);
  ::google::protobuf::RepeatedPtrField< ::nakama::api::DeleteStorageObjectId >*
      mutable_object_ids();
  const ::nakama::api::DeleteStorageObjectId& object_ids(int index) const;
  ::nakama::api::DeleteStorageObjectId* add_object_ids();
  const ::google::protobuf::RepeatedPtrField< ::nakama::api::DeleteStorageObjectId >&
      object_ids() const;

  // @@protoc_insertion_point(class_scope:nakama.api.DeleteStorageObjectsRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::nakama::api::DeleteStorageObjectId > object_ids_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Friend : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.Friend) */ {
 public:
  Friend();
  virtual ~Friend();

  Friend(const Friend& from);

  inline Friend& operator=(const Friend& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Friend(Friend&& from) noexcept
    : Friend() {
    *this = ::std::move(from);
  }

  inline Friend& operator=(Friend&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Friend& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Friend* internal_default_instance() {
    return reinterpret_cast<const Friend*>(
               &_Friend_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(Friend* other);
  friend void swap(Friend& a, Friend& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Friend* New() const final {
    return CreateMaybeMessage<Friend>(NULL);
  }

  Friend* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Friend>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Friend& from);
  void MergeFrom(const Friend& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Friend* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Friend_State State;
  static const State FRIEND =
    Friend_State_FRIEND;
  static const State INVITE_SENT =
    Friend_State_INVITE_SENT;
  static const State INVITE_RECEIVED =
    Friend_State_INVITE_RECEIVED;
  static const State BLOCKED =
    Friend_State_BLOCKED;
  static inline bool State_IsValid(int value) {
    return Friend_State_IsValid(value);
  }
  static const State State_MIN =
    Friend_State_State_MIN;
  static const State State_MAX =
    Friend_State_State_MAX;
  static const int State_ARRAYSIZE =
    Friend_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  State_descriptor() {
    return Friend_State_descriptor();
  }
  static inline const ::std::string& State_Name(State value) {
    return Friend_State_Name(value);
  }
  static inline bool State_Parse(const ::std::string& name,
      State* value) {
    return Friend_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .nakama.api.User user = 1;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 1;
  private:
  const ::nakama::api::User& _internal_user() const;
  public:
  const ::nakama::api::User& user() const;
  ::nakama::api::User* release_user();
  ::nakama::api::User* mutable_user();
  void set_allocated_user(::nakama::api::User* user);

  // .google.protobuf.Int32Value state = 2;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 2;
  private:
  const ::google::protobuf::Int32Value& _internal_state() const;
  public:
  const ::google::protobuf::Int32Value& state() const;
  ::google::protobuf::Int32Value* release_state();
  ::google::protobuf::Int32Value* mutable_state();
  void set_allocated_state(::google::protobuf::Int32Value* state);

  // @@protoc_insertion_point(class_scope:nakama.api.Friend)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::nakama::api::User* user_;
  ::google::protobuf::Int32Value* state_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Friends : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.Friends) */ {
 public:
  Friends();
  virtual ~Friends();

  Friends(const Friends& from);

  inline Friends& operator=(const Friends& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Friends(Friends&& from) noexcept
    : Friends() {
    *this = ::std::move(from);
  }

  inline Friends& operator=(Friends&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Friends& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Friends* internal_default_instance() {
    return reinterpret_cast<const Friends*>(
               &_Friends_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(Friends* other);
  friend void swap(Friends& a, Friends& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Friends* New() const final {
    return CreateMaybeMessage<Friends>(NULL);
  }

  Friends* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Friends>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Friends& from);
  void MergeFrom(const Friends& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Friends* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nakama.api.Friend friends = 1;
  int friends_size() const;
  void clear_friends();
  static const int kFriendsFieldNumber = 1;
  ::nakama::api::Friend* mutable_friends(int index);
  ::google::protobuf::RepeatedPtrField< ::nakama::api::Friend >*
      mutable_friends();
  const ::nakama::api::Friend& friends(int index) const;
  ::nakama::api::Friend* add_friends();
  const ::google::protobuf::RepeatedPtrField< ::nakama::api::Friend >&
      friends() const;

  // @@protoc_insertion_point(class_scope:nakama.api.Friends)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::nakama::api::Friend > friends_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetUsersRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.GetUsersRequest) */ {
 public:
  GetUsersRequest();
  virtual ~GetUsersRequest();

  GetUsersRequest(const GetUsersRequest& from);

  inline GetUsersRequest& operator=(const GetUsersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetUsersRequest(GetUsersRequest&& from) noexcept
    : GetUsersRequest() {
    *this = ::std::move(from);
  }

  inline GetUsersRequest& operator=(GetUsersRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetUsersRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetUsersRequest* internal_default_instance() {
    return reinterpret_cast<const GetUsersRequest*>(
               &_GetUsersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(GetUsersRequest* other);
  friend void swap(GetUsersRequest& a, GetUsersRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetUsersRequest* New() const final {
    return CreateMaybeMessage<GetUsersRequest>(NULL);
  }

  GetUsersRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetUsersRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetUsersRequest& from);
  void MergeFrom(const GetUsersRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUsersRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string ids = 1;
  int ids_size() const;
  void clear_ids();
  static const int kIdsFieldNumber = 1;
  const ::std::string& ids(int index) const;
  ::std::string* mutable_ids(int index);
  void set_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_ids(int index, ::std::string&& value);
  #endif
  void set_ids(int index, const char* value);
  void set_ids(int index, const char* value, size_t size);
  ::std::string* add_ids();
  void add_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_ids(::std::string&& value);
  #endif
  void add_ids(const char* value);
  void add_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ids();

  // repeated string usernames = 2;
  int usernames_size() const;
  void clear_usernames();
  static const int kUsernamesFieldNumber = 2;
  const ::std::string& usernames(int index) const;
  ::std::string* mutable_usernames(int index);
  void set_usernames(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_usernames(int index, ::std::string&& value);
  #endif
  void set_usernames(int index, const char* value);
  void set_usernames(int index, const char* value, size_t size);
  ::std::string* add_usernames();
  void add_usernames(const ::std::string& value);
  #if LANG_CXX11
  void add_usernames(::std::string&& value);
  #endif
  void add_usernames(const char* value);
  void add_usernames(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& usernames() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_usernames();

  // repeated string facebook_ids = 3;
  int facebook_ids_size() const;
  void clear_facebook_ids();
  static const int kFacebookIdsFieldNumber = 3;
  const ::std::string& facebook_ids(int index) const;
  ::std::string* mutable_facebook_ids(int index);
  void set_facebook_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_facebook_ids(int index, ::std::string&& value);
  #endif
  void set_facebook_ids(int index, const char* value);
  void set_facebook_ids(int index, const char* value, size_t size);
  ::std::string* add_facebook_ids();
  void add_facebook_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_facebook_ids(::std::string&& value);
  #endif
  void add_facebook_ids(const char* value);
  void add_facebook_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& facebook_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_facebook_ids();

  // @@protoc_insertion_point(class_scope:nakama.api.GetUsersRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ids_;
  ::google::protobuf::RepeatedPtrField< ::std::string> usernames_;
  ::google::protobuf::RepeatedPtrField< ::std::string> facebook_ids_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Group : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.Group) */ {
 public:
  Group();
  virtual ~Group();

  Group(const Group& from);

  inline Group& operator=(const Group& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Group(Group&& from) noexcept
    : Group() {
    *this = ::std::move(from);
  }

  inline Group& operator=(Group&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Group& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Group* internal_default_instance() {
    return reinterpret_cast<const Group*>(
               &_Group_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(Group* other);
  friend void swap(Group& a, Group& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Group* New() const final {
    return CreateMaybeMessage<Group>(NULL);
  }

  Group* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Group>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Group& from);
  void MergeFrom(const Group& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Group* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string creator_id = 2;
  void clear_creator_id();
  static const int kCreatorIdFieldNumber = 2;
  const ::std::string& creator_id() const;
  void set_creator_id(const ::std::string& value);
  #if LANG_CXX11
  void set_creator_id(::std::string&& value);
  #endif
  void set_creator_id(const char* value);
  void set_creator_id(const char* value, size_t size);
  ::std::string* mutable_creator_id();
  ::std::string* release_creator_id();
  void set_allocated_creator_id(::std::string* creator_id);

  // string name = 3;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string description = 4;
  void clear_description();
  static const int kDescriptionFieldNumber = 4;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // string lang_tag = 5;
  void clear_lang_tag();
  static const int kLangTagFieldNumber = 5;
  const ::std::string& lang_tag() const;
  void set_lang_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_lang_tag(::std::string&& value);
  #endif
  void set_lang_tag(const char* value);
  void set_lang_tag(const char* value, size_t size);
  ::std::string* mutable_lang_tag();
  ::std::string* release_lang_tag();
  void set_allocated_lang_tag(::std::string* lang_tag);

  // string metadata = 6;
  void clear_metadata();
  static const int kMetadataFieldNumber = 6;
  const ::std::string& metadata() const;
  void set_metadata(const ::std::string& value);
  #if LANG_CXX11
  void set_metadata(::std::string&& value);
  #endif
  void set_metadata(const char* value);
  void set_metadata(const char* value, size_t size);
  ::std::string* mutable_metadata();
  ::std::string* release_metadata();
  void set_allocated_metadata(::std::string* metadata);

  // string avatar_url = 7;
  void clear_avatar_url();
  static const int kAvatarUrlFieldNumber = 7;
  const ::std::string& avatar_url() const;
  void set_avatar_url(const ::std::string& value);
  #if LANG_CXX11
  void set_avatar_url(::std::string&& value);
  #endif
  void set_avatar_url(const char* value);
  void set_avatar_url(const char* value, size_t size);
  ::std::string* mutable_avatar_url();
  ::std::string* release_avatar_url();
  void set_allocated_avatar_url(::std::string* avatar_url);

  // .google.protobuf.BoolValue open = 8;
  bool has_open() const;
  void clear_open();
  static const int kOpenFieldNumber = 8;
  private:
  const ::google::protobuf::BoolValue& _internal_open() const;
  public:
  const ::google::protobuf::BoolValue& open() const;
  ::google::protobuf::BoolValue* release_open();
  ::google::protobuf::BoolValue* mutable_open();
  void set_allocated_open(::google::protobuf::BoolValue* open);

  // .google.protobuf.Timestamp create_time = 11;
  bool has_create_time() const;
  void clear_create_time();
  static const int kCreateTimeFieldNumber = 11;
  private:
  const ::google::protobuf::Timestamp& _internal_create_time() const;
  public:
  const ::google::protobuf::Timestamp& create_time() const;
  ::google::protobuf::Timestamp* release_create_time();
  ::google::protobuf::Timestamp* mutable_create_time();
  void set_allocated_create_time(::google::protobuf::Timestamp* create_time);

  // .google.protobuf.Timestamp update_time = 12;
  bool has_update_time() const;
  void clear_update_time();
  static const int kUpdateTimeFieldNumber = 12;
  private:
  const ::google::protobuf::Timestamp& _internal_update_time() const;
  public:
  const ::google::protobuf::Timestamp& update_time() const;
  ::google::protobuf::Timestamp* release_update_time();
  ::google::protobuf::Timestamp* mutable_update_time();
  void set_allocated_update_time(::google::protobuf::Timestamp* update_time);

  // int32 edge_count = 9;
  void clear_edge_count();
  static const int kEdgeCountFieldNumber = 9;
  ::google::protobuf::int32 edge_count() const;
  void set_edge_count(::google::protobuf::int32 value);

  // int32 max_count = 10;
  void clear_max_count();
  static const int kMaxCountFieldNumber = 10;
  ::google::protobuf::int32 max_count() const;
  void set_max_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:nakama.api.Group)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr creator_id_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr lang_tag_;
  ::google::protobuf::internal::ArenaStringPtr metadata_;
  ::google::protobuf::internal::ArenaStringPtr avatar_url_;
  ::google::protobuf::BoolValue* open_;
  ::google::protobuf::Timestamp* create_time_;
  ::google::protobuf::Timestamp* update_time_;
  ::google::protobuf::int32 edge_count_;
  ::google::protobuf::int32 max_count_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GroupList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.GroupList) */ {
 public:
  GroupList();
  virtual ~GroupList();

  GroupList(const GroupList& from);

  inline GroupList& operator=(const GroupList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GroupList(GroupList&& from) noexcept
    : GroupList() {
    *this = ::std::move(from);
  }

  inline GroupList& operator=(GroupList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GroupList* internal_default_instance() {
    return reinterpret_cast<const GroupList*>(
               &_GroupList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(GroupList* other);
  friend void swap(GroupList& a, GroupList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GroupList* New() const final {
    return CreateMaybeMessage<GroupList>(NULL);
  }

  GroupList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GroupList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GroupList& from);
  void MergeFrom(const GroupList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nakama.api.Group groups = 1;
  int groups_size() const;
  void clear_groups();
  static const int kGroupsFieldNumber = 1;
  ::nakama::api::Group* mutable_groups(int index);
  ::google::protobuf::RepeatedPtrField< ::nakama::api::Group >*
      mutable_groups();
  const ::nakama::api::Group& groups(int index) const;
  ::nakama::api::Group* add_groups();
  const ::google::protobuf::RepeatedPtrField< ::nakama::api::Group >&
      groups() const;

  // string cursor = 2;
  void clear_cursor();
  static const int kCursorFieldNumber = 2;
  const ::std::string& cursor() const;
  void set_cursor(const ::std::string& value);
  #if LANG_CXX11
  void set_cursor(::std::string&& value);
  #endif
  void set_cursor(const char* value);
  void set_cursor(const char* value, size_t size);
  ::std::string* mutable_cursor();
  ::std::string* release_cursor();
  void set_allocated_cursor(::std::string* cursor);

  // @@protoc_insertion_point(class_scope:nakama.api.GroupList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::nakama::api::Group > groups_;
  ::google::protobuf::internal::ArenaStringPtr cursor_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GroupUserList_GroupUser : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.GroupUserList.GroupUser) */ {
 public:
  GroupUserList_GroupUser();
  virtual ~GroupUserList_GroupUser();

  GroupUserList_GroupUser(const GroupUserList_GroupUser& from);

  inline GroupUserList_GroupUser& operator=(const GroupUserList_GroupUser& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GroupUserList_GroupUser(GroupUserList_GroupUser&& from) noexcept
    : GroupUserList_GroupUser() {
    *this = ::std::move(from);
  }

  inline GroupUserList_GroupUser& operator=(GroupUserList_GroupUser&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupUserList_GroupUser& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GroupUserList_GroupUser* internal_default_instance() {
    return reinterpret_cast<const GroupUserList_GroupUser*>(
               &_GroupUserList_GroupUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(GroupUserList_GroupUser* other);
  friend void swap(GroupUserList_GroupUser& a, GroupUserList_GroupUser& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GroupUserList_GroupUser* New() const final {
    return CreateMaybeMessage<GroupUserList_GroupUser>(NULL);
  }

  GroupUserList_GroupUser* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GroupUserList_GroupUser>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GroupUserList_GroupUser& from);
  void MergeFrom(const GroupUserList_GroupUser& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupUserList_GroupUser* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GroupUserList_GroupUser_State State;
  static const State SUPERADMIN =
    GroupUserList_GroupUser_State_SUPERADMIN;
  static const State ADMIN =
    GroupUserList_GroupUser_State_ADMIN;
  static const State MEMBER =
    GroupUserList_GroupUser_State_MEMBER;
  static const State JOIN_REQUEST =
    GroupUserList_GroupUser_State_JOIN_REQUEST;
  static inline bool State_IsValid(int value) {
    return GroupUserList_GroupUser_State_IsValid(value);
  }
  static const State State_MIN =
    GroupUserList_GroupUser_State_State_MIN;
  static const State State_MAX =
    GroupUserList_GroupUser_State_State_MAX;
  static const int State_ARRAYSIZE =
    GroupUserList_GroupUser_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  State_descriptor() {
    return GroupUserList_GroupUser_State_descriptor();
  }
  static inline const ::std::string& State_Name(State value) {
    return GroupUserList_GroupUser_State_Name(value);
  }
  static inline bool State_Parse(const ::std::string& name,
      State* value) {
    return GroupUserList_GroupUser_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .nakama.api.User user = 1;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 1;
  private:
  const ::nakama::api::User& _internal_user() const;
  public:
  const ::nakama::api::User& user() const;
  ::nakama::api::User* release_user();
  ::nakama::api::User* mutable_user();
  void set_allocated_user(::nakama::api::User* user);

  // .google.protobuf.Int32Value state = 2;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 2;
  private:
  const ::google::protobuf::Int32Value& _internal_state() const;
  public:
  const ::google::protobuf::Int32Value& state() const;
  ::google::protobuf::Int32Value* release_state();
  ::google::protobuf::Int32Value* mutable_state();
  void set_allocated_state(::google::protobuf::Int32Value* state);

  // @@protoc_insertion_point(class_scope:nakama.api.GroupUserList.GroupUser)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::nakama::api::User* user_;
  ::google::protobuf::Int32Value* state_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GroupUserList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.GroupUserList) */ {
 public:
  GroupUserList();
  virtual ~GroupUserList();

  GroupUserList(const GroupUserList& from);

  inline GroupUserList& operator=(const GroupUserList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GroupUserList(GroupUserList&& from) noexcept
    : GroupUserList() {
    *this = ::std::move(from);
  }

  inline GroupUserList& operator=(GroupUserList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupUserList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GroupUserList* internal_default_instance() {
    return reinterpret_cast<const GroupUserList*>(
               &_GroupUserList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(GroupUserList* other);
  friend void swap(GroupUserList& a, GroupUserList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GroupUserList* New() const final {
    return CreateMaybeMessage<GroupUserList>(NULL);
  }

  GroupUserList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GroupUserList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GroupUserList& from);
  void MergeFrom(const GroupUserList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupUserList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GroupUserList_GroupUser GroupUser;

  // accessors -------------------------------------------------------

  // repeated .nakama.api.GroupUserList.GroupUser group_users = 1;
  int group_users_size() const;
  void clear_group_users();
  static const int kGroupUsersFieldNumber = 1;
  ::nakama::api::GroupUserList_GroupUser* mutable_group_users(int index);
  ::google::protobuf::RepeatedPtrField< ::nakama::api::GroupUserList_GroupUser >*
      mutable_group_users();
  const ::nakama::api::GroupUserList_GroupUser& group_users(int index) const;
  ::nakama::api::GroupUserList_GroupUser* add_group_users();
  const ::google::protobuf::RepeatedPtrField< ::nakama::api::GroupUserList_GroupUser >&
      group_users() const;

  // @@protoc_insertion_point(class_scope:nakama.api.GroupUserList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::nakama::api::GroupUserList_GroupUser > group_users_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImportFacebookFriendsRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.ImportFacebookFriendsRequest) */ {
 public:
  ImportFacebookFriendsRequest();
  virtual ~ImportFacebookFriendsRequest();

  ImportFacebookFriendsRequest(const ImportFacebookFriendsRequest& from);

  inline ImportFacebookFriendsRequest& operator=(const ImportFacebookFriendsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImportFacebookFriendsRequest(ImportFacebookFriendsRequest&& from) noexcept
    : ImportFacebookFriendsRequest() {
    *this = ::std::move(from);
  }

  inline ImportFacebookFriendsRequest& operator=(ImportFacebookFriendsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ImportFacebookFriendsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImportFacebookFriendsRequest* internal_default_instance() {
    return reinterpret_cast<const ImportFacebookFriendsRequest*>(
               &_ImportFacebookFriendsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(ImportFacebookFriendsRequest* other);
  friend void swap(ImportFacebookFriendsRequest& a, ImportFacebookFriendsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImportFacebookFriendsRequest* New() const final {
    return CreateMaybeMessage<ImportFacebookFriendsRequest>(NULL);
  }

  ImportFacebookFriendsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ImportFacebookFriendsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ImportFacebookFriendsRequest& from);
  void MergeFrom(const ImportFacebookFriendsRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImportFacebookFriendsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .nakama.api.AccountFacebook account = 1;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  private:
  const ::nakama::api::AccountFacebook& _internal_account() const;
  public:
  const ::nakama::api::AccountFacebook& account() const;
  ::nakama::api::AccountFacebook* release_account();
  ::nakama::api::AccountFacebook* mutable_account();
  void set_allocated_account(::nakama::api::AccountFacebook* account);

  // .google.protobuf.BoolValue reset = 2;
  bool has_reset() const;
  void clear_reset();
  static const int kResetFieldNumber = 2;
  private:
  const ::google::protobuf::BoolValue& _internal_reset() const;
  public:
  const ::google::protobuf::BoolValue& reset() const;
  ::google::protobuf::BoolValue* release_reset();
  ::google::protobuf::BoolValue* mutable_reset();
  void set_allocated_reset(::google::protobuf::BoolValue* reset);

  // @@protoc_insertion_point(class_scope:nakama.api.ImportFacebookFriendsRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::nakama::api::AccountFacebook* account_;
  ::google::protobuf::BoolValue* reset_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class JoinGroupRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.JoinGroupRequest) */ {
 public:
  JoinGroupRequest();
  virtual ~JoinGroupRequest();

  JoinGroupRequest(const JoinGroupRequest& from);

  inline JoinGroupRequest& operator=(const JoinGroupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JoinGroupRequest(JoinGroupRequest&& from) noexcept
    : JoinGroupRequest() {
    *this = ::std::move(from);
  }

  inline JoinGroupRequest& operator=(JoinGroupRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JoinGroupRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JoinGroupRequest* internal_default_instance() {
    return reinterpret_cast<const JoinGroupRequest*>(
               &_JoinGroupRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  void Swap(JoinGroupRequest* other);
  friend void swap(JoinGroupRequest& a, JoinGroupRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JoinGroupRequest* New() const final {
    return CreateMaybeMessage<JoinGroupRequest>(NULL);
  }

  JoinGroupRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<JoinGroupRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const JoinGroupRequest& from);
  void MergeFrom(const JoinGroupRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoinGroupRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string group_id = 1;
  void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  const ::std::string& group_id() const;
  void set_group_id(const ::std::string& value);
  #if LANG_CXX11
  void set_group_id(::std::string&& value);
  #endif
  void set_group_id(const char* value);
  void set_group_id(const char* value, size_t size);
  ::std::string* mutable_group_id();
  ::std::string* release_group_id();
  void set_allocated_group_id(::std::string* group_id);

  // @@protoc_insertion_point(class_scope:nakama.api.JoinGroupRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr group_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class JoinTournamentRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.JoinTournamentRequest) */ {
 public:
  JoinTournamentRequest();
  virtual ~JoinTournamentRequest();

  JoinTournamentRequest(const JoinTournamentRequest& from);

  inline JoinTournamentRequest& operator=(const JoinTournamentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JoinTournamentRequest(JoinTournamentRequest&& from) noexcept
    : JoinTournamentRequest() {
    *this = ::std::move(from);
  }

  inline JoinTournamentRequest& operator=(JoinTournamentRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JoinTournamentRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JoinTournamentRequest* internal_default_instance() {
    return reinterpret_cast<const JoinTournamentRequest*>(
               &_JoinTournamentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  void Swap(JoinTournamentRequest* other);
  friend void swap(JoinTournamentRequest& a, JoinTournamentRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JoinTournamentRequest* New() const final {
    return CreateMaybeMessage<JoinTournamentRequest>(NULL);
  }

  JoinTournamentRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<JoinTournamentRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const JoinTournamentRequest& from);
  void MergeFrom(const JoinTournamentRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoinTournamentRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string tournament_id = 1;
  void clear_tournament_id();
  static const int kTournamentIdFieldNumber = 1;
  const ::std::string& tournament_id() const;
  void set_tournament_id(const ::std::string& value);
  #if LANG_CXX11
  void set_tournament_id(::std::string&& value);
  #endif
  void set_tournament_id(const char* value);
  void set_tournament_id(const char* value, size_t size);
  ::std::string* mutable_tournament_id();
  ::std::string* release_tournament_id();
  void set_allocated_tournament_id(::std::string* tournament_id);

  // @@protoc_insertion_point(class_scope:nakama.api.JoinTournamentRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr tournament_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KickGroupUsersRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.KickGroupUsersRequest) */ {
 public:
  KickGroupUsersRequest();
  virtual ~KickGroupUsersRequest();

  KickGroupUsersRequest(const KickGroupUsersRequest& from);

  inline KickGroupUsersRequest& operator=(const KickGroupUsersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KickGroupUsersRequest(KickGroupUsersRequest&& from) noexcept
    : KickGroupUsersRequest() {
    *this = ::std::move(from);
  }

  inline KickGroupUsersRequest& operator=(KickGroupUsersRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KickGroupUsersRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KickGroupUsersRequest* internal_default_instance() {
    return reinterpret_cast<const KickGroupUsersRequest*>(
               &_KickGroupUsersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  void Swap(KickGroupUsersRequest* other);
  friend void swap(KickGroupUsersRequest& a, KickGroupUsersRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KickGroupUsersRequest* New() const final {
    return CreateMaybeMessage<KickGroupUsersRequest>(NULL);
  }

  KickGroupUsersRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KickGroupUsersRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KickGroupUsersRequest& from);
  void MergeFrom(const KickGroupUsersRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KickGroupUsersRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string user_ids = 2;
  int user_ids_size() const;
  void clear_user_ids();
  static const int kUserIdsFieldNumber = 2;
  const ::std::string& user_ids(int index) const;
  ::std::string* mutable_user_ids(int index);
  void set_user_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_user_ids(int index, ::std::string&& value);
  #endif
  void set_user_ids(int index, const char* value);
  void set_user_ids(int index, const char* value, size_t size);
  ::std::string* add_user_ids();
  void add_user_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_user_ids(::std::string&& value);
  #endif
  void add_user_ids(const char* value);
  void add_user_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& user_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_user_ids();

  // string group_id = 1;
  void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  const ::std::string& group_id() const;
  void set_group_id(const ::std::string& value);
  #if LANG_CXX11
  void set_group_id(::std::string&& value);
  #endif
  void set_group_id(const char* value);
  void set_group_id(const char* value, size_t size);
  ::std::string* mutable_group_id();
  ::std::string* release_group_id();
  void set_allocated_group_id(::std::string* group_id);

  // @@protoc_insertion_point(class_scope:nakama.api.KickGroupUsersRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> user_ids_;
  ::google::protobuf::internal::ArenaStringPtr group_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LeaderboardRecord : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.LeaderboardRecord) */ {
 public:
  LeaderboardRecord();
  virtual ~LeaderboardRecord();

  LeaderboardRecord(const LeaderboardRecord& from);

  inline LeaderboardRecord& operator=(const LeaderboardRecord& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LeaderboardRecord(LeaderboardRecord&& from) noexcept
    : LeaderboardRecord() {
    *this = ::std::move(from);
  }

  inline LeaderboardRecord& operator=(LeaderboardRecord&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaderboardRecord& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LeaderboardRecord* internal_default_instance() {
    return reinterpret_cast<const LeaderboardRecord*>(
               &_LeaderboardRecord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  void Swap(LeaderboardRecord* other);
  friend void swap(LeaderboardRecord& a, LeaderboardRecord& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LeaderboardRecord* New() const final {
    return CreateMaybeMessage<LeaderboardRecord>(NULL);
  }

  LeaderboardRecord* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LeaderboardRecord>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LeaderboardRecord& from);
  void MergeFrom(const LeaderboardRecord& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeaderboardRecord* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string leaderboard_id = 1;
  void clear_leaderboard_id();
  static const int kLeaderboardIdFieldNumber = 1;
  const ::std::string& leaderboard_id() const;
  void set_leaderboard_id(const ::std::string& value);
  #if LANG_CXX11
  void set_leaderboard_id(::std::string&& value);
  #endif
  void set_leaderboard_id(const char* value);
  void set_leaderboard_id(const char* value, size_t size);
  ::std::string* mutable_leaderboard_id();
  ::std::string* release_leaderboard_id();
  void set_allocated_leaderboard_id(::std::string* leaderboard_id);

  // string owner_id = 2;
  void clear_owner_id();
  static const int kOwnerIdFieldNumber = 2;
  const ::std::string& owner_id() const;
  void set_owner_id(const ::std::string& value);
  #if LANG_CXX11
  void set_owner_id(::std::string&& value);
  #endif
  void set_owner_id(const char* value);
  void set_owner_id(const char* value, size_t size);
  ::std::string* mutable_owner_id();
  ::std::string* release_owner_id();
  void set_allocated_owner_id(::std::string* owner_id);

  // string metadata = 7;
  void clear_metadata();
  static const int kMetadataFieldNumber = 7;
  const ::std::string& metadata() const;
  void set_metadata(const ::std::string& value);
  #if LANG_CXX11
  void set_metadata(::std::string&& value);
  #endif
  void set_metadata(const char* value);
  void set_metadata(const char* value, size_t size);
  ::std::string* mutable_metadata();
  ::std::string* release_metadata();
  void set_allocated_metadata(::std::string* metadata);

  // .google.protobuf.StringValue username = 3;
  bool has_username() const;
  void clear_username();
  static const int kUsernameFieldNumber = 3;
  private:
  const ::google::protobuf::StringValue& _internal_username() const;
  public:
  const ::google::protobuf::StringValue& username() const;
  ::google::protobuf::StringValue* release_username();
  ::google::protobuf::StringValue* mutable_username();
  void set_allocated_username(::google::protobuf::StringValue* username);

  // .google.protobuf.Timestamp create_time = 8;
  bool has_create_time() const;
  void clear_create_time();
  static const int kCreateTimeFieldNumber = 8;
  private:
  const ::google::protobuf::Timestamp& _internal_create_time() const;
  public:
  const ::google::protobuf::Timestamp& create_time() const;
  ::google::protobuf::Timestamp* release_create_time();
  ::google::protobuf::Timestamp* mutable_create_time();
  void set_allocated_create_time(::google::protobuf::Timestamp* create_time);

  // .google.protobuf.Timestamp update_time = 9;
  bool has_update_time() const;
  void clear_update_time();
  static const int kUpdateTimeFieldNumber = 9;
  private:
  const ::google::protobuf::Timestamp& _internal_update_time() const;
  public:
  const ::google::protobuf::Timestamp& update_time() const;
  ::google::protobuf::Timestamp* release_update_time();
  ::google::protobuf::Timestamp* mutable_update_time();
  void set_allocated_update_time(::google::protobuf::Timestamp* update_time);

  // .google.protobuf.Timestamp expiry_time = 10;
  bool has_expiry_time() const;
  void clear_expiry_time();
  static const int kExpiryTimeFieldNumber = 10;
  private:
  const ::google::protobuf::Timestamp& _internal_expiry_time() const;
  public:
  const ::google::protobuf::Timestamp& expiry_time() const;
  ::google::protobuf::Timestamp* release_expiry_time();
  ::google::protobuf::Timestamp* mutable_expiry_time();
  void set_allocated_expiry_time(::google::protobuf::Timestamp* expiry_time);

  // int64 score = 4;
  void clear_score();
  static const int kScoreFieldNumber = 4;
  ::google::protobuf::int64 score() const;
  void set_score(::google::protobuf::int64 value);

  // int64 subscore = 5;
  void clear_subscore();
  static const int kSubscoreFieldNumber = 5;
  ::google::protobuf::int64 subscore() const;
  void set_subscore(::google::protobuf::int64 value);

  // int32 num_score = 6;
  void clear_num_score();
  static const int kNumScoreFieldNumber = 6;
  ::google::protobuf::int32 num_score() const;
  void set_num_score(::google::protobuf::int32 value);

  // uint32 max_num_score = 12;
  void clear_max_num_score();
  static const int kMaxNumScoreFieldNumber = 12;
  ::google::protobuf::uint32 max_num_score() const;
  void set_max_num_score(::google::protobuf::uint32 value);

  // int64 rank = 11;
  void clear_rank();
  static const int kRankFieldNumber = 11;
  ::google::protobuf::int64 rank() const;
  void set_rank(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:nakama.api.LeaderboardRecord)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr leaderboard_id_;
  ::google::protobuf::internal::ArenaStringPtr owner_id_;
  ::google::protobuf::internal::ArenaStringPtr metadata_;
  ::google::protobuf::StringValue* username_;
  ::google::protobuf::Timestamp* create_time_;
  ::google::protobuf::Timestamp* update_time_;
  ::google::protobuf::Timestamp* expiry_time_;
  ::google::protobuf::int64 score_;
  ::google::protobuf::int64 subscore_;
  ::google::protobuf::int32 num_score_;
  ::google::protobuf::uint32 max_num_score_;
  ::google::protobuf::int64 rank_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LeaderboardRecordList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.LeaderboardRecordList) */ {
 public:
  LeaderboardRecordList();
  virtual ~LeaderboardRecordList();

  LeaderboardRecordList(const LeaderboardRecordList& from);

  inline LeaderboardRecordList& operator=(const LeaderboardRecordList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LeaderboardRecordList(LeaderboardRecordList&& from) noexcept
    : LeaderboardRecordList() {
    *this = ::std::move(from);
  }

  inline LeaderboardRecordList& operator=(LeaderboardRecordList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaderboardRecordList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LeaderboardRecordList* internal_default_instance() {
    return reinterpret_cast<const LeaderboardRecordList*>(
               &_LeaderboardRecordList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  void Swap(LeaderboardRecordList* other);
  friend void swap(LeaderboardRecordList& a, LeaderboardRecordList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LeaderboardRecordList* New() const final {
    return CreateMaybeMessage<LeaderboardRecordList>(NULL);
  }

  LeaderboardRecordList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LeaderboardRecordList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LeaderboardRecordList& from);
  void MergeFrom(const LeaderboardRecordList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeaderboardRecordList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nakama.api.LeaderboardRecord records = 1;
  int records_size() const;
  void clear_records();
  static const int kRecordsFieldNumber = 1;
  ::nakama::api::LeaderboardRecord* mutable_records(int index);
  ::google::protobuf::RepeatedPtrField< ::nakama::api::LeaderboardRecord >*
      mutable_records();
  const ::nakama::api::LeaderboardRecord& records(int index) const;
  ::nakama::api::LeaderboardRecord* add_records();
  const ::google::protobuf::RepeatedPtrField< ::nakama::api::LeaderboardRecord >&
      records() const;

  // repeated .nakama.api.LeaderboardRecord owner_records = 2;
  int owner_records_size() const;
  void clear_owner_records();
  static const int kOwnerRecordsFieldNumber = 2;
  ::nakama::api::LeaderboardRecord* mutable_owner_records(int index);
  ::google::protobuf::RepeatedPtrField< ::nakama::api::LeaderboardRecord >*
      mutable_owner_records();
  const ::nakama::api::LeaderboardRecord& owner_records(int index) const;
  ::nakama::api::LeaderboardRecord* add_owner_records();
  const ::google::protobuf::RepeatedPtrField< ::nakama::api::LeaderboardRecord >&
      owner_records() const;

  // string next_cursor = 3;
  void clear_next_cursor();
  static const int kNextCursorFieldNumber = 3;
  const ::std::string& next_cursor() const;
  void set_next_cursor(const ::std::string& value);
  #if LANG_CXX11
  void set_next_cursor(::std::string&& value);
  #endif
  void set_next_cursor(const char* value);
  void set_next_cursor(const char* value, size_t size);
  ::std::string* mutable_next_cursor();
  ::std::string* release_next_cursor();
  void set_allocated_next_cursor(::std::string* next_cursor);

  // string prev_cursor = 4;
  void clear_prev_cursor();
  static const int kPrevCursorFieldNumber = 4;
  const ::std::string& prev_cursor() const;
  void set_prev_cursor(const ::std::string& value);
  #if LANG_CXX11
  void set_prev_cursor(::std::string&& value);
  #endif
  void set_prev_cursor(const char* value);
  void set_prev_cursor(const char* value, size_t size);
  ::std::string* mutable_prev_cursor();
  ::std::string* release_prev_cursor();
  void set_allocated_prev_cursor(::std::string* prev_cursor);

  // @@protoc_insertion_point(class_scope:nakama.api.LeaderboardRecordList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::nakama::api::LeaderboardRecord > records_;
  ::google::protobuf::RepeatedPtrField< ::nakama::api::LeaderboardRecord > owner_records_;
  ::google::protobuf::internal::ArenaStringPtr next_cursor_;
  ::google::protobuf::internal::ArenaStringPtr prev_cursor_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LeaveGroupRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.LeaveGroupRequest) */ {
 public:
  LeaveGroupRequest();
  virtual ~LeaveGroupRequest();

  LeaveGroupRequest(const LeaveGroupRequest& from);

  inline LeaveGroupRequest& operator=(const LeaveGroupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LeaveGroupRequest(LeaveGroupRequest&& from) noexcept
    : LeaveGroupRequest() {
    *this = ::std::move(from);
  }

  inline LeaveGroupRequest& operator=(LeaveGroupRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaveGroupRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LeaveGroupRequest* internal_default_instance() {
    return reinterpret_cast<const LeaveGroupRequest*>(
               &_LeaveGroupRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  void Swap(LeaveGroupRequest* other);
  friend void swap(LeaveGroupRequest& a, LeaveGroupRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LeaveGroupRequest* New() const final {
    return CreateMaybeMessage<LeaveGroupRequest>(NULL);
  }

  LeaveGroupRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LeaveGroupRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LeaveGroupRequest& from);
  void MergeFrom(const LeaveGroupRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeaveGroupRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string group_id = 1;
  void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  const ::std::string& group_id() const;
  void set_group_id(const ::std::string& value);
  #if LANG_CXX11
  void set_group_id(::std::string&& value);
  #endif
  void set_group_id(const char* value);
  void set_group_id(const char* value, size_t size);
  ::std::string* mutable_group_id();
  ::std::string* release_group_id();
  void set_allocated_group_id(::std::string* group_id);

  // @@protoc_insertion_point(class_scope:nakama.api.LeaveGroupRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr group_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LinkFacebookRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.LinkFacebookRequest) */ {
 public:
  LinkFacebookRequest();
  virtual ~LinkFacebookRequest();

  LinkFacebookRequest(const LinkFacebookRequest& from);

  inline LinkFacebookRequest& operator=(const LinkFacebookRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LinkFacebookRequest(LinkFacebookRequest&& from) noexcept
    : LinkFacebookRequest() {
    *this = ::std::move(from);
  }

  inline LinkFacebookRequest& operator=(LinkFacebookRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LinkFacebookRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LinkFacebookRequest* internal_default_instance() {
    return reinterpret_cast<const LinkFacebookRequest*>(
               &_LinkFacebookRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  void Swap(LinkFacebookRequest* other);
  friend void swap(LinkFacebookRequest& a, LinkFacebookRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LinkFacebookRequest* New() const final {
    return CreateMaybeMessage<LinkFacebookRequest>(NULL);
  }

  LinkFacebookRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LinkFacebookRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LinkFacebookRequest& from);
  void MergeFrom(const LinkFacebookRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LinkFacebookRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .nakama.api.AccountFacebook account = 1;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  private:
  const ::nakama::api::AccountFacebook& _internal_account() const;
  public:
  const ::nakama::api::AccountFacebook& account() const;
  ::nakama::api::AccountFacebook* release_account();
  ::nakama::api::AccountFacebook* mutable_account();
  void set_allocated_account(::nakama::api::AccountFacebook* account);

  // .google.protobuf.BoolValue import = 4;
  bool has_import() const;
  void clear_import();
  static const int kImportFieldNumber = 4;
  private:
  const ::google::protobuf::BoolValue& _internal_import() const;
  public:
  const ::google::protobuf::BoolValue& import() const;
  ::google::protobuf::BoolValue* release_import();
  ::google::protobuf::BoolValue* mutable_import();
  void set_allocated_import(::google::protobuf::BoolValue* import);

  // @@protoc_insertion_point(class_scope:nakama.api.LinkFacebookRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::nakama::api::AccountFacebook* account_;
  ::google::protobuf::BoolValue* import_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListChannelMessagesRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.ListChannelMessagesRequest) */ {
 public:
  ListChannelMessagesRequest();
  virtual ~ListChannelMessagesRequest();

  ListChannelMessagesRequest(const ListChannelMessagesRequest& from);

  inline ListChannelMessagesRequest& operator=(const ListChannelMessagesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListChannelMessagesRequest(ListChannelMessagesRequest&& from) noexcept
    : ListChannelMessagesRequest() {
    *this = ::std::move(from);
  }

  inline ListChannelMessagesRequest& operator=(ListChannelMessagesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListChannelMessagesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListChannelMessagesRequest* internal_default_instance() {
    return reinterpret_cast<const ListChannelMessagesRequest*>(
               &_ListChannelMessagesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  void Swap(ListChannelMessagesRequest* other);
  friend void swap(ListChannelMessagesRequest& a, ListChannelMessagesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListChannelMessagesRequest* New() const final {
    return CreateMaybeMessage<ListChannelMessagesRequest>(NULL);
  }

  ListChannelMessagesRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListChannelMessagesRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListChannelMessagesRequest& from);
  void MergeFrom(const ListChannelMessagesRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListChannelMessagesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string channel_id = 1;
  void clear_channel_id();
  static const int kChannelIdFieldNumber = 1;
  const ::std::string& channel_id() const;
  void set_channel_id(const ::std::string& value);
  #if LANG_CXX11
  void set_channel_id(::std::string&& value);
  #endif
  void set_channel_id(const char* value);
  void set_channel_id(const char* value, size_t size);
  ::std::string* mutable_channel_id();
  ::std::string* release_channel_id();
  void set_allocated_channel_id(::std::string* channel_id);

  // string cursor = 4;
  void clear_cursor();
  static const int kCursorFieldNumber = 4;
  const ::std::string& cursor() const;
  void set_cursor(const ::std::string& value);
  #if LANG_CXX11
  void set_cursor(::std::string&& value);
  #endif
  void set_cursor(const char* value);
  void set_cursor(const char* value, size_t size);
  ::std::string* mutable_cursor();
  ::std::string* release_cursor();
  void set_allocated_cursor(::std::string* cursor);

  // .google.protobuf.Int32Value limit = 2;
  bool has_limit() const;
  void clear_limit();
  static const int kLimitFieldNumber = 2;
  private:
  const ::google::protobuf::Int32Value& _internal_limit() const;
  public:
  const ::google::protobuf::Int32Value& limit() const;
  ::google::protobuf::Int32Value* release_limit();
  ::google::protobuf::Int32Value* mutable_limit();
  void set_allocated_limit(::google::protobuf::Int32Value* limit);

  // .google.protobuf.BoolValue forward = 3;
  bool has_forward() const;
  void clear_forward();
  static const int kForwardFieldNumber = 3;
  private:
  const ::google::protobuf::BoolValue& _internal_forward() const;
  public:
  const ::google::protobuf::BoolValue& forward() const;
  ::google::protobuf::BoolValue* release_forward();
  ::google::protobuf::BoolValue* mutable_forward();
  void set_allocated_forward(::google::protobuf::BoolValue* forward);

  // @@protoc_insertion_point(class_scope:nakama.api.ListChannelMessagesRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr channel_id_;
  ::google::protobuf::internal::ArenaStringPtr cursor_;
  ::google::protobuf::Int32Value* limit_;
  ::google::protobuf::BoolValue* forward_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListGroupsRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.ListGroupsRequest) */ {
 public:
  ListGroupsRequest();
  virtual ~ListGroupsRequest();

  ListGroupsRequest(const ListGroupsRequest& from);

  inline ListGroupsRequest& operator=(const ListGroupsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListGroupsRequest(ListGroupsRequest&& from) noexcept
    : ListGroupsRequest() {
    *this = ::std::move(from);
  }

  inline ListGroupsRequest& operator=(ListGroupsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListGroupsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListGroupsRequest* internal_default_instance() {
    return reinterpret_cast<const ListGroupsRequest*>(
               &_ListGroupsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  void Swap(ListGroupsRequest* other);
  friend void swap(ListGroupsRequest& a, ListGroupsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListGroupsRequest* New() const final {
    return CreateMaybeMessage<ListGroupsRequest>(NULL);
  }

  ListGroupsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListGroupsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListGroupsRequest& from);
  void MergeFrom(const ListGroupsRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListGroupsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string cursor = 2;
  void clear_cursor();
  static const int kCursorFieldNumber = 2;
  const ::std::string& cursor() const;
  void set_cursor(const ::std::string& value);
  #if LANG_CXX11
  void set_cursor(::std::string&& value);
  #endif
  void set_cursor(const char* value);
  void set_cursor(const char* value, size_t size);
  ::std::string* mutable_cursor();
  ::std::string* release_cursor();
  void set_allocated_cursor(::std::string* cursor);

  // .google.protobuf.Int32Value limit = 3;
  bool has_limit() const;
  void clear_limit();
  static const int kLimitFieldNumber = 3;
  private:
  const ::google::protobuf::Int32Value& _internal_limit() const;
  public:
  const ::google::protobuf::Int32Value& limit() const;
  ::google::protobuf::Int32Value* release_limit();
  ::google::protobuf::Int32Value* mutable_limit();
  void set_allocated_limit(::google::protobuf::Int32Value* limit);

  // @@protoc_insertion_point(class_scope:nakama.api.ListGroupsRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr cursor_;
  ::google::protobuf::Int32Value* limit_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListGroupUsersRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.ListGroupUsersRequest) */ {
 public:
  ListGroupUsersRequest();
  virtual ~ListGroupUsersRequest();

  ListGroupUsersRequest(const ListGroupUsersRequest& from);

  inline ListGroupUsersRequest& operator=(const ListGroupUsersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListGroupUsersRequest(ListGroupUsersRequest&& from) noexcept
    : ListGroupUsersRequest() {
    *this = ::std::move(from);
  }

  inline ListGroupUsersRequest& operator=(ListGroupUsersRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListGroupUsersRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListGroupUsersRequest* internal_default_instance() {
    return reinterpret_cast<const ListGroupUsersRequest*>(
               &_ListGroupUsersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  void Swap(ListGroupUsersRequest* other);
  friend void swap(ListGroupUsersRequest& a, ListGroupUsersRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListGroupUsersRequest* New() const final {
    return CreateMaybeMessage<ListGroupUsersRequest>(NULL);
  }

  ListGroupUsersRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListGroupUsersRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListGroupUsersRequest& from);
  void MergeFrom(const ListGroupUsersRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListGroupUsersRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string group_id = 1;
  void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  const ::std::string& group_id() const;
  void set_group_id(const ::std::string& value);
  #if LANG_CXX11
  void set_group_id(::std::string&& value);
  #endif
  void set_group_id(const char* value);
  void set_group_id(const char* value, size_t size);
  ::std::string* mutable_group_id();
  ::std::string* release_group_id();
  void set_allocated_group_id(::std::string* group_id);

  // @@protoc_insertion_point(class_scope:nakama.api.ListGroupUsersRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr group_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListLeaderboardRecordsAroundOwnerRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.ListLeaderboardRecordsAroundOwnerRequest) */ {
 public:
  ListLeaderboardRecordsAroundOwnerRequest();
  virtual ~ListLeaderboardRecordsAroundOwnerRequest();

  ListLeaderboardRecordsAroundOwnerRequest(const ListLeaderboardRecordsAroundOwnerRequest& from);

  inline ListLeaderboardRecordsAroundOwnerRequest& operator=(const ListLeaderboardRecordsAroundOwnerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListLeaderboardRecordsAroundOwnerRequest(ListLeaderboardRecordsAroundOwnerRequest&& from) noexcept
    : ListLeaderboardRecordsAroundOwnerRequest() {
    *this = ::std::move(from);
  }

  inline ListLeaderboardRecordsAroundOwnerRequest& operator=(ListLeaderboardRecordsAroundOwnerRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListLeaderboardRecordsAroundOwnerRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListLeaderboardRecordsAroundOwnerRequest* internal_default_instance() {
    return reinterpret_cast<const ListLeaderboardRecordsAroundOwnerRequest*>(
               &_ListLeaderboardRecordsAroundOwnerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  void Swap(ListLeaderboardRecordsAroundOwnerRequest* other);
  friend void swap(ListLeaderboardRecordsAroundOwnerRequest& a, ListLeaderboardRecordsAroundOwnerRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListLeaderboardRecordsAroundOwnerRequest* New() const final {
    return CreateMaybeMessage<ListLeaderboardRecordsAroundOwnerRequest>(NULL);
  }

  ListLeaderboardRecordsAroundOwnerRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListLeaderboardRecordsAroundOwnerRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListLeaderboardRecordsAroundOwnerRequest& from);
  void MergeFrom(const ListLeaderboardRecordsAroundOwnerRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListLeaderboardRecordsAroundOwnerRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string leaderboard_id = 1;
  void clear_leaderboard_id();
  static const int kLeaderboardIdFieldNumber = 1;
  const ::std::string& leaderboard_id() const;
  void set_leaderboard_id(const ::std::string& value);
  #if LANG_CXX11
  void set_leaderboard_id(::std::string&& value);
  #endif
  void set_leaderboard_id(const char* value);
  void set_leaderboard_id(const char* value, size_t size);
  ::std::string* mutable_leaderboard_id();
  ::std::string* release_leaderboard_id();
  void set_allocated_leaderboard_id(::std::string* leaderboard_id);

  // string owner_id = 3;
  void clear_owner_id();
  static const int kOwnerIdFieldNumber = 3;
  const ::std::string& owner_id() const;
  void set_owner_id(const ::std::string& value);
  #if LANG_CXX11
  void set_owner_id(::std::string&& value);
  #endif
  void set_owner_id(const char* value);
  void set_owner_id(const char* value, size_t size);
  ::std::string* mutable_owner_id();
  ::std::string* release_owner_id();
  void set_allocated_owner_id(::std::string* owner_id);

  // .google.protobuf.UInt32Value limit = 2;
  bool has_limit() const;
  void clear_limit();
  static const int kLimitFieldNumber = 2;
  private:
  const ::google::protobuf::UInt32Value& _internal_limit() const;
  public:
  const ::google::protobuf::UInt32Value& limit() const;
  ::google::protobuf::UInt32Value* release_limit();
  ::google::protobuf::UInt32Value* mutable_limit();
  void set_allocated_limit(::google::protobuf::UInt32Value* limit);

  // @@protoc_insertion_point(class_scope:nakama.api.ListLeaderboardRecordsAroundOwnerRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr leaderboard_id_;
  ::google::protobuf::internal::ArenaStringPtr owner_id_;
  ::google::protobuf::UInt32Value* limit_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListLeaderboardRecordsRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.ListLeaderboardRecordsRequest) */ {
 public:
  ListLeaderboardRecordsRequest();
  virtual ~ListLeaderboardRecordsRequest();

  ListLeaderboardRecordsRequest(const ListLeaderboardRecordsRequest& from);

  inline ListLeaderboardRecordsRequest& operator=(const ListLeaderboardRecordsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListLeaderboardRecordsRequest(ListLeaderboardRecordsRequest&& from) noexcept
    : ListLeaderboardRecordsRequest() {
    *this = ::std::move(from);
  }

  inline ListLeaderboardRecordsRequest& operator=(ListLeaderboardRecordsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListLeaderboardRecordsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListLeaderboardRecordsRequest* internal_default_instance() {
    return reinterpret_cast<const ListLeaderboardRecordsRequest*>(
               &_ListLeaderboardRecordsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  void Swap(ListLeaderboardRecordsRequest* other);
  friend void swap(ListLeaderboardRecordsRequest& a, ListLeaderboardRecordsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListLeaderboardRecordsRequest* New() const final {
    return CreateMaybeMessage<ListLeaderboardRecordsRequest>(NULL);
  }

  ListLeaderboardRecordsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListLeaderboardRecordsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListLeaderboardRecordsRequest& from);
  void MergeFrom(const ListLeaderboardRecordsRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListLeaderboardRecordsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string owner_ids = 2;
  int owner_ids_size() const;
  void clear_owner_ids();
  static const int kOwnerIdsFieldNumber = 2;
  const ::std::string& owner_ids(int index) const;
  ::std::string* mutable_owner_ids(int index);
  void set_owner_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_owner_ids(int index, ::std::string&& value);
  #endif
  void set_owner_ids(int index, const char* value);
  void set_owner_ids(int index, const char* value, size_t size);
  ::std::string* add_owner_ids();
  void add_owner_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_owner_ids(::std::string&& value);
  #endif
  void add_owner_ids(const char* value);
  void add_owner_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& owner_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_owner_ids();

  // string leaderboard_id = 1;
  void clear_leaderboard_id();
  static const int kLeaderboardIdFieldNumber = 1;
  const ::std::string& leaderboard_id() const;
  void set_leaderboard_id(const ::std::string& value);
  #if LANG_CXX11
  void set_leaderboard_id(::std::string&& value);
  #endif
  void set_leaderboard_id(const char* value);
  void set_leaderboard_id(const char* value, size_t size);
  ::std::string* mutable_leaderboard_id();
  ::std::string* release_leaderboard_id();
  void set_allocated_leaderboard_id(::std::string* leaderboard_id);

  // string cursor = 4;
  void clear_cursor();
  static const int kCursorFieldNumber = 4;
  const ::std::string& cursor() const;
  void set_cursor(const ::std::string& value);
  #if LANG_CXX11
  void set_cursor(::std::string&& value);
  #endif
  void set_cursor(const char* value);
  void set_cursor(const char* value, size_t size);
  ::std::string* mutable_cursor();
  ::std::string* release_cursor();
  void set_allocated_cursor(::std::string* cursor);

  // .google.protobuf.Int32Value limit = 3;
  bool has_limit() const;
  void clear_limit();
  static const int kLimitFieldNumber = 3;
  private:
  const ::google::protobuf::Int32Value& _internal_limit() const;
  public:
  const ::google::protobuf::Int32Value& limit() const;
  ::google::protobuf::Int32Value* release_limit();
  ::google::protobuf::Int32Value* mutable_limit();
  void set_allocated_limit(::google::protobuf::Int32Value* limit);

  // @@protoc_insertion_point(class_scope:nakama.api.ListLeaderboardRecordsRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> owner_ids_;
  ::google::protobuf::internal::ArenaStringPtr leaderboard_id_;
  ::google::protobuf::internal::ArenaStringPtr cursor_;
  ::google::protobuf::Int32Value* limit_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListMatchesRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.ListMatchesRequest) */ {
 public:
  ListMatchesRequest();
  virtual ~ListMatchesRequest();

  ListMatchesRequest(const ListMatchesRequest& from);

  inline ListMatchesRequest& operator=(const ListMatchesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListMatchesRequest(ListMatchesRequest&& from) noexcept
    : ListMatchesRequest() {
    *this = ::std::move(from);
  }

  inline ListMatchesRequest& operator=(ListMatchesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListMatchesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListMatchesRequest* internal_default_instance() {
    return reinterpret_cast<const ListMatchesRequest*>(
               &_ListMatchesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  void Swap(ListMatchesRequest* other);
  friend void swap(ListMatchesRequest& a, ListMatchesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListMatchesRequest* New() const final {
    return CreateMaybeMessage<ListMatchesRequest>(NULL);
  }

  ListMatchesRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListMatchesRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListMatchesRequest& from);
  void MergeFrom(const ListMatchesRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListMatchesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.Int32Value limit = 1;
  bool has_limit() const;
  void clear_limit();
  static const int kLimitFieldNumber = 1;
  private:
  const ::google::protobuf::Int32Value& _internal_limit() const;
  public:
  const ::google::protobuf::Int32Value& limit() const;
  ::google::protobuf::Int32Value* release_limit();
  ::google::protobuf::Int32Value* mutable_limit();
  void set_allocated_limit(::google::protobuf::Int32Value* limit);

  // .google.protobuf.BoolValue authoritative = 2;
  bool has_authoritative() const;
  void clear_authoritative();
  static const int kAuthoritativeFieldNumber = 2;
  private:
  const ::google::protobuf::BoolValue& _internal_authoritative() const;
  public:
  const ::google::protobuf::BoolValue& authoritative() const;
  ::google::protobuf::BoolValue* release_authoritative();
  ::google::protobuf::BoolValue* mutable_authoritative();
  void set_allocated_authoritative(::google::protobuf::BoolValue* authoritative);

  // .google.protobuf.StringValue label = 3;
  bool has_label() const;
  void clear_label();
  static const int kLabelFieldNumber = 3;
  private:
  const ::google::protobuf::StringValue& _internal_label() const;
  public:
  const ::google::protobuf::StringValue& label() const;
  ::google::protobuf::StringValue* release_label();
  ::google::protobuf::StringValue* mutable_label();
  void set_allocated_label(::google::protobuf::StringValue* label);

  // .google.protobuf.Int32Value min_size = 4;
  bool has_min_size() const;
  void clear_min_size();
  static const int kMinSizeFieldNumber = 4;
  private:
  const ::google::protobuf::Int32Value& _internal_min_size() const;
  public:
  const ::google::protobuf::Int32Value& min_size() const;
  ::google::protobuf::Int32Value* release_min_size();
  ::google::protobuf::Int32Value* mutable_min_size();
  void set_allocated_min_size(::google::protobuf::Int32Value* min_size);

  // .google.protobuf.Int32Value max_size = 5;
  bool has_max_size() const;
  void clear_max_size();
  static const int kMaxSizeFieldNumber = 5;
  private:
  const ::google::protobuf::Int32Value& _internal_max_size() const;
  public:
  const ::google::protobuf::Int32Value& max_size() const;
  ::google::protobuf::Int32Value* release_max_size();
  ::google::protobuf::Int32Value* mutable_max_size();
  void set_allocated_max_size(::google::protobuf::Int32Value* max_size);

  // .google.protobuf.StringValue query = 6;
  bool has_query() const;
  void clear_query();
  static const int kQueryFieldNumber = 6;
  private:
  const ::google::protobuf::StringValue& _internal_query() const;
  public:
  const ::google::protobuf::StringValue& query() const;
  ::google::protobuf::StringValue* release_query();
  ::google::protobuf::StringValue* mutable_query();
  void set_allocated_query(::google::protobuf::StringValue* query);

  // @@protoc_insertion_point(class_scope:nakama.api.ListMatchesRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::Int32Value* limit_;
  ::google::protobuf::BoolValue* authoritative_;
  ::google::protobuf::StringValue* label_;
  ::google::protobuf::Int32Value* min_size_;
  ::google::protobuf::Int32Value* max_size_;
  ::google::protobuf::StringValue* query_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListNotificationsRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.ListNotificationsRequest) */ {
 public:
  ListNotificationsRequest();
  virtual ~ListNotificationsRequest();

  ListNotificationsRequest(const ListNotificationsRequest& from);

  inline ListNotificationsRequest& operator=(const ListNotificationsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListNotificationsRequest(ListNotificationsRequest&& from) noexcept
    : ListNotificationsRequest() {
    *this = ::std::move(from);
  }

  inline ListNotificationsRequest& operator=(ListNotificationsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListNotificationsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListNotificationsRequest* internal_default_instance() {
    return reinterpret_cast<const ListNotificationsRequest*>(
               &_ListNotificationsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  void Swap(ListNotificationsRequest* other);
  friend void swap(ListNotificationsRequest& a, ListNotificationsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListNotificationsRequest* New() const final {
    return CreateMaybeMessage<ListNotificationsRequest>(NULL);
  }

  ListNotificationsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListNotificationsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListNotificationsRequest& from);
  void MergeFrom(const ListNotificationsRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListNotificationsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string cacheable_cursor = 2;
  void clear_cacheable_cursor();
  static const int kCacheableCursorFieldNumber = 2;
  const ::std::string& cacheable_cursor() const;
  void set_cacheable_cursor(const ::std::string& value);
  #if LANG_CXX11
  void set_cacheable_cursor(::std::string&& value);
  #endif
  void set_cacheable_cursor(const char* value);
  void set_cacheable_cursor(const char* value, size_t size);
  ::std::string* mutable_cacheable_cursor();
  ::std::string* release_cacheable_cursor();
  void set_allocated_cacheable_cursor(::std::string* cacheable_cursor);

  // .google.protobuf.Int32Value limit = 1;
  bool has_limit() const;
  void clear_limit();
  static const int kLimitFieldNumber = 1;
  private:
  const ::google::protobuf::Int32Value& _internal_limit() const;
  public:
  const ::google::protobuf::Int32Value& limit() const;
  ::google::protobuf::Int32Value* release_limit();
  ::google::protobuf::Int32Value* mutable_limit();
  void set_allocated_limit(::google::protobuf::Int32Value* limit);

  // @@protoc_insertion_point(class_scope:nakama.api.ListNotificationsRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr cacheable_cursor_;
  ::google::protobuf::Int32Value* limit_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListStorageObjectsRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.ListStorageObjectsRequest) */ {
 public:
  ListStorageObjectsRequest();
  virtual ~ListStorageObjectsRequest();

  ListStorageObjectsRequest(const ListStorageObjectsRequest& from);

  inline ListStorageObjectsRequest& operator=(const ListStorageObjectsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListStorageObjectsRequest(ListStorageObjectsRequest&& from) noexcept
    : ListStorageObjectsRequest() {
    *this = ::std::move(from);
  }

  inline ListStorageObjectsRequest& operator=(ListStorageObjectsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListStorageObjectsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListStorageObjectsRequest* internal_default_instance() {
    return reinterpret_cast<const ListStorageObjectsRequest*>(
               &_ListStorageObjectsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  void Swap(ListStorageObjectsRequest* other);
  friend void swap(ListStorageObjectsRequest& a, ListStorageObjectsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListStorageObjectsRequest* New() const final {
    return CreateMaybeMessage<ListStorageObjectsRequest>(NULL);
  }

  ListStorageObjectsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListStorageObjectsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListStorageObjectsRequest& from);
  void MergeFrom(const ListStorageObjectsRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListStorageObjectsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string user_id = 1;
  void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  const ::std::string& user_id() const;
  void set_user_id(const ::std::string& value);
  #if LANG_CXX11
  void set_user_id(::std::string&& value);
  #endif
  void set_user_id(const char* value);
  void set_user_id(const char* value, size_t size);
  ::std::string* mutable_user_id();
  ::std::string* release_user_id();
  void set_allocated_user_id(::std::string* user_id);

  // string collection = 2;
  void clear_collection();
  static const int kCollectionFieldNumber = 2;
  const ::std::string& collection() const;
  void set_collection(const ::std::string& value);
  #if LANG_CXX11
  void set_collection(::std::string&& value);
  #endif
  void set_collection(const char* value);
  void set_collection(const char* value, size_t size);
  ::std::string* mutable_collection();
  ::std::string* release_collection();
  void set_allocated_collection(::std::string* collection);

  // string cursor = 4;
  void clear_cursor();
  static const int kCursorFieldNumber = 4;
  const ::std::string& cursor() const;
  void set_cursor(const ::std::string& value);
  #if LANG_CXX11
  void set_cursor(::std::string&& value);
  #endif
  void set_cursor(const char* value);
  void set_cursor(const char* value, size_t size);
  ::std::string* mutable_cursor();
  ::std::string* release_cursor();
  void set_allocated_cursor(::std::string* cursor);

  // .google.protobuf.Int32Value limit = 3;
  bool has_limit() const;
  void clear_limit();
  static const int kLimitFieldNumber = 3;
  private:
  const ::google::protobuf::Int32Value& _internal_limit() const;
  public:
  const ::google::protobuf::Int32Value& limit() const;
  ::google::protobuf::Int32Value* release_limit();
  ::google::protobuf::Int32Value* mutable_limit();
  void set_allocated_limit(::google::protobuf::Int32Value* limit);

  // @@protoc_insertion_point(class_scope:nakama.api.ListStorageObjectsRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr user_id_;
  ::google::protobuf::internal::ArenaStringPtr collection_;
  ::google::protobuf::internal::ArenaStringPtr cursor_;
  ::google::protobuf::Int32Value* limit_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListTournamentRecordsAroundOwnerRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.ListTournamentRecordsAroundOwnerRequest) */ {
 public:
  ListTournamentRecordsAroundOwnerRequest();
  virtual ~ListTournamentRecordsAroundOwnerRequest();

  ListTournamentRecordsAroundOwnerRequest(const ListTournamentRecordsAroundOwnerRequest& from);

  inline ListTournamentRecordsAroundOwnerRequest& operator=(const ListTournamentRecordsAroundOwnerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListTournamentRecordsAroundOwnerRequest(ListTournamentRecordsAroundOwnerRequest&& from) noexcept
    : ListTournamentRecordsAroundOwnerRequest() {
    *this = ::std::move(from);
  }

  inline ListTournamentRecordsAroundOwnerRequest& operator=(ListTournamentRecordsAroundOwnerRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListTournamentRecordsAroundOwnerRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListTournamentRecordsAroundOwnerRequest* internal_default_instance() {
    return reinterpret_cast<const ListTournamentRecordsAroundOwnerRequest*>(
               &_ListTournamentRecordsAroundOwnerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  void Swap(ListTournamentRecordsAroundOwnerRequest* other);
  friend void swap(ListTournamentRecordsAroundOwnerRequest& a, ListTournamentRecordsAroundOwnerRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListTournamentRecordsAroundOwnerRequest* New() const final {
    return CreateMaybeMessage<ListTournamentRecordsAroundOwnerRequest>(NULL);
  }

  ListTournamentRecordsAroundOwnerRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListTournamentRecordsAroundOwnerRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListTournamentRecordsAroundOwnerRequest& from);
  void MergeFrom(const ListTournamentRecordsAroundOwnerRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListTournamentRecordsAroundOwnerRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string tournament_id = 1;
  void clear_tournament_id();
  static const int kTournamentIdFieldNumber = 1;
  const ::std::string& tournament_id() const;
  void set_tournament_id(const ::std::string& value);
  #if LANG_CXX11
  void set_tournament_id(::std::string&& value);
  #endif
  void set_tournament_id(const char* value);
  void set_tournament_id(const char* value, size_t size);
  ::std::string* mutable_tournament_id();
  ::std::string* release_tournament_id();
  void set_allocated_tournament_id(::std::string* tournament_id);

  // string owner_id = 3;
  void clear_owner_id();
  static const int kOwnerIdFieldNumber = 3;
  const ::std::string& owner_id() const;
  void set_owner_id(const ::std::string& value);
  #if LANG_CXX11
  void set_owner_id(::std::string&& value);
  #endif
  void set_owner_id(const char* value);
  void set_owner_id(const char* value, size_t size);
  ::std::string* mutable_owner_id();
  ::std::string* release_owner_id();
  void set_allocated_owner_id(::std::string* owner_id);

  // .google.protobuf.UInt32Value limit = 2;
  bool has_limit() const;
  void clear_limit();
  static const int kLimitFieldNumber = 2;
  private:
  const ::google::protobuf::UInt32Value& _internal_limit() const;
  public:
  const ::google::protobuf::UInt32Value& limit() const;
  ::google::protobuf::UInt32Value* release_limit();
  ::google::protobuf::UInt32Value* mutable_limit();
  void set_allocated_limit(::google::protobuf::UInt32Value* limit);

  // @@protoc_insertion_point(class_scope:nakama.api.ListTournamentRecordsAroundOwnerRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr tournament_id_;
  ::google::protobuf::internal::ArenaStringPtr owner_id_;
  ::google::protobuf::UInt32Value* limit_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListTournamentRecordsRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.ListTournamentRecordsRequest) */ {
 public:
  ListTournamentRecordsRequest();
  virtual ~ListTournamentRecordsRequest();

  ListTournamentRecordsRequest(const ListTournamentRecordsRequest& from);

  inline ListTournamentRecordsRequest& operator=(const ListTournamentRecordsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListTournamentRecordsRequest(ListTournamentRecordsRequest&& from) noexcept
    : ListTournamentRecordsRequest() {
    *this = ::std::move(from);
  }

  inline ListTournamentRecordsRequest& operator=(ListTournamentRecordsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListTournamentRecordsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListTournamentRecordsRequest* internal_default_instance() {
    return reinterpret_cast<const ListTournamentRecordsRequest*>(
               &_ListTournamentRecordsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  void Swap(ListTournamentRecordsRequest* other);
  friend void swap(ListTournamentRecordsRequest& a, ListTournamentRecordsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListTournamentRecordsRequest* New() const final {
    return CreateMaybeMessage<ListTournamentRecordsRequest>(NULL);
  }

  ListTournamentRecordsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListTournamentRecordsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListTournamentRecordsRequest& from);
  void MergeFrom(const ListTournamentRecordsRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListTournamentRecordsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string owner_ids = 2;
  int owner_ids_size() const;
  void clear_owner_ids();
  static const int kOwnerIdsFieldNumber = 2;
  const ::std::string& owner_ids(int index) const;
  ::std::string* mutable_owner_ids(int index);
  void set_owner_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_owner_ids(int index, ::std::string&& value);
  #endif
  void set_owner_ids(int index, const char* value);
  void set_owner_ids(int index, const char* value, size_t size);
  ::std::string* add_owner_ids();
  void add_owner_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_owner_ids(::std::string&& value);
  #endif
  void add_owner_ids(const char* value);
  void add_owner_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& owner_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_owner_ids();

  // string tournament_id = 1;
  void clear_tournament_id();
  static const int kTournamentIdFieldNumber = 1;
  const ::std::string& tournament_id() const;
  void set_tournament_id(const ::std::string& value);
  #if LANG_CXX11
  void set_tournament_id(::std::string&& value);
  #endif
  void set_tournament_id(const char* value);
  void set_tournament_id(const char* value, size_t size);
  ::std::string* mutable_tournament_id();
  ::std::string* release_tournament_id();
  void set_allocated_tournament_id(::std::string* tournament_id);

  // string cursor = 4;
  void clear_cursor();
  static const int kCursorFieldNumber = 4;
  const ::std::string& cursor() const;
  void set_cursor(const ::std::string& value);
  #if LANG_CXX11
  void set_cursor(::std::string&& value);
  #endif
  void set_cursor(const char* value);
  void set_cursor(const char* value, size_t size);
  ::std::string* mutable_cursor();
  ::std::string* release_cursor();
  void set_allocated_cursor(::std::string* cursor);

  // .google.protobuf.Int32Value limit = 3;
  bool has_limit() const;
  void clear_limit();
  static const int kLimitFieldNumber = 3;
  private:
  const ::google::protobuf::Int32Value& _internal_limit() const;
  public:
  const ::google::protobuf::Int32Value& limit() const;
  ::google::protobuf::Int32Value* release_limit();
  ::google::protobuf::Int32Value* mutable_limit();
  void set_allocated_limit(::google::protobuf::Int32Value* limit);

  // @@protoc_insertion_point(class_scope:nakama.api.ListTournamentRecordsRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> owner_ids_;
  ::google::protobuf::internal::ArenaStringPtr tournament_id_;
  ::google::protobuf::internal::ArenaStringPtr cursor_;
  ::google::protobuf::Int32Value* limit_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListTournamentsRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.ListTournamentsRequest) */ {
 public:
  ListTournamentsRequest();
  virtual ~ListTournamentsRequest();

  ListTournamentsRequest(const ListTournamentsRequest& from);

  inline ListTournamentsRequest& operator=(const ListTournamentsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListTournamentsRequest(ListTournamentsRequest&& from) noexcept
    : ListTournamentsRequest() {
    *this = ::std::move(from);
  }

  inline ListTournamentsRequest& operator=(ListTournamentsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListTournamentsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListTournamentsRequest* internal_default_instance() {
    return reinterpret_cast<const ListTournamentsRequest*>(
               &_ListTournamentsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  void Swap(ListTournamentsRequest* other);
  friend void swap(ListTournamentsRequest& a, ListTournamentsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListTournamentsRequest* New() const final {
    return CreateMaybeMessage<ListTournamentsRequest>(NULL);
  }

  ListTournamentsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListTournamentsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListTournamentsRequest& from);
  void MergeFrom(const ListTournamentsRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListTournamentsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string cursor = 8;
  void clear_cursor();
  static const int kCursorFieldNumber = 8;
  const ::std::string& cursor() const;
  void set_cursor(const ::std::string& value);
  #if LANG_CXX11
  void set_cursor(::std::string&& value);
  #endif
  void set_cursor(const char* value);
  void set_cursor(const char* value, size_t size);
  ::std::string* mutable_cursor();
  ::std::string* release_cursor();
  void set_allocated_cursor(::std::string* cursor);

  // .google.protobuf.UInt32Value category_start = 1;
  bool has_category_start() const;
  void clear_category_start();
  static const int kCategoryStartFieldNumber = 1;
  private:
  const ::google::protobuf::UInt32Value& _internal_category_start() const;
  public:
  const ::google::protobuf::UInt32Value& category_start() const;
  ::google::protobuf::UInt32Value* release_category_start();
  ::google::protobuf::UInt32Value* mutable_category_start();
  void set_allocated_category_start(::google::protobuf::UInt32Value* category_start);

  // .google.protobuf.UInt32Value category_end = 2;
  bool has_category_end() const;
  void clear_category_end();
  static const int kCategoryEndFieldNumber = 2;
  private:
  const ::google::protobuf::UInt32Value& _internal_category_end() const;
  public:
  const ::google::protobuf::UInt32Value& category_end() const;
  ::google::protobuf::UInt32Value* release_category_end();
  ::google::protobuf::UInt32Value* mutable_category_end();
  void set_allocated_category_end(::google::protobuf::UInt32Value* category_end);

  // .google.protobuf.UInt32Value start_time = 3;
  bool has_start_time() const;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 3;
  private:
  const ::google::protobuf::UInt32Value& _internal_start_time() const;
  public:
  const ::google::protobuf::UInt32Value& start_time() const;
  ::google::protobuf::UInt32Value* release_start_time();
  ::google::protobuf::UInt32Value* mutable_start_time();
  void set_allocated_start_time(::google::protobuf::UInt32Value* start_time);

  // .google.protobuf.UInt32Value end_time = 4;
  bool has_end_time() const;
  void clear_end_time();
  static const int kEndTimeFieldNumber = 4;
  private:
  const ::google::protobuf::UInt32Value& _internal_end_time() const;
  public:
  const ::google::protobuf::UInt32Value& end_time() const;
  ::google::protobuf::UInt32Value* release_end_time();
  ::google::protobuf::UInt32Value* mutable_end_time();
  void set_allocated_end_time(::google::protobuf::UInt32Value* end_time);

  // .google.protobuf.Int32Value limit = 6;
  bool has_limit() const;
  void clear_limit();
  static const int kLimitFieldNumber = 6;
  private:
  const ::google::protobuf::Int32Value& _internal_limit() const;
  public:
  const ::google::protobuf::Int32Value& limit() const;
  ::google::protobuf::Int32Value* release_limit();
  ::google::protobuf::Int32Value* mutable_limit();
  void set_allocated_limit(::google::protobuf::Int32Value* limit);

  // @@protoc_insertion_point(class_scope:nakama.api.ListTournamentsRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr cursor_;
  ::google::protobuf::UInt32Value* category_start_;
  ::google::protobuf::UInt32Value* category_end_;
  ::google::protobuf::UInt32Value* start_time_;
  ::google::protobuf::UInt32Value* end_time_;
  ::google::protobuf::Int32Value* limit_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListUserGroupsRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.ListUserGroupsRequest) */ {
 public:
  ListUserGroupsRequest();
  virtual ~ListUserGroupsRequest();

  ListUserGroupsRequest(const ListUserGroupsRequest& from);

  inline ListUserGroupsRequest& operator=(const ListUserGroupsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListUserGroupsRequest(ListUserGroupsRequest&& from) noexcept
    : ListUserGroupsRequest() {
    *this = ::std::move(from);
  }

  inline ListUserGroupsRequest& operator=(ListUserGroupsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListUserGroupsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListUserGroupsRequest* internal_default_instance() {
    return reinterpret_cast<const ListUserGroupsRequest*>(
               &_ListUserGroupsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  void Swap(ListUserGroupsRequest* other);
  friend void swap(ListUserGroupsRequest& a, ListUserGroupsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListUserGroupsRequest* New() const final {
    return CreateMaybeMessage<ListUserGroupsRequest>(NULL);
  }

  ListUserGroupsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListUserGroupsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListUserGroupsRequest& from);
  void MergeFrom(const ListUserGroupsRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListUserGroupsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string user_id = 1;
  void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  const ::std::string& user_id() const;
  void set_user_id(const ::std::string& value);
  #if LANG_CXX11
  void set_user_id(::std::string&& value);
  #endif
  void set_user_id(const char* value);
  void set_user_id(const char* value, size_t size);
  ::std::string* mutable_user_id();
  ::std::string* release_user_id();
  void set_allocated_user_id(::std::string* user_id);

  // @@protoc_insertion_point(class_scope:nakama.api.ListUserGroupsRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr user_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Match : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.Match) */ {
 public:
  Match();
  virtual ~Match();

  Match(const Match& from);

  inline Match& operator=(const Match& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Match(Match&& from) noexcept
    : Match() {
    *this = ::std::move(from);
  }

  inline Match& operator=(Match&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Match& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Match* internal_default_instance() {
    return reinterpret_cast<const Match*>(
               &_Match_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  void Swap(Match* other);
  friend void swap(Match& a, Match& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Match* New() const final {
    return CreateMaybeMessage<Match>(NULL);
  }

  Match* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Match>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Match& from);
  void MergeFrom(const Match& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Match* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string match_id = 1;
  void clear_match_id();
  static const int kMatchIdFieldNumber = 1;
  const ::std::string& match_id() const;
  void set_match_id(const ::std::string& value);
  #if LANG_CXX11
  void set_match_id(::std::string&& value);
  #endif
  void set_match_id(const char* value);
  void set_match_id(const char* value, size_t size);
  ::std::string* mutable_match_id();
  ::std::string* release_match_id();
  void set_allocated_match_id(::std::string* match_id);

  // .google.protobuf.StringValue label = 3;
  bool has_label() const;
  void clear_label();
  static const int kLabelFieldNumber = 3;
  private:
  const ::google::protobuf::StringValue& _internal_label() const;
  public:
  const ::google::protobuf::StringValue& label() const;
  ::google::protobuf::StringValue* release_label();
  ::google::protobuf::StringValue* mutable_label();
  void set_allocated_label(::google::protobuf::StringValue* label);

  // bool authoritative = 2;
  void clear_authoritative();
  static const int kAuthoritativeFieldNumber = 2;
  bool authoritative() const;
  void set_authoritative(bool value);

  // int32 size = 4;
  void clear_size();
  static const int kSizeFieldNumber = 4;
  ::google::protobuf::int32 size() const;
  void set_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:nakama.api.Match)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr match_id_;
  ::google::protobuf::StringValue* label_;
  bool authoritative_;
  ::google::protobuf::int32 size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MatchList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.MatchList) */ {
 public:
  MatchList();
  virtual ~MatchList();

  MatchList(const MatchList& from);

  inline MatchList& operator=(const MatchList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MatchList(MatchList&& from) noexcept
    : MatchList() {
    *this = ::std::move(from);
  }

  inline MatchList& operator=(MatchList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MatchList* internal_default_instance() {
    return reinterpret_cast<const MatchList*>(
               &_MatchList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  void Swap(MatchList* other);
  friend void swap(MatchList& a, MatchList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MatchList* New() const final {
    return CreateMaybeMessage<MatchList>(NULL);
  }

  MatchList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MatchList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MatchList& from);
  void MergeFrom(const MatchList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nakama.api.Match matches = 1;
  int matches_size() const;
  void clear_matches();
  static const int kMatchesFieldNumber = 1;
  ::nakama::api::Match* mutable_matches(int index);
  ::google::protobuf::RepeatedPtrField< ::nakama::api::Match >*
      mutable_matches();
  const ::nakama::api::Match& matches(int index) const;
  ::nakama::api::Match* add_matches();
  const ::google::protobuf::RepeatedPtrField< ::nakama::api::Match >&
      matches() const;

  // @@protoc_insertion_point(class_scope:nakama.api.MatchList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::nakama::api::Match > matches_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Notification : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.Notification) */ {
 public:
  Notification();
  virtual ~Notification();

  Notification(const Notification& from);

  inline Notification& operator=(const Notification& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Notification(Notification&& from) noexcept
    : Notification() {
    *this = ::std::move(from);
  }

  inline Notification& operator=(Notification&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Notification& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Notification* internal_default_instance() {
    return reinterpret_cast<const Notification*>(
               &_Notification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  void Swap(Notification* other);
  friend void swap(Notification& a, Notification& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Notification* New() const final {
    return CreateMaybeMessage<Notification>(NULL);
  }

  Notification* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Notification>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Notification& from);
  void MergeFrom(const Notification& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Notification* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string subject = 2;
  void clear_subject();
  static const int kSubjectFieldNumber = 2;
  const ::std::string& subject() const;
  void set_subject(const ::std::string& value);
  #if LANG_CXX11
  void set_subject(::std::string&& value);
  #endif
  void set_subject(const char* value);
  void set_subject(const char* value, size_t size);
  ::std::string* mutable_subject();
  ::std::string* release_subject();
  void set_allocated_subject(::std::string* subject);

  // string content = 3;
  void clear_content();
  static const int kContentFieldNumber = 3;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  #if LANG_CXX11
  void set_content(::std::string&& value);
  #endif
  void set_content(const char* value);
  void set_content(const char* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // string sender_id = 5;
  void clear_sender_id();
  static const int kSenderIdFieldNumber = 5;
  const ::std::string& sender_id() const;
  void set_sender_id(const ::std::string& value);
  #if LANG_CXX11
  void set_sender_id(::std::string&& value);
  #endif
  void set_sender_id(const char* value);
  void set_sender_id(const char* value, size_t size);
  ::std::string* mutable_sender_id();
  ::std::string* release_sender_id();
  void set_allocated_sender_id(::std::string* sender_id);

  // .google.protobuf.Timestamp create_time = 6;
  bool has_create_time() const;
  void clear_create_time();
  static const int kCreateTimeFieldNumber = 6;
  private:
  const ::google::protobuf::Timestamp& _internal_create_time() const;
  public:
  const ::google::protobuf::Timestamp& create_time() const;
  ::google::protobuf::Timestamp* release_create_time();
  ::google::protobuf::Timestamp* mutable_create_time();
  void set_allocated_create_time(::google::protobuf::Timestamp* create_time);

  // int32 code = 4;
  void clear_code();
  static const int kCodeFieldNumber = 4;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // bool persistent = 7;
  void clear_persistent();
  static const int kPersistentFieldNumber = 7;
  bool persistent() const;
  void set_persistent(bool value);

  // @@protoc_insertion_point(class_scope:nakama.api.Notification)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr subject_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  ::google::protobuf::internal::ArenaStringPtr sender_id_;
  ::google::protobuf::Timestamp* create_time_;
  ::google::protobuf::int32 code_;
  bool persistent_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NotificationList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.NotificationList) */ {
 public:
  NotificationList();
  virtual ~NotificationList();

  NotificationList(const NotificationList& from);

  inline NotificationList& operator=(const NotificationList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NotificationList(NotificationList&& from) noexcept
    : NotificationList() {
    *this = ::std::move(from);
  }

  inline NotificationList& operator=(NotificationList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NotificationList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NotificationList* internal_default_instance() {
    return reinterpret_cast<const NotificationList*>(
               &_NotificationList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  void Swap(NotificationList* other);
  friend void swap(NotificationList& a, NotificationList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NotificationList* New() const final {
    return CreateMaybeMessage<NotificationList>(NULL);
  }

  NotificationList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NotificationList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NotificationList& from);
  void MergeFrom(const NotificationList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotificationList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nakama.api.Notification notifications = 1;
  int notifications_size() const;
  void clear_notifications();
  static const int kNotificationsFieldNumber = 1;
  ::nakama::api::Notification* mutable_notifications(int index);
  ::google::protobuf::RepeatedPtrField< ::nakama::api::Notification >*
      mutable_notifications();
  const ::nakama::api::Notification& notifications(int index) const;
  ::nakama::api::Notification* add_notifications();
  const ::google::protobuf::RepeatedPtrField< ::nakama::api::Notification >&
      notifications() const;

  // string cacheable_cursor = 2;
  void clear_cacheable_cursor();
  static const int kCacheableCursorFieldNumber = 2;
  const ::std::string& cacheable_cursor() const;
  void set_cacheable_cursor(const ::std::string& value);
  #if LANG_CXX11
  void set_cacheable_cursor(::std::string&& value);
  #endif
  void set_cacheable_cursor(const char* value);
  void set_cacheable_cursor(const char* value, size_t size);
  ::std::string* mutable_cacheable_cursor();
  ::std::string* release_cacheable_cursor();
  void set_allocated_cacheable_cursor(::std::string* cacheable_cursor);

  // @@protoc_insertion_point(class_scope:nakama.api.NotificationList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::nakama::api::Notification > notifications_;
  ::google::protobuf::internal::ArenaStringPtr cacheable_cursor_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PromoteGroupUsersRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.PromoteGroupUsersRequest) */ {
 public:
  PromoteGroupUsersRequest();
  virtual ~PromoteGroupUsersRequest();

  PromoteGroupUsersRequest(const PromoteGroupUsersRequest& from);

  inline PromoteGroupUsersRequest& operator=(const PromoteGroupUsersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PromoteGroupUsersRequest(PromoteGroupUsersRequest&& from) noexcept
    : PromoteGroupUsersRequest() {
    *this = ::std::move(from);
  }

  inline PromoteGroupUsersRequest& operator=(PromoteGroupUsersRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PromoteGroupUsersRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PromoteGroupUsersRequest* internal_default_instance() {
    return reinterpret_cast<const PromoteGroupUsersRequest*>(
               &_PromoteGroupUsersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  void Swap(PromoteGroupUsersRequest* other);
  friend void swap(PromoteGroupUsersRequest& a, PromoteGroupUsersRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PromoteGroupUsersRequest* New() const final {
    return CreateMaybeMessage<PromoteGroupUsersRequest>(NULL);
  }

  PromoteGroupUsersRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PromoteGroupUsersRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PromoteGroupUsersRequest& from);
  void MergeFrom(const PromoteGroupUsersRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PromoteGroupUsersRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string user_ids = 2;
  int user_ids_size() const;
  void clear_user_ids();
  static const int kUserIdsFieldNumber = 2;
  const ::std::string& user_ids(int index) const;
  ::std::string* mutable_user_ids(int index);
  void set_user_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_user_ids(int index, ::std::string&& value);
  #endif
  void set_user_ids(int index, const char* value);
  void set_user_ids(int index, const char* value, size_t size);
  ::std::string* add_user_ids();
  void add_user_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_user_ids(::std::string&& value);
  #endif
  void add_user_ids(const char* value);
  void add_user_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& user_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_user_ids();

  // string group_id = 1;
  void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  const ::std::string& group_id() const;
  void set_group_id(const ::std::string& value);
  #if LANG_CXX11
  void set_group_id(::std::string&& value);
  #endif
  void set_group_id(const char* value);
  void set_group_id(const char* value, size_t size);
  ::std::string* mutable_group_id();
  ::std::string* release_group_id();
  void set_allocated_group_id(::std::string* group_id);

  // @@protoc_insertion_point(class_scope:nakama.api.PromoteGroupUsersRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> user_ids_;
  ::google::protobuf::internal::ArenaStringPtr group_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReadStorageObjectId : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.ReadStorageObjectId) */ {
 public:
  ReadStorageObjectId();
  virtual ~ReadStorageObjectId();

  ReadStorageObjectId(const ReadStorageObjectId& from);

  inline ReadStorageObjectId& operator=(const ReadStorageObjectId& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReadStorageObjectId(ReadStorageObjectId&& from) noexcept
    : ReadStorageObjectId() {
    *this = ::std::move(from);
  }

  inline ReadStorageObjectId& operator=(ReadStorageObjectId&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadStorageObjectId& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadStorageObjectId* internal_default_instance() {
    return reinterpret_cast<const ReadStorageObjectId*>(
               &_ReadStorageObjectId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  void Swap(ReadStorageObjectId* other);
  friend void swap(ReadStorageObjectId& a, ReadStorageObjectId& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReadStorageObjectId* New() const final {
    return CreateMaybeMessage<ReadStorageObjectId>(NULL);
  }

  ReadStorageObjectId* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReadStorageObjectId>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReadStorageObjectId& from);
  void MergeFrom(const ReadStorageObjectId& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadStorageObjectId* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string collection = 1;
  void clear_collection();
  static const int kCollectionFieldNumber = 1;
  const ::std::string& collection() const;
  void set_collection(const ::std::string& value);
  #if LANG_CXX11
  void set_collection(::std::string&& value);
  #endif
  void set_collection(const char* value);
  void set_collection(const char* value, size_t size);
  ::std::string* mutable_collection();
  ::std::string* release_collection();
  void set_allocated_collection(::std::string* collection);

  // string key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string user_id = 3;
  void clear_user_id();
  static const int kUserIdFieldNumber = 3;
  const ::std::string& user_id() const;
  void set_user_id(const ::std::string& value);
  #if LANG_CXX11
  void set_user_id(::std::string&& value);
  #endif
  void set_user_id(const char* value);
  void set_user_id(const char* value, size_t size);
  ::std::string* mutable_user_id();
  ::std::string* release_user_id();
  void set_allocated_user_id(::std::string* user_id);

  // @@protoc_insertion_point(class_scope:nakama.api.ReadStorageObjectId)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr collection_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr user_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReadStorageObjectsRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.ReadStorageObjectsRequest) */ {
 public:
  ReadStorageObjectsRequest();
  virtual ~ReadStorageObjectsRequest();

  ReadStorageObjectsRequest(const ReadStorageObjectsRequest& from);

  inline ReadStorageObjectsRequest& operator=(const ReadStorageObjectsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReadStorageObjectsRequest(ReadStorageObjectsRequest&& from) noexcept
    : ReadStorageObjectsRequest() {
    *this = ::std::move(from);
  }

  inline ReadStorageObjectsRequest& operator=(ReadStorageObjectsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadStorageObjectsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadStorageObjectsRequest* internal_default_instance() {
    return reinterpret_cast<const ReadStorageObjectsRequest*>(
               &_ReadStorageObjectsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  void Swap(ReadStorageObjectsRequest* other);
  friend void swap(ReadStorageObjectsRequest& a, ReadStorageObjectsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReadStorageObjectsRequest* New() const final {
    return CreateMaybeMessage<ReadStorageObjectsRequest>(NULL);
  }

  ReadStorageObjectsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReadStorageObjectsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReadStorageObjectsRequest& from);
  void MergeFrom(const ReadStorageObjectsRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadStorageObjectsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nakama.api.ReadStorageObjectId object_ids = 1;
  int object_ids_size() const;
  void clear_object_ids();
  static const int kObjectIdsFieldNumber = 1;
  ::nakama::api::ReadStorageObjectId* mutable_object_ids(int index);
  ::google::protobuf::RepeatedPtrField< ::nakama::api::ReadStorageObjectId >*
      mutable_object_ids();
  const ::nakama::api::ReadStorageObjectId& object_ids(int index) const;
  ::nakama::api::ReadStorageObjectId* add_object_ids();
  const ::google::protobuf::RepeatedPtrField< ::nakama::api::ReadStorageObjectId >&
      object_ids() const;

  // @@protoc_insertion_point(class_scope:nakama.api.ReadStorageObjectsRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::nakama::api::ReadStorageObjectId > object_ids_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Rpc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.Rpc) */ {
 public:
  Rpc();
  virtual ~Rpc();

  Rpc(const Rpc& from);

  inline Rpc& operator=(const Rpc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Rpc(Rpc&& from) noexcept
    : Rpc() {
    *this = ::std::move(from);
  }

  inline Rpc& operator=(Rpc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Rpc& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Rpc* internal_default_instance() {
    return reinterpret_cast<const Rpc*>(
               &_Rpc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  void Swap(Rpc* other);
  friend void swap(Rpc& a, Rpc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Rpc* New() const final {
    return CreateMaybeMessage<Rpc>(NULL);
  }

  Rpc* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Rpc>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Rpc& from);
  void MergeFrom(const Rpc& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rpc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string payload = 2;
  void clear_payload();
  static const int kPayloadFieldNumber = 2;
  const ::std::string& payload() const;
  void set_payload(const ::std::string& value);
  #if LANG_CXX11
  void set_payload(::std::string&& value);
  #endif
  void set_payload(const char* value);
  void set_payload(const char* value, size_t size);
  ::std::string* mutable_payload();
  ::std::string* release_payload();
  void set_allocated_payload(::std::string* payload);

  // string http_key = 3;
  void clear_http_key();
  static const int kHttpKeyFieldNumber = 3;
  const ::std::string& http_key() const;
  void set_http_key(const ::std::string& value);
  #if LANG_CXX11
  void set_http_key(::std::string&& value);
  #endif
  void set_http_key(const char* value);
  void set_http_key(const char* value, size_t size);
  ::std::string* mutable_http_key();
  ::std::string* release_http_key();
  void set_allocated_http_key(::std::string* http_key);

  // @@protoc_insertion_point(class_scope:nakama.api.Rpc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr payload_;
  ::google::protobuf::internal::ArenaStringPtr http_key_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Session : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.Session) */ {
 public:
  Session();
  virtual ~Session();

  Session(const Session& from);

  inline Session& operator=(const Session& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Session(Session&& from) noexcept
    : Session() {
    *this = ::std::move(from);
  }

  inline Session& operator=(Session&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Session& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Session* internal_default_instance() {
    return reinterpret_cast<const Session*>(
               &_Session_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  void Swap(Session* other);
  friend void swap(Session& a, Session& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Session* New() const final {
    return CreateMaybeMessage<Session>(NULL);
  }

  Session* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Session>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Session& from);
  void MergeFrom(const Session& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Session* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string token = 2;
  void clear_token();
  static const int kTokenFieldNumber = 2;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  #if LANG_CXX11
  void set_token(::std::string&& value);
  #endif
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // string udp_token = 3;
  void clear_udp_token();
  static const int kUdpTokenFieldNumber = 3;
  const ::std::string& udp_token() const;
  void set_udp_token(const ::std::string& value);
  #if LANG_CXX11
  void set_udp_token(::std::string&& value);
  #endif
  void set_udp_token(const char* value);
  void set_udp_token(const char* value, size_t size);
  ::std::string* mutable_udp_token();
  ::std::string* release_udp_token();
  void set_allocated_udp_token(::std::string* udp_token);

  // bool created = 1;
  void clear_created();
  static const int kCreatedFieldNumber = 1;
  bool created() const;
  void set_created(bool value);

  // @@protoc_insertion_point(class_scope:nakama.api.Session)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  ::google::protobuf::internal::ArenaStringPtr udp_token_;
  bool created_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StorageObject : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.StorageObject) */ {
 public:
  StorageObject();
  virtual ~StorageObject();

  StorageObject(const StorageObject& from);

  inline StorageObject& operator=(const StorageObject& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StorageObject(StorageObject&& from) noexcept
    : StorageObject() {
    *this = ::std::move(from);
  }

  inline StorageObject& operator=(StorageObject&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StorageObject& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StorageObject* internal_default_instance() {
    return reinterpret_cast<const StorageObject*>(
               &_StorageObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  void Swap(StorageObject* other);
  friend void swap(StorageObject& a, StorageObject& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StorageObject* New() const final {
    return CreateMaybeMessage<StorageObject>(NULL);
  }

  StorageObject* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StorageObject>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StorageObject& from);
  void MergeFrom(const StorageObject& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StorageObject* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string collection = 1;
  void clear_collection();
  static const int kCollectionFieldNumber = 1;
  const ::std::string& collection() const;
  void set_collection(const ::std::string& value);
  #if LANG_CXX11
  void set_collection(::std::string&& value);
  #endif
  void set_collection(const char* value);
  void set_collection(const char* value, size_t size);
  ::std::string* mutable_collection();
  ::std::string* release_collection();
  void set_allocated_collection(::std::string* collection);

  // string key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string user_id = 3;
  void clear_user_id();
  static const int kUserIdFieldNumber = 3;
  const ::std::string& user_id() const;
  void set_user_id(const ::std::string& value);
  #if LANG_CXX11
  void set_user_id(::std::string&& value);
  #endif
  void set_user_id(const char* value);
  void set_user_id(const char* value, size_t size);
  ::std::string* mutable_user_id();
  ::std::string* release_user_id();
  void set_allocated_user_id(::std::string* user_id);

  // string value = 4;
  void clear_value();
  static const int kValueFieldNumber = 4;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // string version = 5;
  void clear_version();
  static const int kVersionFieldNumber = 5;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // .google.protobuf.Timestamp create_time = 8;
  bool has_create_time() const;
  void clear_create_time();
  static const int kCreateTimeFieldNumber = 8;
  private:
  const ::google::protobuf::Timestamp& _internal_create_time() const;
  public:
  const ::google::protobuf::Timestamp& create_time() const;
  ::google::protobuf::Timestamp* release_create_time();
  ::google::protobuf::Timestamp* mutable_create_time();
  void set_allocated_create_time(::google::protobuf::Timestamp* create_time);

  // .google.protobuf.Timestamp update_time = 9;
  bool has_update_time() const;
  void clear_update_time();
  static const int kUpdateTimeFieldNumber = 9;
  private:
  const ::google::protobuf::Timestamp& _internal_update_time() const;
  public:
  const ::google::protobuf::Timestamp& update_time() const;
  ::google::protobuf::Timestamp* release_update_time();
  ::google::protobuf::Timestamp* mutable_update_time();
  void set_allocated_update_time(::google::protobuf::Timestamp* update_time);

  // int32 permission_read = 6;
  void clear_permission_read();
  static const int kPermissionReadFieldNumber = 6;
  ::google::protobuf::int32 permission_read() const;
  void set_permission_read(::google::protobuf::int32 value);

  // int32 permission_write = 7;
  void clear_permission_write();
  static const int kPermissionWriteFieldNumber = 7;
  ::google::protobuf::int32 permission_write() const;
  void set_permission_write(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:nakama.api.StorageObject)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr collection_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr user_id_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::Timestamp* create_time_;
  ::google::protobuf::Timestamp* update_time_;
  ::google::protobuf::int32 permission_read_;
  ::google::protobuf::int32 permission_write_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StorageObjectAck : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.StorageObjectAck) */ {
 public:
  StorageObjectAck();
  virtual ~StorageObjectAck();

  StorageObjectAck(const StorageObjectAck& from);

  inline StorageObjectAck& operator=(const StorageObjectAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StorageObjectAck(StorageObjectAck&& from) noexcept
    : StorageObjectAck() {
    *this = ::std::move(from);
  }

  inline StorageObjectAck& operator=(StorageObjectAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StorageObjectAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StorageObjectAck* internal_default_instance() {
    return reinterpret_cast<const StorageObjectAck*>(
               &_StorageObjectAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  void Swap(StorageObjectAck* other);
  friend void swap(StorageObjectAck& a, StorageObjectAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StorageObjectAck* New() const final {
    return CreateMaybeMessage<StorageObjectAck>(NULL);
  }

  StorageObjectAck* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StorageObjectAck>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StorageObjectAck& from);
  void MergeFrom(const StorageObjectAck& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StorageObjectAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string collection = 1;
  void clear_collection();
  static const int kCollectionFieldNumber = 1;
  const ::std::string& collection() const;
  void set_collection(const ::std::string& value);
  #if LANG_CXX11
  void set_collection(::std::string&& value);
  #endif
  void set_collection(const char* value);
  void set_collection(const char* value, size_t size);
  ::std::string* mutable_collection();
  ::std::string* release_collection();
  void set_allocated_collection(::std::string* collection);

  // string key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string version = 3;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string user_id = 4;
  void clear_user_id();
  static const int kUserIdFieldNumber = 4;
  const ::std::string& user_id() const;
  void set_user_id(const ::std::string& value);
  #if LANG_CXX11
  void set_user_id(::std::string&& value);
  #endif
  void set_user_id(const char* value);
  void set_user_id(const char* value, size_t size);
  ::std::string* mutable_user_id();
  ::std::string* release_user_id();
  void set_allocated_user_id(::std::string* user_id);

  // @@protoc_insertion_point(class_scope:nakama.api.StorageObjectAck)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr collection_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr user_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StorageObjectAcks : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.StorageObjectAcks) */ {
 public:
  StorageObjectAcks();
  virtual ~StorageObjectAcks();

  StorageObjectAcks(const StorageObjectAcks& from);

  inline StorageObjectAcks& operator=(const StorageObjectAcks& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StorageObjectAcks(StorageObjectAcks&& from) noexcept
    : StorageObjectAcks() {
    *this = ::std::move(from);
  }

  inline StorageObjectAcks& operator=(StorageObjectAcks&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StorageObjectAcks& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StorageObjectAcks* internal_default_instance() {
    return reinterpret_cast<const StorageObjectAcks*>(
               &_StorageObjectAcks_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  void Swap(StorageObjectAcks* other);
  friend void swap(StorageObjectAcks& a, StorageObjectAcks& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StorageObjectAcks* New() const final {
    return CreateMaybeMessage<StorageObjectAcks>(NULL);
  }

  StorageObjectAcks* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StorageObjectAcks>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StorageObjectAcks& from);
  void MergeFrom(const StorageObjectAcks& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StorageObjectAcks* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nakama.api.StorageObjectAck acks = 1;
  int acks_size() const;
  void clear_acks();
  static const int kAcksFieldNumber = 1;
  ::nakama::api::StorageObjectAck* mutable_acks(int index);
  ::google::protobuf::RepeatedPtrField< ::nakama::api::StorageObjectAck >*
      mutable_acks();
  const ::nakama::api::StorageObjectAck& acks(int index) const;
  ::nakama::api::StorageObjectAck* add_acks();
  const ::google::protobuf::RepeatedPtrField< ::nakama::api::StorageObjectAck >&
      acks() const;

  // @@protoc_insertion_point(class_scope:nakama.api.StorageObjectAcks)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::nakama::api::StorageObjectAck > acks_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StorageObjects : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.StorageObjects) */ {
 public:
  StorageObjects();
  virtual ~StorageObjects();

  StorageObjects(const StorageObjects& from);

  inline StorageObjects& operator=(const StorageObjects& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StorageObjects(StorageObjects&& from) noexcept
    : StorageObjects() {
    *this = ::std::move(from);
  }

  inline StorageObjects& operator=(StorageObjects&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StorageObjects& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StorageObjects* internal_default_instance() {
    return reinterpret_cast<const StorageObjects*>(
               &_StorageObjects_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  void Swap(StorageObjects* other);
  friend void swap(StorageObjects& a, StorageObjects& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StorageObjects* New() const final {
    return CreateMaybeMessage<StorageObjects>(NULL);
  }

  StorageObjects* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StorageObjects>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StorageObjects& from);
  void MergeFrom(const StorageObjects& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StorageObjects* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nakama.api.StorageObject objects = 1;
  int objects_size() const;
  void clear_objects();
  static const int kObjectsFieldNumber = 1;
  ::nakama::api::StorageObject* mutable_objects(int index);
  ::google::protobuf::RepeatedPtrField< ::nakama::api::StorageObject >*
      mutable_objects();
  const ::nakama::api::StorageObject& objects(int index) const;
  ::nakama::api::StorageObject* add_objects();
  const ::google::protobuf::RepeatedPtrField< ::nakama::api::StorageObject >&
      objects() const;

  // @@protoc_insertion_point(class_scope:nakama.api.StorageObjects)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::nakama::api::StorageObject > objects_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StorageObjectList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.StorageObjectList) */ {
 public:
  StorageObjectList();
  virtual ~StorageObjectList();

  StorageObjectList(const StorageObjectList& from);

  inline StorageObjectList& operator=(const StorageObjectList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StorageObjectList(StorageObjectList&& from) noexcept
    : StorageObjectList() {
    *this = ::std::move(from);
  }

  inline StorageObjectList& operator=(StorageObjectList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StorageObjectList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StorageObjectList* internal_default_instance() {
    return reinterpret_cast<const StorageObjectList*>(
               &_StorageObjectList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  void Swap(StorageObjectList* other);
  friend void swap(StorageObjectList& a, StorageObjectList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StorageObjectList* New() const final {
    return CreateMaybeMessage<StorageObjectList>(NULL);
  }

  StorageObjectList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StorageObjectList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StorageObjectList& from);
  void MergeFrom(const StorageObjectList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StorageObjectList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nakama.api.StorageObject objects = 1;
  int objects_size() const;
  void clear_objects();
  static const int kObjectsFieldNumber = 1;
  ::nakama::api::StorageObject* mutable_objects(int index);
  ::google::protobuf::RepeatedPtrField< ::nakama::api::StorageObject >*
      mutable_objects();
  const ::nakama::api::StorageObject& objects(int index) const;
  ::nakama::api::StorageObject* add_objects();
  const ::google::protobuf::RepeatedPtrField< ::nakama::api::StorageObject >&
      objects() const;

  // string cursor = 2;
  void clear_cursor();
  static const int kCursorFieldNumber = 2;
  const ::std::string& cursor() const;
  void set_cursor(const ::std::string& value);
  #if LANG_CXX11
  void set_cursor(::std::string&& value);
  #endif
  void set_cursor(const char* value);
  void set_cursor(const char* value, size_t size);
  ::std::string* mutable_cursor();
  ::std::string* release_cursor();
  void set_allocated_cursor(::std::string* cursor);

  // @@protoc_insertion_point(class_scope:nakama.api.StorageObjectList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::nakama::api::StorageObject > objects_;
  ::google::protobuf::internal::ArenaStringPtr cursor_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Tournament : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.Tournament) */ {
 public:
  Tournament();
  virtual ~Tournament();

  Tournament(const Tournament& from);

  inline Tournament& operator=(const Tournament& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Tournament(Tournament&& from) noexcept
    : Tournament() {
    *this = ::std::move(from);
  }

  inline Tournament& operator=(Tournament&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Tournament& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Tournament* internal_default_instance() {
    return reinterpret_cast<const Tournament*>(
               &_Tournament_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  void Swap(Tournament* other);
  friend void swap(Tournament& a, Tournament& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Tournament* New() const final {
    return CreateMaybeMessage<Tournament>(NULL);
  }

  Tournament* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Tournament>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Tournament& from);
  void MergeFrom(const Tournament& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tournament* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string title = 2;
  void clear_title();
  static const int kTitleFieldNumber = 2;
  const ::std::string& title() const;
  void set_title(const ::std::string& value);
  #if LANG_CXX11
  void set_title(::std::string&& value);
  #endif
  void set_title(const char* value);
  void set_title(const char* value, size_t size);
  ::std::string* mutable_title();
  ::std::string* release_title();
  void set_allocated_title(::std::string* title);

  // string description = 3;
  void clear_description();
  static const int kDescriptionFieldNumber = 3;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // string metadata = 12;
  void clear_metadata();
  static const int kMetadataFieldNumber = 12;
  const ::std::string& metadata() const;
  void set_metadata(const ::std::string& value);
  #if LANG_CXX11
  void set_metadata(::std::string&& value);
  #endif
  void set_metadata(const char* value);
  void set_metadata(const char* value, size_t size);
  ::std::string* mutable_metadata();
  ::std::string* release_metadata();
  void set_allocated_metadata(::std::string* metadata);

  // .google.protobuf.Timestamp create_time = 13;
  bool has_create_time() const;
  void clear_create_time();
  static const int kCreateTimeFieldNumber = 13;
  private:
  const ::google::protobuf::Timestamp& _internal_create_time() const;
  public:
  const ::google::protobuf::Timestamp& create_time() const;
  ::google::protobuf::Timestamp* release_create_time();
  ::google::protobuf::Timestamp* mutable_create_time();
  void set_allocated_create_time(::google::protobuf::Timestamp* create_time);

  // .google.protobuf.Timestamp start_time = 14;
  bool has_start_time() const;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 14;
  private:
  const ::google::protobuf::Timestamp& _internal_start_time() const;
  public:
  const ::google::protobuf::Timestamp& start_time() const;
  ::google::protobuf::Timestamp* release_start_time();
  ::google::protobuf::Timestamp* mutable_start_time();
  void set_allocated_start_time(::google::protobuf::Timestamp* start_time);

  // .google.protobuf.Timestamp end_time = 15;
  bool has_end_time() const;
  void clear_end_time();
  static const int kEndTimeFieldNumber = 15;
  private:
  const ::google::protobuf::Timestamp& _internal_end_time() const;
  public:
  const ::google::protobuf::Timestamp& end_time() const;
  ::google::protobuf::Timestamp* release_end_time();
  ::google::protobuf::Timestamp* mutable_end_time();
  void set_allocated_end_time(::google::protobuf::Timestamp* end_time);

  // uint32 category = 4;
  void clear_category();
  static const int kCategoryFieldNumber = 4;
  ::google::protobuf::uint32 category() const;
  void set_category(::google::protobuf::uint32 value);

  // uint32 sort_order = 5;
  void clear_sort_order();
  static const int kSortOrderFieldNumber = 5;
  ::google::protobuf::uint32 sort_order() const;
  void set_sort_order(::google::protobuf::uint32 value);

  // uint32 size = 6;
  void clear_size();
  static const int kSizeFieldNumber = 6;
  ::google::protobuf::uint32 size() const;
  void set_size(::google::protobuf::uint32 value);

  // uint32 max_size = 7;
  void clear_max_size();
  static const int kMaxSizeFieldNumber = 7;
  ::google::protobuf::uint32 max_size() const;
  void set_max_size(::google::protobuf::uint32 value);

  // uint32 max_num_score = 8;
  void clear_max_num_score();
  static const int kMaxNumScoreFieldNumber = 8;
  ::google::protobuf::uint32 max_num_score() const;
  void set_max_num_score(::google::protobuf::uint32 value);

  // bool can_enter = 9;
  void clear_can_enter();
  static const int kCanEnterFieldNumber = 9;
  bool can_enter() const;
  void set_can_enter(bool value);

  // uint32 end_active = 10;
  void clear_end_active();
  static const int kEndActiveFieldNumber = 10;
  ::google::protobuf::uint32 end_active() const;
  void set_end_active(::google::protobuf::uint32 value);

  // uint32 next_reset = 11;
  void clear_next_reset();
  static const int kNextResetFieldNumber = 11;
  ::google::protobuf::uint32 next_reset() const;
  void set_next_reset(::google::protobuf::uint32 value);

  // uint32 duration = 16;
  void clear_duration();
  static const int kDurationFieldNumber = 16;
  ::google::protobuf::uint32 duration() const;
  void set_duration(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nakama.api.Tournament)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr title_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr metadata_;
  ::google::protobuf::Timestamp* create_time_;
  ::google::protobuf::Timestamp* start_time_;
  ::google::protobuf::Timestamp* end_time_;
  ::google::protobuf::uint32 category_;
  ::google::protobuf::uint32 sort_order_;
  ::google::protobuf::uint32 size_;
  ::google::protobuf::uint32 max_size_;
  ::google::protobuf::uint32 max_num_score_;
  bool can_enter_;
  ::google::protobuf::uint32 end_active_;
  ::google::protobuf::uint32 next_reset_;
  ::google::protobuf::uint32 duration_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TournamentList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.TournamentList) */ {
 public:
  TournamentList();
  virtual ~TournamentList();

  TournamentList(const TournamentList& from);

  inline TournamentList& operator=(const TournamentList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TournamentList(TournamentList&& from) noexcept
    : TournamentList() {
    *this = ::std::move(from);
  }

  inline TournamentList& operator=(TournamentList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TournamentList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TournamentList* internal_default_instance() {
    return reinterpret_cast<const TournamentList*>(
               &_TournamentList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  void Swap(TournamentList* other);
  friend void swap(TournamentList& a, TournamentList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TournamentList* New() const final {
    return CreateMaybeMessage<TournamentList>(NULL);
  }

  TournamentList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TournamentList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TournamentList& from);
  void MergeFrom(const TournamentList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TournamentList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nakama.api.Tournament tournaments = 1;
  int tournaments_size() const;
  void clear_tournaments();
  static const int kTournamentsFieldNumber = 1;
  ::nakama::api::Tournament* mutable_tournaments(int index);
  ::google::protobuf::RepeatedPtrField< ::nakama::api::Tournament >*
      mutable_tournaments();
  const ::nakama::api::Tournament& tournaments(int index) const;
  ::nakama::api::Tournament* add_tournaments();
  const ::google::protobuf::RepeatedPtrField< ::nakama::api::Tournament >&
      tournaments() const;

  // string cursor = 2;
  void clear_cursor();
  static const int kCursorFieldNumber = 2;
  const ::std::string& cursor() const;
  void set_cursor(const ::std::string& value);
  #if LANG_CXX11
  void set_cursor(::std::string&& value);
  #endif
  void set_cursor(const char* value);
  void set_cursor(const char* value, size_t size);
  ::std::string* mutable_cursor();
  ::std::string* release_cursor();
  void set_allocated_cursor(::std::string* cursor);

  // @@protoc_insertion_point(class_scope:nakama.api.TournamentList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::nakama::api::Tournament > tournaments_;
  ::google::protobuf::internal::ArenaStringPtr cursor_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TournamentRecordList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.TournamentRecordList) */ {
 public:
  TournamentRecordList();
  virtual ~TournamentRecordList();

  TournamentRecordList(const TournamentRecordList& from);

  inline TournamentRecordList& operator=(const TournamentRecordList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TournamentRecordList(TournamentRecordList&& from) noexcept
    : TournamentRecordList() {
    *this = ::std::move(from);
  }

  inline TournamentRecordList& operator=(TournamentRecordList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TournamentRecordList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TournamentRecordList* internal_default_instance() {
    return reinterpret_cast<const TournamentRecordList*>(
               &_TournamentRecordList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  void Swap(TournamentRecordList* other);
  friend void swap(TournamentRecordList& a, TournamentRecordList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TournamentRecordList* New() const final {
    return CreateMaybeMessage<TournamentRecordList>(NULL);
  }

  TournamentRecordList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TournamentRecordList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TournamentRecordList& from);
  void MergeFrom(const TournamentRecordList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TournamentRecordList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nakama.api.LeaderboardRecord records = 1;
  int records_size() const;
  void clear_records();
  static const int kRecordsFieldNumber = 1;
  ::nakama::api::LeaderboardRecord* mutable_records(int index);
  ::google::protobuf::RepeatedPtrField< ::nakama::api::LeaderboardRecord >*
      mutable_records();
  const ::nakama::api::LeaderboardRecord& records(int index) const;
  ::nakama::api::LeaderboardRecord* add_records();
  const ::google::protobuf::RepeatedPtrField< ::nakama::api::LeaderboardRecord >&
      records() const;

  // repeated .nakama.api.LeaderboardRecord owner_records = 2;
  int owner_records_size() const;
  void clear_owner_records();
  static const int kOwnerRecordsFieldNumber = 2;
  ::nakama::api::LeaderboardRecord* mutable_owner_records(int index);
  ::google::protobuf::RepeatedPtrField< ::nakama::api::LeaderboardRecord >*
      mutable_owner_records();
  const ::nakama::api::LeaderboardRecord& owner_records(int index) const;
  ::nakama::api::LeaderboardRecord* add_owner_records();
  const ::google::protobuf::RepeatedPtrField< ::nakama::api::LeaderboardRecord >&
      owner_records() const;

  // string next_cursor = 3;
  void clear_next_cursor();
  static const int kNextCursorFieldNumber = 3;
  const ::std::string& next_cursor() const;
  void set_next_cursor(const ::std::string& value);
  #if LANG_CXX11
  void set_next_cursor(::std::string&& value);
  #endif
  void set_next_cursor(const char* value);
  void set_next_cursor(const char* value, size_t size);
  ::std::string* mutable_next_cursor();
  ::std::string* release_next_cursor();
  void set_allocated_next_cursor(::std::string* next_cursor);

  // string prev_cursor = 4;
  void clear_prev_cursor();
  static const int kPrevCursorFieldNumber = 4;
  const ::std::string& prev_cursor() const;
  void set_prev_cursor(const ::std::string& value);
  #if LANG_CXX11
  void set_prev_cursor(::std::string&& value);
  #endif
  void set_prev_cursor(const char* value);
  void set_prev_cursor(const char* value, size_t size);
  ::std::string* mutable_prev_cursor();
  ::std::string* release_prev_cursor();
  void set_allocated_prev_cursor(::std::string* prev_cursor);

  // @@protoc_insertion_point(class_scope:nakama.api.TournamentRecordList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::nakama::api::LeaderboardRecord > records_;
  ::google::protobuf::RepeatedPtrField< ::nakama::api::LeaderboardRecord > owner_records_;
  ::google::protobuf::internal::ArenaStringPtr next_cursor_;
  ::google::protobuf::internal::ArenaStringPtr prev_cursor_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UpdateAccountRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.UpdateAccountRequest) */ {
 public:
  UpdateAccountRequest();
  virtual ~UpdateAccountRequest();

  UpdateAccountRequest(const UpdateAccountRequest& from);

  inline UpdateAccountRequest& operator=(const UpdateAccountRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateAccountRequest(UpdateAccountRequest&& from) noexcept
    : UpdateAccountRequest() {
    *this = ::std::move(from);
  }

  inline UpdateAccountRequest& operator=(UpdateAccountRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateAccountRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateAccountRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateAccountRequest*>(
               &_UpdateAccountRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  void Swap(UpdateAccountRequest* other);
  friend void swap(UpdateAccountRequest& a, UpdateAccountRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateAccountRequest* New() const final {
    return CreateMaybeMessage<UpdateAccountRequest>(NULL);
  }

  UpdateAccountRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UpdateAccountRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UpdateAccountRequest& from);
  void MergeFrom(const UpdateAccountRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateAccountRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.StringValue username = 1;
  bool has_username() const;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  private:
  const ::google::protobuf::StringValue& _internal_username() const;
  public:
  const ::google::protobuf::StringValue& username() const;
  ::google::protobuf::StringValue* release_username();
  ::google::protobuf::StringValue* mutable_username();
  void set_allocated_username(::google::protobuf::StringValue* username);

  // .google.protobuf.StringValue display_name = 2;
  bool has_display_name() const;
  void clear_display_name();
  static const int kDisplayNameFieldNumber = 2;
  private:
  const ::google::protobuf::StringValue& _internal_display_name() const;
  public:
  const ::google::protobuf::StringValue& display_name() const;
  ::google::protobuf::StringValue* release_display_name();
  ::google::protobuf::StringValue* mutable_display_name();
  void set_allocated_display_name(::google::protobuf::StringValue* display_name);

  // .google.protobuf.StringValue avatar_url = 3;
  bool has_avatar_url() const;
  void clear_avatar_url();
  static const int kAvatarUrlFieldNumber = 3;
  private:
  const ::google::protobuf::StringValue& _internal_avatar_url() const;
  public:
  const ::google::protobuf::StringValue& avatar_url() const;
  ::google::protobuf::StringValue* release_avatar_url();
  ::google::protobuf::StringValue* mutable_avatar_url();
  void set_allocated_avatar_url(::google::protobuf::StringValue* avatar_url);

  // .google.protobuf.StringValue lang_tag = 4;
  bool has_lang_tag() const;
  void clear_lang_tag();
  static const int kLangTagFieldNumber = 4;
  private:
  const ::google::protobuf::StringValue& _internal_lang_tag() const;
  public:
  const ::google::protobuf::StringValue& lang_tag() const;
  ::google::protobuf::StringValue* release_lang_tag();
  ::google::protobuf::StringValue* mutable_lang_tag();
  void set_allocated_lang_tag(::google::protobuf::StringValue* lang_tag);

  // .google.protobuf.StringValue location = 5;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 5;
  private:
  const ::google::protobuf::StringValue& _internal_location() const;
  public:
  const ::google::protobuf::StringValue& location() const;
  ::google::protobuf::StringValue* release_location();
  ::google::protobuf::StringValue* mutable_location();
  void set_allocated_location(::google::protobuf::StringValue* location);

  // .google.protobuf.StringValue timezone = 6;
  bool has_timezone() const;
  void clear_timezone();
  static const int kTimezoneFieldNumber = 6;
  private:
  const ::google::protobuf::StringValue& _internal_timezone() const;
  public:
  const ::google::protobuf::StringValue& timezone() const;
  ::google::protobuf::StringValue* release_timezone();
  ::google::protobuf::StringValue* mutable_timezone();
  void set_allocated_timezone(::google::protobuf::StringValue* timezone);

  // @@protoc_insertion_point(class_scope:nakama.api.UpdateAccountRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::StringValue* username_;
  ::google::protobuf::StringValue* display_name_;
  ::google::protobuf::StringValue* avatar_url_;
  ::google::protobuf::StringValue* lang_tag_;
  ::google::protobuf::StringValue* location_;
  ::google::protobuf::StringValue* timezone_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UpdateGroupRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.UpdateGroupRequest) */ {
 public:
  UpdateGroupRequest();
  virtual ~UpdateGroupRequest();

  UpdateGroupRequest(const UpdateGroupRequest& from);

  inline UpdateGroupRequest& operator=(const UpdateGroupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateGroupRequest(UpdateGroupRequest&& from) noexcept
    : UpdateGroupRequest() {
    *this = ::std::move(from);
  }

  inline UpdateGroupRequest& operator=(UpdateGroupRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateGroupRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateGroupRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateGroupRequest*>(
               &_UpdateGroupRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  void Swap(UpdateGroupRequest* other);
  friend void swap(UpdateGroupRequest& a, UpdateGroupRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateGroupRequest* New() const final {
    return CreateMaybeMessage<UpdateGroupRequest>(NULL);
  }

  UpdateGroupRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UpdateGroupRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UpdateGroupRequest& from);
  void MergeFrom(const UpdateGroupRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateGroupRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string group_id = 1;
  void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  const ::std::string& group_id() const;
  void set_group_id(const ::std::string& value);
  #if LANG_CXX11
  void set_group_id(::std::string&& value);
  #endif
  void set_group_id(const char* value);
  void set_group_id(const char* value, size_t size);
  ::std::string* mutable_group_id();
  ::std::string* release_group_id();
  void set_allocated_group_id(::std::string* group_id);

  // .google.protobuf.StringValue name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  private:
  const ::google::protobuf::StringValue& _internal_name() const;
  public:
  const ::google::protobuf::StringValue& name() const;
  ::google::protobuf::StringValue* release_name();
  ::google::protobuf::StringValue* mutable_name();
  void set_allocated_name(::google::protobuf::StringValue* name);

  // .google.protobuf.StringValue description = 3;
  bool has_description() const;
  void clear_description();
  static const int kDescriptionFieldNumber = 3;
  private:
  const ::google::protobuf::StringValue& _internal_description() const;
  public:
  const ::google::protobuf::StringValue& description() const;
  ::google::protobuf::StringValue* release_description();
  ::google::protobuf::StringValue* mutable_description();
  void set_allocated_description(::google::protobuf::StringValue* description);

  // .google.protobuf.StringValue lang_tag = 4;
  bool has_lang_tag() const;
  void clear_lang_tag();
  static const int kLangTagFieldNumber = 4;
  private:
  const ::google::protobuf::StringValue& _internal_lang_tag() const;
  public:
  const ::google::protobuf::StringValue& lang_tag() const;
  ::google::protobuf::StringValue* release_lang_tag();
  ::google::protobuf::StringValue* mutable_lang_tag();
  void set_allocated_lang_tag(::google::protobuf::StringValue* lang_tag);

  // .google.protobuf.StringValue avatar_url = 5;
  bool has_avatar_url() const;
  void clear_avatar_url();
  static const int kAvatarUrlFieldNumber = 5;
  private:
  const ::google::protobuf::StringValue& _internal_avatar_url() const;
  public:
  const ::google::protobuf::StringValue& avatar_url() const;
  ::google::protobuf::StringValue* release_avatar_url();
  ::google::protobuf::StringValue* mutable_avatar_url();
  void set_allocated_avatar_url(::google::protobuf::StringValue* avatar_url);

  // .google.protobuf.BoolValue open = 6;
  bool has_open() const;
  void clear_open();
  static const int kOpenFieldNumber = 6;
  private:
  const ::google::protobuf::BoolValue& _internal_open() const;
  public:
  const ::google::protobuf::BoolValue& open() const;
  ::google::protobuf::BoolValue* release_open();
  ::google::protobuf::BoolValue* mutable_open();
  void set_allocated_open(::google::protobuf::BoolValue* open);

  // @@protoc_insertion_point(class_scope:nakama.api.UpdateGroupRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr group_id_;
  ::google::protobuf::StringValue* name_;
  ::google::protobuf::StringValue* description_;
  ::google::protobuf::StringValue* lang_tag_;
  ::google::protobuf::StringValue* avatar_url_;
  ::google::protobuf::BoolValue* open_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class User : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.User) */ {
 public:
  User();
  virtual ~User();

  User(const User& from);

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  User(User&& from) noexcept
    : User() {
    *this = ::std::move(from);
  }

  inline User& operator=(User&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const User& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  void Swap(User* other);
  friend void swap(User& a, User& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline User* New() const final {
    return CreateMaybeMessage<User>(NULL);
  }

  User* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<User>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const User& from);
  void MergeFrom(const User& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(User* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string username = 2;
  void clear_username();
  static const int kUsernameFieldNumber = 2;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // string display_name = 3;
  void clear_display_name();
  static const int kDisplayNameFieldNumber = 3;
  const ::std::string& display_name() const;
  void set_display_name(const ::std::string& value);
  #if LANG_CXX11
  void set_display_name(::std::string&& value);
  #endif
  void set_display_name(const char* value);
  void set_display_name(const char* value, size_t size);
  ::std::string* mutable_display_name();
  ::std::string* release_display_name();
  void set_allocated_display_name(::std::string* display_name);

  // string avatar_url = 4;
  void clear_avatar_url();
  static const int kAvatarUrlFieldNumber = 4;
  const ::std::string& avatar_url() const;
  void set_avatar_url(const ::std::string& value);
  #if LANG_CXX11
  void set_avatar_url(::std::string&& value);
  #endif
  void set_avatar_url(const char* value);
  void set_avatar_url(const char* value, size_t size);
  ::std::string* mutable_avatar_url();
  ::std::string* release_avatar_url();
  void set_allocated_avatar_url(::std::string* avatar_url);

  // string lang_tag = 5;
  void clear_lang_tag();
  static const int kLangTagFieldNumber = 5;
  const ::std::string& lang_tag() const;
  void set_lang_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_lang_tag(::std::string&& value);
  #endif
  void set_lang_tag(const char* value);
  void set_lang_tag(const char* value, size_t size);
  ::std::string* mutable_lang_tag();
  ::std::string* release_lang_tag();
  void set_allocated_lang_tag(::std::string* lang_tag);

  // string location = 6;
  void clear_location();
  static const int kLocationFieldNumber = 6;
  const ::std::string& location() const;
  void set_location(const ::std::string& value);
  #if LANG_CXX11
  void set_location(::std::string&& value);
  #endif
  void set_location(const char* value);
  void set_location(const char* value, size_t size);
  ::std::string* mutable_location();
  ::std::string* release_location();
  void set_allocated_location(::std::string* location);

  // string timezone = 7;
  void clear_timezone();
  static const int kTimezoneFieldNumber = 7;
  const ::std::string& timezone() const;
  void set_timezone(const ::std::string& value);
  #if LANG_CXX11
  void set_timezone(::std::string&& value);
  #endif
  void set_timezone(const char* value);
  void set_timezone(const char* value, size_t size);
  ::std::string* mutable_timezone();
  ::std::string* release_timezone();
  void set_allocated_timezone(::std::string* timezone);

  // string metadata = 8;
  void clear_metadata();
  static const int kMetadataFieldNumber = 8;
  const ::std::string& metadata() const;
  void set_metadata(const ::std::string& value);
  #if LANG_CXX11
  void set_metadata(::std::string&& value);
  #endif
  void set_metadata(const char* value);
  void set_metadata(const char* value, size_t size);
  ::std::string* mutable_metadata();
  ::std::string* release_metadata();
  void set_allocated_metadata(::std::string* metadata);

  // string facebook_id = 9;
  void clear_facebook_id();
  static const int kFacebookIdFieldNumber = 9;
  const ::std::string& facebook_id() const;
  void set_facebook_id(const ::std::string& value);
  #if LANG_CXX11
  void set_facebook_id(::std::string&& value);
  #endif
  void set_facebook_id(const char* value);
  void set_facebook_id(const char* value, size_t size);
  ::std::string* mutable_facebook_id();
  ::std::string* release_facebook_id();
  void set_allocated_facebook_id(::std::string* facebook_id);

  // string google_id = 10;
  void clear_google_id();
  static const int kGoogleIdFieldNumber = 10;
  const ::std::string& google_id() const;
  void set_google_id(const ::std::string& value);
  #if LANG_CXX11
  void set_google_id(::std::string&& value);
  #endif
  void set_google_id(const char* value);
  void set_google_id(const char* value, size_t size);
  ::std::string* mutable_google_id();
  ::std::string* release_google_id();
  void set_allocated_google_id(::std::string* google_id);

  // string gamecenter_id = 11;
  void clear_gamecenter_id();
  static const int kGamecenterIdFieldNumber = 11;
  const ::std::string& gamecenter_id() const;
  void set_gamecenter_id(const ::std::string& value);
  #if LANG_CXX11
  void set_gamecenter_id(::std::string&& value);
  #endif
  void set_gamecenter_id(const char* value);
  void set_gamecenter_id(const char* value, size_t size);
  ::std::string* mutable_gamecenter_id();
  ::std::string* release_gamecenter_id();
  void set_allocated_gamecenter_id(::std::string* gamecenter_id);

  // string steam_id = 12;
  void clear_steam_id();
  static const int kSteamIdFieldNumber = 12;
  const ::std::string& steam_id() const;
  void set_steam_id(const ::std::string& value);
  #if LANG_CXX11
  void set_steam_id(::std::string&& value);
  #endif
  void set_steam_id(const char* value);
  void set_steam_id(const char* value, size_t size);
  ::std::string* mutable_steam_id();
  ::std::string* release_steam_id();
  void set_allocated_steam_id(::std::string* steam_id);

  // .google.protobuf.Timestamp create_time = 15;
  bool has_create_time() const;
  void clear_create_time();
  static const int kCreateTimeFieldNumber = 15;
  private:
  const ::google::protobuf::Timestamp& _internal_create_time() const;
  public:
  const ::google::protobuf::Timestamp& create_time() const;
  ::google::protobuf::Timestamp* release_create_time();
  ::google::protobuf::Timestamp* mutable_create_time();
  void set_allocated_create_time(::google::protobuf::Timestamp* create_time);

  // .google.protobuf.Timestamp update_time = 16;
  bool has_update_time() const;
  void clear_update_time();
  static const int kUpdateTimeFieldNumber = 16;
  private:
  const ::google::protobuf::Timestamp& _internal_update_time() const;
  public:
  const ::google::protobuf::Timestamp& update_time() const;
  ::google::protobuf::Timestamp* release_update_time();
  ::google::protobuf::Timestamp* mutable_update_time();
  void set_allocated_update_time(::google::protobuf::Timestamp* update_time);

  // bool online = 13;
  void clear_online();
  static const int kOnlineFieldNumber = 13;
  bool online() const;
  void set_online(bool value);

  // int32 edge_count = 14;
  void clear_edge_count();
  static const int kEdgeCountFieldNumber = 14;
  ::google::protobuf::int32 edge_count() const;
  void set_edge_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:nakama.api.User)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr display_name_;
  ::google::protobuf::internal::ArenaStringPtr avatar_url_;
  ::google::protobuf::internal::ArenaStringPtr lang_tag_;
  ::google::protobuf::internal::ArenaStringPtr location_;
  ::google::protobuf::internal::ArenaStringPtr timezone_;
  ::google::protobuf::internal::ArenaStringPtr metadata_;
  ::google::protobuf::internal::ArenaStringPtr facebook_id_;
  ::google::protobuf::internal::ArenaStringPtr google_id_;
  ::google::protobuf::internal::ArenaStringPtr gamecenter_id_;
  ::google::protobuf::internal::ArenaStringPtr steam_id_;
  ::google::protobuf::Timestamp* create_time_;
  ::google::protobuf::Timestamp* update_time_;
  bool online_;
  ::google::protobuf::int32 edge_count_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserGroupList_UserGroup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.UserGroupList.UserGroup) */ {
 public:
  UserGroupList_UserGroup();
  virtual ~UserGroupList_UserGroup();

  UserGroupList_UserGroup(const UserGroupList_UserGroup& from);

  inline UserGroupList_UserGroup& operator=(const UserGroupList_UserGroup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserGroupList_UserGroup(UserGroupList_UserGroup&& from) noexcept
    : UserGroupList_UserGroup() {
    *this = ::std::move(from);
  }

  inline UserGroupList_UserGroup& operator=(UserGroupList_UserGroup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserGroupList_UserGroup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserGroupList_UserGroup* internal_default_instance() {
    return reinterpret_cast<const UserGroupList_UserGroup*>(
               &_UserGroupList_UserGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  void Swap(UserGroupList_UserGroup* other);
  friend void swap(UserGroupList_UserGroup& a, UserGroupList_UserGroup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserGroupList_UserGroup* New() const final {
    return CreateMaybeMessage<UserGroupList_UserGroup>(NULL);
  }

  UserGroupList_UserGroup* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserGroupList_UserGroup>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserGroupList_UserGroup& from);
  void MergeFrom(const UserGroupList_UserGroup& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserGroupList_UserGroup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UserGroupList_UserGroup_State State;
  static const State SUPERADMIN =
    UserGroupList_UserGroup_State_SUPERADMIN;
  static const State ADMIN =
    UserGroupList_UserGroup_State_ADMIN;
  static const State MEMBER =
    UserGroupList_UserGroup_State_MEMBER;
  static const State JOIN_REQUEST =
    UserGroupList_UserGroup_State_JOIN_REQUEST;
  static inline bool State_IsValid(int value) {
    return UserGroupList_UserGroup_State_IsValid(value);
  }
  static const State State_MIN =
    UserGroupList_UserGroup_State_State_MIN;
  static const State State_MAX =
    UserGroupList_UserGroup_State_State_MAX;
  static const int State_ARRAYSIZE =
    UserGroupList_UserGroup_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  State_descriptor() {
    return UserGroupList_UserGroup_State_descriptor();
  }
  static inline const ::std::string& State_Name(State value) {
    return UserGroupList_UserGroup_State_Name(value);
  }
  static inline bool State_Parse(const ::std::string& name,
      State* value) {
    return UserGroupList_UserGroup_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .nakama.api.Group group = 1;
  bool has_group() const;
  void clear_group();
  static const int kGroupFieldNumber = 1;
  private:
  const ::nakama::api::Group& _internal_group() const;
  public:
  const ::nakama::api::Group& group() const;
  ::nakama::api::Group* release_group();
  ::nakama::api::Group* mutable_group();
  void set_allocated_group(::nakama::api::Group* group);

  // .google.protobuf.Int32Value state = 2;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 2;
  private:
  const ::google::protobuf::Int32Value& _internal_state() const;
  public:
  const ::google::protobuf::Int32Value& state() const;
  ::google::protobuf::Int32Value* release_state();
  ::google::protobuf::Int32Value* mutable_state();
  void set_allocated_state(::google::protobuf::Int32Value* state);

  // @@protoc_insertion_point(class_scope:nakama.api.UserGroupList.UserGroup)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::nakama::api::Group* group_;
  ::google::protobuf::Int32Value* state_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserGroupList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.UserGroupList) */ {
 public:
  UserGroupList();
  virtual ~UserGroupList();

  UserGroupList(const UserGroupList& from);

  inline UserGroupList& operator=(const UserGroupList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserGroupList(UserGroupList&& from) noexcept
    : UserGroupList() {
    *this = ::std::move(from);
  }

  inline UserGroupList& operator=(UserGroupList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserGroupList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserGroupList* internal_default_instance() {
    return reinterpret_cast<const UserGroupList*>(
               &_UserGroupList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  void Swap(UserGroupList* other);
  friend void swap(UserGroupList& a, UserGroupList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserGroupList* New() const final {
    return CreateMaybeMessage<UserGroupList>(NULL);
  }

  UserGroupList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserGroupList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserGroupList& from);
  void MergeFrom(const UserGroupList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserGroupList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UserGroupList_UserGroup UserGroup;

  // accessors -------------------------------------------------------

  // repeated .nakama.api.UserGroupList.UserGroup user_groups = 1;
  int user_groups_size() const;
  void clear_user_groups();
  static const int kUserGroupsFieldNumber = 1;
  ::nakama::api::UserGroupList_UserGroup* mutable_user_groups(int index);
  ::google::protobuf::RepeatedPtrField< ::nakama::api::UserGroupList_UserGroup >*
      mutable_user_groups();
  const ::nakama::api::UserGroupList_UserGroup& user_groups(int index) const;
  ::nakama::api::UserGroupList_UserGroup* add_user_groups();
  const ::google::protobuf::RepeatedPtrField< ::nakama::api::UserGroupList_UserGroup >&
      user_groups() const;

  // @@protoc_insertion_point(class_scope:nakama.api.UserGroupList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::nakama::api::UserGroupList_UserGroup > user_groups_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Users : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.Users) */ {
 public:
  Users();
  virtual ~Users();

  Users(const Users& from);

  inline Users& operator=(const Users& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Users(Users&& from) noexcept
    : Users() {
    *this = ::std::move(from);
  }

  inline Users& operator=(Users&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Users& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Users* internal_default_instance() {
    return reinterpret_cast<const Users*>(
               &_Users_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  void Swap(Users* other);
  friend void swap(Users& a, Users& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Users* New() const final {
    return CreateMaybeMessage<Users>(NULL);
  }

  Users* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Users>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Users& from);
  void MergeFrom(const Users& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Users* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nakama.api.User users = 1;
  int users_size() const;
  void clear_users();
  static const int kUsersFieldNumber = 1;
  ::nakama::api::User* mutable_users(int index);
  ::google::protobuf::RepeatedPtrField< ::nakama::api::User >*
      mutable_users();
  const ::nakama::api::User& users(int index) const;
  ::nakama::api::User* add_users();
  const ::google::protobuf::RepeatedPtrField< ::nakama::api::User >&
      users() const;

  // @@protoc_insertion_point(class_scope:nakama.api.Users)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::nakama::api::User > users_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WriteLeaderboardRecordRequest_LeaderboardRecordWrite : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.WriteLeaderboardRecordRequest.LeaderboardRecordWrite) */ {
 public:
  WriteLeaderboardRecordRequest_LeaderboardRecordWrite();
  virtual ~WriteLeaderboardRecordRequest_LeaderboardRecordWrite();

  WriteLeaderboardRecordRequest_LeaderboardRecordWrite(const WriteLeaderboardRecordRequest_LeaderboardRecordWrite& from);

  inline WriteLeaderboardRecordRequest_LeaderboardRecordWrite& operator=(const WriteLeaderboardRecordRequest_LeaderboardRecordWrite& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WriteLeaderboardRecordRequest_LeaderboardRecordWrite(WriteLeaderboardRecordRequest_LeaderboardRecordWrite&& from) noexcept
    : WriteLeaderboardRecordRequest_LeaderboardRecordWrite() {
    *this = ::std::move(from);
  }

  inline WriteLeaderboardRecordRequest_LeaderboardRecordWrite& operator=(WriteLeaderboardRecordRequest_LeaderboardRecordWrite&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WriteLeaderboardRecordRequest_LeaderboardRecordWrite& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WriteLeaderboardRecordRequest_LeaderboardRecordWrite* internal_default_instance() {
    return reinterpret_cast<const WriteLeaderboardRecordRequest_LeaderboardRecordWrite*>(
               &_WriteLeaderboardRecordRequest_LeaderboardRecordWrite_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  void Swap(WriteLeaderboardRecordRequest_LeaderboardRecordWrite* other);
  friend void swap(WriteLeaderboardRecordRequest_LeaderboardRecordWrite& a, WriteLeaderboardRecordRequest_LeaderboardRecordWrite& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WriteLeaderboardRecordRequest_LeaderboardRecordWrite* New() const final {
    return CreateMaybeMessage<WriteLeaderboardRecordRequest_LeaderboardRecordWrite>(NULL);
  }

  WriteLeaderboardRecordRequest_LeaderboardRecordWrite* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WriteLeaderboardRecordRequest_LeaderboardRecordWrite>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WriteLeaderboardRecordRequest_LeaderboardRecordWrite& from);
  void MergeFrom(const WriteLeaderboardRecordRequest_LeaderboardRecordWrite& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteLeaderboardRecordRequest_LeaderboardRecordWrite* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string metadata = 3;
  void clear_metadata();
  static const int kMetadataFieldNumber = 3;
  const ::std::string& metadata() const;
  void set_metadata(const ::std::string& value);
  #if LANG_CXX11
  void set_metadata(::std::string&& value);
  #endif
  void set_metadata(const char* value);
  void set_metadata(const char* value, size_t size);
  ::std::string* mutable_metadata();
  ::std::string* release_metadata();
  void set_allocated_metadata(::std::string* metadata);

  // int64 score = 1;
  void clear_score();
  static const int kScoreFieldNumber = 1;
  ::google::protobuf::int64 score() const;
  void set_score(::google::protobuf::int64 value);

  // int64 subscore = 2;
  void clear_subscore();
  static const int kSubscoreFieldNumber = 2;
  ::google::protobuf::int64 subscore() const;
  void set_subscore(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:nakama.api.WriteLeaderboardRecordRequest.LeaderboardRecordWrite)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr metadata_;
  ::google::protobuf::int64 score_;
  ::google::protobuf::int64 subscore_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WriteLeaderboardRecordRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.WriteLeaderboardRecordRequest) */ {
 public:
  WriteLeaderboardRecordRequest();
  virtual ~WriteLeaderboardRecordRequest();

  WriteLeaderboardRecordRequest(const WriteLeaderboardRecordRequest& from);

  inline WriteLeaderboardRecordRequest& operator=(const WriteLeaderboardRecordRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WriteLeaderboardRecordRequest(WriteLeaderboardRecordRequest&& from) noexcept
    : WriteLeaderboardRecordRequest() {
    *this = ::std::move(from);
  }

  inline WriteLeaderboardRecordRequest& operator=(WriteLeaderboardRecordRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WriteLeaderboardRecordRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WriteLeaderboardRecordRequest* internal_default_instance() {
    return reinterpret_cast<const WriteLeaderboardRecordRequest*>(
               &_WriteLeaderboardRecordRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  void Swap(WriteLeaderboardRecordRequest* other);
  friend void swap(WriteLeaderboardRecordRequest& a, WriteLeaderboardRecordRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WriteLeaderboardRecordRequest* New() const final {
    return CreateMaybeMessage<WriteLeaderboardRecordRequest>(NULL);
  }

  WriteLeaderboardRecordRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WriteLeaderboardRecordRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WriteLeaderboardRecordRequest& from);
  void MergeFrom(const WriteLeaderboardRecordRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteLeaderboardRecordRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef WriteLeaderboardRecordRequest_LeaderboardRecordWrite LeaderboardRecordWrite;

  // accessors -------------------------------------------------------

  // string leaderboard_id = 1;
  void clear_leaderboard_id();
  static const int kLeaderboardIdFieldNumber = 1;
  const ::std::string& leaderboard_id() const;
  void set_leaderboard_id(const ::std::string& value);
  #if LANG_CXX11
  void set_leaderboard_id(::std::string&& value);
  #endif
  void set_leaderboard_id(const char* value);
  void set_leaderboard_id(const char* value, size_t size);
  ::std::string* mutable_leaderboard_id();
  ::std::string* release_leaderboard_id();
  void set_allocated_leaderboard_id(::std::string* leaderboard_id);

  // .nakama.api.WriteLeaderboardRecordRequest.LeaderboardRecordWrite record = 2;
  bool has_record() const;
  void clear_record();
  static const int kRecordFieldNumber = 2;
  private:
  const ::nakama::api::WriteLeaderboardRecordRequest_LeaderboardRecordWrite& _internal_record() const;
  public:
  const ::nakama::api::WriteLeaderboardRecordRequest_LeaderboardRecordWrite& record() const;
  ::nakama::api::WriteLeaderboardRecordRequest_LeaderboardRecordWrite* release_record();
  ::nakama::api::WriteLeaderboardRecordRequest_LeaderboardRecordWrite* mutable_record();
  void set_allocated_record(::nakama::api::WriteLeaderboardRecordRequest_LeaderboardRecordWrite* record);

  // @@protoc_insertion_point(class_scope:nakama.api.WriteLeaderboardRecordRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr leaderboard_id_;
  ::nakama::api::WriteLeaderboardRecordRequest_LeaderboardRecordWrite* record_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WriteStorageObject : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.WriteStorageObject) */ {
 public:
  WriteStorageObject();
  virtual ~WriteStorageObject();

  WriteStorageObject(const WriteStorageObject& from);

  inline WriteStorageObject& operator=(const WriteStorageObject& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WriteStorageObject(WriteStorageObject&& from) noexcept
    : WriteStorageObject() {
    *this = ::std::move(from);
  }

  inline WriteStorageObject& operator=(WriteStorageObject&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WriteStorageObject& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WriteStorageObject* internal_default_instance() {
    return reinterpret_cast<const WriteStorageObject*>(
               &_WriteStorageObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  void Swap(WriteStorageObject* other);
  friend void swap(WriteStorageObject& a, WriteStorageObject& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WriteStorageObject* New() const final {
    return CreateMaybeMessage<WriteStorageObject>(NULL);
  }

  WriteStorageObject* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WriteStorageObject>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WriteStorageObject& from);
  void MergeFrom(const WriteStorageObject& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteStorageObject* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string collection = 1;
  void clear_collection();
  static const int kCollectionFieldNumber = 1;
  const ::std::string& collection() const;
  void set_collection(const ::std::string& value);
  #if LANG_CXX11
  void set_collection(::std::string&& value);
  #endif
  void set_collection(const char* value);
  void set_collection(const char* value, size_t size);
  ::std::string* mutable_collection();
  ::std::string* release_collection();
  void set_allocated_collection(::std::string* collection);

  // string key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string value = 3;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // string version = 4;
  void clear_version();
  static const int kVersionFieldNumber = 4;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // .google.protobuf.Int32Value permission_read = 5;
  bool has_permission_read() const;
  void clear_permission_read();
  static const int kPermissionReadFieldNumber = 5;
  private:
  const ::google::protobuf::Int32Value& _internal_permission_read() const;
  public:
  const ::google::protobuf::Int32Value& permission_read() const;
  ::google::protobuf::Int32Value* release_permission_read();
  ::google::protobuf::Int32Value* mutable_permission_read();
  void set_allocated_permission_read(::google::protobuf::Int32Value* permission_read);

  // .google.protobuf.Int32Value permission_write = 6;
  bool has_permission_write() const;
  void clear_permission_write();
  static const int kPermissionWriteFieldNumber = 6;
  private:
  const ::google::protobuf::Int32Value& _internal_permission_write() const;
  public:
  const ::google::protobuf::Int32Value& permission_write() const;
  ::google::protobuf::Int32Value* release_permission_write();
  ::google::protobuf::Int32Value* mutable_permission_write();
  void set_allocated_permission_write(::google::protobuf::Int32Value* permission_write);

  // @@protoc_insertion_point(class_scope:nakama.api.WriteStorageObject)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr collection_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::Int32Value* permission_read_;
  ::google::protobuf::Int32Value* permission_write_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WriteStorageObjectsRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.WriteStorageObjectsRequest) */ {
 public:
  WriteStorageObjectsRequest();
  virtual ~WriteStorageObjectsRequest();

  WriteStorageObjectsRequest(const WriteStorageObjectsRequest& from);

  inline WriteStorageObjectsRequest& operator=(const WriteStorageObjectsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WriteStorageObjectsRequest(WriteStorageObjectsRequest&& from) noexcept
    : WriteStorageObjectsRequest() {
    *this = ::std::move(from);
  }

  inline WriteStorageObjectsRequest& operator=(WriteStorageObjectsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WriteStorageObjectsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WriteStorageObjectsRequest* internal_default_instance() {
    return reinterpret_cast<const WriteStorageObjectsRequest*>(
               &_WriteStorageObjectsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  void Swap(WriteStorageObjectsRequest* other);
  friend void swap(WriteStorageObjectsRequest& a, WriteStorageObjectsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WriteStorageObjectsRequest* New() const final {
    return CreateMaybeMessage<WriteStorageObjectsRequest>(NULL);
  }

  WriteStorageObjectsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WriteStorageObjectsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WriteStorageObjectsRequest& from);
  void MergeFrom(const WriteStorageObjectsRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteStorageObjectsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nakama.api.WriteStorageObject objects = 1;
  int objects_size() const;
  void clear_objects();
  static const int kObjectsFieldNumber = 1;
  ::nakama::api::WriteStorageObject* mutable_objects(int index);
  ::google::protobuf::RepeatedPtrField< ::nakama::api::WriteStorageObject >*
      mutable_objects();
  const ::nakama::api::WriteStorageObject& objects(int index) const;
  ::nakama::api::WriteStorageObject* add_objects();
  const ::google::protobuf::RepeatedPtrField< ::nakama::api::WriteStorageObject >&
      objects() const;

  // @@protoc_insertion_point(class_scope:nakama.api.WriteStorageObjectsRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::nakama::api::WriteStorageObject > objects_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WriteTournamentRecordRequest_TournamentRecordWrite : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.WriteTournamentRecordRequest.TournamentRecordWrite) */ {
 public:
  WriteTournamentRecordRequest_TournamentRecordWrite();
  virtual ~WriteTournamentRecordRequest_TournamentRecordWrite();

  WriteTournamentRecordRequest_TournamentRecordWrite(const WriteTournamentRecordRequest_TournamentRecordWrite& from);

  inline WriteTournamentRecordRequest_TournamentRecordWrite& operator=(const WriteTournamentRecordRequest_TournamentRecordWrite& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WriteTournamentRecordRequest_TournamentRecordWrite(WriteTournamentRecordRequest_TournamentRecordWrite&& from) noexcept
    : WriteTournamentRecordRequest_TournamentRecordWrite() {
    *this = ::std::move(from);
  }

  inline WriteTournamentRecordRequest_TournamentRecordWrite& operator=(WriteTournamentRecordRequest_TournamentRecordWrite&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WriteTournamentRecordRequest_TournamentRecordWrite& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WriteTournamentRecordRequest_TournamentRecordWrite* internal_default_instance() {
    return reinterpret_cast<const WriteTournamentRecordRequest_TournamentRecordWrite*>(
               &_WriteTournamentRecordRequest_TournamentRecordWrite_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  void Swap(WriteTournamentRecordRequest_TournamentRecordWrite* other);
  friend void swap(WriteTournamentRecordRequest_TournamentRecordWrite& a, WriteTournamentRecordRequest_TournamentRecordWrite& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WriteTournamentRecordRequest_TournamentRecordWrite* New() const final {
    return CreateMaybeMessage<WriteTournamentRecordRequest_TournamentRecordWrite>(NULL);
  }

  WriteTournamentRecordRequest_TournamentRecordWrite* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WriteTournamentRecordRequest_TournamentRecordWrite>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WriteTournamentRecordRequest_TournamentRecordWrite& from);
  void MergeFrom(const WriteTournamentRecordRequest_TournamentRecordWrite& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteTournamentRecordRequest_TournamentRecordWrite* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string metadata = 3;
  void clear_metadata();
  static const int kMetadataFieldNumber = 3;
  const ::std::string& metadata() const;
  void set_metadata(const ::std::string& value);
  #if LANG_CXX11
  void set_metadata(::std::string&& value);
  #endif
  void set_metadata(const char* value);
  void set_metadata(const char* value, size_t size);
  ::std::string* mutable_metadata();
  ::std::string* release_metadata();
  void set_allocated_metadata(::std::string* metadata);

  // int64 score = 1;
  void clear_score();
  static const int kScoreFieldNumber = 1;
  ::google::protobuf::int64 score() const;
  void set_score(::google::protobuf::int64 value);

  // int64 subscore = 2;
  void clear_subscore();
  static const int kSubscoreFieldNumber = 2;
  ::google::protobuf::int64 subscore() const;
  void set_subscore(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:nakama.api.WriteTournamentRecordRequest.TournamentRecordWrite)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr metadata_;
  ::google::protobuf::int64 score_;
  ::google::protobuf::int64 subscore_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WriteTournamentRecordRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.api.WriteTournamentRecordRequest) */ {
 public:
  WriteTournamentRecordRequest();
  virtual ~WriteTournamentRecordRequest();

  WriteTournamentRecordRequest(const WriteTournamentRecordRequest& from);

  inline WriteTournamentRecordRequest& operator=(const WriteTournamentRecordRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WriteTournamentRecordRequest(WriteTournamentRecordRequest&& from) noexcept
    : WriteTournamentRecordRequest() {
    *this = ::std::move(from);
  }

  inline WriteTournamentRecordRequest& operator=(WriteTournamentRecordRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WriteTournamentRecordRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WriteTournamentRecordRequest* internal_default_instance() {
    return reinterpret_cast<const WriteTournamentRecordRequest*>(
               &_WriteTournamentRecordRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  void Swap(WriteTournamentRecordRequest* other);
  friend void swap(WriteTournamentRecordRequest& a, WriteTournamentRecordRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WriteTournamentRecordRequest* New() const final {
    return CreateMaybeMessage<WriteTournamentRecordRequest>(NULL);
  }

  WriteTournamentRecordRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WriteTournamentRecordRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WriteTournamentRecordRequest& from);
  void MergeFrom(const WriteTournamentRecordRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteTournamentRecordRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef WriteTournamentRecordRequest_TournamentRecordWrite TournamentRecordWrite;

  // accessors -------------------------------------------------------

  // string tournament_id = 1;
  void clear_tournament_id();
  static const int kTournamentIdFieldNumber = 1;
  const ::std::string& tournament_id() const;
  void set_tournament_id(const ::std::string& value);
  #if LANG_CXX11
  void set_tournament_id(::std::string&& value);
  #endif
  void set_tournament_id(const char* value);
  void set_tournament_id(const char* value, size_t size);
  ::std::string* mutable_tournament_id();
  ::std::string* release_tournament_id();
  void set_allocated_tournament_id(::std::string* tournament_id);

  // .nakama.api.WriteTournamentRecordRequest.TournamentRecordWrite record = 2;
  bool has_record() const;
  void clear_record();
  static const int kRecordFieldNumber = 2;
  private:
  const ::nakama::api::WriteTournamentRecordRequest_TournamentRecordWrite& _internal_record() const;
  public:
  const ::nakama::api::WriteTournamentRecordRequest_TournamentRecordWrite& record() const;
  ::nakama::api::WriteTournamentRecordRequest_TournamentRecordWrite* release_record();
  ::nakama::api::WriteTournamentRecordRequest_TournamentRecordWrite* mutable_record();
  void set_allocated_record(::nakama::api::WriteTournamentRecordRequest_TournamentRecordWrite* record);

  // @@protoc_insertion_point(class_scope:nakama.api.WriteTournamentRecordRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr tournament_id_;
  ::nakama::api::WriteTournamentRecordRequest_TournamentRecordWrite* record_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Account

// .nakama.api.User user = 1;
inline bool Account::has_user() const {
  return this != internal_default_instance() && user_ != NULL;
}
inline void Account::clear_user() {
  if (GetArenaNoVirtual() == NULL && user_ != NULL) {
    delete user_;
  }
  user_ = NULL;
}
inline const ::nakama::api::User& Account::_internal_user() const {
  return *user_;
}
inline const ::nakama::api::User& Account::user() const {
  const ::nakama::api::User* p = user_;
  // @@protoc_insertion_point(field_get:nakama.api.Account.user)
  return p != NULL ? *p : *reinterpret_cast<const ::nakama::api::User*>(
      &::nakama::api::_User_default_instance_);
}
inline ::nakama::api::User* Account::release_user() {
  // @@protoc_insertion_point(field_release:nakama.api.Account.user)
  
  ::nakama::api::User* temp = user_;
  user_ = NULL;
  return temp;
}
inline ::nakama::api::User* Account::mutable_user() {
  
  if (user_ == NULL) {
    auto* p = CreateMaybeMessage<::nakama::api::User>(GetArenaNoVirtual());
    user_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.Account.user)
  return user_;
}
inline void Account::set_allocated_user(::nakama::api::User* user) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete user_;
  }
  if (user) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.Account.user)
}

// string wallet = 2;
inline void Account::clear_wallet() {
  wallet_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Account::wallet() const {
  // @@protoc_insertion_point(field_get:nakama.api.Account.wallet)
  return wallet_.GetNoArena();
}
inline void Account::set_wallet(const ::std::string& value) {
  
  wallet_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.Account.wallet)
}
#if LANG_CXX11
inline void Account::set_wallet(::std::string&& value) {
  
  wallet_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.Account.wallet)
}
#endif
inline void Account::set_wallet(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  wallet_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.Account.wallet)
}
inline void Account::set_wallet(const char* value, size_t size) {
  
  wallet_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.Account.wallet)
}
inline ::std::string* Account::mutable_wallet() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.Account.wallet)
  return wallet_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Account::release_wallet() {
  // @@protoc_insertion_point(field_release:nakama.api.Account.wallet)
  
  return wallet_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Account::set_allocated_wallet(::std::string* wallet) {
  if (wallet != NULL) {
    
  } else {
    
  }
  wallet_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), wallet);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.Account.wallet)
}

// string email = 3;
inline void Account::clear_email() {
  email_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Account::email() const {
  // @@protoc_insertion_point(field_get:nakama.api.Account.email)
  return email_.GetNoArena();
}
inline void Account::set_email(const ::std::string& value) {
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.Account.email)
}
#if LANG_CXX11
inline void Account::set_email(::std::string&& value) {
  
  email_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.Account.email)
}
#endif
inline void Account::set_email(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.Account.email)
}
inline void Account::set_email(const char* value, size_t size) {
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.Account.email)
}
inline ::std::string* Account::mutable_email() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.Account.email)
  return email_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Account::release_email() {
  // @@protoc_insertion_point(field_release:nakama.api.Account.email)
  
  return email_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Account::set_allocated_email(::std::string* email) {
  if (email != NULL) {
    
  } else {
    
  }
  email_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), email);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.Account.email)
}

// repeated .nakama.api.AccountDevice devices = 4;
inline int Account::devices_size() const {
  return devices_.size();
}
inline void Account::clear_devices() {
  devices_.Clear();
}
inline ::nakama::api::AccountDevice* Account::mutable_devices(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.api.Account.devices)
  return devices_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nakama::api::AccountDevice >*
Account::mutable_devices() {
  // @@protoc_insertion_point(field_mutable_list:nakama.api.Account.devices)
  return &devices_;
}
inline const ::nakama::api::AccountDevice& Account::devices(int index) const {
  // @@protoc_insertion_point(field_get:nakama.api.Account.devices)
  return devices_.Get(index);
}
inline ::nakama::api::AccountDevice* Account::add_devices() {
  // @@protoc_insertion_point(field_add:nakama.api.Account.devices)
  return devices_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nakama::api::AccountDevice >&
Account::devices() const {
  // @@protoc_insertion_point(field_list:nakama.api.Account.devices)
  return devices_;
}

// string custom_id = 5;
inline void Account::clear_custom_id() {
  custom_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Account::custom_id() const {
  // @@protoc_insertion_point(field_get:nakama.api.Account.custom_id)
  return custom_id_.GetNoArena();
}
inline void Account::set_custom_id(const ::std::string& value) {
  
  custom_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.Account.custom_id)
}
#if LANG_CXX11
inline void Account::set_custom_id(::std::string&& value) {
  
  custom_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.Account.custom_id)
}
#endif
inline void Account::set_custom_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  custom_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.Account.custom_id)
}
inline void Account::set_custom_id(const char* value, size_t size) {
  
  custom_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.Account.custom_id)
}
inline ::std::string* Account::mutable_custom_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.Account.custom_id)
  return custom_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Account::release_custom_id() {
  // @@protoc_insertion_point(field_release:nakama.api.Account.custom_id)
  
  return custom_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Account::set_allocated_custom_id(::std::string* custom_id) {
  if (custom_id != NULL) {
    
  } else {
    
  }
  custom_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), custom_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.Account.custom_id)
}

// .google.protobuf.Timestamp verify_time = 6;
inline bool Account::has_verify_time() const {
  return this != internal_default_instance() && verify_time_ != NULL;
}
inline const ::google::protobuf::Timestamp& Account::_internal_verify_time() const {
  return *verify_time_;
}
inline const ::google::protobuf::Timestamp& Account::verify_time() const {
  const ::google::protobuf::Timestamp* p = verify_time_;
  // @@protoc_insertion_point(field_get:nakama.api.Account.verify_time)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* Account::release_verify_time() {
  // @@protoc_insertion_point(field_release:nakama.api.Account.verify_time)
  
  ::google::protobuf::Timestamp* temp = verify_time_;
  verify_time_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* Account::mutable_verify_time() {
  
  if (verify_time_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    verify_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.Account.verify_time)
  return verify_time_;
}
inline void Account::set_allocated_verify_time(::google::protobuf::Timestamp* verify_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(verify_time_);
  }
  if (verify_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(verify_time)->GetArena();
    if (message_arena != submessage_arena) {
      verify_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, verify_time, submessage_arena);
    }
    
  } else {
    
  }
  verify_time_ = verify_time;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.Account.verify_time)
}

// -------------------------------------------------------------------

// AccountCustom

// string id = 1;
inline void AccountCustom::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AccountCustom::id() const {
  // @@protoc_insertion_point(field_get:nakama.api.AccountCustom.id)
  return id_.GetNoArena();
}
inline void AccountCustom::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.AccountCustom.id)
}
#if LANG_CXX11
inline void AccountCustom::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.AccountCustom.id)
}
#endif
inline void AccountCustom::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.AccountCustom.id)
}
inline void AccountCustom::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.AccountCustom.id)
}
inline ::std::string* AccountCustom::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.AccountCustom.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccountCustom::release_id() {
  // @@protoc_insertion_point(field_release:nakama.api.AccountCustom.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccountCustom::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.AccountCustom.id)
}

// -------------------------------------------------------------------

// AccountDevice

// string id = 1;
inline void AccountDevice::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AccountDevice::id() const {
  // @@protoc_insertion_point(field_get:nakama.api.AccountDevice.id)
  return id_.GetNoArena();
}
inline void AccountDevice::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.AccountDevice.id)
}
#if LANG_CXX11
inline void AccountDevice::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.AccountDevice.id)
}
#endif
inline void AccountDevice::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.AccountDevice.id)
}
inline void AccountDevice::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.AccountDevice.id)
}
inline ::std::string* AccountDevice::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.AccountDevice.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccountDevice::release_id() {
  // @@protoc_insertion_point(field_release:nakama.api.AccountDevice.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccountDevice::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.AccountDevice.id)
}

// -------------------------------------------------------------------

// AccountEmail

// string email = 1;
inline void AccountEmail::clear_email() {
  email_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AccountEmail::email() const {
  // @@protoc_insertion_point(field_get:nakama.api.AccountEmail.email)
  return email_.GetNoArena();
}
inline void AccountEmail::set_email(const ::std::string& value) {
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.AccountEmail.email)
}
#if LANG_CXX11
inline void AccountEmail::set_email(::std::string&& value) {
  
  email_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.AccountEmail.email)
}
#endif
inline void AccountEmail::set_email(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.AccountEmail.email)
}
inline void AccountEmail::set_email(const char* value, size_t size) {
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.AccountEmail.email)
}
inline ::std::string* AccountEmail::mutable_email() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.AccountEmail.email)
  return email_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccountEmail::release_email() {
  // @@protoc_insertion_point(field_release:nakama.api.AccountEmail.email)
  
  return email_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccountEmail::set_allocated_email(::std::string* email) {
  if (email != NULL) {
    
  } else {
    
  }
  email_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), email);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.AccountEmail.email)
}

// string password = 2;
inline void AccountEmail::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AccountEmail::password() const {
  // @@protoc_insertion_point(field_get:nakama.api.AccountEmail.password)
  return password_.GetNoArena();
}
inline void AccountEmail::set_password(const ::std::string& value) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.AccountEmail.password)
}
#if LANG_CXX11
inline void AccountEmail::set_password(::std::string&& value) {
  
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.AccountEmail.password)
}
#endif
inline void AccountEmail::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.AccountEmail.password)
}
inline void AccountEmail::set_password(const char* value, size_t size) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.AccountEmail.password)
}
inline ::std::string* AccountEmail::mutable_password() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.AccountEmail.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccountEmail::release_password() {
  // @@protoc_insertion_point(field_release:nakama.api.AccountEmail.password)
  
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccountEmail::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.AccountEmail.password)
}

// -------------------------------------------------------------------

// AccountFacebook

// string token = 1;
inline void AccountFacebook::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AccountFacebook::token() const {
  // @@protoc_insertion_point(field_get:nakama.api.AccountFacebook.token)
  return token_.GetNoArena();
}
inline void AccountFacebook::set_token(const ::std::string& value) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.AccountFacebook.token)
}
#if LANG_CXX11
inline void AccountFacebook::set_token(::std::string&& value) {
  
  token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.AccountFacebook.token)
}
#endif
inline void AccountFacebook::set_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.AccountFacebook.token)
}
inline void AccountFacebook::set_token(const char* value, size_t size) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.AccountFacebook.token)
}
inline ::std::string* AccountFacebook::mutable_token() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.AccountFacebook.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccountFacebook::release_token() {
  // @@protoc_insertion_point(field_release:nakama.api.AccountFacebook.token)
  
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccountFacebook::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.AccountFacebook.token)
}

// -------------------------------------------------------------------

// AccountGameCenter

// string player_id = 1;
inline void AccountGameCenter::clear_player_id() {
  player_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AccountGameCenter::player_id() const {
  // @@protoc_insertion_point(field_get:nakama.api.AccountGameCenter.player_id)
  return player_id_.GetNoArena();
}
inline void AccountGameCenter::set_player_id(const ::std::string& value) {
  
  player_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.AccountGameCenter.player_id)
}
#if LANG_CXX11
inline void AccountGameCenter::set_player_id(::std::string&& value) {
  
  player_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.AccountGameCenter.player_id)
}
#endif
inline void AccountGameCenter::set_player_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  player_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.AccountGameCenter.player_id)
}
inline void AccountGameCenter::set_player_id(const char* value, size_t size) {
  
  player_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.AccountGameCenter.player_id)
}
inline ::std::string* AccountGameCenter::mutable_player_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.AccountGameCenter.player_id)
  return player_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccountGameCenter::release_player_id() {
  // @@protoc_insertion_point(field_release:nakama.api.AccountGameCenter.player_id)
  
  return player_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccountGameCenter::set_allocated_player_id(::std::string* player_id) {
  if (player_id != NULL) {
    
  } else {
    
  }
  player_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), player_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.AccountGameCenter.player_id)
}

// string bundle_id = 2;
inline void AccountGameCenter::clear_bundle_id() {
  bundle_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AccountGameCenter::bundle_id() const {
  // @@protoc_insertion_point(field_get:nakama.api.AccountGameCenter.bundle_id)
  return bundle_id_.GetNoArena();
}
inline void AccountGameCenter::set_bundle_id(const ::std::string& value) {
  
  bundle_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.AccountGameCenter.bundle_id)
}
#if LANG_CXX11
inline void AccountGameCenter::set_bundle_id(::std::string&& value) {
  
  bundle_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.AccountGameCenter.bundle_id)
}
#endif
inline void AccountGameCenter::set_bundle_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  bundle_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.AccountGameCenter.bundle_id)
}
inline void AccountGameCenter::set_bundle_id(const char* value, size_t size) {
  
  bundle_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.AccountGameCenter.bundle_id)
}
inline ::std::string* AccountGameCenter::mutable_bundle_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.AccountGameCenter.bundle_id)
  return bundle_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccountGameCenter::release_bundle_id() {
  // @@protoc_insertion_point(field_release:nakama.api.AccountGameCenter.bundle_id)
  
  return bundle_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccountGameCenter::set_allocated_bundle_id(::std::string* bundle_id) {
  if (bundle_id != NULL) {
    
  } else {
    
  }
  bundle_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bundle_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.AccountGameCenter.bundle_id)
}

// int64 timestamp_seconds = 3;
inline void AccountGameCenter::clear_timestamp_seconds() {
  timestamp_seconds_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 AccountGameCenter::timestamp_seconds() const {
  // @@protoc_insertion_point(field_get:nakama.api.AccountGameCenter.timestamp_seconds)
  return timestamp_seconds_;
}
inline void AccountGameCenter::set_timestamp_seconds(::google::protobuf::int64 value) {
  
  timestamp_seconds_ = value;
  // @@protoc_insertion_point(field_set:nakama.api.AccountGameCenter.timestamp_seconds)
}

// string salt = 4;
inline void AccountGameCenter::clear_salt() {
  salt_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AccountGameCenter::salt() const {
  // @@protoc_insertion_point(field_get:nakama.api.AccountGameCenter.salt)
  return salt_.GetNoArena();
}
inline void AccountGameCenter::set_salt(const ::std::string& value) {
  
  salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.AccountGameCenter.salt)
}
#if LANG_CXX11
inline void AccountGameCenter::set_salt(::std::string&& value) {
  
  salt_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.AccountGameCenter.salt)
}
#endif
inline void AccountGameCenter::set_salt(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.AccountGameCenter.salt)
}
inline void AccountGameCenter::set_salt(const char* value, size_t size) {
  
  salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.AccountGameCenter.salt)
}
inline ::std::string* AccountGameCenter::mutable_salt() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.AccountGameCenter.salt)
  return salt_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccountGameCenter::release_salt() {
  // @@protoc_insertion_point(field_release:nakama.api.AccountGameCenter.salt)
  
  return salt_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccountGameCenter::set_allocated_salt(::std::string* salt) {
  if (salt != NULL) {
    
  } else {
    
  }
  salt_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), salt);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.AccountGameCenter.salt)
}

// string signature = 5;
inline void AccountGameCenter::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AccountGameCenter::signature() const {
  // @@protoc_insertion_point(field_get:nakama.api.AccountGameCenter.signature)
  return signature_.GetNoArena();
}
inline void AccountGameCenter::set_signature(const ::std::string& value) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.AccountGameCenter.signature)
}
#if LANG_CXX11
inline void AccountGameCenter::set_signature(::std::string&& value) {
  
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.AccountGameCenter.signature)
}
#endif
inline void AccountGameCenter::set_signature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.AccountGameCenter.signature)
}
inline void AccountGameCenter::set_signature(const char* value, size_t size) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.AccountGameCenter.signature)
}
inline ::std::string* AccountGameCenter::mutable_signature() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.AccountGameCenter.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccountGameCenter::release_signature() {
  // @@protoc_insertion_point(field_release:nakama.api.AccountGameCenter.signature)
  
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccountGameCenter::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    
  } else {
    
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.AccountGameCenter.signature)
}

// string public_key_url = 6;
inline void AccountGameCenter::clear_public_key_url() {
  public_key_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AccountGameCenter::public_key_url() const {
  // @@protoc_insertion_point(field_get:nakama.api.AccountGameCenter.public_key_url)
  return public_key_url_.GetNoArena();
}
inline void AccountGameCenter::set_public_key_url(const ::std::string& value) {
  
  public_key_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.AccountGameCenter.public_key_url)
}
#if LANG_CXX11
inline void AccountGameCenter::set_public_key_url(::std::string&& value) {
  
  public_key_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.AccountGameCenter.public_key_url)
}
#endif
inline void AccountGameCenter::set_public_key_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  public_key_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.AccountGameCenter.public_key_url)
}
inline void AccountGameCenter::set_public_key_url(const char* value, size_t size) {
  
  public_key_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.AccountGameCenter.public_key_url)
}
inline ::std::string* AccountGameCenter::mutable_public_key_url() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.AccountGameCenter.public_key_url)
  return public_key_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccountGameCenter::release_public_key_url() {
  // @@protoc_insertion_point(field_release:nakama.api.AccountGameCenter.public_key_url)
  
  return public_key_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccountGameCenter::set_allocated_public_key_url(::std::string* public_key_url) {
  if (public_key_url != NULL) {
    
  } else {
    
  }
  public_key_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_key_url);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.AccountGameCenter.public_key_url)
}

// -------------------------------------------------------------------

// AccountGoogle

// string token = 1;
inline void AccountGoogle::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AccountGoogle::token() const {
  // @@protoc_insertion_point(field_get:nakama.api.AccountGoogle.token)
  return token_.GetNoArena();
}
inline void AccountGoogle::set_token(const ::std::string& value) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.AccountGoogle.token)
}
#if LANG_CXX11
inline void AccountGoogle::set_token(::std::string&& value) {
  
  token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.AccountGoogle.token)
}
#endif
inline void AccountGoogle::set_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.AccountGoogle.token)
}
inline void AccountGoogle::set_token(const char* value, size_t size) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.AccountGoogle.token)
}
inline ::std::string* AccountGoogle::mutable_token() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.AccountGoogle.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccountGoogle::release_token() {
  // @@protoc_insertion_point(field_release:nakama.api.AccountGoogle.token)
  
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccountGoogle::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.AccountGoogle.token)
}

// -------------------------------------------------------------------

// AccountSteam

// string token = 1;
inline void AccountSteam::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AccountSteam::token() const {
  // @@protoc_insertion_point(field_get:nakama.api.AccountSteam.token)
  return token_.GetNoArena();
}
inline void AccountSteam::set_token(const ::std::string& value) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.AccountSteam.token)
}
#if LANG_CXX11
inline void AccountSteam::set_token(::std::string&& value) {
  
  token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.AccountSteam.token)
}
#endif
inline void AccountSteam::set_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.AccountSteam.token)
}
inline void AccountSteam::set_token(const char* value, size_t size) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.AccountSteam.token)
}
inline ::std::string* AccountSteam::mutable_token() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.AccountSteam.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccountSteam::release_token() {
  // @@protoc_insertion_point(field_release:nakama.api.AccountSteam.token)
  
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccountSteam::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.AccountSteam.token)
}

// -------------------------------------------------------------------

// AddFriendsRequest

// repeated string ids = 1;
inline int AddFriendsRequest::ids_size() const {
  return ids_.size();
}
inline void AddFriendsRequest::clear_ids() {
  ids_.Clear();
}
inline const ::std::string& AddFriendsRequest::ids(int index) const {
  // @@protoc_insertion_point(field_get:nakama.api.AddFriendsRequest.ids)
  return ids_.Get(index);
}
inline ::std::string* AddFriendsRequest::mutable_ids(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.api.AddFriendsRequest.ids)
  return ids_.Mutable(index);
}
inline void AddFriendsRequest::set_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:nakama.api.AddFriendsRequest.ids)
  ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void AddFriendsRequest::set_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:nakama.api.AddFriendsRequest.ids)
  ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void AddFriendsRequest::set_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nakama.api.AddFriendsRequest.ids)
}
inline void AddFriendsRequest::set_ids(int index, const char* value, size_t size) {
  ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nakama.api.AddFriendsRequest.ids)
}
inline ::std::string* AddFriendsRequest::add_ids() {
  // @@protoc_insertion_point(field_add_mutable:nakama.api.AddFriendsRequest.ids)
  return ids_.Add();
}
inline void AddFriendsRequest::add_ids(const ::std::string& value) {
  ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:nakama.api.AddFriendsRequest.ids)
}
#if LANG_CXX11
inline void AddFriendsRequest::add_ids(::std::string&& value) {
  ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:nakama.api.AddFriendsRequest.ids)
}
#endif
inline void AddFriendsRequest::add_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nakama.api.AddFriendsRequest.ids)
}
inline void AddFriendsRequest::add_ids(const char* value, size_t size) {
  ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nakama.api.AddFriendsRequest.ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AddFriendsRequest::ids() const {
  // @@protoc_insertion_point(field_list:nakama.api.AddFriendsRequest.ids)
  return ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AddFriendsRequest::mutable_ids() {
  // @@protoc_insertion_point(field_mutable_list:nakama.api.AddFriendsRequest.ids)
  return &ids_;
}

// repeated string usernames = 2;
inline int AddFriendsRequest::usernames_size() const {
  return usernames_.size();
}
inline void AddFriendsRequest::clear_usernames() {
  usernames_.Clear();
}
inline const ::std::string& AddFriendsRequest::usernames(int index) const {
  // @@protoc_insertion_point(field_get:nakama.api.AddFriendsRequest.usernames)
  return usernames_.Get(index);
}
inline ::std::string* AddFriendsRequest::mutable_usernames(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.api.AddFriendsRequest.usernames)
  return usernames_.Mutable(index);
}
inline void AddFriendsRequest::set_usernames(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:nakama.api.AddFriendsRequest.usernames)
  usernames_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void AddFriendsRequest::set_usernames(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:nakama.api.AddFriendsRequest.usernames)
  usernames_.Mutable(index)->assign(std::move(value));
}
#endif
inline void AddFriendsRequest::set_usernames(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  usernames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nakama.api.AddFriendsRequest.usernames)
}
inline void AddFriendsRequest::set_usernames(int index, const char* value, size_t size) {
  usernames_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nakama.api.AddFriendsRequest.usernames)
}
inline ::std::string* AddFriendsRequest::add_usernames() {
  // @@protoc_insertion_point(field_add_mutable:nakama.api.AddFriendsRequest.usernames)
  return usernames_.Add();
}
inline void AddFriendsRequest::add_usernames(const ::std::string& value) {
  usernames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:nakama.api.AddFriendsRequest.usernames)
}
#if LANG_CXX11
inline void AddFriendsRequest::add_usernames(::std::string&& value) {
  usernames_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:nakama.api.AddFriendsRequest.usernames)
}
#endif
inline void AddFriendsRequest::add_usernames(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  usernames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nakama.api.AddFriendsRequest.usernames)
}
inline void AddFriendsRequest::add_usernames(const char* value, size_t size) {
  usernames_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nakama.api.AddFriendsRequest.usernames)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AddFriendsRequest::usernames() const {
  // @@protoc_insertion_point(field_list:nakama.api.AddFriendsRequest.usernames)
  return usernames_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AddFriendsRequest::mutable_usernames() {
  // @@protoc_insertion_point(field_mutable_list:nakama.api.AddFriendsRequest.usernames)
  return &usernames_;
}

// -------------------------------------------------------------------

// AddGroupUsersRequest

// string group_id = 1;
inline void AddGroupUsersRequest::clear_group_id() {
  group_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AddGroupUsersRequest::group_id() const {
  // @@protoc_insertion_point(field_get:nakama.api.AddGroupUsersRequest.group_id)
  return group_id_.GetNoArena();
}
inline void AddGroupUsersRequest::set_group_id(const ::std::string& value) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.AddGroupUsersRequest.group_id)
}
#if LANG_CXX11
inline void AddGroupUsersRequest::set_group_id(::std::string&& value) {
  
  group_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.AddGroupUsersRequest.group_id)
}
#endif
inline void AddGroupUsersRequest::set_group_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.AddGroupUsersRequest.group_id)
}
inline void AddGroupUsersRequest::set_group_id(const char* value, size_t size) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.AddGroupUsersRequest.group_id)
}
inline ::std::string* AddGroupUsersRequest::mutable_group_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.AddGroupUsersRequest.group_id)
  return group_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AddGroupUsersRequest::release_group_id() {
  // @@protoc_insertion_point(field_release:nakama.api.AddGroupUsersRequest.group_id)
  
  return group_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AddGroupUsersRequest::set_allocated_group_id(::std::string* group_id) {
  if (group_id != NULL) {
    
  } else {
    
  }
  group_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), group_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.AddGroupUsersRequest.group_id)
}

// repeated string user_ids = 2;
inline int AddGroupUsersRequest::user_ids_size() const {
  return user_ids_.size();
}
inline void AddGroupUsersRequest::clear_user_ids() {
  user_ids_.Clear();
}
inline const ::std::string& AddGroupUsersRequest::user_ids(int index) const {
  // @@protoc_insertion_point(field_get:nakama.api.AddGroupUsersRequest.user_ids)
  return user_ids_.Get(index);
}
inline ::std::string* AddGroupUsersRequest::mutable_user_ids(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.api.AddGroupUsersRequest.user_ids)
  return user_ids_.Mutable(index);
}
inline void AddGroupUsersRequest::set_user_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:nakama.api.AddGroupUsersRequest.user_ids)
  user_ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void AddGroupUsersRequest::set_user_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:nakama.api.AddGroupUsersRequest.user_ids)
  user_ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void AddGroupUsersRequest::set_user_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  user_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nakama.api.AddGroupUsersRequest.user_ids)
}
inline void AddGroupUsersRequest::set_user_ids(int index, const char* value, size_t size) {
  user_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nakama.api.AddGroupUsersRequest.user_ids)
}
inline ::std::string* AddGroupUsersRequest::add_user_ids() {
  // @@protoc_insertion_point(field_add_mutable:nakama.api.AddGroupUsersRequest.user_ids)
  return user_ids_.Add();
}
inline void AddGroupUsersRequest::add_user_ids(const ::std::string& value) {
  user_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:nakama.api.AddGroupUsersRequest.user_ids)
}
#if LANG_CXX11
inline void AddGroupUsersRequest::add_user_ids(::std::string&& value) {
  user_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:nakama.api.AddGroupUsersRequest.user_ids)
}
#endif
inline void AddGroupUsersRequest::add_user_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  user_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nakama.api.AddGroupUsersRequest.user_ids)
}
inline void AddGroupUsersRequest::add_user_ids(const char* value, size_t size) {
  user_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nakama.api.AddGroupUsersRequest.user_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AddGroupUsersRequest::user_ids() const {
  // @@protoc_insertion_point(field_list:nakama.api.AddGroupUsersRequest.user_ids)
  return user_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AddGroupUsersRequest::mutable_user_ids() {
  // @@protoc_insertion_point(field_mutable_list:nakama.api.AddGroupUsersRequest.user_ids)
  return &user_ids_;
}

// -------------------------------------------------------------------

// AuthenticateCustomRequest

// .nakama.api.AccountCustom account = 1;
inline bool AuthenticateCustomRequest::has_account() const {
  return this != internal_default_instance() && account_ != NULL;
}
inline void AuthenticateCustomRequest::clear_account() {
  if (GetArenaNoVirtual() == NULL && account_ != NULL) {
    delete account_;
  }
  account_ = NULL;
}
inline const ::nakama::api::AccountCustom& AuthenticateCustomRequest::_internal_account() const {
  return *account_;
}
inline const ::nakama::api::AccountCustom& AuthenticateCustomRequest::account() const {
  const ::nakama::api::AccountCustom* p = account_;
  // @@protoc_insertion_point(field_get:nakama.api.AuthenticateCustomRequest.account)
  return p != NULL ? *p : *reinterpret_cast<const ::nakama::api::AccountCustom*>(
      &::nakama::api::_AccountCustom_default_instance_);
}
inline ::nakama::api::AccountCustom* AuthenticateCustomRequest::release_account() {
  // @@protoc_insertion_point(field_release:nakama.api.AuthenticateCustomRequest.account)
  
  ::nakama::api::AccountCustom* temp = account_;
  account_ = NULL;
  return temp;
}
inline ::nakama::api::AccountCustom* AuthenticateCustomRequest::mutable_account() {
  
  if (account_ == NULL) {
    auto* p = CreateMaybeMessage<::nakama::api::AccountCustom>(GetArenaNoVirtual());
    account_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.AuthenticateCustomRequest.account)
  return account_;
}
inline void AuthenticateCustomRequest::set_allocated_account(::nakama::api::AccountCustom* account) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete account_;
  }
  if (account) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      account = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, account, submessage_arena);
    }
    
  } else {
    
  }
  account_ = account;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.AuthenticateCustomRequest.account)
}

// .google.protobuf.BoolValue create = 2;
inline bool AuthenticateCustomRequest::has_create() const {
  return this != internal_default_instance() && create_ != NULL;
}
inline const ::google::protobuf::BoolValue& AuthenticateCustomRequest::_internal_create() const {
  return *create_;
}
inline const ::google::protobuf::BoolValue& AuthenticateCustomRequest::create() const {
  const ::google::protobuf::BoolValue* p = create_;
  // @@protoc_insertion_point(field_get:nakama.api.AuthenticateCustomRequest.create)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::BoolValue*>(
      &::google::protobuf::_BoolValue_default_instance_);
}
inline ::google::protobuf::BoolValue* AuthenticateCustomRequest::release_create() {
  // @@protoc_insertion_point(field_release:nakama.api.AuthenticateCustomRequest.create)
  
  ::google::protobuf::BoolValue* temp = create_;
  create_ = NULL;
  return temp;
}
inline ::google::protobuf::BoolValue* AuthenticateCustomRequest::mutable_create() {
  
  if (create_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::BoolValue>(GetArenaNoVirtual());
    create_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.AuthenticateCustomRequest.create)
  return create_;
}
inline void AuthenticateCustomRequest::set_allocated_create(::google::protobuf::BoolValue* create) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(create_);
  }
  if (create) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(create)->GetArena();
    if (message_arena != submessage_arena) {
      create = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, create, submessage_arena);
    }
    
  } else {
    
  }
  create_ = create;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.AuthenticateCustomRequest.create)
}

// string username = 3;
inline void AuthenticateCustomRequest::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AuthenticateCustomRequest::username() const {
  // @@protoc_insertion_point(field_get:nakama.api.AuthenticateCustomRequest.username)
  return username_.GetNoArena();
}
inline void AuthenticateCustomRequest::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.AuthenticateCustomRequest.username)
}
#if LANG_CXX11
inline void AuthenticateCustomRequest::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.AuthenticateCustomRequest.username)
}
#endif
inline void AuthenticateCustomRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.AuthenticateCustomRequest.username)
}
inline void AuthenticateCustomRequest::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.AuthenticateCustomRequest.username)
}
inline ::std::string* AuthenticateCustomRequest::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.AuthenticateCustomRequest.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateCustomRequest::release_username() {
  // @@protoc_insertion_point(field_release:nakama.api.AuthenticateCustomRequest.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateCustomRequest::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.AuthenticateCustomRequest.username)
}

// -------------------------------------------------------------------

// AuthenticateDeviceRequest

// .nakama.api.AccountDevice account = 1;
inline bool AuthenticateDeviceRequest::has_account() const {
  return this != internal_default_instance() && account_ != NULL;
}
inline void AuthenticateDeviceRequest::clear_account() {
  if (GetArenaNoVirtual() == NULL && account_ != NULL) {
    delete account_;
  }
  account_ = NULL;
}
inline const ::nakama::api::AccountDevice& AuthenticateDeviceRequest::_internal_account() const {
  return *account_;
}
inline const ::nakama::api::AccountDevice& AuthenticateDeviceRequest::account() const {
  const ::nakama::api::AccountDevice* p = account_;
  // @@protoc_insertion_point(field_get:nakama.api.AuthenticateDeviceRequest.account)
  return p != NULL ? *p : *reinterpret_cast<const ::nakama::api::AccountDevice*>(
      &::nakama::api::_AccountDevice_default_instance_);
}
inline ::nakama::api::AccountDevice* AuthenticateDeviceRequest::release_account() {
  // @@protoc_insertion_point(field_release:nakama.api.AuthenticateDeviceRequest.account)
  
  ::nakama::api::AccountDevice* temp = account_;
  account_ = NULL;
  return temp;
}
inline ::nakama::api::AccountDevice* AuthenticateDeviceRequest::mutable_account() {
  
  if (account_ == NULL) {
    auto* p = CreateMaybeMessage<::nakama::api::AccountDevice>(GetArenaNoVirtual());
    account_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.AuthenticateDeviceRequest.account)
  return account_;
}
inline void AuthenticateDeviceRequest::set_allocated_account(::nakama::api::AccountDevice* account) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete account_;
  }
  if (account) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      account = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, account, submessage_arena);
    }
    
  } else {
    
  }
  account_ = account;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.AuthenticateDeviceRequest.account)
}

// .google.protobuf.BoolValue create = 2;
inline bool AuthenticateDeviceRequest::has_create() const {
  return this != internal_default_instance() && create_ != NULL;
}
inline const ::google::protobuf::BoolValue& AuthenticateDeviceRequest::_internal_create() const {
  return *create_;
}
inline const ::google::protobuf::BoolValue& AuthenticateDeviceRequest::create() const {
  const ::google::protobuf::BoolValue* p = create_;
  // @@protoc_insertion_point(field_get:nakama.api.AuthenticateDeviceRequest.create)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::BoolValue*>(
      &::google::protobuf::_BoolValue_default_instance_);
}
inline ::google::protobuf::BoolValue* AuthenticateDeviceRequest::release_create() {
  // @@protoc_insertion_point(field_release:nakama.api.AuthenticateDeviceRequest.create)
  
  ::google::protobuf::BoolValue* temp = create_;
  create_ = NULL;
  return temp;
}
inline ::google::protobuf::BoolValue* AuthenticateDeviceRequest::mutable_create() {
  
  if (create_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::BoolValue>(GetArenaNoVirtual());
    create_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.AuthenticateDeviceRequest.create)
  return create_;
}
inline void AuthenticateDeviceRequest::set_allocated_create(::google::protobuf::BoolValue* create) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(create_);
  }
  if (create) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(create)->GetArena();
    if (message_arena != submessage_arena) {
      create = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, create, submessage_arena);
    }
    
  } else {
    
  }
  create_ = create;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.AuthenticateDeviceRequest.create)
}

// string username = 3;
inline void AuthenticateDeviceRequest::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AuthenticateDeviceRequest::username() const {
  // @@protoc_insertion_point(field_get:nakama.api.AuthenticateDeviceRequest.username)
  return username_.GetNoArena();
}
inline void AuthenticateDeviceRequest::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.AuthenticateDeviceRequest.username)
}
#if LANG_CXX11
inline void AuthenticateDeviceRequest::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.AuthenticateDeviceRequest.username)
}
#endif
inline void AuthenticateDeviceRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.AuthenticateDeviceRequest.username)
}
inline void AuthenticateDeviceRequest::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.AuthenticateDeviceRequest.username)
}
inline ::std::string* AuthenticateDeviceRequest::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.AuthenticateDeviceRequest.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateDeviceRequest::release_username() {
  // @@protoc_insertion_point(field_release:nakama.api.AuthenticateDeviceRequest.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateDeviceRequest::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.AuthenticateDeviceRequest.username)
}

// -------------------------------------------------------------------

// AuthenticateEmailRequest

// .nakama.api.AccountEmail account = 1;
inline bool AuthenticateEmailRequest::has_account() const {
  return this != internal_default_instance() && account_ != NULL;
}
inline void AuthenticateEmailRequest::clear_account() {
  if (GetArenaNoVirtual() == NULL && account_ != NULL) {
    delete account_;
  }
  account_ = NULL;
}
inline const ::nakama::api::AccountEmail& AuthenticateEmailRequest::_internal_account() const {
  return *account_;
}
inline const ::nakama::api::AccountEmail& AuthenticateEmailRequest::account() const {
  const ::nakama::api::AccountEmail* p = account_;
  // @@protoc_insertion_point(field_get:nakama.api.AuthenticateEmailRequest.account)
  return p != NULL ? *p : *reinterpret_cast<const ::nakama::api::AccountEmail*>(
      &::nakama::api::_AccountEmail_default_instance_);
}
inline ::nakama::api::AccountEmail* AuthenticateEmailRequest::release_account() {
  // @@protoc_insertion_point(field_release:nakama.api.AuthenticateEmailRequest.account)
  
  ::nakama::api::AccountEmail* temp = account_;
  account_ = NULL;
  return temp;
}
inline ::nakama::api::AccountEmail* AuthenticateEmailRequest::mutable_account() {
  
  if (account_ == NULL) {
    auto* p = CreateMaybeMessage<::nakama::api::AccountEmail>(GetArenaNoVirtual());
    account_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.AuthenticateEmailRequest.account)
  return account_;
}
inline void AuthenticateEmailRequest::set_allocated_account(::nakama::api::AccountEmail* account) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete account_;
  }
  if (account) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      account = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, account, submessage_arena);
    }
    
  } else {
    
  }
  account_ = account;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.AuthenticateEmailRequest.account)
}

// .google.protobuf.BoolValue create = 2;
inline bool AuthenticateEmailRequest::has_create() const {
  return this != internal_default_instance() && create_ != NULL;
}
inline const ::google::protobuf::BoolValue& AuthenticateEmailRequest::_internal_create() const {
  return *create_;
}
inline const ::google::protobuf::BoolValue& AuthenticateEmailRequest::create() const {
  const ::google::protobuf::BoolValue* p = create_;
  // @@protoc_insertion_point(field_get:nakama.api.AuthenticateEmailRequest.create)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::BoolValue*>(
      &::google::protobuf::_BoolValue_default_instance_);
}
inline ::google::protobuf::BoolValue* AuthenticateEmailRequest::release_create() {
  // @@protoc_insertion_point(field_release:nakama.api.AuthenticateEmailRequest.create)
  
  ::google::protobuf::BoolValue* temp = create_;
  create_ = NULL;
  return temp;
}
inline ::google::protobuf::BoolValue* AuthenticateEmailRequest::mutable_create() {
  
  if (create_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::BoolValue>(GetArenaNoVirtual());
    create_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.AuthenticateEmailRequest.create)
  return create_;
}
inline void AuthenticateEmailRequest::set_allocated_create(::google::protobuf::BoolValue* create) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(create_);
  }
  if (create) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(create)->GetArena();
    if (message_arena != submessage_arena) {
      create = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, create, submessage_arena);
    }
    
  } else {
    
  }
  create_ = create;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.AuthenticateEmailRequest.create)
}

// string username = 3;
inline void AuthenticateEmailRequest::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AuthenticateEmailRequest::username() const {
  // @@protoc_insertion_point(field_get:nakama.api.AuthenticateEmailRequest.username)
  return username_.GetNoArena();
}
inline void AuthenticateEmailRequest::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.AuthenticateEmailRequest.username)
}
#if LANG_CXX11
inline void AuthenticateEmailRequest::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.AuthenticateEmailRequest.username)
}
#endif
inline void AuthenticateEmailRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.AuthenticateEmailRequest.username)
}
inline void AuthenticateEmailRequest::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.AuthenticateEmailRequest.username)
}
inline ::std::string* AuthenticateEmailRequest::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.AuthenticateEmailRequest.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateEmailRequest::release_username() {
  // @@protoc_insertion_point(field_release:nakama.api.AuthenticateEmailRequest.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateEmailRequest::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.AuthenticateEmailRequest.username)
}

// -------------------------------------------------------------------

// AuthenticateFacebookRequest

// .nakama.api.AccountFacebook account = 1;
inline bool AuthenticateFacebookRequest::has_account() const {
  return this != internal_default_instance() && account_ != NULL;
}
inline void AuthenticateFacebookRequest::clear_account() {
  if (GetArenaNoVirtual() == NULL && account_ != NULL) {
    delete account_;
  }
  account_ = NULL;
}
inline const ::nakama::api::AccountFacebook& AuthenticateFacebookRequest::_internal_account() const {
  return *account_;
}
inline const ::nakama::api::AccountFacebook& AuthenticateFacebookRequest::account() const {
  const ::nakama::api::AccountFacebook* p = account_;
  // @@protoc_insertion_point(field_get:nakama.api.AuthenticateFacebookRequest.account)
  return p != NULL ? *p : *reinterpret_cast<const ::nakama::api::AccountFacebook*>(
      &::nakama::api::_AccountFacebook_default_instance_);
}
inline ::nakama::api::AccountFacebook* AuthenticateFacebookRequest::release_account() {
  // @@protoc_insertion_point(field_release:nakama.api.AuthenticateFacebookRequest.account)
  
  ::nakama::api::AccountFacebook* temp = account_;
  account_ = NULL;
  return temp;
}
inline ::nakama::api::AccountFacebook* AuthenticateFacebookRequest::mutable_account() {
  
  if (account_ == NULL) {
    auto* p = CreateMaybeMessage<::nakama::api::AccountFacebook>(GetArenaNoVirtual());
    account_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.AuthenticateFacebookRequest.account)
  return account_;
}
inline void AuthenticateFacebookRequest::set_allocated_account(::nakama::api::AccountFacebook* account) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete account_;
  }
  if (account) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      account = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, account, submessage_arena);
    }
    
  } else {
    
  }
  account_ = account;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.AuthenticateFacebookRequest.account)
}

// .google.protobuf.BoolValue create = 2;
inline bool AuthenticateFacebookRequest::has_create() const {
  return this != internal_default_instance() && create_ != NULL;
}
inline const ::google::protobuf::BoolValue& AuthenticateFacebookRequest::_internal_create() const {
  return *create_;
}
inline const ::google::protobuf::BoolValue& AuthenticateFacebookRequest::create() const {
  const ::google::protobuf::BoolValue* p = create_;
  // @@protoc_insertion_point(field_get:nakama.api.AuthenticateFacebookRequest.create)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::BoolValue*>(
      &::google::protobuf::_BoolValue_default_instance_);
}
inline ::google::protobuf::BoolValue* AuthenticateFacebookRequest::release_create() {
  // @@protoc_insertion_point(field_release:nakama.api.AuthenticateFacebookRequest.create)
  
  ::google::protobuf::BoolValue* temp = create_;
  create_ = NULL;
  return temp;
}
inline ::google::protobuf::BoolValue* AuthenticateFacebookRequest::mutable_create() {
  
  if (create_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::BoolValue>(GetArenaNoVirtual());
    create_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.AuthenticateFacebookRequest.create)
  return create_;
}
inline void AuthenticateFacebookRequest::set_allocated_create(::google::protobuf::BoolValue* create) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(create_);
  }
  if (create) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(create)->GetArena();
    if (message_arena != submessage_arena) {
      create = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, create, submessage_arena);
    }
    
  } else {
    
  }
  create_ = create;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.AuthenticateFacebookRequest.create)
}

// string username = 3;
inline void AuthenticateFacebookRequest::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AuthenticateFacebookRequest::username() const {
  // @@protoc_insertion_point(field_get:nakama.api.AuthenticateFacebookRequest.username)
  return username_.GetNoArena();
}
inline void AuthenticateFacebookRequest::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.AuthenticateFacebookRequest.username)
}
#if LANG_CXX11
inline void AuthenticateFacebookRequest::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.AuthenticateFacebookRequest.username)
}
#endif
inline void AuthenticateFacebookRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.AuthenticateFacebookRequest.username)
}
inline void AuthenticateFacebookRequest::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.AuthenticateFacebookRequest.username)
}
inline ::std::string* AuthenticateFacebookRequest::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.AuthenticateFacebookRequest.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateFacebookRequest::release_username() {
  // @@protoc_insertion_point(field_release:nakama.api.AuthenticateFacebookRequest.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateFacebookRequest::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.AuthenticateFacebookRequest.username)
}

// .google.protobuf.BoolValue import = 4;
inline bool AuthenticateFacebookRequest::has_import() const {
  return this != internal_default_instance() && import_ != NULL;
}
inline const ::google::protobuf::BoolValue& AuthenticateFacebookRequest::_internal_import() const {
  return *import_;
}
inline const ::google::protobuf::BoolValue& AuthenticateFacebookRequest::import() const {
  const ::google::protobuf::BoolValue* p = import_;
  // @@protoc_insertion_point(field_get:nakama.api.AuthenticateFacebookRequest.import)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::BoolValue*>(
      &::google::protobuf::_BoolValue_default_instance_);
}
inline ::google::protobuf::BoolValue* AuthenticateFacebookRequest::release_import() {
  // @@protoc_insertion_point(field_release:nakama.api.AuthenticateFacebookRequest.import)
  
  ::google::protobuf::BoolValue* temp = import_;
  import_ = NULL;
  return temp;
}
inline ::google::protobuf::BoolValue* AuthenticateFacebookRequest::mutable_import() {
  
  if (import_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::BoolValue>(GetArenaNoVirtual());
    import_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.AuthenticateFacebookRequest.import)
  return import_;
}
inline void AuthenticateFacebookRequest::set_allocated_import(::google::protobuf::BoolValue* import) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(import_);
  }
  if (import) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(import)->GetArena();
    if (message_arena != submessage_arena) {
      import = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, import, submessage_arena);
    }
    
  } else {
    
  }
  import_ = import;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.AuthenticateFacebookRequest.import)
}

// -------------------------------------------------------------------

// AuthenticateGameCenterRequest

// .nakama.api.AccountGameCenter account = 1;
inline bool AuthenticateGameCenterRequest::has_account() const {
  return this != internal_default_instance() && account_ != NULL;
}
inline void AuthenticateGameCenterRequest::clear_account() {
  if (GetArenaNoVirtual() == NULL && account_ != NULL) {
    delete account_;
  }
  account_ = NULL;
}
inline const ::nakama::api::AccountGameCenter& AuthenticateGameCenterRequest::_internal_account() const {
  return *account_;
}
inline const ::nakama::api::AccountGameCenter& AuthenticateGameCenterRequest::account() const {
  const ::nakama::api::AccountGameCenter* p = account_;
  // @@protoc_insertion_point(field_get:nakama.api.AuthenticateGameCenterRequest.account)
  return p != NULL ? *p : *reinterpret_cast<const ::nakama::api::AccountGameCenter*>(
      &::nakama::api::_AccountGameCenter_default_instance_);
}
inline ::nakama::api::AccountGameCenter* AuthenticateGameCenterRequest::release_account() {
  // @@protoc_insertion_point(field_release:nakama.api.AuthenticateGameCenterRequest.account)
  
  ::nakama::api::AccountGameCenter* temp = account_;
  account_ = NULL;
  return temp;
}
inline ::nakama::api::AccountGameCenter* AuthenticateGameCenterRequest::mutable_account() {
  
  if (account_ == NULL) {
    auto* p = CreateMaybeMessage<::nakama::api::AccountGameCenter>(GetArenaNoVirtual());
    account_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.AuthenticateGameCenterRequest.account)
  return account_;
}
inline void AuthenticateGameCenterRequest::set_allocated_account(::nakama::api::AccountGameCenter* account) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete account_;
  }
  if (account) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      account = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, account, submessage_arena);
    }
    
  } else {
    
  }
  account_ = account;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.AuthenticateGameCenterRequest.account)
}

// .google.protobuf.BoolValue create = 2;
inline bool AuthenticateGameCenterRequest::has_create() const {
  return this != internal_default_instance() && create_ != NULL;
}
inline const ::google::protobuf::BoolValue& AuthenticateGameCenterRequest::_internal_create() const {
  return *create_;
}
inline const ::google::protobuf::BoolValue& AuthenticateGameCenterRequest::create() const {
  const ::google::protobuf::BoolValue* p = create_;
  // @@protoc_insertion_point(field_get:nakama.api.AuthenticateGameCenterRequest.create)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::BoolValue*>(
      &::google::protobuf::_BoolValue_default_instance_);
}
inline ::google::protobuf::BoolValue* AuthenticateGameCenterRequest::release_create() {
  // @@protoc_insertion_point(field_release:nakama.api.AuthenticateGameCenterRequest.create)
  
  ::google::protobuf::BoolValue* temp = create_;
  create_ = NULL;
  return temp;
}
inline ::google::protobuf::BoolValue* AuthenticateGameCenterRequest::mutable_create() {
  
  if (create_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::BoolValue>(GetArenaNoVirtual());
    create_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.AuthenticateGameCenterRequest.create)
  return create_;
}
inline void AuthenticateGameCenterRequest::set_allocated_create(::google::protobuf::BoolValue* create) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(create_);
  }
  if (create) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(create)->GetArena();
    if (message_arena != submessage_arena) {
      create = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, create, submessage_arena);
    }
    
  } else {
    
  }
  create_ = create;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.AuthenticateGameCenterRequest.create)
}

// string username = 3;
inline void AuthenticateGameCenterRequest::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AuthenticateGameCenterRequest::username() const {
  // @@protoc_insertion_point(field_get:nakama.api.AuthenticateGameCenterRequest.username)
  return username_.GetNoArena();
}
inline void AuthenticateGameCenterRequest::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.AuthenticateGameCenterRequest.username)
}
#if LANG_CXX11
inline void AuthenticateGameCenterRequest::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.AuthenticateGameCenterRequest.username)
}
#endif
inline void AuthenticateGameCenterRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.AuthenticateGameCenterRequest.username)
}
inline void AuthenticateGameCenterRequest::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.AuthenticateGameCenterRequest.username)
}
inline ::std::string* AuthenticateGameCenterRequest::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.AuthenticateGameCenterRequest.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateGameCenterRequest::release_username() {
  // @@protoc_insertion_point(field_release:nakama.api.AuthenticateGameCenterRequest.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateGameCenterRequest::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.AuthenticateGameCenterRequest.username)
}

// -------------------------------------------------------------------

// AuthenticateGoogleRequest

// .nakama.api.AccountGoogle account = 1;
inline bool AuthenticateGoogleRequest::has_account() const {
  return this != internal_default_instance() && account_ != NULL;
}
inline void AuthenticateGoogleRequest::clear_account() {
  if (GetArenaNoVirtual() == NULL && account_ != NULL) {
    delete account_;
  }
  account_ = NULL;
}
inline const ::nakama::api::AccountGoogle& AuthenticateGoogleRequest::_internal_account() const {
  return *account_;
}
inline const ::nakama::api::AccountGoogle& AuthenticateGoogleRequest::account() const {
  const ::nakama::api::AccountGoogle* p = account_;
  // @@protoc_insertion_point(field_get:nakama.api.AuthenticateGoogleRequest.account)
  return p != NULL ? *p : *reinterpret_cast<const ::nakama::api::AccountGoogle*>(
      &::nakama::api::_AccountGoogle_default_instance_);
}
inline ::nakama::api::AccountGoogle* AuthenticateGoogleRequest::release_account() {
  // @@protoc_insertion_point(field_release:nakama.api.AuthenticateGoogleRequest.account)
  
  ::nakama::api::AccountGoogle* temp = account_;
  account_ = NULL;
  return temp;
}
inline ::nakama::api::AccountGoogle* AuthenticateGoogleRequest::mutable_account() {
  
  if (account_ == NULL) {
    auto* p = CreateMaybeMessage<::nakama::api::AccountGoogle>(GetArenaNoVirtual());
    account_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.AuthenticateGoogleRequest.account)
  return account_;
}
inline void AuthenticateGoogleRequest::set_allocated_account(::nakama::api::AccountGoogle* account) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete account_;
  }
  if (account) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      account = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, account, submessage_arena);
    }
    
  } else {
    
  }
  account_ = account;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.AuthenticateGoogleRequest.account)
}

// .google.protobuf.BoolValue create = 2;
inline bool AuthenticateGoogleRequest::has_create() const {
  return this != internal_default_instance() && create_ != NULL;
}
inline const ::google::protobuf::BoolValue& AuthenticateGoogleRequest::_internal_create() const {
  return *create_;
}
inline const ::google::protobuf::BoolValue& AuthenticateGoogleRequest::create() const {
  const ::google::protobuf::BoolValue* p = create_;
  // @@protoc_insertion_point(field_get:nakama.api.AuthenticateGoogleRequest.create)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::BoolValue*>(
      &::google::protobuf::_BoolValue_default_instance_);
}
inline ::google::protobuf::BoolValue* AuthenticateGoogleRequest::release_create() {
  // @@protoc_insertion_point(field_release:nakama.api.AuthenticateGoogleRequest.create)
  
  ::google::protobuf::BoolValue* temp = create_;
  create_ = NULL;
  return temp;
}
inline ::google::protobuf::BoolValue* AuthenticateGoogleRequest::mutable_create() {
  
  if (create_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::BoolValue>(GetArenaNoVirtual());
    create_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.AuthenticateGoogleRequest.create)
  return create_;
}
inline void AuthenticateGoogleRequest::set_allocated_create(::google::protobuf::BoolValue* create) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(create_);
  }
  if (create) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(create)->GetArena();
    if (message_arena != submessage_arena) {
      create = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, create, submessage_arena);
    }
    
  } else {
    
  }
  create_ = create;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.AuthenticateGoogleRequest.create)
}

// string username = 3;
inline void AuthenticateGoogleRequest::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AuthenticateGoogleRequest::username() const {
  // @@protoc_insertion_point(field_get:nakama.api.AuthenticateGoogleRequest.username)
  return username_.GetNoArena();
}
inline void AuthenticateGoogleRequest::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.AuthenticateGoogleRequest.username)
}
#if LANG_CXX11
inline void AuthenticateGoogleRequest::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.AuthenticateGoogleRequest.username)
}
#endif
inline void AuthenticateGoogleRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.AuthenticateGoogleRequest.username)
}
inline void AuthenticateGoogleRequest::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.AuthenticateGoogleRequest.username)
}
inline ::std::string* AuthenticateGoogleRequest::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.AuthenticateGoogleRequest.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateGoogleRequest::release_username() {
  // @@protoc_insertion_point(field_release:nakama.api.AuthenticateGoogleRequest.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateGoogleRequest::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.AuthenticateGoogleRequest.username)
}

// -------------------------------------------------------------------

// AuthenticateSteamRequest

// .nakama.api.AccountSteam account = 1;
inline bool AuthenticateSteamRequest::has_account() const {
  return this != internal_default_instance() && account_ != NULL;
}
inline void AuthenticateSteamRequest::clear_account() {
  if (GetArenaNoVirtual() == NULL && account_ != NULL) {
    delete account_;
  }
  account_ = NULL;
}
inline const ::nakama::api::AccountSteam& AuthenticateSteamRequest::_internal_account() const {
  return *account_;
}
inline const ::nakama::api::AccountSteam& AuthenticateSteamRequest::account() const {
  const ::nakama::api::AccountSteam* p = account_;
  // @@protoc_insertion_point(field_get:nakama.api.AuthenticateSteamRequest.account)
  return p != NULL ? *p : *reinterpret_cast<const ::nakama::api::AccountSteam*>(
      &::nakama::api::_AccountSteam_default_instance_);
}
inline ::nakama::api::AccountSteam* AuthenticateSteamRequest::release_account() {
  // @@protoc_insertion_point(field_release:nakama.api.AuthenticateSteamRequest.account)
  
  ::nakama::api::AccountSteam* temp = account_;
  account_ = NULL;
  return temp;
}
inline ::nakama::api::AccountSteam* AuthenticateSteamRequest::mutable_account() {
  
  if (account_ == NULL) {
    auto* p = CreateMaybeMessage<::nakama::api::AccountSteam>(GetArenaNoVirtual());
    account_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.AuthenticateSteamRequest.account)
  return account_;
}
inline void AuthenticateSteamRequest::set_allocated_account(::nakama::api::AccountSteam* account) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete account_;
  }
  if (account) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      account = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, account, submessage_arena);
    }
    
  } else {
    
  }
  account_ = account;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.AuthenticateSteamRequest.account)
}

// .google.protobuf.BoolValue create = 2;
inline bool AuthenticateSteamRequest::has_create() const {
  return this != internal_default_instance() && create_ != NULL;
}
inline const ::google::protobuf::BoolValue& AuthenticateSteamRequest::_internal_create() const {
  return *create_;
}
inline const ::google::protobuf::BoolValue& AuthenticateSteamRequest::create() const {
  const ::google::protobuf::BoolValue* p = create_;
  // @@protoc_insertion_point(field_get:nakama.api.AuthenticateSteamRequest.create)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::BoolValue*>(
      &::google::protobuf::_BoolValue_default_instance_);
}
inline ::google::protobuf::BoolValue* AuthenticateSteamRequest::release_create() {
  // @@protoc_insertion_point(field_release:nakama.api.AuthenticateSteamRequest.create)
  
  ::google::protobuf::BoolValue* temp = create_;
  create_ = NULL;
  return temp;
}
inline ::google::protobuf::BoolValue* AuthenticateSteamRequest::mutable_create() {
  
  if (create_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::BoolValue>(GetArenaNoVirtual());
    create_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.AuthenticateSteamRequest.create)
  return create_;
}
inline void AuthenticateSteamRequest::set_allocated_create(::google::protobuf::BoolValue* create) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(create_);
  }
  if (create) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(create)->GetArena();
    if (message_arena != submessage_arena) {
      create = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, create, submessage_arena);
    }
    
  } else {
    
  }
  create_ = create;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.AuthenticateSteamRequest.create)
}

// string username = 3;
inline void AuthenticateSteamRequest::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AuthenticateSteamRequest::username() const {
  // @@protoc_insertion_point(field_get:nakama.api.AuthenticateSteamRequest.username)
  return username_.GetNoArena();
}
inline void AuthenticateSteamRequest::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.AuthenticateSteamRequest.username)
}
#if LANG_CXX11
inline void AuthenticateSteamRequest::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.AuthenticateSteamRequest.username)
}
#endif
inline void AuthenticateSteamRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.AuthenticateSteamRequest.username)
}
inline void AuthenticateSteamRequest::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.AuthenticateSteamRequest.username)
}
inline ::std::string* AuthenticateSteamRequest::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.AuthenticateSteamRequest.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateSteamRequest::release_username() {
  // @@protoc_insertion_point(field_release:nakama.api.AuthenticateSteamRequest.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateSteamRequest::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.AuthenticateSteamRequest.username)
}

// -------------------------------------------------------------------

// BlockFriendsRequest

// repeated string ids = 1;
inline int BlockFriendsRequest::ids_size() const {
  return ids_.size();
}
inline void BlockFriendsRequest::clear_ids() {
  ids_.Clear();
}
inline const ::std::string& BlockFriendsRequest::ids(int index) const {
  // @@protoc_insertion_point(field_get:nakama.api.BlockFriendsRequest.ids)
  return ids_.Get(index);
}
inline ::std::string* BlockFriendsRequest::mutable_ids(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.api.BlockFriendsRequest.ids)
  return ids_.Mutable(index);
}
inline void BlockFriendsRequest::set_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:nakama.api.BlockFriendsRequest.ids)
  ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void BlockFriendsRequest::set_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:nakama.api.BlockFriendsRequest.ids)
  ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void BlockFriendsRequest::set_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nakama.api.BlockFriendsRequest.ids)
}
inline void BlockFriendsRequest::set_ids(int index, const char* value, size_t size) {
  ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nakama.api.BlockFriendsRequest.ids)
}
inline ::std::string* BlockFriendsRequest::add_ids() {
  // @@protoc_insertion_point(field_add_mutable:nakama.api.BlockFriendsRequest.ids)
  return ids_.Add();
}
inline void BlockFriendsRequest::add_ids(const ::std::string& value) {
  ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:nakama.api.BlockFriendsRequest.ids)
}
#if LANG_CXX11
inline void BlockFriendsRequest::add_ids(::std::string&& value) {
  ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:nakama.api.BlockFriendsRequest.ids)
}
#endif
inline void BlockFriendsRequest::add_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nakama.api.BlockFriendsRequest.ids)
}
inline void BlockFriendsRequest::add_ids(const char* value, size_t size) {
  ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nakama.api.BlockFriendsRequest.ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BlockFriendsRequest::ids() const {
  // @@protoc_insertion_point(field_list:nakama.api.BlockFriendsRequest.ids)
  return ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BlockFriendsRequest::mutable_ids() {
  // @@protoc_insertion_point(field_mutable_list:nakama.api.BlockFriendsRequest.ids)
  return &ids_;
}

// repeated string usernames = 2;
inline int BlockFriendsRequest::usernames_size() const {
  return usernames_.size();
}
inline void BlockFriendsRequest::clear_usernames() {
  usernames_.Clear();
}
inline const ::std::string& BlockFriendsRequest::usernames(int index) const {
  // @@protoc_insertion_point(field_get:nakama.api.BlockFriendsRequest.usernames)
  return usernames_.Get(index);
}
inline ::std::string* BlockFriendsRequest::mutable_usernames(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.api.BlockFriendsRequest.usernames)
  return usernames_.Mutable(index);
}
inline void BlockFriendsRequest::set_usernames(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:nakama.api.BlockFriendsRequest.usernames)
  usernames_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void BlockFriendsRequest::set_usernames(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:nakama.api.BlockFriendsRequest.usernames)
  usernames_.Mutable(index)->assign(std::move(value));
}
#endif
inline void BlockFriendsRequest::set_usernames(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  usernames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nakama.api.BlockFriendsRequest.usernames)
}
inline void BlockFriendsRequest::set_usernames(int index, const char* value, size_t size) {
  usernames_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nakama.api.BlockFriendsRequest.usernames)
}
inline ::std::string* BlockFriendsRequest::add_usernames() {
  // @@protoc_insertion_point(field_add_mutable:nakama.api.BlockFriendsRequest.usernames)
  return usernames_.Add();
}
inline void BlockFriendsRequest::add_usernames(const ::std::string& value) {
  usernames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:nakama.api.BlockFriendsRequest.usernames)
}
#if LANG_CXX11
inline void BlockFriendsRequest::add_usernames(::std::string&& value) {
  usernames_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:nakama.api.BlockFriendsRequest.usernames)
}
#endif
inline void BlockFriendsRequest::add_usernames(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  usernames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nakama.api.BlockFriendsRequest.usernames)
}
inline void BlockFriendsRequest::add_usernames(const char* value, size_t size) {
  usernames_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nakama.api.BlockFriendsRequest.usernames)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BlockFriendsRequest::usernames() const {
  // @@protoc_insertion_point(field_list:nakama.api.BlockFriendsRequest.usernames)
  return usernames_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BlockFriendsRequest::mutable_usernames() {
  // @@protoc_insertion_point(field_mutable_list:nakama.api.BlockFriendsRequest.usernames)
  return &usernames_;
}

// -------------------------------------------------------------------

// ChannelMessage

// string channel_id = 1;
inline void ChannelMessage::clear_channel_id() {
  channel_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChannelMessage::channel_id() const {
  // @@protoc_insertion_point(field_get:nakama.api.ChannelMessage.channel_id)
  return channel_id_.GetNoArena();
}
inline void ChannelMessage::set_channel_id(const ::std::string& value) {
  
  channel_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.ChannelMessage.channel_id)
}
#if LANG_CXX11
inline void ChannelMessage::set_channel_id(::std::string&& value) {
  
  channel_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.ChannelMessage.channel_id)
}
#endif
inline void ChannelMessage::set_channel_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  channel_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.ChannelMessage.channel_id)
}
inline void ChannelMessage::set_channel_id(const char* value, size_t size) {
  
  channel_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.ChannelMessage.channel_id)
}
inline ::std::string* ChannelMessage::mutable_channel_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.ChannelMessage.channel_id)
  return channel_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChannelMessage::release_channel_id() {
  // @@protoc_insertion_point(field_release:nakama.api.ChannelMessage.channel_id)
  
  return channel_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChannelMessage::set_allocated_channel_id(::std::string* channel_id) {
  if (channel_id != NULL) {
    
  } else {
    
  }
  channel_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), channel_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ChannelMessage.channel_id)
}

// string message_id = 2;
inline void ChannelMessage::clear_message_id() {
  message_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChannelMessage::message_id() const {
  // @@protoc_insertion_point(field_get:nakama.api.ChannelMessage.message_id)
  return message_id_.GetNoArena();
}
inline void ChannelMessage::set_message_id(const ::std::string& value) {
  
  message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.ChannelMessage.message_id)
}
#if LANG_CXX11
inline void ChannelMessage::set_message_id(::std::string&& value) {
  
  message_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.ChannelMessage.message_id)
}
#endif
inline void ChannelMessage::set_message_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.ChannelMessage.message_id)
}
inline void ChannelMessage::set_message_id(const char* value, size_t size) {
  
  message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.ChannelMessage.message_id)
}
inline ::std::string* ChannelMessage::mutable_message_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.ChannelMessage.message_id)
  return message_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChannelMessage::release_message_id() {
  // @@protoc_insertion_point(field_release:nakama.api.ChannelMessage.message_id)
  
  return message_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChannelMessage::set_allocated_message_id(::std::string* message_id) {
  if (message_id != NULL) {
    
  } else {
    
  }
  message_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ChannelMessage.message_id)
}

// .google.protobuf.Int32Value code = 3;
inline bool ChannelMessage::has_code() const {
  return this != internal_default_instance() && code_ != NULL;
}
inline const ::google::protobuf::Int32Value& ChannelMessage::_internal_code() const {
  return *code_;
}
inline const ::google::protobuf::Int32Value& ChannelMessage::code() const {
  const ::google::protobuf::Int32Value* p = code_;
  // @@protoc_insertion_point(field_get:nakama.api.ChannelMessage.code)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* ChannelMessage::release_code() {
  // @@protoc_insertion_point(field_release:nakama.api.ChannelMessage.code)
  
  ::google::protobuf::Int32Value* temp = code_;
  code_ = NULL;
  return temp;
}
inline ::google::protobuf::Int32Value* ChannelMessage::mutable_code() {
  
  if (code_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    code_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.ChannelMessage.code)
  return code_;
}
inline void ChannelMessage::set_allocated_code(::google::protobuf::Int32Value* code) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(code_);
  }
  if (code) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(code)->GetArena();
    if (message_arena != submessage_arena) {
      code = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, code, submessage_arena);
    }
    
  } else {
    
  }
  code_ = code;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ChannelMessage.code)
}

// string sender_id = 4;
inline void ChannelMessage::clear_sender_id() {
  sender_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChannelMessage::sender_id() const {
  // @@protoc_insertion_point(field_get:nakama.api.ChannelMessage.sender_id)
  return sender_id_.GetNoArena();
}
inline void ChannelMessage::set_sender_id(const ::std::string& value) {
  
  sender_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.ChannelMessage.sender_id)
}
#if LANG_CXX11
inline void ChannelMessage::set_sender_id(::std::string&& value) {
  
  sender_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.ChannelMessage.sender_id)
}
#endif
inline void ChannelMessage::set_sender_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sender_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.ChannelMessage.sender_id)
}
inline void ChannelMessage::set_sender_id(const char* value, size_t size) {
  
  sender_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.ChannelMessage.sender_id)
}
inline ::std::string* ChannelMessage::mutable_sender_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.ChannelMessage.sender_id)
  return sender_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChannelMessage::release_sender_id() {
  // @@protoc_insertion_point(field_release:nakama.api.ChannelMessage.sender_id)
  
  return sender_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChannelMessage::set_allocated_sender_id(::std::string* sender_id) {
  if (sender_id != NULL) {
    
  } else {
    
  }
  sender_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sender_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ChannelMessage.sender_id)
}

// string username = 5;
inline void ChannelMessage::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChannelMessage::username() const {
  // @@protoc_insertion_point(field_get:nakama.api.ChannelMessage.username)
  return username_.GetNoArena();
}
inline void ChannelMessage::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.ChannelMessage.username)
}
#if LANG_CXX11
inline void ChannelMessage::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.ChannelMessage.username)
}
#endif
inline void ChannelMessage::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.ChannelMessage.username)
}
inline void ChannelMessage::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.ChannelMessage.username)
}
inline ::std::string* ChannelMessage::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.ChannelMessage.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChannelMessage::release_username() {
  // @@protoc_insertion_point(field_release:nakama.api.ChannelMessage.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChannelMessage::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ChannelMessage.username)
}

// string content = 6;
inline void ChannelMessage::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChannelMessage::content() const {
  // @@protoc_insertion_point(field_get:nakama.api.ChannelMessage.content)
  return content_.GetNoArena();
}
inline void ChannelMessage::set_content(const ::std::string& value) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.ChannelMessage.content)
}
#if LANG_CXX11
inline void ChannelMessage::set_content(::std::string&& value) {
  
  content_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.ChannelMessage.content)
}
#endif
inline void ChannelMessage::set_content(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.ChannelMessage.content)
}
inline void ChannelMessage::set_content(const char* value, size_t size) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.ChannelMessage.content)
}
inline ::std::string* ChannelMessage::mutable_content() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.ChannelMessage.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChannelMessage::release_content() {
  // @@protoc_insertion_point(field_release:nakama.api.ChannelMessage.content)
  
  return content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChannelMessage::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    
  } else {
    
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ChannelMessage.content)
}

// .google.protobuf.Timestamp create_time = 7;
inline bool ChannelMessage::has_create_time() const {
  return this != internal_default_instance() && create_time_ != NULL;
}
inline const ::google::protobuf::Timestamp& ChannelMessage::_internal_create_time() const {
  return *create_time_;
}
inline const ::google::protobuf::Timestamp& ChannelMessage::create_time() const {
  const ::google::protobuf::Timestamp* p = create_time_;
  // @@protoc_insertion_point(field_get:nakama.api.ChannelMessage.create_time)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* ChannelMessage::release_create_time() {
  // @@protoc_insertion_point(field_release:nakama.api.ChannelMessage.create_time)
  
  ::google::protobuf::Timestamp* temp = create_time_;
  create_time_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* ChannelMessage::mutable_create_time() {
  
  if (create_time_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    create_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.ChannelMessage.create_time)
  return create_time_;
}
inline void ChannelMessage::set_allocated_create_time(::google::protobuf::Timestamp* create_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(create_time_);
  }
  if (create_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(create_time)->GetArena();
    if (message_arena != submessage_arena) {
      create_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, create_time, submessage_arena);
    }
    
  } else {
    
  }
  create_time_ = create_time;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ChannelMessage.create_time)
}

// .google.protobuf.Timestamp update_time = 8;
inline bool ChannelMessage::has_update_time() const {
  return this != internal_default_instance() && update_time_ != NULL;
}
inline const ::google::protobuf::Timestamp& ChannelMessage::_internal_update_time() const {
  return *update_time_;
}
inline const ::google::protobuf::Timestamp& ChannelMessage::update_time() const {
  const ::google::protobuf::Timestamp* p = update_time_;
  // @@protoc_insertion_point(field_get:nakama.api.ChannelMessage.update_time)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* ChannelMessage::release_update_time() {
  // @@protoc_insertion_point(field_release:nakama.api.ChannelMessage.update_time)
  
  ::google::protobuf::Timestamp* temp = update_time_;
  update_time_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* ChannelMessage::mutable_update_time() {
  
  if (update_time_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    update_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.ChannelMessage.update_time)
  return update_time_;
}
inline void ChannelMessage::set_allocated_update_time(::google::protobuf::Timestamp* update_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(update_time_);
  }
  if (update_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(update_time)->GetArena();
    if (message_arena != submessage_arena) {
      update_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, update_time, submessage_arena);
    }
    
  } else {
    
  }
  update_time_ = update_time;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ChannelMessage.update_time)
}

// .google.protobuf.BoolValue persistent = 9;
inline bool ChannelMessage::has_persistent() const {
  return this != internal_default_instance() && persistent_ != NULL;
}
inline const ::google::protobuf::BoolValue& ChannelMessage::_internal_persistent() const {
  return *persistent_;
}
inline const ::google::protobuf::BoolValue& ChannelMessage::persistent() const {
  const ::google::protobuf::BoolValue* p = persistent_;
  // @@protoc_insertion_point(field_get:nakama.api.ChannelMessage.persistent)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::BoolValue*>(
      &::google::protobuf::_BoolValue_default_instance_);
}
inline ::google::protobuf::BoolValue* ChannelMessage::release_persistent() {
  // @@protoc_insertion_point(field_release:nakama.api.ChannelMessage.persistent)
  
  ::google::protobuf::BoolValue* temp = persistent_;
  persistent_ = NULL;
  return temp;
}
inline ::google::protobuf::BoolValue* ChannelMessage::mutable_persistent() {
  
  if (persistent_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::BoolValue>(GetArenaNoVirtual());
    persistent_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.ChannelMessage.persistent)
  return persistent_;
}
inline void ChannelMessage::set_allocated_persistent(::google::protobuf::BoolValue* persistent) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(persistent_);
  }
  if (persistent) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(persistent)->GetArena();
    if (message_arena != submessage_arena) {
      persistent = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, persistent, submessage_arena);
    }
    
  } else {
    
  }
  persistent_ = persistent;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ChannelMessage.persistent)
}

// -------------------------------------------------------------------

// ChannelMessageList

// repeated .nakama.api.ChannelMessage messages = 1;
inline int ChannelMessageList::messages_size() const {
  return messages_.size();
}
inline void ChannelMessageList::clear_messages() {
  messages_.Clear();
}
inline ::nakama::api::ChannelMessage* ChannelMessageList::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.api.ChannelMessageList.messages)
  return messages_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nakama::api::ChannelMessage >*
ChannelMessageList::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:nakama.api.ChannelMessageList.messages)
  return &messages_;
}
inline const ::nakama::api::ChannelMessage& ChannelMessageList::messages(int index) const {
  // @@protoc_insertion_point(field_get:nakama.api.ChannelMessageList.messages)
  return messages_.Get(index);
}
inline ::nakama::api::ChannelMessage* ChannelMessageList::add_messages() {
  // @@protoc_insertion_point(field_add:nakama.api.ChannelMessageList.messages)
  return messages_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nakama::api::ChannelMessage >&
ChannelMessageList::messages() const {
  // @@protoc_insertion_point(field_list:nakama.api.ChannelMessageList.messages)
  return messages_;
}

// string next_cursor = 2;
inline void ChannelMessageList::clear_next_cursor() {
  next_cursor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChannelMessageList::next_cursor() const {
  // @@protoc_insertion_point(field_get:nakama.api.ChannelMessageList.next_cursor)
  return next_cursor_.GetNoArena();
}
inline void ChannelMessageList::set_next_cursor(const ::std::string& value) {
  
  next_cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.ChannelMessageList.next_cursor)
}
#if LANG_CXX11
inline void ChannelMessageList::set_next_cursor(::std::string&& value) {
  
  next_cursor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.ChannelMessageList.next_cursor)
}
#endif
inline void ChannelMessageList::set_next_cursor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  next_cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.ChannelMessageList.next_cursor)
}
inline void ChannelMessageList::set_next_cursor(const char* value, size_t size) {
  
  next_cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.ChannelMessageList.next_cursor)
}
inline ::std::string* ChannelMessageList::mutable_next_cursor() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.ChannelMessageList.next_cursor)
  return next_cursor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChannelMessageList::release_next_cursor() {
  // @@protoc_insertion_point(field_release:nakama.api.ChannelMessageList.next_cursor)
  
  return next_cursor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChannelMessageList::set_allocated_next_cursor(::std::string* next_cursor) {
  if (next_cursor != NULL) {
    
  } else {
    
  }
  next_cursor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), next_cursor);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ChannelMessageList.next_cursor)
}

// string prev_cursor = 3;
inline void ChannelMessageList::clear_prev_cursor() {
  prev_cursor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChannelMessageList::prev_cursor() const {
  // @@protoc_insertion_point(field_get:nakama.api.ChannelMessageList.prev_cursor)
  return prev_cursor_.GetNoArena();
}
inline void ChannelMessageList::set_prev_cursor(const ::std::string& value) {
  
  prev_cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.ChannelMessageList.prev_cursor)
}
#if LANG_CXX11
inline void ChannelMessageList::set_prev_cursor(::std::string&& value) {
  
  prev_cursor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.ChannelMessageList.prev_cursor)
}
#endif
inline void ChannelMessageList::set_prev_cursor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  prev_cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.ChannelMessageList.prev_cursor)
}
inline void ChannelMessageList::set_prev_cursor(const char* value, size_t size) {
  
  prev_cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.ChannelMessageList.prev_cursor)
}
inline ::std::string* ChannelMessageList::mutable_prev_cursor() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.ChannelMessageList.prev_cursor)
  return prev_cursor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChannelMessageList::release_prev_cursor() {
  // @@protoc_insertion_point(field_release:nakama.api.ChannelMessageList.prev_cursor)
  
  return prev_cursor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChannelMessageList::set_allocated_prev_cursor(::std::string* prev_cursor) {
  if (prev_cursor != NULL) {
    
  } else {
    
  }
  prev_cursor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), prev_cursor);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ChannelMessageList.prev_cursor)
}

// -------------------------------------------------------------------

// CreateGroupRequest

// string name = 1;
inline void CreateGroupRequest::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateGroupRequest::name() const {
  // @@protoc_insertion_point(field_get:nakama.api.CreateGroupRequest.name)
  return name_.GetNoArena();
}
inline void CreateGroupRequest::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.CreateGroupRequest.name)
}
#if LANG_CXX11
inline void CreateGroupRequest::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.CreateGroupRequest.name)
}
#endif
inline void CreateGroupRequest::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.CreateGroupRequest.name)
}
inline void CreateGroupRequest::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.CreateGroupRequest.name)
}
inline ::std::string* CreateGroupRequest::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.CreateGroupRequest.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateGroupRequest::release_name() {
  // @@protoc_insertion_point(field_release:nakama.api.CreateGroupRequest.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateGroupRequest::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.CreateGroupRequest.name)
}

// string description = 2;
inline void CreateGroupRequest::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateGroupRequest::description() const {
  // @@protoc_insertion_point(field_get:nakama.api.CreateGroupRequest.description)
  return description_.GetNoArena();
}
inline void CreateGroupRequest::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.CreateGroupRequest.description)
}
#if LANG_CXX11
inline void CreateGroupRequest::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.CreateGroupRequest.description)
}
#endif
inline void CreateGroupRequest::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.CreateGroupRequest.description)
}
inline void CreateGroupRequest::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.CreateGroupRequest.description)
}
inline ::std::string* CreateGroupRequest::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.CreateGroupRequest.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateGroupRequest::release_description() {
  // @@protoc_insertion_point(field_release:nakama.api.CreateGroupRequest.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateGroupRequest::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.CreateGroupRequest.description)
}

// string lang_tag = 3;
inline void CreateGroupRequest::clear_lang_tag() {
  lang_tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateGroupRequest::lang_tag() const {
  // @@protoc_insertion_point(field_get:nakama.api.CreateGroupRequest.lang_tag)
  return lang_tag_.GetNoArena();
}
inline void CreateGroupRequest::set_lang_tag(const ::std::string& value) {
  
  lang_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.CreateGroupRequest.lang_tag)
}
#if LANG_CXX11
inline void CreateGroupRequest::set_lang_tag(::std::string&& value) {
  
  lang_tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.CreateGroupRequest.lang_tag)
}
#endif
inline void CreateGroupRequest::set_lang_tag(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  lang_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.CreateGroupRequest.lang_tag)
}
inline void CreateGroupRequest::set_lang_tag(const char* value, size_t size) {
  
  lang_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.CreateGroupRequest.lang_tag)
}
inline ::std::string* CreateGroupRequest::mutable_lang_tag() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.CreateGroupRequest.lang_tag)
  return lang_tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateGroupRequest::release_lang_tag() {
  // @@protoc_insertion_point(field_release:nakama.api.CreateGroupRequest.lang_tag)
  
  return lang_tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateGroupRequest::set_allocated_lang_tag(::std::string* lang_tag) {
  if (lang_tag != NULL) {
    
  } else {
    
  }
  lang_tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lang_tag);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.CreateGroupRequest.lang_tag)
}

// string avatar_url = 4;
inline void CreateGroupRequest::clear_avatar_url() {
  avatar_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateGroupRequest::avatar_url() const {
  // @@protoc_insertion_point(field_get:nakama.api.CreateGroupRequest.avatar_url)
  return avatar_url_.GetNoArena();
}
inline void CreateGroupRequest::set_avatar_url(const ::std::string& value) {
  
  avatar_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.CreateGroupRequest.avatar_url)
}
#if LANG_CXX11
inline void CreateGroupRequest::set_avatar_url(::std::string&& value) {
  
  avatar_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.CreateGroupRequest.avatar_url)
}
#endif
inline void CreateGroupRequest::set_avatar_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  avatar_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.CreateGroupRequest.avatar_url)
}
inline void CreateGroupRequest::set_avatar_url(const char* value, size_t size) {
  
  avatar_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.CreateGroupRequest.avatar_url)
}
inline ::std::string* CreateGroupRequest::mutable_avatar_url() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.CreateGroupRequest.avatar_url)
  return avatar_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateGroupRequest::release_avatar_url() {
  // @@protoc_insertion_point(field_release:nakama.api.CreateGroupRequest.avatar_url)
  
  return avatar_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateGroupRequest::set_allocated_avatar_url(::std::string* avatar_url) {
  if (avatar_url != NULL) {
    
  } else {
    
  }
  avatar_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), avatar_url);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.CreateGroupRequest.avatar_url)
}

// bool open = 5;
inline void CreateGroupRequest::clear_open() {
  open_ = false;
}
inline bool CreateGroupRequest::open() const {
  // @@protoc_insertion_point(field_get:nakama.api.CreateGroupRequest.open)
  return open_;
}
inline void CreateGroupRequest::set_open(bool value) {
  
  open_ = value;
  // @@protoc_insertion_point(field_set:nakama.api.CreateGroupRequest.open)
}

// -------------------------------------------------------------------

// DeleteFriendsRequest

// repeated string ids = 1;
inline int DeleteFriendsRequest::ids_size() const {
  return ids_.size();
}
inline void DeleteFriendsRequest::clear_ids() {
  ids_.Clear();
}
inline const ::std::string& DeleteFriendsRequest::ids(int index) const {
  // @@protoc_insertion_point(field_get:nakama.api.DeleteFriendsRequest.ids)
  return ids_.Get(index);
}
inline ::std::string* DeleteFriendsRequest::mutable_ids(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.api.DeleteFriendsRequest.ids)
  return ids_.Mutable(index);
}
inline void DeleteFriendsRequest::set_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:nakama.api.DeleteFriendsRequest.ids)
  ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void DeleteFriendsRequest::set_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:nakama.api.DeleteFriendsRequest.ids)
  ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void DeleteFriendsRequest::set_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nakama.api.DeleteFriendsRequest.ids)
}
inline void DeleteFriendsRequest::set_ids(int index, const char* value, size_t size) {
  ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nakama.api.DeleteFriendsRequest.ids)
}
inline ::std::string* DeleteFriendsRequest::add_ids() {
  // @@protoc_insertion_point(field_add_mutable:nakama.api.DeleteFriendsRequest.ids)
  return ids_.Add();
}
inline void DeleteFriendsRequest::add_ids(const ::std::string& value) {
  ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:nakama.api.DeleteFriendsRequest.ids)
}
#if LANG_CXX11
inline void DeleteFriendsRequest::add_ids(::std::string&& value) {
  ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:nakama.api.DeleteFriendsRequest.ids)
}
#endif
inline void DeleteFriendsRequest::add_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nakama.api.DeleteFriendsRequest.ids)
}
inline void DeleteFriendsRequest::add_ids(const char* value, size_t size) {
  ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nakama.api.DeleteFriendsRequest.ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DeleteFriendsRequest::ids() const {
  // @@protoc_insertion_point(field_list:nakama.api.DeleteFriendsRequest.ids)
  return ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DeleteFriendsRequest::mutable_ids() {
  // @@protoc_insertion_point(field_mutable_list:nakama.api.DeleteFriendsRequest.ids)
  return &ids_;
}

// repeated string usernames = 2;
inline int DeleteFriendsRequest::usernames_size() const {
  return usernames_.size();
}
inline void DeleteFriendsRequest::clear_usernames() {
  usernames_.Clear();
}
inline const ::std::string& DeleteFriendsRequest::usernames(int index) const {
  // @@protoc_insertion_point(field_get:nakama.api.DeleteFriendsRequest.usernames)
  return usernames_.Get(index);
}
inline ::std::string* DeleteFriendsRequest::mutable_usernames(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.api.DeleteFriendsRequest.usernames)
  return usernames_.Mutable(index);
}
inline void DeleteFriendsRequest::set_usernames(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:nakama.api.DeleteFriendsRequest.usernames)
  usernames_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void DeleteFriendsRequest::set_usernames(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:nakama.api.DeleteFriendsRequest.usernames)
  usernames_.Mutable(index)->assign(std::move(value));
}
#endif
inline void DeleteFriendsRequest::set_usernames(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  usernames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nakama.api.DeleteFriendsRequest.usernames)
}
inline void DeleteFriendsRequest::set_usernames(int index, const char* value, size_t size) {
  usernames_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nakama.api.DeleteFriendsRequest.usernames)
}
inline ::std::string* DeleteFriendsRequest::add_usernames() {
  // @@protoc_insertion_point(field_add_mutable:nakama.api.DeleteFriendsRequest.usernames)
  return usernames_.Add();
}
inline void DeleteFriendsRequest::add_usernames(const ::std::string& value) {
  usernames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:nakama.api.DeleteFriendsRequest.usernames)
}
#if LANG_CXX11
inline void DeleteFriendsRequest::add_usernames(::std::string&& value) {
  usernames_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:nakama.api.DeleteFriendsRequest.usernames)
}
#endif
inline void DeleteFriendsRequest::add_usernames(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  usernames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nakama.api.DeleteFriendsRequest.usernames)
}
inline void DeleteFriendsRequest::add_usernames(const char* value, size_t size) {
  usernames_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nakama.api.DeleteFriendsRequest.usernames)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DeleteFriendsRequest::usernames() const {
  // @@protoc_insertion_point(field_list:nakama.api.DeleteFriendsRequest.usernames)
  return usernames_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DeleteFriendsRequest::mutable_usernames() {
  // @@protoc_insertion_point(field_mutable_list:nakama.api.DeleteFriendsRequest.usernames)
  return &usernames_;
}

// -------------------------------------------------------------------

// DeleteGroupRequest

// string group_id = 1;
inline void DeleteGroupRequest::clear_group_id() {
  group_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeleteGroupRequest::group_id() const {
  // @@protoc_insertion_point(field_get:nakama.api.DeleteGroupRequest.group_id)
  return group_id_.GetNoArena();
}
inline void DeleteGroupRequest::set_group_id(const ::std::string& value) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.DeleteGroupRequest.group_id)
}
#if LANG_CXX11
inline void DeleteGroupRequest::set_group_id(::std::string&& value) {
  
  group_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.DeleteGroupRequest.group_id)
}
#endif
inline void DeleteGroupRequest::set_group_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.DeleteGroupRequest.group_id)
}
inline void DeleteGroupRequest::set_group_id(const char* value, size_t size) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.DeleteGroupRequest.group_id)
}
inline ::std::string* DeleteGroupRequest::mutable_group_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.DeleteGroupRequest.group_id)
  return group_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeleteGroupRequest::release_group_id() {
  // @@protoc_insertion_point(field_release:nakama.api.DeleteGroupRequest.group_id)
  
  return group_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeleteGroupRequest::set_allocated_group_id(::std::string* group_id) {
  if (group_id != NULL) {
    
  } else {
    
  }
  group_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), group_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.DeleteGroupRequest.group_id)
}

// -------------------------------------------------------------------

// DeleteLeaderboardRecordRequest

// string leaderboard_id = 1;
inline void DeleteLeaderboardRecordRequest::clear_leaderboard_id() {
  leaderboard_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeleteLeaderboardRecordRequest::leaderboard_id() const {
  // @@protoc_insertion_point(field_get:nakama.api.DeleteLeaderboardRecordRequest.leaderboard_id)
  return leaderboard_id_.GetNoArena();
}
inline void DeleteLeaderboardRecordRequest::set_leaderboard_id(const ::std::string& value) {
  
  leaderboard_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.DeleteLeaderboardRecordRequest.leaderboard_id)
}
#if LANG_CXX11
inline void DeleteLeaderboardRecordRequest::set_leaderboard_id(::std::string&& value) {
  
  leaderboard_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.DeleteLeaderboardRecordRequest.leaderboard_id)
}
#endif
inline void DeleteLeaderboardRecordRequest::set_leaderboard_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  leaderboard_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.DeleteLeaderboardRecordRequest.leaderboard_id)
}
inline void DeleteLeaderboardRecordRequest::set_leaderboard_id(const char* value, size_t size) {
  
  leaderboard_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.DeleteLeaderboardRecordRequest.leaderboard_id)
}
inline ::std::string* DeleteLeaderboardRecordRequest::mutable_leaderboard_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.DeleteLeaderboardRecordRequest.leaderboard_id)
  return leaderboard_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeleteLeaderboardRecordRequest::release_leaderboard_id() {
  // @@protoc_insertion_point(field_release:nakama.api.DeleteLeaderboardRecordRequest.leaderboard_id)
  
  return leaderboard_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeleteLeaderboardRecordRequest::set_allocated_leaderboard_id(::std::string* leaderboard_id) {
  if (leaderboard_id != NULL) {
    
  } else {
    
  }
  leaderboard_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), leaderboard_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.DeleteLeaderboardRecordRequest.leaderboard_id)
}

// -------------------------------------------------------------------

// DeleteNotificationsRequest

// repeated string ids = 1;
inline int DeleteNotificationsRequest::ids_size() const {
  return ids_.size();
}
inline void DeleteNotificationsRequest::clear_ids() {
  ids_.Clear();
}
inline const ::std::string& DeleteNotificationsRequest::ids(int index) const {
  // @@protoc_insertion_point(field_get:nakama.api.DeleteNotificationsRequest.ids)
  return ids_.Get(index);
}
inline ::std::string* DeleteNotificationsRequest::mutable_ids(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.api.DeleteNotificationsRequest.ids)
  return ids_.Mutable(index);
}
inline void DeleteNotificationsRequest::set_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:nakama.api.DeleteNotificationsRequest.ids)
  ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void DeleteNotificationsRequest::set_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:nakama.api.DeleteNotificationsRequest.ids)
  ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void DeleteNotificationsRequest::set_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nakama.api.DeleteNotificationsRequest.ids)
}
inline void DeleteNotificationsRequest::set_ids(int index, const char* value, size_t size) {
  ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nakama.api.DeleteNotificationsRequest.ids)
}
inline ::std::string* DeleteNotificationsRequest::add_ids() {
  // @@protoc_insertion_point(field_add_mutable:nakama.api.DeleteNotificationsRequest.ids)
  return ids_.Add();
}
inline void DeleteNotificationsRequest::add_ids(const ::std::string& value) {
  ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:nakama.api.DeleteNotificationsRequest.ids)
}
#if LANG_CXX11
inline void DeleteNotificationsRequest::add_ids(::std::string&& value) {
  ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:nakama.api.DeleteNotificationsRequest.ids)
}
#endif
inline void DeleteNotificationsRequest::add_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nakama.api.DeleteNotificationsRequest.ids)
}
inline void DeleteNotificationsRequest::add_ids(const char* value, size_t size) {
  ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nakama.api.DeleteNotificationsRequest.ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DeleteNotificationsRequest::ids() const {
  // @@protoc_insertion_point(field_list:nakama.api.DeleteNotificationsRequest.ids)
  return ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DeleteNotificationsRequest::mutable_ids() {
  // @@protoc_insertion_point(field_mutable_list:nakama.api.DeleteNotificationsRequest.ids)
  return &ids_;
}

// -------------------------------------------------------------------

// DeleteStorageObjectId

// string collection = 1;
inline void DeleteStorageObjectId::clear_collection() {
  collection_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeleteStorageObjectId::collection() const {
  // @@protoc_insertion_point(field_get:nakama.api.DeleteStorageObjectId.collection)
  return collection_.GetNoArena();
}
inline void DeleteStorageObjectId::set_collection(const ::std::string& value) {
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.DeleteStorageObjectId.collection)
}
#if LANG_CXX11
inline void DeleteStorageObjectId::set_collection(::std::string&& value) {
  
  collection_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.DeleteStorageObjectId.collection)
}
#endif
inline void DeleteStorageObjectId::set_collection(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.DeleteStorageObjectId.collection)
}
inline void DeleteStorageObjectId::set_collection(const char* value, size_t size) {
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.DeleteStorageObjectId.collection)
}
inline ::std::string* DeleteStorageObjectId::mutable_collection() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.DeleteStorageObjectId.collection)
  return collection_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeleteStorageObjectId::release_collection() {
  // @@protoc_insertion_point(field_release:nakama.api.DeleteStorageObjectId.collection)
  
  return collection_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeleteStorageObjectId::set_allocated_collection(::std::string* collection) {
  if (collection != NULL) {
    
  } else {
    
  }
  collection_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), collection);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.DeleteStorageObjectId.collection)
}

// string key = 2;
inline void DeleteStorageObjectId::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeleteStorageObjectId::key() const {
  // @@protoc_insertion_point(field_get:nakama.api.DeleteStorageObjectId.key)
  return key_.GetNoArena();
}
inline void DeleteStorageObjectId::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.DeleteStorageObjectId.key)
}
#if LANG_CXX11
inline void DeleteStorageObjectId::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.DeleteStorageObjectId.key)
}
#endif
inline void DeleteStorageObjectId::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.DeleteStorageObjectId.key)
}
inline void DeleteStorageObjectId::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.DeleteStorageObjectId.key)
}
inline ::std::string* DeleteStorageObjectId::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.DeleteStorageObjectId.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeleteStorageObjectId::release_key() {
  // @@protoc_insertion_point(field_release:nakama.api.DeleteStorageObjectId.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeleteStorageObjectId::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.DeleteStorageObjectId.key)
}

// string version = 3;
inline void DeleteStorageObjectId::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeleteStorageObjectId::version() const {
  // @@protoc_insertion_point(field_get:nakama.api.DeleteStorageObjectId.version)
  return version_.GetNoArena();
}
inline void DeleteStorageObjectId::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.DeleteStorageObjectId.version)
}
#if LANG_CXX11
inline void DeleteStorageObjectId::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.DeleteStorageObjectId.version)
}
#endif
inline void DeleteStorageObjectId::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.DeleteStorageObjectId.version)
}
inline void DeleteStorageObjectId::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.DeleteStorageObjectId.version)
}
inline ::std::string* DeleteStorageObjectId::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.DeleteStorageObjectId.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeleteStorageObjectId::release_version() {
  // @@protoc_insertion_point(field_release:nakama.api.DeleteStorageObjectId.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeleteStorageObjectId::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.DeleteStorageObjectId.version)
}

// -------------------------------------------------------------------

// DeleteStorageObjectsRequest

// repeated .nakama.api.DeleteStorageObjectId object_ids = 1;
inline int DeleteStorageObjectsRequest::object_ids_size() const {
  return object_ids_.size();
}
inline void DeleteStorageObjectsRequest::clear_object_ids() {
  object_ids_.Clear();
}
inline ::nakama::api::DeleteStorageObjectId* DeleteStorageObjectsRequest::mutable_object_ids(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.api.DeleteStorageObjectsRequest.object_ids)
  return object_ids_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nakama::api::DeleteStorageObjectId >*
DeleteStorageObjectsRequest::mutable_object_ids() {
  // @@protoc_insertion_point(field_mutable_list:nakama.api.DeleteStorageObjectsRequest.object_ids)
  return &object_ids_;
}
inline const ::nakama::api::DeleteStorageObjectId& DeleteStorageObjectsRequest::object_ids(int index) const {
  // @@protoc_insertion_point(field_get:nakama.api.DeleteStorageObjectsRequest.object_ids)
  return object_ids_.Get(index);
}
inline ::nakama::api::DeleteStorageObjectId* DeleteStorageObjectsRequest::add_object_ids() {
  // @@protoc_insertion_point(field_add:nakama.api.DeleteStorageObjectsRequest.object_ids)
  return object_ids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nakama::api::DeleteStorageObjectId >&
DeleteStorageObjectsRequest::object_ids() const {
  // @@protoc_insertion_point(field_list:nakama.api.DeleteStorageObjectsRequest.object_ids)
  return object_ids_;
}

// -------------------------------------------------------------------

// Friend

// .nakama.api.User user = 1;
inline bool Friend::has_user() const {
  return this != internal_default_instance() && user_ != NULL;
}
inline void Friend::clear_user() {
  if (GetArenaNoVirtual() == NULL && user_ != NULL) {
    delete user_;
  }
  user_ = NULL;
}
inline const ::nakama::api::User& Friend::_internal_user() const {
  return *user_;
}
inline const ::nakama::api::User& Friend::user() const {
  const ::nakama::api::User* p = user_;
  // @@protoc_insertion_point(field_get:nakama.api.Friend.user)
  return p != NULL ? *p : *reinterpret_cast<const ::nakama::api::User*>(
      &::nakama::api::_User_default_instance_);
}
inline ::nakama::api::User* Friend::release_user() {
  // @@protoc_insertion_point(field_release:nakama.api.Friend.user)
  
  ::nakama::api::User* temp = user_;
  user_ = NULL;
  return temp;
}
inline ::nakama::api::User* Friend::mutable_user() {
  
  if (user_ == NULL) {
    auto* p = CreateMaybeMessage<::nakama::api::User>(GetArenaNoVirtual());
    user_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.Friend.user)
  return user_;
}
inline void Friend::set_allocated_user(::nakama::api::User* user) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete user_;
  }
  if (user) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.Friend.user)
}

// .google.protobuf.Int32Value state = 2;
inline bool Friend::has_state() const {
  return this != internal_default_instance() && state_ != NULL;
}
inline const ::google::protobuf::Int32Value& Friend::_internal_state() const {
  return *state_;
}
inline const ::google::protobuf::Int32Value& Friend::state() const {
  const ::google::protobuf::Int32Value* p = state_;
  // @@protoc_insertion_point(field_get:nakama.api.Friend.state)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* Friend::release_state() {
  // @@protoc_insertion_point(field_release:nakama.api.Friend.state)
  
  ::google::protobuf::Int32Value* temp = state_;
  state_ = NULL;
  return temp;
}
inline ::google::protobuf::Int32Value* Friend::mutable_state() {
  
  if (state_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    state_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.Friend.state)
  return state_;
}
inline void Friend::set_allocated_state(::google::protobuf::Int32Value* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(state_);
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(state)->GetArena();
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.Friend.state)
}

// -------------------------------------------------------------------

// Friends

// repeated .nakama.api.Friend friends = 1;
inline int Friends::friends_size() const {
  return friends_.size();
}
inline void Friends::clear_friends() {
  friends_.Clear();
}
inline ::nakama::api::Friend* Friends::mutable_friends(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.api.Friends.friends)
  return friends_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nakama::api::Friend >*
Friends::mutable_friends() {
  // @@protoc_insertion_point(field_mutable_list:nakama.api.Friends.friends)
  return &friends_;
}
inline const ::nakama::api::Friend& Friends::friends(int index) const {
  // @@protoc_insertion_point(field_get:nakama.api.Friends.friends)
  return friends_.Get(index);
}
inline ::nakama::api::Friend* Friends::add_friends() {
  // @@protoc_insertion_point(field_add:nakama.api.Friends.friends)
  return friends_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nakama::api::Friend >&
Friends::friends() const {
  // @@protoc_insertion_point(field_list:nakama.api.Friends.friends)
  return friends_;
}

// -------------------------------------------------------------------

// GetUsersRequest

// repeated string ids = 1;
inline int GetUsersRequest::ids_size() const {
  return ids_.size();
}
inline void GetUsersRequest::clear_ids() {
  ids_.Clear();
}
inline const ::std::string& GetUsersRequest::ids(int index) const {
  // @@protoc_insertion_point(field_get:nakama.api.GetUsersRequest.ids)
  return ids_.Get(index);
}
inline ::std::string* GetUsersRequest::mutable_ids(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.api.GetUsersRequest.ids)
  return ids_.Mutable(index);
}
inline void GetUsersRequest::set_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:nakama.api.GetUsersRequest.ids)
  ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void GetUsersRequest::set_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:nakama.api.GetUsersRequest.ids)
  ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void GetUsersRequest::set_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nakama.api.GetUsersRequest.ids)
}
inline void GetUsersRequest::set_ids(int index, const char* value, size_t size) {
  ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nakama.api.GetUsersRequest.ids)
}
inline ::std::string* GetUsersRequest::add_ids() {
  // @@protoc_insertion_point(field_add_mutable:nakama.api.GetUsersRequest.ids)
  return ids_.Add();
}
inline void GetUsersRequest::add_ids(const ::std::string& value) {
  ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:nakama.api.GetUsersRequest.ids)
}
#if LANG_CXX11
inline void GetUsersRequest::add_ids(::std::string&& value) {
  ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:nakama.api.GetUsersRequest.ids)
}
#endif
inline void GetUsersRequest::add_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nakama.api.GetUsersRequest.ids)
}
inline void GetUsersRequest::add_ids(const char* value, size_t size) {
  ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nakama.api.GetUsersRequest.ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetUsersRequest::ids() const {
  // @@protoc_insertion_point(field_list:nakama.api.GetUsersRequest.ids)
  return ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetUsersRequest::mutable_ids() {
  // @@protoc_insertion_point(field_mutable_list:nakama.api.GetUsersRequest.ids)
  return &ids_;
}

// repeated string usernames = 2;
inline int GetUsersRequest::usernames_size() const {
  return usernames_.size();
}
inline void GetUsersRequest::clear_usernames() {
  usernames_.Clear();
}
inline const ::std::string& GetUsersRequest::usernames(int index) const {
  // @@protoc_insertion_point(field_get:nakama.api.GetUsersRequest.usernames)
  return usernames_.Get(index);
}
inline ::std::string* GetUsersRequest::mutable_usernames(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.api.GetUsersRequest.usernames)
  return usernames_.Mutable(index);
}
inline void GetUsersRequest::set_usernames(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:nakama.api.GetUsersRequest.usernames)
  usernames_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void GetUsersRequest::set_usernames(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:nakama.api.GetUsersRequest.usernames)
  usernames_.Mutable(index)->assign(std::move(value));
}
#endif
inline void GetUsersRequest::set_usernames(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  usernames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nakama.api.GetUsersRequest.usernames)
}
inline void GetUsersRequest::set_usernames(int index, const char* value, size_t size) {
  usernames_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nakama.api.GetUsersRequest.usernames)
}
inline ::std::string* GetUsersRequest::add_usernames() {
  // @@protoc_insertion_point(field_add_mutable:nakama.api.GetUsersRequest.usernames)
  return usernames_.Add();
}
inline void GetUsersRequest::add_usernames(const ::std::string& value) {
  usernames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:nakama.api.GetUsersRequest.usernames)
}
#if LANG_CXX11
inline void GetUsersRequest::add_usernames(::std::string&& value) {
  usernames_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:nakama.api.GetUsersRequest.usernames)
}
#endif
inline void GetUsersRequest::add_usernames(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  usernames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nakama.api.GetUsersRequest.usernames)
}
inline void GetUsersRequest::add_usernames(const char* value, size_t size) {
  usernames_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nakama.api.GetUsersRequest.usernames)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetUsersRequest::usernames() const {
  // @@protoc_insertion_point(field_list:nakama.api.GetUsersRequest.usernames)
  return usernames_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetUsersRequest::mutable_usernames() {
  // @@protoc_insertion_point(field_mutable_list:nakama.api.GetUsersRequest.usernames)
  return &usernames_;
}

// repeated string facebook_ids = 3;
inline int GetUsersRequest::facebook_ids_size() const {
  return facebook_ids_.size();
}
inline void GetUsersRequest::clear_facebook_ids() {
  facebook_ids_.Clear();
}
inline const ::std::string& GetUsersRequest::facebook_ids(int index) const {
  // @@protoc_insertion_point(field_get:nakama.api.GetUsersRequest.facebook_ids)
  return facebook_ids_.Get(index);
}
inline ::std::string* GetUsersRequest::mutable_facebook_ids(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.api.GetUsersRequest.facebook_ids)
  return facebook_ids_.Mutable(index);
}
inline void GetUsersRequest::set_facebook_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:nakama.api.GetUsersRequest.facebook_ids)
  facebook_ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void GetUsersRequest::set_facebook_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:nakama.api.GetUsersRequest.facebook_ids)
  facebook_ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void GetUsersRequest::set_facebook_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  facebook_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nakama.api.GetUsersRequest.facebook_ids)
}
inline void GetUsersRequest::set_facebook_ids(int index, const char* value, size_t size) {
  facebook_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nakama.api.GetUsersRequest.facebook_ids)
}
inline ::std::string* GetUsersRequest::add_facebook_ids() {
  // @@protoc_insertion_point(field_add_mutable:nakama.api.GetUsersRequest.facebook_ids)
  return facebook_ids_.Add();
}
inline void GetUsersRequest::add_facebook_ids(const ::std::string& value) {
  facebook_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:nakama.api.GetUsersRequest.facebook_ids)
}
#if LANG_CXX11
inline void GetUsersRequest::add_facebook_ids(::std::string&& value) {
  facebook_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:nakama.api.GetUsersRequest.facebook_ids)
}
#endif
inline void GetUsersRequest::add_facebook_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  facebook_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nakama.api.GetUsersRequest.facebook_ids)
}
inline void GetUsersRequest::add_facebook_ids(const char* value, size_t size) {
  facebook_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nakama.api.GetUsersRequest.facebook_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetUsersRequest::facebook_ids() const {
  // @@protoc_insertion_point(field_list:nakama.api.GetUsersRequest.facebook_ids)
  return facebook_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetUsersRequest::mutable_facebook_ids() {
  // @@protoc_insertion_point(field_mutable_list:nakama.api.GetUsersRequest.facebook_ids)
  return &facebook_ids_;
}

// -------------------------------------------------------------------

// Group

// string id = 1;
inline void Group::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Group::id() const {
  // @@protoc_insertion_point(field_get:nakama.api.Group.id)
  return id_.GetNoArena();
}
inline void Group::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.Group.id)
}
#if LANG_CXX11
inline void Group::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.Group.id)
}
#endif
inline void Group::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.Group.id)
}
inline void Group::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.Group.id)
}
inline ::std::string* Group::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.Group.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Group::release_id() {
  // @@protoc_insertion_point(field_release:nakama.api.Group.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Group::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.Group.id)
}

// string creator_id = 2;
inline void Group::clear_creator_id() {
  creator_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Group::creator_id() const {
  // @@protoc_insertion_point(field_get:nakama.api.Group.creator_id)
  return creator_id_.GetNoArena();
}
inline void Group::set_creator_id(const ::std::string& value) {
  
  creator_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.Group.creator_id)
}
#if LANG_CXX11
inline void Group::set_creator_id(::std::string&& value) {
  
  creator_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.Group.creator_id)
}
#endif
inline void Group::set_creator_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  creator_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.Group.creator_id)
}
inline void Group::set_creator_id(const char* value, size_t size) {
  
  creator_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.Group.creator_id)
}
inline ::std::string* Group::mutable_creator_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.Group.creator_id)
  return creator_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Group::release_creator_id() {
  // @@protoc_insertion_point(field_release:nakama.api.Group.creator_id)
  
  return creator_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Group::set_allocated_creator_id(::std::string* creator_id) {
  if (creator_id != NULL) {
    
  } else {
    
  }
  creator_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), creator_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.Group.creator_id)
}

// string name = 3;
inline void Group::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Group::name() const {
  // @@protoc_insertion_point(field_get:nakama.api.Group.name)
  return name_.GetNoArena();
}
inline void Group::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.Group.name)
}
#if LANG_CXX11
inline void Group::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.Group.name)
}
#endif
inline void Group::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.Group.name)
}
inline void Group::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.Group.name)
}
inline ::std::string* Group::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.Group.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Group::release_name() {
  // @@protoc_insertion_point(field_release:nakama.api.Group.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Group::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.Group.name)
}

// string description = 4;
inline void Group::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Group::description() const {
  // @@protoc_insertion_point(field_get:nakama.api.Group.description)
  return description_.GetNoArena();
}
inline void Group::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.Group.description)
}
#if LANG_CXX11
inline void Group::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.Group.description)
}
#endif
inline void Group::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.Group.description)
}
inline void Group::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.Group.description)
}
inline ::std::string* Group::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.Group.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Group::release_description() {
  // @@protoc_insertion_point(field_release:nakama.api.Group.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Group::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.Group.description)
}

// string lang_tag = 5;
inline void Group::clear_lang_tag() {
  lang_tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Group::lang_tag() const {
  // @@protoc_insertion_point(field_get:nakama.api.Group.lang_tag)
  return lang_tag_.GetNoArena();
}
inline void Group::set_lang_tag(const ::std::string& value) {
  
  lang_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.Group.lang_tag)
}
#if LANG_CXX11
inline void Group::set_lang_tag(::std::string&& value) {
  
  lang_tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.Group.lang_tag)
}
#endif
inline void Group::set_lang_tag(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  lang_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.Group.lang_tag)
}
inline void Group::set_lang_tag(const char* value, size_t size) {
  
  lang_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.Group.lang_tag)
}
inline ::std::string* Group::mutable_lang_tag() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.Group.lang_tag)
  return lang_tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Group::release_lang_tag() {
  // @@protoc_insertion_point(field_release:nakama.api.Group.lang_tag)
  
  return lang_tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Group::set_allocated_lang_tag(::std::string* lang_tag) {
  if (lang_tag != NULL) {
    
  } else {
    
  }
  lang_tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lang_tag);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.Group.lang_tag)
}

// string metadata = 6;
inline void Group::clear_metadata() {
  metadata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Group::metadata() const {
  // @@protoc_insertion_point(field_get:nakama.api.Group.metadata)
  return metadata_.GetNoArena();
}
inline void Group::set_metadata(const ::std::string& value) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.Group.metadata)
}
#if LANG_CXX11
inline void Group::set_metadata(::std::string&& value) {
  
  metadata_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.Group.metadata)
}
#endif
inline void Group::set_metadata(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.Group.metadata)
}
inline void Group::set_metadata(const char* value, size_t size) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.Group.metadata)
}
inline ::std::string* Group::mutable_metadata() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.Group.metadata)
  return metadata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Group::release_metadata() {
  // @@protoc_insertion_point(field_release:nakama.api.Group.metadata)
  
  return metadata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Group::set_allocated_metadata(::std::string* metadata) {
  if (metadata != NULL) {
    
  } else {
    
  }
  metadata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), metadata);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.Group.metadata)
}

// string avatar_url = 7;
inline void Group::clear_avatar_url() {
  avatar_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Group::avatar_url() const {
  // @@protoc_insertion_point(field_get:nakama.api.Group.avatar_url)
  return avatar_url_.GetNoArena();
}
inline void Group::set_avatar_url(const ::std::string& value) {
  
  avatar_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.Group.avatar_url)
}
#if LANG_CXX11
inline void Group::set_avatar_url(::std::string&& value) {
  
  avatar_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.Group.avatar_url)
}
#endif
inline void Group::set_avatar_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  avatar_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.Group.avatar_url)
}
inline void Group::set_avatar_url(const char* value, size_t size) {
  
  avatar_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.Group.avatar_url)
}
inline ::std::string* Group::mutable_avatar_url() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.Group.avatar_url)
  return avatar_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Group::release_avatar_url() {
  // @@protoc_insertion_point(field_release:nakama.api.Group.avatar_url)
  
  return avatar_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Group::set_allocated_avatar_url(::std::string* avatar_url) {
  if (avatar_url != NULL) {
    
  } else {
    
  }
  avatar_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), avatar_url);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.Group.avatar_url)
}

// .google.protobuf.BoolValue open = 8;
inline bool Group::has_open() const {
  return this != internal_default_instance() && open_ != NULL;
}
inline const ::google::protobuf::BoolValue& Group::_internal_open() const {
  return *open_;
}
inline const ::google::protobuf::BoolValue& Group::open() const {
  const ::google::protobuf::BoolValue* p = open_;
  // @@protoc_insertion_point(field_get:nakama.api.Group.open)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::BoolValue*>(
      &::google::protobuf::_BoolValue_default_instance_);
}
inline ::google::protobuf::BoolValue* Group::release_open() {
  // @@protoc_insertion_point(field_release:nakama.api.Group.open)
  
  ::google::protobuf::BoolValue* temp = open_;
  open_ = NULL;
  return temp;
}
inline ::google::protobuf::BoolValue* Group::mutable_open() {
  
  if (open_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::BoolValue>(GetArenaNoVirtual());
    open_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.Group.open)
  return open_;
}
inline void Group::set_allocated_open(::google::protobuf::BoolValue* open) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(open_);
  }
  if (open) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(open)->GetArena();
    if (message_arena != submessage_arena) {
      open = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, open, submessage_arena);
    }
    
  } else {
    
  }
  open_ = open;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.Group.open)
}

// int32 edge_count = 9;
inline void Group::clear_edge_count() {
  edge_count_ = 0;
}
inline ::google::protobuf::int32 Group::edge_count() const {
  // @@protoc_insertion_point(field_get:nakama.api.Group.edge_count)
  return edge_count_;
}
inline void Group::set_edge_count(::google::protobuf::int32 value) {
  
  edge_count_ = value;
  // @@protoc_insertion_point(field_set:nakama.api.Group.edge_count)
}

// int32 max_count = 10;
inline void Group::clear_max_count() {
  max_count_ = 0;
}
inline ::google::protobuf::int32 Group::max_count() const {
  // @@protoc_insertion_point(field_get:nakama.api.Group.max_count)
  return max_count_;
}
inline void Group::set_max_count(::google::protobuf::int32 value) {
  
  max_count_ = value;
  // @@protoc_insertion_point(field_set:nakama.api.Group.max_count)
}

// .google.protobuf.Timestamp create_time = 11;
inline bool Group::has_create_time() const {
  return this != internal_default_instance() && create_time_ != NULL;
}
inline const ::google::protobuf::Timestamp& Group::_internal_create_time() const {
  return *create_time_;
}
inline const ::google::protobuf::Timestamp& Group::create_time() const {
  const ::google::protobuf::Timestamp* p = create_time_;
  // @@protoc_insertion_point(field_get:nakama.api.Group.create_time)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* Group::release_create_time() {
  // @@protoc_insertion_point(field_release:nakama.api.Group.create_time)
  
  ::google::protobuf::Timestamp* temp = create_time_;
  create_time_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* Group::mutable_create_time() {
  
  if (create_time_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    create_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.Group.create_time)
  return create_time_;
}
inline void Group::set_allocated_create_time(::google::protobuf::Timestamp* create_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(create_time_);
  }
  if (create_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(create_time)->GetArena();
    if (message_arena != submessage_arena) {
      create_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, create_time, submessage_arena);
    }
    
  } else {
    
  }
  create_time_ = create_time;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.Group.create_time)
}

// .google.protobuf.Timestamp update_time = 12;
inline bool Group::has_update_time() const {
  return this != internal_default_instance() && update_time_ != NULL;
}
inline const ::google::protobuf::Timestamp& Group::_internal_update_time() const {
  return *update_time_;
}
inline const ::google::protobuf::Timestamp& Group::update_time() const {
  const ::google::protobuf::Timestamp* p = update_time_;
  // @@protoc_insertion_point(field_get:nakama.api.Group.update_time)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* Group::release_update_time() {
  // @@protoc_insertion_point(field_release:nakama.api.Group.update_time)
  
  ::google::protobuf::Timestamp* temp = update_time_;
  update_time_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* Group::mutable_update_time() {
  
  if (update_time_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    update_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.Group.update_time)
  return update_time_;
}
inline void Group::set_allocated_update_time(::google::protobuf::Timestamp* update_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(update_time_);
  }
  if (update_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(update_time)->GetArena();
    if (message_arena != submessage_arena) {
      update_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, update_time, submessage_arena);
    }
    
  } else {
    
  }
  update_time_ = update_time;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.Group.update_time)
}

// -------------------------------------------------------------------

// GroupList

// repeated .nakama.api.Group groups = 1;
inline int GroupList::groups_size() const {
  return groups_.size();
}
inline void GroupList::clear_groups() {
  groups_.Clear();
}
inline ::nakama::api::Group* GroupList::mutable_groups(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.api.GroupList.groups)
  return groups_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nakama::api::Group >*
GroupList::mutable_groups() {
  // @@protoc_insertion_point(field_mutable_list:nakama.api.GroupList.groups)
  return &groups_;
}
inline const ::nakama::api::Group& GroupList::groups(int index) const {
  // @@protoc_insertion_point(field_get:nakama.api.GroupList.groups)
  return groups_.Get(index);
}
inline ::nakama::api::Group* GroupList::add_groups() {
  // @@protoc_insertion_point(field_add:nakama.api.GroupList.groups)
  return groups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nakama::api::Group >&
GroupList::groups() const {
  // @@protoc_insertion_point(field_list:nakama.api.GroupList.groups)
  return groups_;
}

// string cursor = 2;
inline void GroupList::clear_cursor() {
  cursor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GroupList::cursor() const {
  // @@protoc_insertion_point(field_get:nakama.api.GroupList.cursor)
  return cursor_.GetNoArena();
}
inline void GroupList::set_cursor(const ::std::string& value) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.GroupList.cursor)
}
#if LANG_CXX11
inline void GroupList::set_cursor(::std::string&& value) {
  
  cursor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.GroupList.cursor)
}
#endif
inline void GroupList::set_cursor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.GroupList.cursor)
}
inline void GroupList::set_cursor(const char* value, size_t size) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.GroupList.cursor)
}
inline ::std::string* GroupList::mutable_cursor() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.GroupList.cursor)
  return cursor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GroupList::release_cursor() {
  // @@protoc_insertion_point(field_release:nakama.api.GroupList.cursor)
  
  return cursor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GroupList::set_allocated_cursor(::std::string* cursor) {
  if (cursor != NULL) {
    
  } else {
    
  }
  cursor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cursor);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.GroupList.cursor)
}

// -------------------------------------------------------------------

// GroupUserList_GroupUser

// .nakama.api.User user = 1;
inline bool GroupUserList_GroupUser::has_user() const {
  return this != internal_default_instance() && user_ != NULL;
}
inline void GroupUserList_GroupUser::clear_user() {
  if (GetArenaNoVirtual() == NULL && user_ != NULL) {
    delete user_;
  }
  user_ = NULL;
}
inline const ::nakama::api::User& GroupUserList_GroupUser::_internal_user() const {
  return *user_;
}
inline const ::nakama::api::User& GroupUserList_GroupUser::user() const {
  const ::nakama::api::User* p = user_;
  // @@protoc_insertion_point(field_get:nakama.api.GroupUserList.GroupUser.user)
  return p != NULL ? *p : *reinterpret_cast<const ::nakama::api::User*>(
      &::nakama::api::_User_default_instance_);
}
inline ::nakama::api::User* GroupUserList_GroupUser::release_user() {
  // @@protoc_insertion_point(field_release:nakama.api.GroupUserList.GroupUser.user)
  
  ::nakama::api::User* temp = user_;
  user_ = NULL;
  return temp;
}
inline ::nakama::api::User* GroupUserList_GroupUser::mutable_user() {
  
  if (user_ == NULL) {
    auto* p = CreateMaybeMessage<::nakama::api::User>(GetArenaNoVirtual());
    user_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.GroupUserList.GroupUser.user)
  return user_;
}
inline void GroupUserList_GroupUser::set_allocated_user(::nakama::api::User* user) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete user_;
  }
  if (user) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.GroupUserList.GroupUser.user)
}

// .google.protobuf.Int32Value state = 2;
inline bool GroupUserList_GroupUser::has_state() const {
  return this != internal_default_instance() && state_ != NULL;
}
inline const ::google::protobuf::Int32Value& GroupUserList_GroupUser::_internal_state() const {
  return *state_;
}
inline const ::google::protobuf::Int32Value& GroupUserList_GroupUser::state() const {
  const ::google::protobuf::Int32Value* p = state_;
  // @@protoc_insertion_point(field_get:nakama.api.GroupUserList.GroupUser.state)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* GroupUserList_GroupUser::release_state() {
  // @@protoc_insertion_point(field_release:nakama.api.GroupUserList.GroupUser.state)
  
  ::google::protobuf::Int32Value* temp = state_;
  state_ = NULL;
  return temp;
}
inline ::google::protobuf::Int32Value* GroupUserList_GroupUser::mutable_state() {
  
  if (state_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    state_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.GroupUserList.GroupUser.state)
  return state_;
}
inline void GroupUserList_GroupUser::set_allocated_state(::google::protobuf::Int32Value* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(state_);
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(state)->GetArena();
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.GroupUserList.GroupUser.state)
}

// -------------------------------------------------------------------

// GroupUserList

// repeated .nakama.api.GroupUserList.GroupUser group_users = 1;
inline int GroupUserList::group_users_size() const {
  return group_users_.size();
}
inline void GroupUserList::clear_group_users() {
  group_users_.Clear();
}
inline ::nakama::api::GroupUserList_GroupUser* GroupUserList::mutable_group_users(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.api.GroupUserList.group_users)
  return group_users_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nakama::api::GroupUserList_GroupUser >*
GroupUserList::mutable_group_users() {
  // @@protoc_insertion_point(field_mutable_list:nakama.api.GroupUserList.group_users)
  return &group_users_;
}
inline const ::nakama::api::GroupUserList_GroupUser& GroupUserList::group_users(int index) const {
  // @@protoc_insertion_point(field_get:nakama.api.GroupUserList.group_users)
  return group_users_.Get(index);
}
inline ::nakama::api::GroupUserList_GroupUser* GroupUserList::add_group_users() {
  // @@protoc_insertion_point(field_add:nakama.api.GroupUserList.group_users)
  return group_users_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nakama::api::GroupUserList_GroupUser >&
GroupUserList::group_users() const {
  // @@protoc_insertion_point(field_list:nakama.api.GroupUserList.group_users)
  return group_users_;
}

// -------------------------------------------------------------------

// ImportFacebookFriendsRequest

// .nakama.api.AccountFacebook account = 1;
inline bool ImportFacebookFriendsRequest::has_account() const {
  return this != internal_default_instance() && account_ != NULL;
}
inline void ImportFacebookFriendsRequest::clear_account() {
  if (GetArenaNoVirtual() == NULL && account_ != NULL) {
    delete account_;
  }
  account_ = NULL;
}
inline const ::nakama::api::AccountFacebook& ImportFacebookFriendsRequest::_internal_account() const {
  return *account_;
}
inline const ::nakama::api::AccountFacebook& ImportFacebookFriendsRequest::account() const {
  const ::nakama::api::AccountFacebook* p = account_;
  // @@protoc_insertion_point(field_get:nakama.api.ImportFacebookFriendsRequest.account)
  return p != NULL ? *p : *reinterpret_cast<const ::nakama::api::AccountFacebook*>(
      &::nakama::api::_AccountFacebook_default_instance_);
}
inline ::nakama::api::AccountFacebook* ImportFacebookFriendsRequest::release_account() {
  // @@protoc_insertion_point(field_release:nakama.api.ImportFacebookFriendsRequest.account)
  
  ::nakama::api::AccountFacebook* temp = account_;
  account_ = NULL;
  return temp;
}
inline ::nakama::api::AccountFacebook* ImportFacebookFriendsRequest::mutable_account() {
  
  if (account_ == NULL) {
    auto* p = CreateMaybeMessage<::nakama::api::AccountFacebook>(GetArenaNoVirtual());
    account_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.ImportFacebookFriendsRequest.account)
  return account_;
}
inline void ImportFacebookFriendsRequest::set_allocated_account(::nakama::api::AccountFacebook* account) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete account_;
  }
  if (account) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      account = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, account, submessage_arena);
    }
    
  } else {
    
  }
  account_ = account;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ImportFacebookFriendsRequest.account)
}

// .google.protobuf.BoolValue reset = 2;
inline bool ImportFacebookFriendsRequest::has_reset() const {
  return this != internal_default_instance() && reset_ != NULL;
}
inline const ::google::protobuf::BoolValue& ImportFacebookFriendsRequest::_internal_reset() const {
  return *reset_;
}
inline const ::google::protobuf::BoolValue& ImportFacebookFriendsRequest::reset() const {
  const ::google::protobuf::BoolValue* p = reset_;
  // @@protoc_insertion_point(field_get:nakama.api.ImportFacebookFriendsRequest.reset)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::BoolValue*>(
      &::google::protobuf::_BoolValue_default_instance_);
}
inline ::google::protobuf::BoolValue* ImportFacebookFriendsRequest::release_reset() {
  // @@protoc_insertion_point(field_release:nakama.api.ImportFacebookFriendsRequest.reset)
  
  ::google::protobuf::BoolValue* temp = reset_;
  reset_ = NULL;
  return temp;
}
inline ::google::protobuf::BoolValue* ImportFacebookFriendsRequest::mutable_reset() {
  
  if (reset_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::BoolValue>(GetArenaNoVirtual());
    reset_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.ImportFacebookFriendsRequest.reset)
  return reset_;
}
inline void ImportFacebookFriendsRequest::set_allocated_reset(::google::protobuf::BoolValue* reset) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(reset_);
  }
  if (reset) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(reset)->GetArena();
    if (message_arena != submessage_arena) {
      reset = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reset, submessage_arena);
    }
    
  } else {
    
  }
  reset_ = reset;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ImportFacebookFriendsRequest.reset)
}

// -------------------------------------------------------------------

// JoinGroupRequest

// string group_id = 1;
inline void JoinGroupRequest::clear_group_id() {
  group_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& JoinGroupRequest::group_id() const {
  // @@protoc_insertion_point(field_get:nakama.api.JoinGroupRequest.group_id)
  return group_id_.GetNoArena();
}
inline void JoinGroupRequest::set_group_id(const ::std::string& value) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.JoinGroupRequest.group_id)
}
#if LANG_CXX11
inline void JoinGroupRequest::set_group_id(::std::string&& value) {
  
  group_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.JoinGroupRequest.group_id)
}
#endif
inline void JoinGroupRequest::set_group_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.JoinGroupRequest.group_id)
}
inline void JoinGroupRequest::set_group_id(const char* value, size_t size) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.JoinGroupRequest.group_id)
}
inline ::std::string* JoinGroupRequest::mutable_group_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.JoinGroupRequest.group_id)
  return group_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JoinGroupRequest::release_group_id() {
  // @@protoc_insertion_point(field_release:nakama.api.JoinGroupRequest.group_id)
  
  return group_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JoinGroupRequest::set_allocated_group_id(::std::string* group_id) {
  if (group_id != NULL) {
    
  } else {
    
  }
  group_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), group_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.JoinGroupRequest.group_id)
}

// -------------------------------------------------------------------

// JoinTournamentRequest

// string tournament_id = 1;
inline void JoinTournamentRequest::clear_tournament_id() {
  tournament_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& JoinTournamentRequest::tournament_id() const {
  // @@protoc_insertion_point(field_get:nakama.api.JoinTournamentRequest.tournament_id)
  return tournament_id_.GetNoArena();
}
inline void JoinTournamentRequest::set_tournament_id(const ::std::string& value) {
  
  tournament_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.JoinTournamentRequest.tournament_id)
}
#if LANG_CXX11
inline void JoinTournamentRequest::set_tournament_id(::std::string&& value) {
  
  tournament_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.JoinTournamentRequest.tournament_id)
}
#endif
inline void JoinTournamentRequest::set_tournament_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tournament_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.JoinTournamentRequest.tournament_id)
}
inline void JoinTournamentRequest::set_tournament_id(const char* value, size_t size) {
  
  tournament_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.JoinTournamentRequest.tournament_id)
}
inline ::std::string* JoinTournamentRequest::mutable_tournament_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.JoinTournamentRequest.tournament_id)
  return tournament_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JoinTournamentRequest::release_tournament_id() {
  // @@protoc_insertion_point(field_release:nakama.api.JoinTournamentRequest.tournament_id)
  
  return tournament_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JoinTournamentRequest::set_allocated_tournament_id(::std::string* tournament_id) {
  if (tournament_id != NULL) {
    
  } else {
    
  }
  tournament_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tournament_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.JoinTournamentRequest.tournament_id)
}

// -------------------------------------------------------------------

// KickGroupUsersRequest

// string group_id = 1;
inline void KickGroupUsersRequest::clear_group_id() {
  group_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KickGroupUsersRequest::group_id() const {
  // @@protoc_insertion_point(field_get:nakama.api.KickGroupUsersRequest.group_id)
  return group_id_.GetNoArena();
}
inline void KickGroupUsersRequest::set_group_id(const ::std::string& value) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.KickGroupUsersRequest.group_id)
}
#if LANG_CXX11
inline void KickGroupUsersRequest::set_group_id(::std::string&& value) {
  
  group_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.KickGroupUsersRequest.group_id)
}
#endif
inline void KickGroupUsersRequest::set_group_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.KickGroupUsersRequest.group_id)
}
inline void KickGroupUsersRequest::set_group_id(const char* value, size_t size) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.KickGroupUsersRequest.group_id)
}
inline ::std::string* KickGroupUsersRequest::mutable_group_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.KickGroupUsersRequest.group_id)
  return group_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KickGroupUsersRequest::release_group_id() {
  // @@protoc_insertion_point(field_release:nakama.api.KickGroupUsersRequest.group_id)
  
  return group_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KickGroupUsersRequest::set_allocated_group_id(::std::string* group_id) {
  if (group_id != NULL) {
    
  } else {
    
  }
  group_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), group_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.KickGroupUsersRequest.group_id)
}

// repeated string user_ids = 2;
inline int KickGroupUsersRequest::user_ids_size() const {
  return user_ids_.size();
}
inline void KickGroupUsersRequest::clear_user_ids() {
  user_ids_.Clear();
}
inline const ::std::string& KickGroupUsersRequest::user_ids(int index) const {
  // @@protoc_insertion_point(field_get:nakama.api.KickGroupUsersRequest.user_ids)
  return user_ids_.Get(index);
}
inline ::std::string* KickGroupUsersRequest::mutable_user_ids(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.api.KickGroupUsersRequest.user_ids)
  return user_ids_.Mutable(index);
}
inline void KickGroupUsersRequest::set_user_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:nakama.api.KickGroupUsersRequest.user_ids)
  user_ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void KickGroupUsersRequest::set_user_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:nakama.api.KickGroupUsersRequest.user_ids)
  user_ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void KickGroupUsersRequest::set_user_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  user_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nakama.api.KickGroupUsersRequest.user_ids)
}
inline void KickGroupUsersRequest::set_user_ids(int index, const char* value, size_t size) {
  user_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nakama.api.KickGroupUsersRequest.user_ids)
}
inline ::std::string* KickGroupUsersRequest::add_user_ids() {
  // @@protoc_insertion_point(field_add_mutable:nakama.api.KickGroupUsersRequest.user_ids)
  return user_ids_.Add();
}
inline void KickGroupUsersRequest::add_user_ids(const ::std::string& value) {
  user_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:nakama.api.KickGroupUsersRequest.user_ids)
}
#if LANG_CXX11
inline void KickGroupUsersRequest::add_user_ids(::std::string&& value) {
  user_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:nakama.api.KickGroupUsersRequest.user_ids)
}
#endif
inline void KickGroupUsersRequest::add_user_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  user_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nakama.api.KickGroupUsersRequest.user_ids)
}
inline void KickGroupUsersRequest::add_user_ids(const char* value, size_t size) {
  user_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nakama.api.KickGroupUsersRequest.user_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
KickGroupUsersRequest::user_ids() const {
  // @@protoc_insertion_point(field_list:nakama.api.KickGroupUsersRequest.user_ids)
  return user_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
KickGroupUsersRequest::mutable_user_ids() {
  // @@protoc_insertion_point(field_mutable_list:nakama.api.KickGroupUsersRequest.user_ids)
  return &user_ids_;
}

// -------------------------------------------------------------------

// LeaderboardRecord

// string leaderboard_id = 1;
inline void LeaderboardRecord::clear_leaderboard_id() {
  leaderboard_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LeaderboardRecord::leaderboard_id() const {
  // @@protoc_insertion_point(field_get:nakama.api.LeaderboardRecord.leaderboard_id)
  return leaderboard_id_.GetNoArena();
}
inline void LeaderboardRecord::set_leaderboard_id(const ::std::string& value) {
  
  leaderboard_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.LeaderboardRecord.leaderboard_id)
}
#if LANG_CXX11
inline void LeaderboardRecord::set_leaderboard_id(::std::string&& value) {
  
  leaderboard_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.LeaderboardRecord.leaderboard_id)
}
#endif
inline void LeaderboardRecord::set_leaderboard_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  leaderboard_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.LeaderboardRecord.leaderboard_id)
}
inline void LeaderboardRecord::set_leaderboard_id(const char* value, size_t size) {
  
  leaderboard_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.LeaderboardRecord.leaderboard_id)
}
inline ::std::string* LeaderboardRecord::mutable_leaderboard_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.LeaderboardRecord.leaderboard_id)
  return leaderboard_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LeaderboardRecord::release_leaderboard_id() {
  // @@protoc_insertion_point(field_release:nakama.api.LeaderboardRecord.leaderboard_id)
  
  return leaderboard_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LeaderboardRecord::set_allocated_leaderboard_id(::std::string* leaderboard_id) {
  if (leaderboard_id != NULL) {
    
  } else {
    
  }
  leaderboard_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), leaderboard_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.LeaderboardRecord.leaderboard_id)
}

// string owner_id = 2;
inline void LeaderboardRecord::clear_owner_id() {
  owner_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LeaderboardRecord::owner_id() const {
  // @@protoc_insertion_point(field_get:nakama.api.LeaderboardRecord.owner_id)
  return owner_id_.GetNoArena();
}
inline void LeaderboardRecord::set_owner_id(const ::std::string& value) {
  
  owner_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.LeaderboardRecord.owner_id)
}
#if LANG_CXX11
inline void LeaderboardRecord::set_owner_id(::std::string&& value) {
  
  owner_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.LeaderboardRecord.owner_id)
}
#endif
inline void LeaderboardRecord::set_owner_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  owner_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.LeaderboardRecord.owner_id)
}
inline void LeaderboardRecord::set_owner_id(const char* value, size_t size) {
  
  owner_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.LeaderboardRecord.owner_id)
}
inline ::std::string* LeaderboardRecord::mutable_owner_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.LeaderboardRecord.owner_id)
  return owner_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LeaderboardRecord::release_owner_id() {
  // @@protoc_insertion_point(field_release:nakama.api.LeaderboardRecord.owner_id)
  
  return owner_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LeaderboardRecord::set_allocated_owner_id(::std::string* owner_id) {
  if (owner_id != NULL) {
    
  } else {
    
  }
  owner_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), owner_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.LeaderboardRecord.owner_id)
}

// .google.protobuf.StringValue username = 3;
inline bool LeaderboardRecord::has_username() const {
  return this != internal_default_instance() && username_ != NULL;
}
inline const ::google::protobuf::StringValue& LeaderboardRecord::_internal_username() const {
  return *username_;
}
inline const ::google::protobuf::StringValue& LeaderboardRecord::username() const {
  const ::google::protobuf::StringValue* p = username_;
  // @@protoc_insertion_point(field_get:nakama.api.LeaderboardRecord.username)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::StringValue*>(
      &::google::protobuf::_StringValue_default_instance_);
}
inline ::google::protobuf::StringValue* LeaderboardRecord::release_username() {
  // @@protoc_insertion_point(field_release:nakama.api.LeaderboardRecord.username)
  
  ::google::protobuf::StringValue* temp = username_;
  username_ = NULL;
  return temp;
}
inline ::google::protobuf::StringValue* LeaderboardRecord::mutable_username() {
  
  if (username_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::StringValue>(GetArenaNoVirtual());
    username_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.LeaderboardRecord.username)
  return username_;
}
inline void LeaderboardRecord::set_allocated_username(::google::protobuf::StringValue* username) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(username_);
  }
  if (username) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(username)->GetArena();
    if (message_arena != submessage_arena) {
      username = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, username, submessage_arena);
    }
    
  } else {
    
  }
  username_ = username;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.LeaderboardRecord.username)
}

// int64 score = 4;
inline void LeaderboardRecord::clear_score() {
  score_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LeaderboardRecord::score() const {
  // @@protoc_insertion_point(field_get:nakama.api.LeaderboardRecord.score)
  return score_;
}
inline void LeaderboardRecord::set_score(::google::protobuf::int64 value) {
  
  score_ = value;
  // @@protoc_insertion_point(field_set:nakama.api.LeaderboardRecord.score)
}

// int64 subscore = 5;
inline void LeaderboardRecord::clear_subscore() {
  subscore_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LeaderboardRecord::subscore() const {
  // @@protoc_insertion_point(field_get:nakama.api.LeaderboardRecord.subscore)
  return subscore_;
}
inline void LeaderboardRecord::set_subscore(::google::protobuf::int64 value) {
  
  subscore_ = value;
  // @@protoc_insertion_point(field_set:nakama.api.LeaderboardRecord.subscore)
}

// int32 num_score = 6;
inline void LeaderboardRecord::clear_num_score() {
  num_score_ = 0;
}
inline ::google::protobuf::int32 LeaderboardRecord::num_score() const {
  // @@protoc_insertion_point(field_get:nakama.api.LeaderboardRecord.num_score)
  return num_score_;
}
inline void LeaderboardRecord::set_num_score(::google::protobuf::int32 value) {
  
  num_score_ = value;
  // @@protoc_insertion_point(field_set:nakama.api.LeaderboardRecord.num_score)
}

// string metadata = 7;
inline void LeaderboardRecord::clear_metadata() {
  metadata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LeaderboardRecord::metadata() const {
  // @@protoc_insertion_point(field_get:nakama.api.LeaderboardRecord.metadata)
  return metadata_.GetNoArena();
}
inline void LeaderboardRecord::set_metadata(const ::std::string& value) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.LeaderboardRecord.metadata)
}
#if LANG_CXX11
inline void LeaderboardRecord::set_metadata(::std::string&& value) {
  
  metadata_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.LeaderboardRecord.metadata)
}
#endif
inline void LeaderboardRecord::set_metadata(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.LeaderboardRecord.metadata)
}
inline void LeaderboardRecord::set_metadata(const char* value, size_t size) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.LeaderboardRecord.metadata)
}
inline ::std::string* LeaderboardRecord::mutable_metadata() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.LeaderboardRecord.metadata)
  return metadata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LeaderboardRecord::release_metadata() {
  // @@protoc_insertion_point(field_release:nakama.api.LeaderboardRecord.metadata)
  
  return metadata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LeaderboardRecord::set_allocated_metadata(::std::string* metadata) {
  if (metadata != NULL) {
    
  } else {
    
  }
  metadata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), metadata);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.LeaderboardRecord.metadata)
}

// .google.protobuf.Timestamp create_time = 8;
inline bool LeaderboardRecord::has_create_time() const {
  return this != internal_default_instance() && create_time_ != NULL;
}
inline const ::google::protobuf::Timestamp& LeaderboardRecord::_internal_create_time() const {
  return *create_time_;
}
inline const ::google::protobuf::Timestamp& LeaderboardRecord::create_time() const {
  const ::google::protobuf::Timestamp* p = create_time_;
  // @@protoc_insertion_point(field_get:nakama.api.LeaderboardRecord.create_time)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* LeaderboardRecord::release_create_time() {
  // @@protoc_insertion_point(field_release:nakama.api.LeaderboardRecord.create_time)
  
  ::google::protobuf::Timestamp* temp = create_time_;
  create_time_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* LeaderboardRecord::mutable_create_time() {
  
  if (create_time_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    create_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.LeaderboardRecord.create_time)
  return create_time_;
}
inline void LeaderboardRecord::set_allocated_create_time(::google::protobuf::Timestamp* create_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(create_time_);
  }
  if (create_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(create_time)->GetArena();
    if (message_arena != submessage_arena) {
      create_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, create_time, submessage_arena);
    }
    
  } else {
    
  }
  create_time_ = create_time;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.LeaderboardRecord.create_time)
}

// .google.protobuf.Timestamp update_time = 9;
inline bool LeaderboardRecord::has_update_time() const {
  return this != internal_default_instance() && update_time_ != NULL;
}
inline const ::google::protobuf::Timestamp& LeaderboardRecord::_internal_update_time() const {
  return *update_time_;
}
inline const ::google::protobuf::Timestamp& LeaderboardRecord::update_time() const {
  const ::google::protobuf::Timestamp* p = update_time_;
  // @@protoc_insertion_point(field_get:nakama.api.LeaderboardRecord.update_time)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* LeaderboardRecord::release_update_time() {
  // @@protoc_insertion_point(field_release:nakama.api.LeaderboardRecord.update_time)
  
  ::google::protobuf::Timestamp* temp = update_time_;
  update_time_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* LeaderboardRecord::mutable_update_time() {
  
  if (update_time_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    update_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.LeaderboardRecord.update_time)
  return update_time_;
}
inline void LeaderboardRecord::set_allocated_update_time(::google::protobuf::Timestamp* update_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(update_time_);
  }
  if (update_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(update_time)->GetArena();
    if (message_arena != submessage_arena) {
      update_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, update_time, submessage_arena);
    }
    
  } else {
    
  }
  update_time_ = update_time;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.LeaderboardRecord.update_time)
}

// .google.protobuf.Timestamp expiry_time = 10;
inline bool LeaderboardRecord::has_expiry_time() const {
  return this != internal_default_instance() && expiry_time_ != NULL;
}
inline const ::google::protobuf::Timestamp& LeaderboardRecord::_internal_expiry_time() const {
  return *expiry_time_;
}
inline const ::google::protobuf::Timestamp& LeaderboardRecord::expiry_time() const {
  const ::google::protobuf::Timestamp* p = expiry_time_;
  // @@protoc_insertion_point(field_get:nakama.api.LeaderboardRecord.expiry_time)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* LeaderboardRecord::release_expiry_time() {
  // @@protoc_insertion_point(field_release:nakama.api.LeaderboardRecord.expiry_time)
  
  ::google::protobuf::Timestamp* temp = expiry_time_;
  expiry_time_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* LeaderboardRecord::mutable_expiry_time() {
  
  if (expiry_time_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    expiry_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.LeaderboardRecord.expiry_time)
  return expiry_time_;
}
inline void LeaderboardRecord::set_allocated_expiry_time(::google::protobuf::Timestamp* expiry_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(expiry_time_);
  }
  if (expiry_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(expiry_time)->GetArena();
    if (message_arena != submessage_arena) {
      expiry_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, expiry_time, submessage_arena);
    }
    
  } else {
    
  }
  expiry_time_ = expiry_time;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.LeaderboardRecord.expiry_time)
}

// int64 rank = 11;
inline void LeaderboardRecord::clear_rank() {
  rank_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LeaderboardRecord::rank() const {
  // @@protoc_insertion_point(field_get:nakama.api.LeaderboardRecord.rank)
  return rank_;
}
inline void LeaderboardRecord::set_rank(::google::protobuf::int64 value) {
  
  rank_ = value;
  // @@protoc_insertion_point(field_set:nakama.api.LeaderboardRecord.rank)
}

// uint32 max_num_score = 12;
inline void LeaderboardRecord::clear_max_num_score() {
  max_num_score_ = 0u;
}
inline ::google::protobuf::uint32 LeaderboardRecord::max_num_score() const {
  // @@protoc_insertion_point(field_get:nakama.api.LeaderboardRecord.max_num_score)
  return max_num_score_;
}
inline void LeaderboardRecord::set_max_num_score(::google::protobuf::uint32 value) {
  
  max_num_score_ = value;
  // @@protoc_insertion_point(field_set:nakama.api.LeaderboardRecord.max_num_score)
}

// -------------------------------------------------------------------

// LeaderboardRecordList

// repeated .nakama.api.LeaderboardRecord records = 1;
inline int LeaderboardRecordList::records_size() const {
  return records_.size();
}
inline void LeaderboardRecordList::clear_records() {
  records_.Clear();
}
inline ::nakama::api::LeaderboardRecord* LeaderboardRecordList::mutable_records(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.api.LeaderboardRecordList.records)
  return records_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nakama::api::LeaderboardRecord >*
LeaderboardRecordList::mutable_records() {
  // @@protoc_insertion_point(field_mutable_list:nakama.api.LeaderboardRecordList.records)
  return &records_;
}
inline const ::nakama::api::LeaderboardRecord& LeaderboardRecordList::records(int index) const {
  // @@protoc_insertion_point(field_get:nakama.api.LeaderboardRecordList.records)
  return records_.Get(index);
}
inline ::nakama::api::LeaderboardRecord* LeaderboardRecordList::add_records() {
  // @@protoc_insertion_point(field_add:nakama.api.LeaderboardRecordList.records)
  return records_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nakama::api::LeaderboardRecord >&
LeaderboardRecordList::records() const {
  // @@protoc_insertion_point(field_list:nakama.api.LeaderboardRecordList.records)
  return records_;
}

// repeated .nakama.api.LeaderboardRecord owner_records = 2;
inline int LeaderboardRecordList::owner_records_size() const {
  return owner_records_.size();
}
inline void LeaderboardRecordList::clear_owner_records() {
  owner_records_.Clear();
}
inline ::nakama::api::LeaderboardRecord* LeaderboardRecordList::mutable_owner_records(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.api.LeaderboardRecordList.owner_records)
  return owner_records_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nakama::api::LeaderboardRecord >*
LeaderboardRecordList::mutable_owner_records() {
  // @@protoc_insertion_point(field_mutable_list:nakama.api.LeaderboardRecordList.owner_records)
  return &owner_records_;
}
inline const ::nakama::api::LeaderboardRecord& LeaderboardRecordList::owner_records(int index) const {
  // @@protoc_insertion_point(field_get:nakama.api.LeaderboardRecordList.owner_records)
  return owner_records_.Get(index);
}
inline ::nakama::api::LeaderboardRecord* LeaderboardRecordList::add_owner_records() {
  // @@protoc_insertion_point(field_add:nakama.api.LeaderboardRecordList.owner_records)
  return owner_records_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nakama::api::LeaderboardRecord >&
LeaderboardRecordList::owner_records() const {
  // @@protoc_insertion_point(field_list:nakama.api.LeaderboardRecordList.owner_records)
  return owner_records_;
}

// string next_cursor = 3;
inline void LeaderboardRecordList::clear_next_cursor() {
  next_cursor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LeaderboardRecordList::next_cursor() const {
  // @@protoc_insertion_point(field_get:nakama.api.LeaderboardRecordList.next_cursor)
  return next_cursor_.GetNoArena();
}
inline void LeaderboardRecordList::set_next_cursor(const ::std::string& value) {
  
  next_cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.LeaderboardRecordList.next_cursor)
}
#if LANG_CXX11
inline void LeaderboardRecordList::set_next_cursor(::std::string&& value) {
  
  next_cursor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.LeaderboardRecordList.next_cursor)
}
#endif
inline void LeaderboardRecordList::set_next_cursor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  next_cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.LeaderboardRecordList.next_cursor)
}
inline void LeaderboardRecordList::set_next_cursor(const char* value, size_t size) {
  
  next_cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.LeaderboardRecordList.next_cursor)
}
inline ::std::string* LeaderboardRecordList::mutable_next_cursor() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.LeaderboardRecordList.next_cursor)
  return next_cursor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LeaderboardRecordList::release_next_cursor() {
  // @@protoc_insertion_point(field_release:nakama.api.LeaderboardRecordList.next_cursor)
  
  return next_cursor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LeaderboardRecordList::set_allocated_next_cursor(::std::string* next_cursor) {
  if (next_cursor != NULL) {
    
  } else {
    
  }
  next_cursor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), next_cursor);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.LeaderboardRecordList.next_cursor)
}

// string prev_cursor = 4;
inline void LeaderboardRecordList::clear_prev_cursor() {
  prev_cursor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LeaderboardRecordList::prev_cursor() const {
  // @@protoc_insertion_point(field_get:nakama.api.LeaderboardRecordList.prev_cursor)
  return prev_cursor_.GetNoArena();
}
inline void LeaderboardRecordList::set_prev_cursor(const ::std::string& value) {
  
  prev_cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.LeaderboardRecordList.prev_cursor)
}
#if LANG_CXX11
inline void LeaderboardRecordList::set_prev_cursor(::std::string&& value) {
  
  prev_cursor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.LeaderboardRecordList.prev_cursor)
}
#endif
inline void LeaderboardRecordList::set_prev_cursor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  prev_cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.LeaderboardRecordList.prev_cursor)
}
inline void LeaderboardRecordList::set_prev_cursor(const char* value, size_t size) {
  
  prev_cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.LeaderboardRecordList.prev_cursor)
}
inline ::std::string* LeaderboardRecordList::mutable_prev_cursor() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.LeaderboardRecordList.prev_cursor)
  return prev_cursor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LeaderboardRecordList::release_prev_cursor() {
  // @@protoc_insertion_point(field_release:nakama.api.LeaderboardRecordList.prev_cursor)
  
  return prev_cursor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LeaderboardRecordList::set_allocated_prev_cursor(::std::string* prev_cursor) {
  if (prev_cursor != NULL) {
    
  } else {
    
  }
  prev_cursor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), prev_cursor);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.LeaderboardRecordList.prev_cursor)
}

// -------------------------------------------------------------------

// LeaveGroupRequest

// string group_id = 1;
inline void LeaveGroupRequest::clear_group_id() {
  group_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LeaveGroupRequest::group_id() const {
  // @@protoc_insertion_point(field_get:nakama.api.LeaveGroupRequest.group_id)
  return group_id_.GetNoArena();
}
inline void LeaveGroupRequest::set_group_id(const ::std::string& value) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.LeaveGroupRequest.group_id)
}
#if LANG_CXX11
inline void LeaveGroupRequest::set_group_id(::std::string&& value) {
  
  group_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.LeaveGroupRequest.group_id)
}
#endif
inline void LeaveGroupRequest::set_group_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.LeaveGroupRequest.group_id)
}
inline void LeaveGroupRequest::set_group_id(const char* value, size_t size) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.LeaveGroupRequest.group_id)
}
inline ::std::string* LeaveGroupRequest::mutable_group_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.LeaveGroupRequest.group_id)
  return group_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LeaveGroupRequest::release_group_id() {
  // @@protoc_insertion_point(field_release:nakama.api.LeaveGroupRequest.group_id)
  
  return group_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LeaveGroupRequest::set_allocated_group_id(::std::string* group_id) {
  if (group_id != NULL) {
    
  } else {
    
  }
  group_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), group_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.LeaveGroupRequest.group_id)
}

// -------------------------------------------------------------------

// LinkFacebookRequest

// .nakama.api.AccountFacebook account = 1;
inline bool LinkFacebookRequest::has_account() const {
  return this != internal_default_instance() && account_ != NULL;
}
inline void LinkFacebookRequest::clear_account() {
  if (GetArenaNoVirtual() == NULL && account_ != NULL) {
    delete account_;
  }
  account_ = NULL;
}
inline const ::nakama::api::AccountFacebook& LinkFacebookRequest::_internal_account() const {
  return *account_;
}
inline const ::nakama::api::AccountFacebook& LinkFacebookRequest::account() const {
  const ::nakama::api::AccountFacebook* p = account_;
  // @@protoc_insertion_point(field_get:nakama.api.LinkFacebookRequest.account)
  return p != NULL ? *p : *reinterpret_cast<const ::nakama::api::AccountFacebook*>(
      &::nakama::api::_AccountFacebook_default_instance_);
}
inline ::nakama::api::AccountFacebook* LinkFacebookRequest::release_account() {
  // @@protoc_insertion_point(field_release:nakama.api.LinkFacebookRequest.account)
  
  ::nakama::api::AccountFacebook* temp = account_;
  account_ = NULL;
  return temp;
}
inline ::nakama::api::AccountFacebook* LinkFacebookRequest::mutable_account() {
  
  if (account_ == NULL) {
    auto* p = CreateMaybeMessage<::nakama::api::AccountFacebook>(GetArenaNoVirtual());
    account_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.LinkFacebookRequest.account)
  return account_;
}
inline void LinkFacebookRequest::set_allocated_account(::nakama::api::AccountFacebook* account) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete account_;
  }
  if (account) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      account = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, account, submessage_arena);
    }
    
  } else {
    
  }
  account_ = account;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.LinkFacebookRequest.account)
}

// .google.protobuf.BoolValue import = 4;
inline bool LinkFacebookRequest::has_import() const {
  return this != internal_default_instance() && import_ != NULL;
}
inline const ::google::protobuf::BoolValue& LinkFacebookRequest::_internal_import() const {
  return *import_;
}
inline const ::google::protobuf::BoolValue& LinkFacebookRequest::import() const {
  const ::google::protobuf::BoolValue* p = import_;
  // @@protoc_insertion_point(field_get:nakama.api.LinkFacebookRequest.import)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::BoolValue*>(
      &::google::protobuf::_BoolValue_default_instance_);
}
inline ::google::protobuf::BoolValue* LinkFacebookRequest::release_import() {
  // @@protoc_insertion_point(field_release:nakama.api.LinkFacebookRequest.import)
  
  ::google::protobuf::BoolValue* temp = import_;
  import_ = NULL;
  return temp;
}
inline ::google::protobuf::BoolValue* LinkFacebookRequest::mutable_import() {
  
  if (import_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::BoolValue>(GetArenaNoVirtual());
    import_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.LinkFacebookRequest.import)
  return import_;
}
inline void LinkFacebookRequest::set_allocated_import(::google::protobuf::BoolValue* import) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(import_);
  }
  if (import) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(import)->GetArena();
    if (message_arena != submessage_arena) {
      import = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, import, submessage_arena);
    }
    
  } else {
    
  }
  import_ = import;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.LinkFacebookRequest.import)
}

// -------------------------------------------------------------------

// ListChannelMessagesRequest

// string channel_id = 1;
inline void ListChannelMessagesRequest::clear_channel_id() {
  channel_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ListChannelMessagesRequest::channel_id() const {
  // @@protoc_insertion_point(field_get:nakama.api.ListChannelMessagesRequest.channel_id)
  return channel_id_.GetNoArena();
}
inline void ListChannelMessagesRequest::set_channel_id(const ::std::string& value) {
  
  channel_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.ListChannelMessagesRequest.channel_id)
}
#if LANG_CXX11
inline void ListChannelMessagesRequest::set_channel_id(::std::string&& value) {
  
  channel_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.ListChannelMessagesRequest.channel_id)
}
#endif
inline void ListChannelMessagesRequest::set_channel_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  channel_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.ListChannelMessagesRequest.channel_id)
}
inline void ListChannelMessagesRequest::set_channel_id(const char* value, size_t size) {
  
  channel_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.ListChannelMessagesRequest.channel_id)
}
inline ::std::string* ListChannelMessagesRequest::mutable_channel_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.ListChannelMessagesRequest.channel_id)
  return channel_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ListChannelMessagesRequest::release_channel_id() {
  // @@protoc_insertion_point(field_release:nakama.api.ListChannelMessagesRequest.channel_id)
  
  return channel_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListChannelMessagesRequest::set_allocated_channel_id(::std::string* channel_id) {
  if (channel_id != NULL) {
    
  } else {
    
  }
  channel_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), channel_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ListChannelMessagesRequest.channel_id)
}

// .google.protobuf.Int32Value limit = 2;
inline bool ListChannelMessagesRequest::has_limit() const {
  return this != internal_default_instance() && limit_ != NULL;
}
inline const ::google::protobuf::Int32Value& ListChannelMessagesRequest::_internal_limit() const {
  return *limit_;
}
inline const ::google::protobuf::Int32Value& ListChannelMessagesRequest::limit() const {
  const ::google::protobuf::Int32Value* p = limit_;
  // @@protoc_insertion_point(field_get:nakama.api.ListChannelMessagesRequest.limit)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* ListChannelMessagesRequest::release_limit() {
  // @@protoc_insertion_point(field_release:nakama.api.ListChannelMessagesRequest.limit)
  
  ::google::protobuf::Int32Value* temp = limit_;
  limit_ = NULL;
  return temp;
}
inline ::google::protobuf::Int32Value* ListChannelMessagesRequest::mutable_limit() {
  
  if (limit_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    limit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.ListChannelMessagesRequest.limit)
  return limit_;
}
inline void ListChannelMessagesRequest::set_allocated_limit(::google::protobuf::Int32Value* limit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(limit_);
  }
  if (limit) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(limit)->GetArena();
    if (message_arena != submessage_arena) {
      limit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, limit, submessage_arena);
    }
    
  } else {
    
  }
  limit_ = limit;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ListChannelMessagesRequest.limit)
}

// .google.protobuf.BoolValue forward = 3;
inline bool ListChannelMessagesRequest::has_forward() const {
  return this != internal_default_instance() && forward_ != NULL;
}
inline const ::google::protobuf::BoolValue& ListChannelMessagesRequest::_internal_forward() const {
  return *forward_;
}
inline const ::google::protobuf::BoolValue& ListChannelMessagesRequest::forward() const {
  const ::google::protobuf::BoolValue* p = forward_;
  // @@protoc_insertion_point(field_get:nakama.api.ListChannelMessagesRequest.forward)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::BoolValue*>(
      &::google::protobuf::_BoolValue_default_instance_);
}
inline ::google::protobuf::BoolValue* ListChannelMessagesRequest::release_forward() {
  // @@protoc_insertion_point(field_release:nakama.api.ListChannelMessagesRequest.forward)
  
  ::google::protobuf::BoolValue* temp = forward_;
  forward_ = NULL;
  return temp;
}
inline ::google::protobuf::BoolValue* ListChannelMessagesRequest::mutable_forward() {
  
  if (forward_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::BoolValue>(GetArenaNoVirtual());
    forward_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.ListChannelMessagesRequest.forward)
  return forward_;
}
inline void ListChannelMessagesRequest::set_allocated_forward(::google::protobuf::BoolValue* forward) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(forward_);
  }
  if (forward) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(forward)->GetArena();
    if (message_arena != submessage_arena) {
      forward = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, forward, submessage_arena);
    }
    
  } else {
    
  }
  forward_ = forward;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ListChannelMessagesRequest.forward)
}

// string cursor = 4;
inline void ListChannelMessagesRequest::clear_cursor() {
  cursor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ListChannelMessagesRequest::cursor() const {
  // @@protoc_insertion_point(field_get:nakama.api.ListChannelMessagesRequest.cursor)
  return cursor_.GetNoArena();
}
inline void ListChannelMessagesRequest::set_cursor(const ::std::string& value) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.ListChannelMessagesRequest.cursor)
}
#if LANG_CXX11
inline void ListChannelMessagesRequest::set_cursor(::std::string&& value) {
  
  cursor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.ListChannelMessagesRequest.cursor)
}
#endif
inline void ListChannelMessagesRequest::set_cursor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.ListChannelMessagesRequest.cursor)
}
inline void ListChannelMessagesRequest::set_cursor(const char* value, size_t size) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.ListChannelMessagesRequest.cursor)
}
inline ::std::string* ListChannelMessagesRequest::mutable_cursor() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.ListChannelMessagesRequest.cursor)
  return cursor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ListChannelMessagesRequest::release_cursor() {
  // @@protoc_insertion_point(field_release:nakama.api.ListChannelMessagesRequest.cursor)
  
  return cursor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListChannelMessagesRequest::set_allocated_cursor(::std::string* cursor) {
  if (cursor != NULL) {
    
  } else {
    
  }
  cursor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cursor);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ListChannelMessagesRequest.cursor)
}

// -------------------------------------------------------------------

// ListGroupsRequest

// string name = 1;
inline void ListGroupsRequest::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ListGroupsRequest::name() const {
  // @@protoc_insertion_point(field_get:nakama.api.ListGroupsRequest.name)
  return name_.GetNoArena();
}
inline void ListGroupsRequest::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.ListGroupsRequest.name)
}
#if LANG_CXX11
inline void ListGroupsRequest::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.ListGroupsRequest.name)
}
#endif
inline void ListGroupsRequest::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.ListGroupsRequest.name)
}
inline void ListGroupsRequest::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.ListGroupsRequest.name)
}
inline ::std::string* ListGroupsRequest::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.ListGroupsRequest.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ListGroupsRequest::release_name() {
  // @@protoc_insertion_point(field_release:nakama.api.ListGroupsRequest.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListGroupsRequest::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ListGroupsRequest.name)
}

// string cursor = 2;
inline void ListGroupsRequest::clear_cursor() {
  cursor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ListGroupsRequest::cursor() const {
  // @@protoc_insertion_point(field_get:nakama.api.ListGroupsRequest.cursor)
  return cursor_.GetNoArena();
}
inline void ListGroupsRequest::set_cursor(const ::std::string& value) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.ListGroupsRequest.cursor)
}
#if LANG_CXX11
inline void ListGroupsRequest::set_cursor(::std::string&& value) {
  
  cursor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.ListGroupsRequest.cursor)
}
#endif
inline void ListGroupsRequest::set_cursor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.ListGroupsRequest.cursor)
}
inline void ListGroupsRequest::set_cursor(const char* value, size_t size) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.ListGroupsRequest.cursor)
}
inline ::std::string* ListGroupsRequest::mutable_cursor() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.ListGroupsRequest.cursor)
  return cursor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ListGroupsRequest::release_cursor() {
  // @@protoc_insertion_point(field_release:nakama.api.ListGroupsRequest.cursor)
  
  return cursor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListGroupsRequest::set_allocated_cursor(::std::string* cursor) {
  if (cursor != NULL) {
    
  } else {
    
  }
  cursor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cursor);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ListGroupsRequest.cursor)
}

// .google.protobuf.Int32Value limit = 3;
inline bool ListGroupsRequest::has_limit() const {
  return this != internal_default_instance() && limit_ != NULL;
}
inline const ::google::protobuf::Int32Value& ListGroupsRequest::_internal_limit() const {
  return *limit_;
}
inline const ::google::protobuf::Int32Value& ListGroupsRequest::limit() const {
  const ::google::protobuf::Int32Value* p = limit_;
  // @@protoc_insertion_point(field_get:nakama.api.ListGroupsRequest.limit)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* ListGroupsRequest::release_limit() {
  // @@protoc_insertion_point(field_release:nakama.api.ListGroupsRequest.limit)
  
  ::google::protobuf::Int32Value* temp = limit_;
  limit_ = NULL;
  return temp;
}
inline ::google::protobuf::Int32Value* ListGroupsRequest::mutable_limit() {
  
  if (limit_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    limit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.ListGroupsRequest.limit)
  return limit_;
}
inline void ListGroupsRequest::set_allocated_limit(::google::protobuf::Int32Value* limit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(limit_);
  }
  if (limit) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(limit)->GetArena();
    if (message_arena != submessage_arena) {
      limit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, limit, submessage_arena);
    }
    
  } else {
    
  }
  limit_ = limit;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ListGroupsRequest.limit)
}

// -------------------------------------------------------------------

// ListGroupUsersRequest

// string group_id = 1;
inline void ListGroupUsersRequest::clear_group_id() {
  group_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ListGroupUsersRequest::group_id() const {
  // @@protoc_insertion_point(field_get:nakama.api.ListGroupUsersRequest.group_id)
  return group_id_.GetNoArena();
}
inline void ListGroupUsersRequest::set_group_id(const ::std::string& value) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.ListGroupUsersRequest.group_id)
}
#if LANG_CXX11
inline void ListGroupUsersRequest::set_group_id(::std::string&& value) {
  
  group_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.ListGroupUsersRequest.group_id)
}
#endif
inline void ListGroupUsersRequest::set_group_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.ListGroupUsersRequest.group_id)
}
inline void ListGroupUsersRequest::set_group_id(const char* value, size_t size) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.ListGroupUsersRequest.group_id)
}
inline ::std::string* ListGroupUsersRequest::mutable_group_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.ListGroupUsersRequest.group_id)
  return group_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ListGroupUsersRequest::release_group_id() {
  // @@protoc_insertion_point(field_release:nakama.api.ListGroupUsersRequest.group_id)
  
  return group_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListGroupUsersRequest::set_allocated_group_id(::std::string* group_id) {
  if (group_id != NULL) {
    
  } else {
    
  }
  group_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), group_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ListGroupUsersRequest.group_id)
}

// -------------------------------------------------------------------

// ListLeaderboardRecordsAroundOwnerRequest

// string leaderboard_id = 1;
inline void ListLeaderboardRecordsAroundOwnerRequest::clear_leaderboard_id() {
  leaderboard_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ListLeaderboardRecordsAroundOwnerRequest::leaderboard_id() const {
  // @@protoc_insertion_point(field_get:nakama.api.ListLeaderboardRecordsAroundOwnerRequest.leaderboard_id)
  return leaderboard_id_.GetNoArena();
}
inline void ListLeaderboardRecordsAroundOwnerRequest::set_leaderboard_id(const ::std::string& value) {
  
  leaderboard_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.ListLeaderboardRecordsAroundOwnerRequest.leaderboard_id)
}
#if LANG_CXX11
inline void ListLeaderboardRecordsAroundOwnerRequest::set_leaderboard_id(::std::string&& value) {
  
  leaderboard_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.ListLeaderboardRecordsAroundOwnerRequest.leaderboard_id)
}
#endif
inline void ListLeaderboardRecordsAroundOwnerRequest::set_leaderboard_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  leaderboard_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.ListLeaderboardRecordsAroundOwnerRequest.leaderboard_id)
}
inline void ListLeaderboardRecordsAroundOwnerRequest::set_leaderboard_id(const char* value, size_t size) {
  
  leaderboard_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.ListLeaderboardRecordsAroundOwnerRequest.leaderboard_id)
}
inline ::std::string* ListLeaderboardRecordsAroundOwnerRequest::mutable_leaderboard_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.ListLeaderboardRecordsAroundOwnerRequest.leaderboard_id)
  return leaderboard_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ListLeaderboardRecordsAroundOwnerRequest::release_leaderboard_id() {
  // @@protoc_insertion_point(field_release:nakama.api.ListLeaderboardRecordsAroundOwnerRequest.leaderboard_id)
  
  return leaderboard_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListLeaderboardRecordsAroundOwnerRequest::set_allocated_leaderboard_id(::std::string* leaderboard_id) {
  if (leaderboard_id != NULL) {
    
  } else {
    
  }
  leaderboard_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), leaderboard_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ListLeaderboardRecordsAroundOwnerRequest.leaderboard_id)
}

// .google.protobuf.UInt32Value limit = 2;
inline bool ListLeaderboardRecordsAroundOwnerRequest::has_limit() const {
  return this != internal_default_instance() && limit_ != NULL;
}
inline const ::google::protobuf::UInt32Value& ListLeaderboardRecordsAroundOwnerRequest::_internal_limit() const {
  return *limit_;
}
inline const ::google::protobuf::UInt32Value& ListLeaderboardRecordsAroundOwnerRequest::limit() const {
  const ::google::protobuf::UInt32Value* p = limit_;
  // @@protoc_insertion_point(field_get:nakama.api.ListLeaderboardRecordsAroundOwnerRequest.limit)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::UInt32Value*>(
      &::google::protobuf::_UInt32Value_default_instance_);
}
inline ::google::protobuf::UInt32Value* ListLeaderboardRecordsAroundOwnerRequest::release_limit() {
  // @@protoc_insertion_point(field_release:nakama.api.ListLeaderboardRecordsAroundOwnerRequest.limit)
  
  ::google::protobuf::UInt32Value* temp = limit_;
  limit_ = NULL;
  return temp;
}
inline ::google::protobuf::UInt32Value* ListLeaderboardRecordsAroundOwnerRequest::mutable_limit() {
  
  if (limit_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::UInt32Value>(GetArenaNoVirtual());
    limit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.ListLeaderboardRecordsAroundOwnerRequest.limit)
  return limit_;
}
inline void ListLeaderboardRecordsAroundOwnerRequest::set_allocated_limit(::google::protobuf::UInt32Value* limit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(limit_);
  }
  if (limit) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(limit)->GetArena();
    if (message_arena != submessage_arena) {
      limit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, limit, submessage_arena);
    }
    
  } else {
    
  }
  limit_ = limit;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ListLeaderboardRecordsAroundOwnerRequest.limit)
}

// string owner_id = 3;
inline void ListLeaderboardRecordsAroundOwnerRequest::clear_owner_id() {
  owner_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ListLeaderboardRecordsAroundOwnerRequest::owner_id() const {
  // @@protoc_insertion_point(field_get:nakama.api.ListLeaderboardRecordsAroundOwnerRequest.owner_id)
  return owner_id_.GetNoArena();
}
inline void ListLeaderboardRecordsAroundOwnerRequest::set_owner_id(const ::std::string& value) {
  
  owner_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.ListLeaderboardRecordsAroundOwnerRequest.owner_id)
}
#if LANG_CXX11
inline void ListLeaderboardRecordsAroundOwnerRequest::set_owner_id(::std::string&& value) {
  
  owner_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.ListLeaderboardRecordsAroundOwnerRequest.owner_id)
}
#endif
inline void ListLeaderboardRecordsAroundOwnerRequest::set_owner_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  owner_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.ListLeaderboardRecordsAroundOwnerRequest.owner_id)
}
inline void ListLeaderboardRecordsAroundOwnerRequest::set_owner_id(const char* value, size_t size) {
  
  owner_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.ListLeaderboardRecordsAroundOwnerRequest.owner_id)
}
inline ::std::string* ListLeaderboardRecordsAroundOwnerRequest::mutable_owner_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.ListLeaderboardRecordsAroundOwnerRequest.owner_id)
  return owner_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ListLeaderboardRecordsAroundOwnerRequest::release_owner_id() {
  // @@protoc_insertion_point(field_release:nakama.api.ListLeaderboardRecordsAroundOwnerRequest.owner_id)
  
  return owner_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListLeaderboardRecordsAroundOwnerRequest::set_allocated_owner_id(::std::string* owner_id) {
  if (owner_id != NULL) {
    
  } else {
    
  }
  owner_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), owner_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ListLeaderboardRecordsAroundOwnerRequest.owner_id)
}

// -------------------------------------------------------------------

// ListLeaderboardRecordsRequest

// string leaderboard_id = 1;
inline void ListLeaderboardRecordsRequest::clear_leaderboard_id() {
  leaderboard_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ListLeaderboardRecordsRequest::leaderboard_id() const {
  // @@protoc_insertion_point(field_get:nakama.api.ListLeaderboardRecordsRequest.leaderboard_id)
  return leaderboard_id_.GetNoArena();
}
inline void ListLeaderboardRecordsRequest::set_leaderboard_id(const ::std::string& value) {
  
  leaderboard_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.ListLeaderboardRecordsRequest.leaderboard_id)
}
#if LANG_CXX11
inline void ListLeaderboardRecordsRequest::set_leaderboard_id(::std::string&& value) {
  
  leaderboard_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.ListLeaderboardRecordsRequest.leaderboard_id)
}
#endif
inline void ListLeaderboardRecordsRequest::set_leaderboard_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  leaderboard_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.ListLeaderboardRecordsRequest.leaderboard_id)
}
inline void ListLeaderboardRecordsRequest::set_leaderboard_id(const char* value, size_t size) {
  
  leaderboard_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.ListLeaderboardRecordsRequest.leaderboard_id)
}
inline ::std::string* ListLeaderboardRecordsRequest::mutable_leaderboard_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.ListLeaderboardRecordsRequest.leaderboard_id)
  return leaderboard_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ListLeaderboardRecordsRequest::release_leaderboard_id() {
  // @@protoc_insertion_point(field_release:nakama.api.ListLeaderboardRecordsRequest.leaderboard_id)
  
  return leaderboard_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListLeaderboardRecordsRequest::set_allocated_leaderboard_id(::std::string* leaderboard_id) {
  if (leaderboard_id != NULL) {
    
  } else {
    
  }
  leaderboard_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), leaderboard_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ListLeaderboardRecordsRequest.leaderboard_id)
}

// repeated string owner_ids = 2;
inline int ListLeaderboardRecordsRequest::owner_ids_size() const {
  return owner_ids_.size();
}
inline void ListLeaderboardRecordsRequest::clear_owner_ids() {
  owner_ids_.Clear();
}
inline const ::std::string& ListLeaderboardRecordsRequest::owner_ids(int index) const {
  // @@protoc_insertion_point(field_get:nakama.api.ListLeaderboardRecordsRequest.owner_ids)
  return owner_ids_.Get(index);
}
inline ::std::string* ListLeaderboardRecordsRequest::mutable_owner_ids(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.api.ListLeaderboardRecordsRequest.owner_ids)
  return owner_ids_.Mutable(index);
}
inline void ListLeaderboardRecordsRequest::set_owner_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:nakama.api.ListLeaderboardRecordsRequest.owner_ids)
  owner_ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ListLeaderboardRecordsRequest::set_owner_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:nakama.api.ListLeaderboardRecordsRequest.owner_ids)
  owner_ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ListLeaderboardRecordsRequest::set_owner_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  owner_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nakama.api.ListLeaderboardRecordsRequest.owner_ids)
}
inline void ListLeaderboardRecordsRequest::set_owner_ids(int index, const char* value, size_t size) {
  owner_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nakama.api.ListLeaderboardRecordsRequest.owner_ids)
}
inline ::std::string* ListLeaderboardRecordsRequest::add_owner_ids() {
  // @@protoc_insertion_point(field_add_mutable:nakama.api.ListLeaderboardRecordsRequest.owner_ids)
  return owner_ids_.Add();
}
inline void ListLeaderboardRecordsRequest::add_owner_ids(const ::std::string& value) {
  owner_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:nakama.api.ListLeaderboardRecordsRequest.owner_ids)
}
#if LANG_CXX11
inline void ListLeaderboardRecordsRequest::add_owner_ids(::std::string&& value) {
  owner_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:nakama.api.ListLeaderboardRecordsRequest.owner_ids)
}
#endif
inline void ListLeaderboardRecordsRequest::add_owner_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  owner_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nakama.api.ListLeaderboardRecordsRequest.owner_ids)
}
inline void ListLeaderboardRecordsRequest::add_owner_ids(const char* value, size_t size) {
  owner_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nakama.api.ListLeaderboardRecordsRequest.owner_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ListLeaderboardRecordsRequest::owner_ids() const {
  // @@protoc_insertion_point(field_list:nakama.api.ListLeaderboardRecordsRequest.owner_ids)
  return owner_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ListLeaderboardRecordsRequest::mutable_owner_ids() {
  // @@protoc_insertion_point(field_mutable_list:nakama.api.ListLeaderboardRecordsRequest.owner_ids)
  return &owner_ids_;
}

// .google.protobuf.Int32Value limit = 3;
inline bool ListLeaderboardRecordsRequest::has_limit() const {
  return this != internal_default_instance() && limit_ != NULL;
}
inline const ::google::protobuf::Int32Value& ListLeaderboardRecordsRequest::_internal_limit() const {
  return *limit_;
}
inline const ::google::protobuf::Int32Value& ListLeaderboardRecordsRequest::limit() const {
  const ::google::protobuf::Int32Value* p = limit_;
  // @@protoc_insertion_point(field_get:nakama.api.ListLeaderboardRecordsRequest.limit)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* ListLeaderboardRecordsRequest::release_limit() {
  // @@protoc_insertion_point(field_release:nakama.api.ListLeaderboardRecordsRequest.limit)
  
  ::google::protobuf::Int32Value* temp = limit_;
  limit_ = NULL;
  return temp;
}
inline ::google::protobuf::Int32Value* ListLeaderboardRecordsRequest::mutable_limit() {
  
  if (limit_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    limit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.ListLeaderboardRecordsRequest.limit)
  return limit_;
}
inline void ListLeaderboardRecordsRequest::set_allocated_limit(::google::protobuf::Int32Value* limit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(limit_);
  }
  if (limit) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(limit)->GetArena();
    if (message_arena != submessage_arena) {
      limit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, limit, submessage_arena);
    }
    
  } else {
    
  }
  limit_ = limit;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ListLeaderboardRecordsRequest.limit)
}

// string cursor = 4;
inline void ListLeaderboardRecordsRequest::clear_cursor() {
  cursor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ListLeaderboardRecordsRequest::cursor() const {
  // @@protoc_insertion_point(field_get:nakama.api.ListLeaderboardRecordsRequest.cursor)
  return cursor_.GetNoArena();
}
inline void ListLeaderboardRecordsRequest::set_cursor(const ::std::string& value) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.ListLeaderboardRecordsRequest.cursor)
}
#if LANG_CXX11
inline void ListLeaderboardRecordsRequest::set_cursor(::std::string&& value) {
  
  cursor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.ListLeaderboardRecordsRequest.cursor)
}
#endif
inline void ListLeaderboardRecordsRequest::set_cursor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.ListLeaderboardRecordsRequest.cursor)
}
inline void ListLeaderboardRecordsRequest::set_cursor(const char* value, size_t size) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.ListLeaderboardRecordsRequest.cursor)
}
inline ::std::string* ListLeaderboardRecordsRequest::mutable_cursor() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.ListLeaderboardRecordsRequest.cursor)
  return cursor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ListLeaderboardRecordsRequest::release_cursor() {
  // @@protoc_insertion_point(field_release:nakama.api.ListLeaderboardRecordsRequest.cursor)
  
  return cursor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListLeaderboardRecordsRequest::set_allocated_cursor(::std::string* cursor) {
  if (cursor != NULL) {
    
  } else {
    
  }
  cursor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cursor);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ListLeaderboardRecordsRequest.cursor)
}

// -------------------------------------------------------------------

// ListMatchesRequest

// .google.protobuf.Int32Value limit = 1;
inline bool ListMatchesRequest::has_limit() const {
  return this != internal_default_instance() && limit_ != NULL;
}
inline const ::google::protobuf::Int32Value& ListMatchesRequest::_internal_limit() const {
  return *limit_;
}
inline const ::google::protobuf::Int32Value& ListMatchesRequest::limit() const {
  const ::google::protobuf::Int32Value* p = limit_;
  // @@protoc_insertion_point(field_get:nakama.api.ListMatchesRequest.limit)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* ListMatchesRequest::release_limit() {
  // @@protoc_insertion_point(field_release:nakama.api.ListMatchesRequest.limit)
  
  ::google::protobuf::Int32Value* temp = limit_;
  limit_ = NULL;
  return temp;
}
inline ::google::protobuf::Int32Value* ListMatchesRequest::mutable_limit() {
  
  if (limit_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    limit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.ListMatchesRequest.limit)
  return limit_;
}
inline void ListMatchesRequest::set_allocated_limit(::google::protobuf::Int32Value* limit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(limit_);
  }
  if (limit) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(limit)->GetArena();
    if (message_arena != submessage_arena) {
      limit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, limit, submessage_arena);
    }
    
  } else {
    
  }
  limit_ = limit;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ListMatchesRequest.limit)
}

// .google.protobuf.BoolValue authoritative = 2;
inline bool ListMatchesRequest::has_authoritative() const {
  return this != internal_default_instance() && authoritative_ != NULL;
}
inline const ::google::protobuf::BoolValue& ListMatchesRequest::_internal_authoritative() const {
  return *authoritative_;
}
inline const ::google::protobuf::BoolValue& ListMatchesRequest::authoritative() const {
  const ::google::protobuf::BoolValue* p = authoritative_;
  // @@protoc_insertion_point(field_get:nakama.api.ListMatchesRequest.authoritative)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::BoolValue*>(
      &::google::protobuf::_BoolValue_default_instance_);
}
inline ::google::protobuf::BoolValue* ListMatchesRequest::release_authoritative() {
  // @@protoc_insertion_point(field_release:nakama.api.ListMatchesRequest.authoritative)
  
  ::google::protobuf::BoolValue* temp = authoritative_;
  authoritative_ = NULL;
  return temp;
}
inline ::google::protobuf::BoolValue* ListMatchesRequest::mutable_authoritative() {
  
  if (authoritative_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::BoolValue>(GetArenaNoVirtual());
    authoritative_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.ListMatchesRequest.authoritative)
  return authoritative_;
}
inline void ListMatchesRequest::set_allocated_authoritative(::google::protobuf::BoolValue* authoritative) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(authoritative_);
  }
  if (authoritative) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(authoritative)->GetArena();
    if (message_arena != submessage_arena) {
      authoritative = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, authoritative, submessage_arena);
    }
    
  } else {
    
  }
  authoritative_ = authoritative;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ListMatchesRequest.authoritative)
}

// .google.protobuf.StringValue label = 3;
inline bool ListMatchesRequest::has_label() const {
  return this != internal_default_instance() && label_ != NULL;
}
inline const ::google::protobuf::StringValue& ListMatchesRequest::_internal_label() const {
  return *label_;
}
inline const ::google::protobuf::StringValue& ListMatchesRequest::label() const {
  const ::google::protobuf::StringValue* p = label_;
  // @@protoc_insertion_point(field_get:nakama.api.ListMatchesRequest.label)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::StringValue*>(
      &::google::protobuf::_StringValue_default_instance_);
}
inline ::google::protobuf::StringValue* ListMatchesRequest::release_label() {
  // @@protoc_insertion_point(field_release:nakama.api.ListMatchesRequest.label)
  
  ::google::protobuf::StringValue* temp = label_;
  label_ = NULL;
  return temp;
}
inline ::google::protobuf::StringValue* ListMatchesRequest::mutable_label() {
  
  if (label_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::StringValue>(GetArenaNoVirtual());
    label_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.ListMatchesRequest.label)
  return label_;
}
inline void ListMatchesRequest::set_allocated_label(::google::protobuf::StringValue* label) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(label_);
  }
  if (label) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(label)->GetArena();
    if (message_arena != submessage_arena) {
      label = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, label, submessage_arena);
    }
    
  } else {
    
  }
  label_ = label;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ListMatchesRequest.label)
}

// .google.protobuf.Int32Value min_size = 4;
inline bool ListMatchesRequest::has_min_size() const {
  return this != internal_default_instance() && min_size_ != NULL;
}
inline const ::google::protobuf::Int32Value& ListMatchesRequest::_internal_min_size() const {
  return *min_size_;
}
inline const ::google::protobuf::Int32Value& ListMatchesRequest::min_size() const {
  const ::google::protobuf::Int32Value* p = min_size_;
  // @@protoc_insertion_point(field_get:nakama.api.ListMatchesRequest.min_size)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* ListMatchesRequest::release_min_size() {
  // @@protoc_insertion_point(field_release:nakama.api.ListMatchesRequest.min_size)
  
  ::google::protobuf::Int32Value* temp = min_size_;
  min_size_ = NULL;
  return temp;
}
inline ::google::protobuf::Int32Value* ListMatchesRequest::mutable_min_size() {
  
  if (min_size_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    min_size_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.ListMatchesRequest.min_size)
  return min_size_;
}
inline void ListMatchesRequest::set_allocated_min_size(::google::protobuf::Int32Value* min_size) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(min_size_);
  }
  if (min_size) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(min_size)->GetArena();
    if (message_arena != submessage_arena) {
      min_size = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, min_size, submessage_arena);
    }
    
  } else {
    
  }
  min_size_ = min_size;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ListMatchesRequest.min_size)
}

// .google.protobuf.Int32Value max_size = 5;
inline bool ListMatchesRequest::has_max_size() const {
  return this != internal_default_instance() && max_size_ != NULL;
}
inline const ::google::protobuf::Int32Value& ListMatchesRequest::_internal_max_size() const {
  return *max_size_;
}
inline const ::google::protobuf::Int32Value& ListMatchesRequest::max_size() const {
  const ::google::protobuf::Int32Value* p = max_size_;
  // @@protoc_insertion_point(field_get:nakama.api.ListMatchesRequest.max_size)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* ListMatchesRequest::release_max_size() {
  // @@protoc_insertion_point(field_release:nakama.api.ListMatchesRequest.max_size)
  
  ::google::protobuf::Int32Value* temp = max_size_;
  max_size_ = NULL;
  return temp;
}
inline ::google::protobuf::Int32Value* ListMatchesRequest::mutable_max_size() {
  
  if (max_size_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    max_size_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.ListMatchesRequest.max_size)
  return max_size_;
}
inline void ListMatchesRequest::set_allocated_max_size(::google::protobuf::Int32Value* max_size) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(max_size_);
  }
  if (max_size) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(max_size)->GetArena();
    if (message_arena != submessage_arena) {
      max_size = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, max_size, submessage_arena);
    }
    
  } else {
    
  }
  max_size_ = max_size;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ListMatchesRequest.max_size)
}

// .google.protobuf.StringValue query = 6;
inline bool ListMatchesRequest::has_query() const {
  return this != internal_default_instance() && query_ != NULL;
}
inline const ::google::protobuf::StringValue& ListMatchesRequest::_internal_query() const {
  return *query_;
}
inline const ::google::protobuf::StringValue& ListMatchesRequest::query() const {
  const ::google::protobuf::StringValue* p = query_;
  // @@protoc_insertion_point(field_get:nakama.api.ListMatchesRequest.query)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::StringValue*>(
      &::google::protobuf::_StringValue_default_instance_);
}
inline ::google::protobuf::StringValue* ListMatchesRequest::release_query() {
  // @@protoc_insertion_point(field_release:nakama.api.ListMatchesRequest.query)
  
  ::google::protobuf::StringValue* temp = query_;
  query_ = NULL;
  return temp;
}
inline ::google::protobuf::StringValue* ListMatchesRequest::mutable_query() {
  
  if (query_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::StringValue>(GetArenaNoVirtual());
    query_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.ListMatchesRequest.query)
  return query_;
}
inline void ListMatchesRequest::set_allocated_query(::google::protobuf::StringValue* query) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(query_);
  }
  if (query) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(query)->GetArena();
    if (message_arena != submessage_arena) {
      query = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, query, submessage_arena);
    }
    
  } else {
    
  }
  query_ = query;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ListMatchesRequest.query)
}

// -------------------------------------------------------------------

// ListNotificationsRequest

// .google.protobuf.Int32Value limit = 1;
inline bool ListNotificationsRequest::has_limit() const {
  return this != internal_default_instance() && limit_ != NULL;
}
inline const ::google::protobuf::Int32Value& ListNotificationsRequest::_internal_limit() const {
  return *limit_;
}
inline const ::google::protobuf::Int32Value& ListNotificationsRequest::limit() const {
  const ::google::protobuf::Int32Value* p = limit_;
  // @@protoc_insertion_point(field_get:nakama.api.ListNotificationsRequest.limit)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* ListNotificationsRequest::release_limit() {
  // @@protoc_insertion_point(field_release:nakama.api.ListNotificationsRequest.limit)
  
  ::google::protobuf::Int32Value* temp = limit_;
  limit_ = NULL;
  return temp;
}
inline ::google::protobuf::Int32Value* ListNotificationsRequest::mutable_limit() {
  
  if (limit_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    limit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.ListNotificationsRequest.limit)
  return limit_;
}
inline void ListNotificationsRequest::set_allocated_limit(::google::protobuf::Int32Value* limit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(limit_);
  }
  if (limit) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(limit)->GetArena();
    if (message_arena != submessage_arena) {
      limit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, limit, submessage_arena);
    }
    
  } else {
    
  }
  limit_ = limit;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ListNotificationsRequest.limit)
}

// string cacheable_cursor = 2;
inline void ListNotificationsRequest::clear_cacheable_cursor() {
  cacheable_cursor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ListNotificationsRequest::cacheable_cursor() const {
  // @@protoc_insertion_point(field_get:nakama.api.ListNotificationsRequest.cacheable_cursor)
  return cacheable_cursor_.GetNoArena();
}
inline void ListNotificationsRequest::set_cacheable_cursor(const ::std::string& value) {
  
  cacheable_cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.ListNotificationsRequest.cacheable_cursor)
}
#if LANG_CXX11
inline void ListNotificationsRequest::set_cacheable_cursor(::std::string&& value) {
  
  cacheable_cursor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.ListNotificationsRequest.cacheable_cursor)
}
#endif
inline void ListNotificationsRequest::set_cacheable_cursor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cacheable_cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.ListNotificationsRequest.cacheable_cursor)
}
inline void ListNotificationsRequest::set_cacheable_cursor(const char* value, size_t size) {
  
  cacheable_cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.ListNotificationsRequest.cacheable_cursor)
}
inline ::std::string* ListNotificationsRequest::mutable_cacheable_cursor() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.ListNotificationsRequest.cacheable_cursor)
  return cacheable_cursor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ListNotificationsRequest::release_cacheable_cursor() {
  // @@protoc_insertion_point(field_release:nakama.api.ListNotificationsRequest.cacheable_cursor)
  
  return cacheable_cursor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListNotificationsRequest::set_allocated_cacheable_cursor(::std::string* cacheable_cursor) {
  if (cacheable_cursor != NULL) {
    
  } else {
    
  }
  cacheable_cursor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cacheable_cursor);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ListNotificationsRequest.cacheable_cursor)
}

// -------------------------------------------------------------------

// ListStorageObjectsRequest

// string user_id = 1;
inline void ListStorageObjectsRequest::clear_user_id() {
  user_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ListStorageObjectsRequest::user_id() const {
  // @@protoc_insertion_point(field_get:nakama.api.ListStorageObjectsRequest.user_id)
  return user_id_.GetNoArena();
}
inline void ListStorageObjectsRequest::set_user_id(const ::std::string& value) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.ListStorageObjectsRequest.user_id)
}
#if LANG_CXX11
inline void ListStorageObjectsRequest::set_user_id(::std::string&& value) {
  
  user_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.ListStorageObjectsRequest.user_id)
}
#endif
inline void ListStorageObjectsRequest::set_user_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.ListStorageObjectsRequest.user_id)
}
inline void ListStorageObjectsRequest::set_user_id(const char* value, size_t size) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.ListStorageObjectsRequest.user_id)
}
inline ::std::string* ListStorageObjectsRequest::mutable_user_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.ListStorageObjectsRequest.user_id)
  return user_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ListStorageObjectsRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:nakama.api.ListStorageObjectsRequest.user_id)
  
  return user_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListStorageObjectsRequest::set_allocated_user_id(::std::string* user_id) {
  if (user_id != NULL) {
    
  } else {
    
  }
  user_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ListStorageObjectsRequest.user_id)
}

// string collection = 2;
inline void ListStorageObjectsRequest::clear_collection() {
  collection_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ListStorageObjectsRequest::collection() const {
  // @@protoc_insertion_point(field_get:nakama.api.ListStorageObjectsRequest.collection)
  return collection_.GetNoArena();
}
inline void ListStorageObjectsRequest::set_collection(const ::std::string& value) {
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.ListStorageObjectsRequest.collection)
}
#if LANG_CXX11
inline void ListStorageObjectsRequest::set_collection(::std::string&& value) {
  
  collection_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.ListStorageObjectsRequest.collection)
}
#endif
inline void ListStorageObjectsRequest::set_collection(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.ListStorageObjectsRequest.collection)
}
inline void ListStorageObjectsRequest::set_collection(const char* value, size_t size) {
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.ListStorageObjectsRequest.collection)
}
inline ::std::string* ListStorageObjectsRequest::mutable_collection() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.ListStorageObjectsRequest.collection)
  return collection_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ListStorageObjectsRequest::release_collection() {
  // @@protoc_insertion_point(field_release:nakama.api.ListStorageObjectsRequest.collection)
  
  return collection_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListStorageObjectsRequest::set_allocated_collection(::std::string* collection) {
  if (collection != NULL) {
    
  } else {
    
  }
  collection_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), collection);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ListStorageObjectsRequest.collection)
}

// .google.protobuf.Int32Value limit = 3;
inline bool ListStorageObjectsRequest::has_limit() const {
  return this != internal_default_instance() && limit_ != NULL;
}
inline const ::google::protobuf::Int32Value& ListStorageObjectsRequest::_internal_limit() const {
  return *limit_;
}
inline const ::google::protobuf::Int32Value& ListStorageObjectsRequest::limit() const {
  const ::google::protobuf::Int32Value* p = limit_;
  // @@protoc_insertion_point(field_get:nakama.api.ListStorageObjectsRequest.limit)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* ListStorageObjectsRequest::release_limit() {
  // @@protoc_insertion_point(field_release:nakama.api.ListStorageObjectsRequest.limit)
  
  ::google::protobuf::Int32Value* temp = limit_;
  limit_ = NULL;
  return temp;
}
inline ::google::protobuf::Int32Value* ListStorageObjectsRequest::mutable_limit() {
  
  if (limit_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    limit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.ListStorageObjectsRequest.limit)
  return limit_;
}
inline void ListStorageObjectsRequest::set_allocated_limit(::google::protobuf::Int32Value* limit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(limit_);
  }
  if (limit) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(limit)->GetArena();
    if (message_arena != submessage_arena) {
      limit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, limit, submessage_arena);
    }
    
  } else {
    
  }
  limit_ = limit;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ListStorageObjectsRequest.limit)
}

// string cursor = 4;
inline void ListStorageObjectsRequest::clear_cursor() {
  cursor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ListStorageObjectsRequest::cursor() const {
  // @@protoc_insertion_point(field_get:nakama.api.ListStorageObjectsRequest.cursor)
  return cursor_.GetNoArena();
}
inline void ListStorageObjectsRequest::set_cursor(const ::std::string& value) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.ListStorageObjectsRequest.cursor)
}
#if LANG_CXX11
inline void ListStorageObjectsRequest::set_cursor(::std::string&& value) {
  
  cursor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.ListStorageObjectsRequest.cursor)
}
#endif
inline void ListStorageObjectsRequest::set_cursor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.ListStorageObjectsRequest.cursor)
}
inline void ListStorageObjectsRequest::set_cursor(const char* value, size_t size) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.ListStorageObjectsRequest.cursor)
}
inline ::std::string* ListStorageObjectsRequest::mutable_cursor() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.ListStorageObjectsRequest.cursor)
  return cursor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ListStorageObjectsRequest::release_cursor() {
  // @@protoc_insertion_point(field_release:nakama.api.ListStorageObjectsRequest.cursor)
  
  return cursor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListStorageObjectsRequest::set_allocated_cursor(::std::string* cursor) {
  if (cursor != NULL) {
    
  } else {
    
  }
  cursor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cursor);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ListStorageObjectsRequest.cursor)
}

// -------------------------------------------------------------------

// ListTournamentRecordsAroundOwnerRequest

// string tournament_id = 1;
inline void ListTournamentRecordsAroundOwnerRequest::clear_tournament_id() {
  tournament_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ListTournamentRecordsAroundOwnerRequest::tournament_id() const {
  // @@protoc_insertion_point(field_get:nakama.api.ListTournamentRecordsAroundOwnerRequest.tournament_id)
  return tournament_id_.GetNoArena();
}
inline void ListTournamentRecordsAroundOwnerRequest::set_tournament_id(const ::std::string& value) {
  
  tournament_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.ListTournamentRecordsAroundOwnerRequest.tournament_id)
}
#if LANG_CXX11
inline void ListTournamentRecordsAroundOwnerRequest::set_tournament_id(::std::string&& value) {
  
  tournament_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.ListTournamentRecordsAroundOwnerRequest.tournament_id)
}
#endif
inline void ListTournamentRecordsAroundOwnerRequest::set_tournament_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tournament_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.ListTournamentRecordsAroundOwnerRequest.tournament_id)
}
inline void ListTournamentRecordsAroundOwnerRequest::set_tournament_id(const char* value, size_t size) {
  
  tournament_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.ListTournamentRecordsAroundOwnerRequest.tournament_id)
}
inline ::std::string* ListTournamentRecordsAroundOwnerRequest::mutable_tournament_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.ListTournamentRecordsAroundOwnerRequest.tournament_id)
  return tournament_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ListTournamentRecordsAroundOwnerRequest::release_tournament_id() {
  // @@protoc_insertion_point(field_release:nakama.api.ListTournamentRecordsAroundOwnerRequest.tournament_id)
  
  return tournament_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListTournamentRecordsAroundOwnerRequest::set_allocated_tournament_id(::std::string* tournament_id) {
  if (tournament_id != NULL) {
    
  } else {
    
  }
  tournament_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tournament_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ListTournamentRecordsAroundOwnerRequest.tournament_id)
}

// .google.protobuf.UInt32Value limit = 2;
inline bool ListTournamentRecordsAroundOwnerRequest::has_limit() const {
  return this != internal_default_instance() && limit_ != NULL;
}
inline const ::google::protobuf::UInt32Value& ListTournamentRecordsAroundOwnerRequest::_internal_limit() const {
  return *limit_;
}
inline const ::google::protobuf::UInt32Value& ListTournamentRecordsAroundOwnerRequest::limit() const {
  const ::google::protobuf::UInt32Value* p = limit_;
  // @@protoc_insertion_point(field_get:nakama.api.ListTournamentRecordsAroundOwnerRequest.limit)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::UInt32Value*>(
      &::google::protobuf::_UInt32Value_default_instance_);
}
inline ::google::protobuf::UInt32Value* ListTournamentRecordsAroundOwnerRequest::release_limit() {
  // @@protoc_insertion_point(field_release:nakama.api.ListTournamentRecordsAroundOwnerRequest.limit)
  
  ::google::protobuf::UInt32Value* temp = limit_;
  limit_ = NULL;
  return temp;
}
inline ::google::protobuf::UInt32Value* ListTournamentRecordsAroundOwnerRequest::mutable_limit() {
  
  if (limit_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::UInt32Value>(GetArenaNoVirtual());
    limit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.ListTournamentRecordsAroundOwnerRequest.limit)
  return limit_;
}
inline void ListTournamentRecordsAroundOwnerRequest::set_allocated_limit(::google::protobuf::UInt32Value* limit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(limit_);
  }
  if (limit) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(limit)->GetArena();
    if (message_arena != submessage_arena) {
      limit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, limit, submessage_arena);
    }
    
  } else {
    
  }
  limit_ = limit;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ListTournamentRecordsAroundOwnerRequest.limit)
}

// string owner_id = 3;
inline void ListTournamentRecordsAroundOwnerRequest::clear_owner_id() {
  owner_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ListTournamentRecordsAroundOwnerRequest::owner_id() const {
  // @@protoc_insertion_point(field_get:nakama.api.ListTournamentRecordsAroundOwnerRequest.owner_id)
  return owner_id_.GetNoArena();
}
inline void ListTournamentRecordsAroundOwnerRequest::set_owner_id(const ::std::string& value) {
  
  owner_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.ListTournamentRecordsAroundOwnerRequest.owner_id)
}
#if LANG_CXX11
inline void ListTournamentRecordsAroundOwnerRequest::set_owner_id(::std::string&& value) {
  
  owner_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.ListTournamentRecordsAroundOwnerRequest.owner_id)
}
#endif
inline void ListTournamentRecordsAroundOwnerRequest::set_owner_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  owner_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.ListTournamentRecordsAroundOwnerRequest.owner_id)
}
inline void ListTournamentRecordsAroundOwnerRequest::set_owner_id(const char* value, size_t size) {
  
  owner_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.ListTournamentRecordsAroundOwnerRequest.owner_id)
}
inline ::std::string* ListTournamentRecordsAroundOwnerRequest::mutable_owner_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.ListTournamentRecordsAroundOwnerRequest.owner_id)
  return owner_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ListTournamentRecordsAroundOwnerRequest::release_owner_id() {
  // @@protoc_insertion_point(field_release:nakama.api.ListTournamentRecordsAroundOwnerRequest.owner_id)
  
  return owner_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListTournamentRecordsAroundOwnerRequest::set_allocated_owner_id(::std::string* owner_id) {
  if (owner_id != NULL) {
    
  } else {
    
  }
  owner_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), owner_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ListTournamentRecordsAroundOwnerRequest.owner_id)
}

// -------------------------------------------------------------------

// ListTournamentRecordsRequest

// string tournament_id = 1;
inline void ListTournamentRecordsRequest::clear_tournament_id() {
  tournament_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ListTournamentRecordsRequest::tournament_id() const {
  // @@protoc_insertion_point(field_get:nakama.api.ListTournamentRecordsRequest.tournament_id)
  return tournament_id_.GetNoArena();
}
inline void ListTournamentRecordsRequest::set_tournament_id(const ::std::string& value) {
  
  tournament_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.ListTournamentRecordsRequest.tournament_id)
}
#if LANG_CXX11
inline void ListTournamentRecordsRequest::set_tournament_id(::std::string&& value) {
  
  tournament_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.ListTournamentRecordsRequest.tournament_id)
}
#endif
inline void ListTournamentRecordsRequest::set_tournament_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tournament_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.ListTournamentRecordsRequest.tournament_id)
}
inline void ListTournamentRecordsRequest::set_tournament_id(const char* value, size_t size) {
  
  tournament_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.ListTournamentRecordsRequest.tournament_id)
}
inline ::std::string* ListTournamentRecordsRequest::mutable_tournament_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.ListTournamentRecordsRequest.tournament_id)
  return tournament_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ListTournamentRecordsRequest::release_tournament_id() {
  // @@protoc_insertion_point(field_release:nakama.api.ListTournamentRecordsRequest.tournament_id)
  
  return tournament_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListTournamentRecordsRequest::set_allocated_tournament_id(::std::string* tournament_id) {
  if (tournament_id != NULL) {
    
  } else {
    
  }
  tournament_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tournament_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ListTournamentRecordsRequest.tournament_id)
}

// repeated string owner_ids = 2;
inline int ListTournamentRecordsRequest::owner_ids_size() const {
  return owner_ids_.size();
}
inline void ListTournamentRecordsRequest::clear_owner_ids() {
  owner_ids_.Clear();
}
inline const ::std::string& ListTournamentRecordsRequest::owner_ids(int index) const {
  // @@protoc_insertion_point(field_get:nakama.api.ListTournamentRecordsRequest.owner_ids)
  return owner_ids_.Get(index);
}
inline ::std::string* ListTournamentRecordsRequest::mutable_owner_ids(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.api.ListTournamentRecordsRequest.owner_ids)
  return owner_ids_.Mutable(index);
}
inline void ListTournamentRecordsRequest::set_owner_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:nakama.api.ListTournamentRecordsRequest.owner_ids)
  owner_ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ListTournamentRecordsRequest::set_owner_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:nakama.api.ListTournamentRecordsRequest.owner_ids)
  owner_ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ListTournamentRecordsRequest::set_owner_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  owner_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nakama.api.ListTournamentRecordsRequest.owner_ids)
}
inline void ListTournamentRecordsRequest::set_owner_ids(int index, const char* value, size_t size) {
  owner_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nakama.api.ListTournamentRecordsRequest.owner_ids)
}
inline ::std::string* ListTournamentRecordsRequest::add_owner_ids() {
  // @@protoc_insertion_point(field_add_mutable:nakama.api.ListTournamentRecordsRequest.owner_ids)
  return owner_ids_.Add();
}
inline void ListTournamentRecordsRequest::add_owner_ids(const ::std::string& value) {
  owner_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:nakama.api.ListTournamentRecordsRequest.owner_ids)
}
#if LANG_CXX11
inline void ListTournamentRecordsRequest::add_owner_ids(::std::string&& value) {
  owner_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:nakama.api.ListTournamentRecordsRequest.owner_ids)
}
#endif
inline void ListTournamentRecordsRequest::add_owner_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  owner_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nakama.api.ListTournamentRecordsRequest.owner_ids)
}
inline void ListTournamentRecordsRequest::add_owner_ids(const char* value, size_t size) {
  owner_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nakama.api.ListTournamentRecordsRequest.owner_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ListTournamentRecordsRequest::owner_ids() const {
  // @@protoc_insertion_point(field_list:nakama.api.ListTournamentRecordsRequest.owner_ids)
  return owner_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ListTournamentRecordsRequest::mutable_owner_ids() {
  // @@protoc_insertion_point(field_mutable_list:nakama.api.ListTournamentRecordsRequest.owner_ids)
  return &owner_ids_;
}

// .google.protobuf.Int32Value limit = 3;
inline bool ListTournamentRecordsRequest::has_limit() const {
  return this != internal_default_instance() && limit_ != NULL;
}
inline const ::google::protobuf::Int32Value& ListTournamentRecordsRequest::_internal_limit() const {
  return *limit_;
}
inline const ::google::protobuf::Int32Value& ListTournamentRecordsRequest::limit() const {
  const ::google::protobuf::Int32Value* p = limit_;
  // @@protoc_insertion_point(field_get:nakama.api.ListTournamentRecordsRequest.limit)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* ListTournamentRecordsRequest::release_limit() {
  // @@protoc_insertion_point(field_release:nakama.api.ListTournamentRecordsRequest.limit)
  
  ::google::protobuf::Int32Value* temp = limit_;
  limit_ = NULL;
  return temp;
}
inline ::google::protobuf::Int32Value* ListTournamentRecordsRequest::mutable_limit() {
  
  if (limit_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    limit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.ListTournamentRecordsRequest.limit)
  return limit_;
}
inline void ListTournamentRecordsRequest::set_allocated_limit(::google::protobuf::Int32Value* limit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(limit_);
  }
  if (limit) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(limit)->GetArena();
    if (message_arena != submessage_arena) {
      limit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, limit, submessage_arena);
    }
    
  } else {
    
  }
  limit_ = limit;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ListTournamentRecordsRequest.limit)
}

// string cursor = 4;
inline void ListTournamentRecordsRequest::clear_cursor() {
  cursor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ListTournamentRecordsRequest::cursor() const {
  // @@protoc_insertion_point(field_get:nakama.api.ListTournamentRecordsRequest.cursor)
  return cursor_.GetNoArena();
}
inline void ListTournamentRecordsRequest::set_cursor(const ::std::string& value) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.ListTournamentRecordsRequest.cursor)
}
#if LANG_CXX11
inline void ListTournamentRecordsRequest::set_cursor(::std::string&& value) {
  
  cursor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.ListTournamentRecordsRequest.cursor)
}
#endif
inline void ListTournamentRecordsRequest::set_cursor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.ListTournamentRecordsRequest.cursor)
}
inline void ListTournamentRecordsRequest::set_cursor(const char* value, size_t size) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.ListTournamentRecordsRequest.cursor)
}
inline ::std::string* ListTournamentRecordsRequest::mutable_cursor() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.ListTournamentRecordsRequest.cursor)
  return cursor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ListTournamentRecordsRequest::release_cursor() {
  // @@protoc_insertion_point(field_release:nakama.api.ListTournamentRecordsRequest.cursor)
  
  return cursor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListTournamentRecordsRequest::set_allocated_cursor(::std::string* cursor) {
  if (cursor != NULL) {
    
  } else {
    
  }
  cursor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cursor);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ListTournamentRecordsRequest.cursor)
}

// -------------------------------------------------------------------

// ListTournamentsRequest

// .google.protobuf.UInt32Value category_start = 1;
inline bool ListTournamentsRequest::has_category_start() const {
  return this != internal_default_instance() && category_start_ != NULL;
}
inline const ::google::protobuf::UInt32Value& ListTournamentsRequest::_internal_category_start() const {
  return *category_start_;
}
inline const ::google::protobuf::UInt32Value& ListTournamentsRequest::category_start() const {
  const ::google::protobuf::UInt32Value* p = category_start_;
  // @@protoc_insertion_point(field_get:nakama.api.ListTournamentsRequest.category_start)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::UInt32Value*>(
      &::google::protobuf::_UInt32Value_default_instance_);
}
inline ::google::protobuf::UInt32Value* ListTournamentsRequest::release_category_start() {
  // @@protoc_insertion_point(field_release:nakama.api.ListTournamentsRequest.category_start)
  
  ::google::protobuf::UInt32Value* temp = category_start_;
  category_start_ = NULL;
  return temp;
}
inline ::google::protobuf::UInt32Value* ListTournamentsRequest::mutable_category_start() {
  
  if (category_start_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::UInt32Value>(GetArenaNoVirtual());
    category_start_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.ListTournamentsRequest.category_start)
  return category_start_;
}
inline void ListTournamentsRequest::set_allocated_category_start(::google::protobuf::UInt32Value* category_start) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(category_start_);
  }
  if (category_start) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(category_start)->GetArena();
    if (message_arena != submessage_arena) {
      category_start = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, category_start, submessage_arena);
    }
    
  } else {
    
  }
  category_start_ = category_start;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ListTournamentsRequest.category_start)
}

// .google.protobuf.UInt32Value category_end = 2;
inline bool ListTournamentsRequest::has_category_end() const {
  return this != internal_default_instance() && category_end_ != NULL;
}
inline const ::google::protobuf::UInt32Value& ListTournamentsRequest::_internal_category_end() const {
  return *category_end_;
}
inline const ::google::protobuf::UInt32Value& ListTournamentsRequest::category_end() const {
  const ::google::protobuf::UInt32Value* p = category_end_;
  // @@protoc_insertion_point(field_get:nakama.api.ListTournamentsRequest.category_end)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::UInt32Value*>(
      &::google::protobuf::_UInt32Value_default_instance_);
}
inline ::google::protobuf::UInt32Value* ListTournamentsRequest::release_category_end() {
  // @@protoc_insertion_point(field_release:nakama.api.ListTournamentsRequest.category_end)
  
  ::google::protobuf::UInt32Value* temp = category_end_;
  category_end_ = NULL;
  return temp;
}
inline ::google::protobuf::UInt32Value* ListTournamentsRequest::mutable_category_end() {
  
  if (category_end_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::UInt32Value>(GetArenaNoVirtual());
    category_end_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.ListTournamentsRequest.category_end)
  return category_end_;
}
inline void ListTournamentsRequest::set_allocated_category_end(::google::protobuf::UInt32Value* category_end) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(category_end_);
  }
  if (category_end) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(category_end)->GetArena();
    if (message_arena != submessage_arena) {
      category_end = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, category_end, submessage_arena);
    }
    
  } else {
    
  }
  category_end_ = category_end;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ListTournamentsRequest.category_end)
}

// .google.protobuf.UInt32Value start_time = 3;
inline bool ListTournamentsRequest::has_start_time() const {
  return this != internal_default_instance() && start_time_ != NULL;
}
inline const ::google::protobuf::UInt32Value& ListTournamentsRequest::_internal_start_time() const {
  return *start_time_;
}
inline const ::google::protobuf::UInt32Value& ListTournamentsRequest::start_time() const {
  const ::google::protobuf::UInt32Value* p = start_time_;
  // @@protoc_insertion_point(field_get:nakama.api.ListTournamentsRequest.start_time)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::UInt32Value*>(
      &::google::protobuf::_UInt32Value_default_instance_);
}
inline ::google::protobuf::UInt32Value* ListTournamentsRequest::release_start_time() {
  // @@protoc_insertion_point(field_release:nakama.api.ListTournamentsRequest.start_time)
  
  ::google::protobuf::UInt32Value* temp = start_time_;
  start_time_ = NULL;
  return temp;
}
inline ::google::protobuf::UInt32Value* ListTournamentsRequest::mutable_start_time() {
  
  if (start_time_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::UInt32Value>(GetArenaNoVirtual());
    start_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.ListTournamentsRequest.start_time)
  return start_time_;
}
inline void ListTournamentsRequest::set_allocated_start_time(::google::protobuf::UInt32Value* start_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(start_time_);
  }
  if (start_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(start_time)->GetArena();
    if (message_arena != submessage_arena) {
      start_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ListTournamentsRequest.start_time)
}

// .google.protobuf.UInt32Value end_time = 4;
inline bool ListTournamentsRequest::has_end_time() const {
  return this != internal_default_instance() && end_time_ != NULL;
}
inline const ::google::protobuf::UInt32Value& ListTournamentsRequest::_internal_end_time() const {
  return *end_time_;
}
inline const ::google::protobuf::UInt32Value& ListTournamentsRequest::end_time() const {
  const ::google::protobuf::UInt32Value* p = end_time_;
  // @@protoc_insertion_point(field_get:nakama.api.ListTournamentsRequest.end_time)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::UInt32Value*>(
      &::google::protobuf::_UInt32Value_default_instance_);
}
inline ::google::protobuf::UInt32Value* ListTournamentsRequest::release_end_time() {
  // @@protoc_insertion_point(field_release:nakama.api.ListTournamentsRequest.end_time)
  
  ::google::protobuf::UInt32Value* temp = end_time_;
  end_time_ = NULL;
  return temp;
}
inline ::google::protobuf::UInt32Value* ListTournamentsRequest::mutable_end_time() {
  
  if (end_time_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::UInt32Value>(GetArenaNoVirtual());
    end_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.ListTournamentsRequest.end_time)
  return end_time_;
}
inline void ListTournamentsRequest::set_allocated_end_time(::google::protobuf::UInt32Value* end_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(end_time_);
  }
  if (end_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(end_time)->GetArena();
    if (message_arena != submessage_arena) {
      end_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, end_time, submessage_arena);
    }
    
  } else {
    
  }
  end_time_ = end_time;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ListTournamentsRequest.end_time)
}

// .google.protobuf.Int32Value limit = 6;
inline bool ListTournamentsRequest::has_limit() const {
  return this != internal_default_instance() && limit_ != NULL;
}
inline const ::google::protobuf::Int32Value& ListTournamentsRequest::_internal_limit() const {
  return *limit_;
}
inline const ::google::protobuf::Int32Value& ListTournamentsRequest::limit() const {
  const ::google::protobuf::Int32Value* p = limit_;
  // @@protoc_insertion_point(field_get:nakama.api.ListTournamentsRequest.limit)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* ListTournamentsRequest::release_limit() {
  // @@protoc_insertion_point(field_release:nakama.api.ListTournamentsRequest.limit)
  
  ::google::protobuf::Int32Value* temp = limit_;
  limit_ = NULL;
  return temp;
}
inline ::google::protobuf::Int32Value* ListTournamentsRequest::mutable_limit() {
  
  if (limit_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    limit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.ListTournamentsRequest.limit)
  return limit_;
}
inline void ListTournamentsRequest::set_allocated_limit(::google::protobuf::Int32Value* limit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(limit_);
  }
  if (limit) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(limit)->GetArena();
    if (message_arena != submessage_arena) {
      limit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, limit, submessage_arena);
    }
    
  } else {
    
  }
  limit_ = limit;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ListTournamentsRequest.limit)
}

// string cursor = 8;
inline void ListTournamentsRequest::clear_cursor() {
  cursor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ListTournamentsRequest::cursor() const {
  // @@protoc_insertion_point(field_get:nakama.api.ListTournamentsRequest.cursor)
  return cursor_.GetNoArena();
}
inline void ListTournamentsRequest::set_cursor(const ::std::string& value) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.ListTournamentsRequest.cursor)
}
#if LANG_CXX11
inline void ListTournamentsRequest::set_cursor(::std::string&& value) {
  
  cursor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.ListTournamentsRequest.cursor)
}
#endif
inline void ListTournamentsRequest::set_cursor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.ListTournamentsRequest.cursor)
}
inline void ListTournamentsRequest::set_cursor(const char* value, size_t size) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.ListTournamentsRequest.cursor)
}
inline ::std::string* ListTournamentsRequest::mutable_cursor() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.ListTournamentsRequest.cursor)
  return cursor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ListTournamentsRequest::release_cursor() {
  // @@protoc_insertion_point(field_release:nakama.api.ListTournamentsRequest.cursor)
  
  return cursor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListTournamentsRequest::set_allocated_cursor(::std::string* cursor) {
  if (cursor != NULL) {
    
  } else {
    
  }
  cursor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cursor);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ListTournamentsRequest.cursor)
}

// -------------------------------------------------------------------

// ListUserGroupsRequest

// string user_id = 1;
inline void ListUserGroupsRequest::clear_user_id() {
  user_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ListUserGroupsRequest::user_id() const {
  // @@protoc_insertion_point(field_get:nakama.api.ListUserGroupsRequest.user_id)
  return user_id_.GetNoArena();
}
inline void ListUserGroupsRequest::set_user_id(const ::std::string& value) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.ListUserGroupsRequest.user_id)
}
#if LANG_CXX11
inline void ListUserGroupsRequest::set_user_id(::std::string&& value) {
  
  user_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.ListUserGroupsRequest.user_id)
}
#endif
inline void ListUserGroupsRequest::set_user_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.ListUserGroupsRequest.user_id)
}
inline void ListUserGroupsRequest::set_user_id(const char* value, size_t size) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.ListUserGroupsRequest.user_id)
}
inline ::std::string* ListUserGroupsRequest::mutable_user_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.ListUserGroupsRequest.user_id)
  return user_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ListUserGroupsRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:nakama.api.ListUserGroupsRequest.user_id)
  
  return user_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListUserGroupsRequest::set_allocated_user_id(::std::string* user_id) {
  if (user_id != NULL) {
    
  } else {
    
  }
  user_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ListUserGroupsRequest.user_id)
}

// -------------------------------------------------------------------

// Match

// string match_id = 1;
inline void Match::clear_match_id() {
  match_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Match::match_id() const {
  // @@protoc_insertion_point(field_get:nakama.api.Match.match_id)
  return match_id_.GetNoArena();
}
inline void Match::set_match_id(const ::std::string& value) {
  
  match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.Match.match_id)
}
#if LANG_CXX11
inline void Match::set_match_id(::std::string&& value) {
  
  match_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.Match.match_id)
}
#endif
inline void Match::set_match_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.Match.match_id)
}
inline void Match::set_match_id(const char* value, size_t size) {
  
  match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.Match.match_id)
}
inline ::std::string* Match::mutable_match_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.Match.match_id)
  return match_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Match::release_match_id() {
  // @@protoc_insertion_point(field_release:nakama.api.Match.match_id)
  
  return match_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Match::set_allocated_match_id(::std::string* match_id) {
  if (match_id != NULL) {
    
  } else {
    
  }
  match_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), match_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.Match.match_id)
}

// bool authoritative = 2;
inline void Match::clear_authoritative() {
  authoritative_ = false;
}
inline bool Match::authoritative() const {
  // @@protoc_insertion_point(field_get:nakama.api.Match.authoritative)
  return authoritative_;
}
inline void Match::set_authoritative(bool value) {
  
  authoritative_ = value;
  // @@protoc_insertion_point(field_set:nakama.api.Match.authoritative)
}

// .google.protobuf.StringValue label = 3;
inline bool Match::has_label() const {
  return this != internal_default_instance() && label_ != NULL;
}
inline const ::google::protobuf::StringValue& Match::_internal_label() const {
  return *label_;
}
inline const ::google::protobuf::StringValue& Match::label() const {
  const ::google::protobuf::StringValue* p = label_;
  // @@protoc_insertion_point(field_get:nakama.api.Match.label)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::StringValue*>(
      &::google::protobuf::_StringValue_default_instance_);
}
inline ::google::protobuf::StringValue* Match::release_label() {
  // @@protoc_insertion_point(field_release:nakama.api.Match.label)
  
  ::google::protobuf::StringValue* temp = label_;
  label_ = NULL;
  return temp;
}
inline ::google::protobuf::StringValue* Match::mutable_label() {
  
  if (label_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::StringValue>(GetArenaNoVirtual());
    label_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.Match.label)
  return label_;
}
inline void Match::set_allocated_label(::google::protobuf::StringValue* label) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(label_);
  }
  if (label) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(label)->GetArena();
    if (message_arena != submessage_arena) {
      label = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, label, submessage_arena);
    }
    
  } else {
    
  }
  label_ = label;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.Match.label)
}

// int32 size = 4;
inline void Match::clear_size() {
  size_ = 0;
}
inline ::google::protobuf::int32 Match::size() const {
  // @@protoc_insertion_point(field_get:nakama.api.Match.size)
  return size_;
}
inline void Match::set_size(::google::protobuf::int32 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:nakama.api.Match.size)
}

// -------------------------------------------------------------------

// MatchList

// repeated .nakama.api.Match matches = 1;
inline int MatchList::matches_size() const {
  return matches_.size();
}
inline void MatchList::clear_matches() {
  matches_.Clear();
}
inline ::nakama::api::Match* MatchList::mutable_matches(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.api.MatchList.matches)
  return matches_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nakama::api::Match >*
MatchList::mutable_matches() {
  // @@protoc_insertion_point(field_mutable_list:nakama.api.MatchList.matches)
  return &matches_;
}
inline const ::nakama::api::Match& MatchList::matches(int index) const {
  // @@protoc_insertion_point(field_get:nakama.api.MatchList.matches)
  return matches_.Get(index);
}
inline ::nakama::api::Match* MatchList::add_matches() {
  // @@protoc_insertion_point(field_add:nakama.api.MatchList.matches)
  return matches_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nakama::api::Match >&
MatchList::matches() const {
  // @@protoc_insertion_point(field_list:nakama.api.MatchList.matches)
  return matches_;
}

// -------------------------------------------------------------------

// Notification

// string id = 1;
inline void Notification::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Notification::id() const {
  // @@protoc_insertion_point(field_get:nakama.api.Notification.id)
  return id_.GetNoArena();
}
inline void Notification::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.Notification.id)
}
#if LANG_CXX11
inline void Notification::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.Notification.id)
}
#endif
inline void Notification::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.Notification.id)
}
inline void Notification::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.Notification.id)
}
inline ::std::string* Notification::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.Notification.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Notification::release_id() {
  // @@protoc_insertion_point(field_release:nakama.api.Notification.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Notification::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.Notification.id)
}

// string subject = 2;
inline void Notification::clear_subject() {
  subject_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Notification::subject() const {
  // @@protoc_insertion_point(field_get:nakama.api.Notification.subject)
  return subject_.GetNoArena();
}
inline void Notification::set_subject(const ::std::string& value) {
  
  subject_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.Notification.subject)
}
#if LANG_CXX11
inline void Notification::set_subject(::std::string&& value) {
  
  subject_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.Notification.subject)
}
#endif
inline void Notification::set_subject(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  subject_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.Notification.subject)
}
inline void Notification::set_subject(const char* value, size_t size) {
  
  subject_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.Notification.subject)
}
inline ::std::string* Notification::mutable_subject() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.Notification.subject)
  return subject_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Notification::release_subject() {
  // @@protoc_insertion_point(field_release:nakama.api.Notification.subject)
  
  return subject_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Notification::set_allocated_subject(::std::string* subject) {
  if (subject != NULL) {
    
  } else {
    
  }
  subject_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), subject);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.Notification.subject)
}

// string content = 3;
inline void Notification::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Notification::content() const {
  // @@protoc_insertion_point(field_get:nakama.api.Notification.content)
  return content_.GetNoArena();
}
inline void Notification::set_content(const ::std::string& value) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.Notification.content)
}
#if LANG_CXX11
inline void Notification::set_content(::std::string&& value) {
  
  content_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.Notification.content)
}
#endif
inline void Notification::set_content(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.Notification.content)
}
inline void Notification::set_content(const char* value, size_t size) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.Notification.content)
}
inline ::std::string* Notification::mutable_content() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.Notification.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Notification::release_content() {
  // @@protoc_insertion_point(field_release:nakama.api.Notification.content)
  
  return content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Notification::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    
  } else {
    
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.Notification.content)
}

// int32 code = 4;
inline void Notification::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 Notification::code() const {
  // @@protoc_insertion_point(field_get:nakama.api.Notification.code)
  return code_;
}
inline void Notification::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:nakama.api.Notification.code)
}

// string sender_id = 5;
inline void Notification::clear_sender_id() {
  sender_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Notification::sender_id() const {
  // @@protoc_insertion_point(field_get:nakama.api.Notification.sender_id)
  return sender_id_.GetNoArena();
}
inline void Notification::set_sender_id(const ::std::string& value) {
  
  sender_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.Notification.sender_id)
}
#if LANG_CXX11
inline void Notification::set_sender_id(::std::string&& value) {
  
  sender_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.Notification.sender_id)
}
#endif
inline void Notification::set_sender_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sender_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.Notification.sender_id)
}
inline void Notification::set_sender_id(const char* value, size_t size) {
  
  sender_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.Notification.sender_id)
}
inline ::std::string* Notification::mutable_sender_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.Notification.sender_id)
  return sender_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Notification::release_sender_id() {
  // @@protoc_insertion_point(field_release:nakama.api.Notification.sender_id)
  
  return sender_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Notification::set_allocated_sender_id(::std::string* sender_id) {
  if (sender_id != NULL) {
    
  } else {
    
  }
  sender_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sender_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.Notification.sender_id)
}

// .google.protobuf.Timestamp create_time = 6;
inline bool Notification::has_create_time() const {
  return this != internal_default_instance() && create_time_ != NULL;
}
inline const ::google::protobuf::Timestamp& Notification::_internal_create_time() const {
  return *create_time_;
}
inline const ::google::protobuf::Timestamp& Notification::create_time() const {
  const ::google::protobuf::Timestamp* p = create_time_;
  // @@protoc_insertion_point(field_get:nakama.api.Notification.create_time)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* Notification::release_create_time() {
  // @@protoc_insertion_point(field_release:nakama.api.Notification.create_time)
  
  ::google::protobuf::Timestamp* temp = create_time_;
  create_time_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* Notification::mutable_create_time() {
  
  if (create_time_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    create_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.Notification.create_time)
  return create_time_;
}
inline void Notification::set_allocated_create_time(::google::protobuf::Timestamp* create_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(create_time_);
  }
  if (create_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(create_time)->GetArena();
    if (message_arena != submessage_arena) {
      create_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, create_time, submessage_arena);
    }
    
  } else {
    
  }
  create_time_ = create_time;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.Notification.create_time)
}

// bool persistent = 7;
inline void Notification::clear_persistent() {
  persistent_ = false;
}
inline bool Notification::persistent() const {
  // @@protoc_insertion_point(field_get:nakama.api.Notification.persistent)
  return persistent_;
}
inline void Notification::set_persistent(bool value) {
  
  persistent_ = value;
  // @@protoc_insertion_point(field_set:nakama.api.Notification.persistent)
}

// -------------------------------------------------------------------

// NotificationList

// repeated .nakama.api.Notification notifications = 1;
inline int NotificationList::notifications_size() const {
  return notifications_.size();
}
inline void NotificationList::clear_notifications() {
  notifications_.Clear();
}
inline ::nakama::api::Notification* NotificationList::mutable_notifications(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.api.NotificationList.notifications)
  return notifications_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nakama::api::Notification >*
NotificationList::mutable_notifications() {
  // @@protoc_insertion_point(field_mutable_list:nakama.api.NotificationList.notifications)
  return &notifications_;
}
inline const ::nakama::api::Notification& NotificationList::notifications(int index) const {
  // @@protoc_insertion_point(field_get:nakama.api.NotificationList.notifications)
  return notifications_.Get(index);
}
inline ::nakama::api::Notification* NotificationList::add_notifications() {
  // @@protoc_insertion_point(field_add:nakama.api.NotificationList.notifications)
  return notifications_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nakama::api::Notification >&
NotificationList::notifications() const {
  // @@protoc_insertion_point(field_list:nakama.api.NotificationList.notifications)
  return notifications_;
}

// string cacheable_cursor = 2;
inline void NotificationList::clear_cacheable_cursor() {
  cacheable_cursor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NotificationList::cacheable_cursor() const {
  // @@protoc_insertion_point(field_get:nakama.api.NotificationList.cacheable_cursor)
  return cacheable_cursor_.GetNoArena();
}
inline void NotificationList::set_cacheable_cursor(const ::std::string& value) {
  
  cacheable_cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.NotificationList.cacheable_cursor)
}
#if LANG_CXX11
inline void NotificationList::set_cacheable_cursor(::std::string&& value) {
  
  cacheable_cursor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.NotificationList.cacheable_cursor)
}
#endif
inline void NotificationList::set_cacheable_cursor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cacheable_cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.NotificationList.cacheable_cursor)
}
inline void NotificationList::set_cacheable_cursor(const char* value, size_t size) {
  
  cacheable_cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.NotificationList.cacheable_cursor)
}
inline ::std::string* NotificationList::mutable_cacheable_cursor() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.NotificationList.cacheable_cursor)
  return cacheable_cursor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NotificationList::release_cacheable_cursor() {
  // @@protoc_insertion_point(field_release:nakama.api.NotificationList.cacheable_cursor)
  
  return cacheable_cursor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NotificationList::set_allocated_cacheable_cursor(::std::string* cacheable_cursor) {
  if (cacheable_cursor != NULL) {
    
  } else {
    
  }
  cacheable_cursor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cacheable_cursor);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.NotificationList.cacheable_cursor)
}

// -------------------------------------------------------------------

// PromoteGroupUsersRequest

// string group_id = 1;
inline void PromoteGroupUsersRequest::clear_group_id() {
  group_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PromoteGroupUsersRequest::group_id() const {
  // @@protoc_insertion_point(field_get:nakama.api.PromoteGroupUsersRequest.group_id)
  return group_id_.GetNoArena();
}
inline void PromoteGroupUsersRequest::set_group_id(const ::std::string& value) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.PromoteGroupUsersRequest.group_id)
}
#if LANG_CXX11
inline void PromoteGroupUsersRequest::set_group_id(::std::string&& value) {
  
  group_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.PromoteGroupUsersRequest.group_id)
}
#endif
inline void PromoteGroupUsersRequest::set_group_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.PromoteGroupUsersRequest.group_id)
}
inline void PromoteGroupUsersRequest::set_group_id(const char* value, size_t size) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.PromoteGroupUsersRequest.group_id)
}
inline ::std::string* PromoteGroupUsersRequest::mutable_group_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.PromoteGroupUsersRequest.group_id)
  return group_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PromoteGroupUsersRequest::release_group_id() {
  // @@protoc_insertion_point(field_release:nakama.api.PromoteGroupUsersRequest.group_id)
  
  return group_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PromoteGroupUsersRequest::set_allocated_group_id(::std::string* group_id) {
  if (group_id != NULL) {
    
  } else {
    
  }
  group_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), group_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.PromoteGroupUsersRequest.group_id)
}

// repeated string user_ids = 2;
inline int PromoteGroupUsersRequest::user_ids_size() const {
  return user_ids_.size();
}
inline void PromoteGroupUsersRequest::clear_user_ids() {
  user_ids_.Clear();
}
inline const ::std::string& PromoteGroupUsersRequest::user_ids(int index) const {
  // @@protoc_insertion_point(field_get:nakama.api.PromoteGroupUsersRequest.user_ids)
  return user_ids_.Get(index);
}
inline ::std::string* PromoteGroupUsersRequest::mutable_user_ids(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.api.PromoteGroupUsersRequest.user_ids)
  return user_ids_.Mutable(index);
}
inline void PromoteGroupUsersRequest::set_user_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:nakama.api.PromoteGroupUsersRequest.user_ids)
  user_ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void PromoteGroupUsersRequest::set_user_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:nakama.api.PromoteGroupUsersRequest.user_ids)
  user_ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void PromoteGroupUsersRequest::set_user_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  user_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nakama.api.PromoteGroupUsersRequest.user_ids)
}
inline void PromoteGroupUsersRequest::set_user_ids(int index, const char* value, size_t size) {
  user_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nakama.api.PromoteGroupUsersRequest.user_ids)
}
inline ::std::string* PromoteGroupUsersRequest::add_user_ids() {
  // @@protoc_insertion_point(field_add_mutable:nakama.api.PromoteGroupUsersRequest.user_ids)
  return user_ids_.Add();
}
inline void PromoteGroupUsersRequest::add_user_ids(const ::std::string& value) {
  user_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:nakama.api.PromoteGroupUsersRequest.user_ids)
}
#if LANG_CXX11
inline void PromoteGroupUsersRequest::add_user_ids(::std::string&& value) {
  user_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:nakama.api.PromoteGroupUsersRequest.user_ids)
}
#endif
inline void PromoteGroupUsersRequest::add_user_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  user_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nakama.api.PromoteGroupUsersRequest.user_ids)
}
inline void PromoteGroupUsersRequest::add_user_ids(const char* value, size_t size) {
  user_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nakama.api.PromoteGroupUsersRequest.user_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PromoteGroupUsersRequest::user_ids() const {
  // @@protoc_insertion_point(field_list:nakama.api.PromoteGroupUsersRequest.user_ids)
  return user_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PromoteGroupUsersRequest::mutable_user_ids() {
  // @@protoc_insertion_point(field_mutable_list:nakama.api.PromoteGroupUsersRequest.user_ids)
  return &user_ids_;
}

// -------------------------------------------------------------------

// ReadStorageObjectId

// string collection = 1;
inline void ReadStorageObjectId::clear_collection() {
  collection_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReadStorageObjectId::collection() const {
  // @@protoc_insertion_point(field_get:nakama.api.ReadStorageObjectId.collection)
  return collection_.GetNoArena();
}
inline void ReadStorageObjectId::set_collection(const ::std::string& value) {
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.ReadStorageObjectId.collection)
}
#if LANG_CXX11
inline void ReadStorageObjectId::set_collection(::std::string&& value) {
  
  collection_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.ReadStorageObjectId.collection)
}
#endif
inline void ReadStorageObjectId::set_collection(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.ReadStorageObjectId.collection)
}
inline void ReadStorageObjectId::set_collection(const char* value, size_t size) {
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.ReadStorageObjectId.collection)
}
inline ::std::string* ReadStorageObjectId::mutable_collection() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.ReadStorageObjectId.collection)
  return collection_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReadStorageObjectId::release_collection() {
  // @@protoc_insertion_point(field_release:nakama.api.ReadStorageObjectId.collection)
  
  return collection_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReadStorageObjectId::set_allocated_collection(::std::string* collection) {
  if (collection != NULL) {
    
  } else {
    
  }
  collection_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), collection);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ReadStorageObjectId.collection)
}

// string key = 2;
inline void ReadStorageObjectId::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReadStorageObjectId::key() const {
  // @@protoc_insertion_point(field_get:nakama.api.ReadStorageObjectId.key)
  return key_.GetNoArena();
}
inline void ReadStorageObjectId::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.ReadStorageObjectId.key)
}
#if LANG_CXX11
inline void ReadStorageObjectId::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.ReadStorageObjectId.key)
}
#endif
inline void ReadStorageObjectId::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.ReadStorageObjectId.key)
}
inline void ReadStorageObjectId::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.ReadStorageObjectId.key)
}
inline ::std::string* ReadStorageObjectId::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.ReadStorageObjectId.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReadStorageObjectId::release_key() {
  // @@protoc_insertion_point(field_release:nakama.api.ReadStorageObjectId.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReadStorageObjectId::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ReadStorageObjectId.key)
}

// string user_id = 3;
inline void ReadStorageObjectId::clear_user_id() {
  user_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReadStorageObjectId::user_id() const {
  // @@protoc_insertion_point(field_get:nakama.api.ReadStorageObjectId.user_id)
  return user_id_.GetNoArena();
}
inline void ReadStorageObjectId::set_user_id(const ::std::string& value) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.ReadStorageObjectId.user_id)
}
#if LANG_CXX11
inline void ReadStorageObjectId::set_user_id(::std::string&& value) {
  
  user_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.ReadStorageObjectId.user_id)
}
#endif
inline void ReadStorageObjectId::set_user_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.ReadStorageObjectId.user_id)
}
inline void ReadStorageObjectId::set_user_id(const char* value, size_t size) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.ReadStorageObjectId.user_id)
}
inline ::std::string* ReadStorageObjectId::mutable_user_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.ReadStorageObjectId.user_id)
  return user_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReadStorageObjectId::release_user_id() {
  // @@protoc_insertion_point(field_release:nakama.api.ReadStorageObjectId.user_id)
  
  return user_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReadStorageObjectId::set_allocated_user_id(::std::string* user_id) {
  if (user_id != NULL) {
    
  } else {
    
  }
  user_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.ReadStorageObjectId.user_id)
}

// -------------------------------------------------------------------

// ReadStorageObjectsRequest

// repeated .nakama.api.ReadStorageObjectId object_ids = 1;
inline int ReadStorageObjectsRequest::object_ids_size() const {
  return object_ids_.size();
}
inline void ReadStorageObjectsRequest::clear_object_ids() {
  object_ids_.Clear();
}
inline ::nakama::api::ReadStorageObjectId* ReadStorageObjectsRequest::mutable_object_ids(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.api.ReadStorageObjectsRequest.object_ids)
  return object_ids_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nakama::api::ReadStorageObjectId >*
ReadStorageObjectsRequest::mutable_object_ids() {
  // @@protoc_insertion_point(field_mutable_list:nakama.api.ReadStorageObjectsRequest.object_ids)
  return &object_ids_;
}
inline const ::nakama::api::ReadStorageObjectId& ReadStorageObjectsRequest::object_ids(int index) const {
  // @@protoc_insertion_point(field_get:nakama.api.ReadStorageObjectsRequest.object_ids)
  return object_ids_.Get(index);
}
inline ::nakama::api::ReadStorageObjectId* ReadStorageObjectsRequest::add_object_ids() {
  // @@protoc_insertion_point(field_add:nakama.api.ReadStorageObjectsRequest.object_ids)
  return object_ids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nakama::api::ReadStorageObjectId >&
ReadStorageObjectsRequest::object_ids() const {
  // @@protoc_insertion_point(field_list:nakama.api.ReadStorageObjectsRequest.object_ids)
  return object_ids_;
}

// -------------------------------------------------------------------

// Rpc

// string id = 1;
inline void Rpc::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Rpc::id() const {
  // @@protoc_insertion_point(field_get:nakama.api.Rpc.id)
  return id_.GetNoArena();
}
inline void Rpc::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.Rpc.id)
}
#if LANG_CXX11
inline void Rpc::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.Rpc.id)
}
#endif
inline void Rpc::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.Rpc.id)
}
inline void Rpc::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.Rpc.id)
}
inline ::std::string* Rpc::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.Rpc.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Rpc::release_id() {
  // @@protoc_insertion_point(field_release:nakama.api.Rpc.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Rpc::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.Rpc.id)
}

// string payload = 2;
inline void Rpc::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Rpc::payload() const {
  // @@protoc_insertion_point(field_get:nakama.api.Rpc.payload)
  return payload_.GetNoArena();
}
inline void Rpc::set_payload(const ::std::string& value) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.Rpc.payload)
}
#if LANG_CXX11
inline void Rpc::set_payload(::std::string&& value) {
  
  payload_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.Rpc.payload)
}
#endif
inline void Rpc::set_payload(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.Rpc.payload)
}
inline void Rpc::set_payload(const char* value, size_t size) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.Rpc.payload)
}
inline ::std::string* Rpc::mutable_payload() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.Rpc.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Rpc::release_payload() {
  // @@protoc_insertion_point(field_release:nakama.api.Rpc.payload)
  
  return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Rpc::set_allocated_payload(::std::string* payload) {
  if (payload != NULL) {
    
  } else {
    
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.Rpc.payload)
}

// string http_key = 3;
inline void Rpc::clear_http_key() {
  http_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Rpc::http_key() const {
  // @@protoc_insertion_point(field_get:nakama.api.Rpc.http_key)
  return http_key_.GetNoArena();
}
inline void Rpc::set_http_key(const ::std::string& value) {
  
  http_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.Rpc.http_key)
}
#if LANG_CXX11
inline void Rpc::set_http_key(::std::string&& value) {
  
  http_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.Rpc.http_key)
}
#endif
inline void Rpc::set_http_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  http_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.Rpc.http_key)
}
inline void Rpc::set_http_key(const char* value, size_t size) {
  
  http_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.Rpc.http_key)
}
inline ::std::string* Rpc::mutable_http_key() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.Rpc.http_key)
  return http_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Rpc::release_http_key() {
  // @@protoc_insertion_point(field_release:nakama.api.Rpc.http_key)
  
  return http_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Rpc::set_allocated_http_key(::std::string* http_key) {
  if (http_key != NULL) {
    
  } else {
    
  }
  http_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), http_key);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.Rpc.http_key)
}

// -------------------------------------------------------------------

// Session

// bool created = 1;
inline void Session::clear_created() {
  created_ = false;
}
inline bool Session::created() const {
  // @@protoc_insertion_point(field_get:nakama.api.Session.created)
  return created_;
}
inline void Session::set_created(bool value) {
  
  created_ = value;
  // @@protoc_insertion_point(field_set:nakama.api.Session.created)
}

// string token = 2;
inline void Session::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Session::token() const {
  // @@protoc_insertion_point(field_get:nakama.api.Session.token)
  return token_.GetNoArena();
}
inline void Session::set_token(const ::std::string& value) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.Session.token)
}
#if LANG_CXX11
inline void Session::set_token(::std::string&& value) {
  
  token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.Session.token)
}
#endif
inline void Session::set_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.Session.token)
}
inline void Session::set_token(const char* value, size_t size) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.Session.token)
}
inline ::std::string* Session::mutable_token() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.Session.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Session::release_token() {
  // @@protoc_insertion_point(field_release:nakama.api.Session.token)
  
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Session::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.Session.token)
}

// string udp_token = 3;
inline void Session::clear_udp_token() {
  udp_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Session::udp_token() const {
  // @@protoc_insertion_point(field_get:nakama.api.Session.udp_token)
  return udp_token_.GetNoArena();
}
inline void Session::set_udp_token(const ::std::string& value) {
  
  udp_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.Session.udp_token)
}
#if LANG_CXX11
inline void Session::set_udp_token(::std::string&& value) {
  
  udp_token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.Session.udp_token)
}
#endif
inline void Session::set_udp_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  udp_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.Session.udp_token)
}
inline void Session::set_udp_token(const char* value, size_t size) {
  
  udp_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.Session.udp_token)
}
inline ::std::string* Session::mutable_udp_token() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.Session.udp_token)
  return udp_token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Session::release_udp_token() {
  // @@protoc_insertion_point(field_release:nakama.api.Session.udp_token)
  
  return udp_token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Session::set_allocated_udp_token(::std::string* udp_token) {
  if (udp_token != NULL) {
    
  } else {
    
  }
  udp_token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), udp_token);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.Session.udp_token)
}

// -------------------------------------------------------------------

// StorageObject

// string collection = 1;
inline void StorageObject::clear_collection() {
  collection_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StorageObject::collection() const {
  // @@protoc_insertion_point(field_get:nakama.api.StorageObject.collection)
  return collection_.GetNoArena();
}
inline void StorageObject::set_collection(const ::std::string& value) {
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.StorageObject.collection)
}
#if LANG_CXX11
inline void StorageObject::set_collection(::std::string&& value) {
  
  collection_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.StorageObject.collection)
}
#endif
inline void StorageObject::set_collection(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.StorageObject.collection)
}
inline void StorageObject::set_collection(const char* value, size_t size) {
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.StorageObject.collection)
}
inline ::std::string* StorageObject::mutable_collection() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.StorageObject.collection)
  return collection_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StorageObject::release_collection() {
  // @@protoc_insertion_point(field_release:nakama.api.StorageObject.collection)
  
  return collection_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StorageObject::set_allocated_collection(::std::string* collection) {
  if (collection != NULL) {
    
  } else {
    
  }
  collection_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), collection);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.StorageObject.collection)
}

// string key = 2;
inline void StorageObject::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StorageObject::key() const {
  // @@protoc_insertion_point(field_get:nakama.api.StorageObject.key)
  return key_.GetNoArena();
}
inline void StorageObject::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.StorageObject.key)
}
#if LANG_CXX11
inline void StorageObject::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.StorageObject.key)
}
#endif
inline void StorageObject::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.StorageObject.key)
}
inline void StorageObject::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.StorageObject.key)
}
inline ::std::string* StorageObject::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.StorageObject.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StorageObject::release_key() {
  // @@protoc_insertion_point(field_release:nakama.api.StorageObject.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StorageObject::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.StorageObject.key)
}

// string user_id = 3;
inline void StorageObject::clear_user_id() {
  user_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StorageObject::user_id() const {
  // @@protoc_insertion_point(field_get:nakama.api.StorageObject.user_id)
  return user_id_.GetNoArena();
}
inline void StorageObject::set_user_id(const ::std::string& value) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.StorageObject.user_id)
}
#if LANG_CXX11
inline void StorageObject::set_user_id(::std::string&& value) {
  
  user_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.StorageObject.user_id)
}
#endif
inline void StorageObject::set_user_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.StorageObject.user_id)
}
inline void StorageObject::set_user_id(const char* value, size_t size) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.StorageObject.user_id)
}
inline ::std::string* StorageObject::mutable_user_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.StorageObject.user_id)
  return user_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StorageObject::release_user_id() {
  // @@protoc_insertion_point(field_release:nakama.api.StorageObject.user_id)
  
  return user_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StorageObject::set_allocated_user_id(::std::string* user_id) {
  if (user_id != NULL) {
    
  } else {
    
  }
  user_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.StorageObject.user_id)
}

// string value = 4;
inline void StorageObject::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StorageObject::value() const {
  // @@protoc_insertion_point(field_get:nakama.api.StorageObject.value)
  return value_.GetNoArena();
}
inline void StorageObject::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.StorageObject.value)
}
#if LANG_CXX11
inline void StorageObject::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.StorageObject.value)
}
#endif
inline void StorageObject::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.StorageObject.value)
}
inline void StorageObject::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.StorageObject.value)
}
inline ::std::string* StorageObject::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.StorageObject.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StorageObject::release_value() {
  // @@protoc_insertion_point(field_release:nakama.api.StorageObject.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StorageObject::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.StorageObject.value)
}

// string version = 5;
inline void StorageObject::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StorageObject::version() const {
  // @@protoc_insertion_point(field_get:nakama.api.StorageObject.version)
  return version_.GetNoArena();
}
inline void StorageObject::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.StorageObject.version)
}
#if LANG_CXX11
inline void StorageObject::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.StorageObject.version)
}
#endif
inline void StorageObject::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.StorageObject.version)
}
inline void StorageObject::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.StorageObject.version)
}
inline ::std::string* StorageObject::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.StorageObject.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StorageObject::release_version() {
  // @@protoc_insertion_point(field_release:nakama.api.StorageObject.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StorageObject::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.StorageObject.version)
}

// int32 permission_read = 6;
inline void StorageObject::clear_permission_read() {
  permission_read_ = 0;
}
inline ::google::protobuf::int32 StorageObject::permission_read() const {
  // @@protoc_insertion_point(field_get:nakama.api.StorageObject.permission_read)
  return permission_read_;
}
inline void StorageObject::set_permission_read(::google::protobuf::int32 value) {
  
  permission_read_ = value;
  // @@protoc_insertion_point(field_set:nakama.api.StorageObject.permission_read)
}

// int32 permission_write = 7;
inline void StorageObject::clear_permission_write() {
  permission_write_ = 0;
}
inline ::google::protobuf::int32 StorageObject::permission_write() const {
  // @@protoc_insertion_point(field_get:nakama.api.StorageObject.permission_write)
  return permission_write_;
}
inline void StorageObject::set_permission_write(::google::protobuf::int32 value) {
  
  permission_write_ = value;
  // @@protoc_insertion_point(field_set:nakama.api.StorageObject.permission_write)
}

// .google.protobuf.Timestamp create_time = 8;
inline bool StorageObject::has_create_time() const {
  return this != internal_default_instance() && create_time_ != NULL;
}
inline const ::google::protobuf::Timestamp& StorageObject::_internal_create_time() const {
  return *create_time_;
}
inline const ::google::protobuf::Timestamp& StorageObject::create_time() const {
  const ::google::protobuf::Timestamp* p = create_time_;
  // @@protoc_insertion_point(field_get:nakama.api.StorageObject.create_time)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* StorageObject::release_create_time() {
  // @@protoc_insertion_point(field_release:nakama.api.StorageObject.create_time)
  
  ::google::protobuf::Timestamp* temp = create_time_;
  create_time_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* StorageObject::mutable_create_time() {
  
  if (create_time_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    create_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.StorageObject.create_time)
  return create_time_;
}
inline void StorageObject::set_allocated_create_time(::google::protobuf::Timestamp* create_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(create_time_);
  }
  if (create_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(create_time)->GetArena();
    if (message_arena != submessage_arena) {
      create_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, create_time, submessage_arena);
    }
    
  } else {
    
  }
  create_time_ = create_time;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.StorageObject.create_time)
}

// .google.protobuf.Timestamp update_time = 9;
inline bool StorageObject::has_update_time() const {
  return this != internal_default_instance() && update_time_ != NULL;
}
inline const ::google::protobuf::Timestamp& StorageObject::_internal_update_time() const {
  return *update_time_;
}
inline const ::google::protobuf::Timestamp& StorageObject::update_time() const {
  const ::google::protobuf::Timestamp* p = update_time_;
  // @@protoc_insertion_point(field_get:nakama.api.StorageObject.update_time)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* StorageObject::release_update_time() {
  // @@protoc_insertion_point(field_release:nakama.api.StorageObject.update_time)
  
  ::google::protobuf::Timestamp* temp = update_time_;
  update_time_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* StorageObject::mutable_update_time() {
  
  if (update_time_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    update_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.StorageObject.update_time)
  return update_time_;
}
inline void StorageObject::set_allocated_update_time(::google::protobuf::Timestamp* update_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(update_time_);
  }
  if (update_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(update_time)->GetArena();
    if (message_arena != submessage_arena) {
      update_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, update_time, submessage_arena);
    }
    
  } else {
    
  }
  update_time_ = update_time;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.StorageObject.update_time)
}

// -------------------------------------------------------------------

// StorageObjectAck

// string collection = 1;
inline void StorageObjectAck::clear_collection() {
  collection_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StorageObjectAck::collection() const {
  // @@protoc_insertion_point(field_get:nakama.api.StorageObjectAck.collection)
  return collection_.GetNoArena();
}
inline void StorageObjectAck::set_collection(const ::std::string& value) {
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.StorageObjectAck.collection)
}
#if LANG_CXX11
inline void StorageObjectAck::set_collection(::std::string&& value) {
  
  collection_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.StorageObjectAck.collection)
}
#endif
inline void StorageObjectAck::set_collection(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.StorageObjectAck.collection)
}
inline void StorageObjectAck::set_collection(const char* value, size_t size) {
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.StorageObjectAck.collection)
}
inline ::std::string* StorageObjectAck::mutable_collection() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.StorageObjectAck.collection)
  return collection_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StorageObjectAck::release_collection() {
  // @@protoc_insertion_point(field_release:nakama.api.StorageObjectAck.collection)
  
  return collection_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StorageObjectAck::set_allocated_collection(::std::string* collection) {
  if (collection != NULL) {
    
  } else {
    
  }
  collection_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), collection);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.StorageObjectAck.collection)
}

// string key = 2;
inline void StorageObjectAck::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StorageObjectAck::key() const {
  // @@protoc_insertion_point(field_get:nakama.api.StorageObjectAck.key)
  return key_.GetNoArena();
}
inline void StorageObjectAck::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.StorageObjectAck.key)
}
#if LANG_CXX11
inline void StorageObjectAck::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.StorageObjectAck.key)
}
#endif
inline void StorageObjectAck::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.StorageObjectAck.key)
}
inline void StorageObjectAck::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.StorageObjectAck.key)
}
inline ::std::string* StorageObjectAck::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.StorageObjectAck.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StorageObjectAck::release_key() {
  // @@protoc_insertion_point(field_release:nakama.api.StorageObjectAck.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StorageObjectAck::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.StorageObjectAck.key)
}

// string version = 3;
inline void StorageObjectAck::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StorageObjectAck::version() const {
  // @@protoc_insertion_point(field_get:nakama.api.StorageObjectAck.version)
  return version_.GetNoArena();
}
inline void StorageObjectAck::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.StorageObjectAck.version)
}
#if LANG_CXX11
inline void StorageObjectAck::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.StorageObjectAck.version)
}
#endif
inline void StorageObjectAck::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.StorageObjectAck.version)
}
inline void StorageObjectAck::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.StorageObjectAck.version)
}
inline ::std::string* StorageObjectAck::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.StorageObjectAck.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StorageObjectAck::release_version() {
  // @@protoc_insertion_point(field_release:nakama.api.StorageObjectAck.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StorageObjectAck::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.StorageObjectAck.version)
}

// string user_id = 4;
inline void StorageObjectAck::clear_user_id() {
  user_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StorageObjectAck::user_id() const {
  // @@protoc_insertion_point(field_get:nakama.api.StorageObjectAck.user_id)
  return user_id_.GetNoArena();
}
inline void StorageObjectAck::set_user_id(const ::std::string& value) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.StorageObjectAck.user_id)
}
#if LANG_CXX11
inline void StorageObjectAck::set_user_id(::std::string&& value) {
  
  user_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.StorageObjectAck.user_id)
}
#endif
inline void StorageObjectAck::set_user_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.StorageObjectAck.user_id)
}
inline void StorageObjectAck::set_user_id(const char* value, size_t size) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.StorageObjectAck.user_id)
}
inline ::std::string* StorageObjectAck::mutable_user_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.StorageObjectAck.user_id)
  return user_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StorageObjectAck::release_user_id() {
  // @@protoc_insertion_point(field_release:nakama.api.StorageObjectAck.user_id)
  
  return user_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StorageObjectAck::set_allocated_user_id(::std::string* user_id) {
  if (user_id != NULL) {
    
  } else {
    
  }
  user_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.StorageObjectAck.user_id)
}

// -------------------------------------------------------------------

// StorageObjectAcks

// repeated .nakama.api.StorageObjectAck acks = 1;
inline int StorageObjectAcks::acks_size() const {
  return acks_.size();
}
inline void StorageObjectAcks::clear_acks() {
  acks_.Clear();
}
inline ::nakama::api::StorageObjectAck* StorageObjectAcks::mutable_acks(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.api.StorageObjectAcks.acks)
  return acks_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nakama::api::StorageObjectAck >*
StorageObjectAcks::mutable_acks() {
  // @@protoc_insertion_point(field_mutable_list:nakama.api.StorageObjectAcks.acks)
  return &acks_;
}
inline const ::nakama::api::StorageObjectAck& StorageObjectAcks::acks(int index) const {
  // @@protoc_insertion_point(field_get:nakama.api.StorageObjectAcks.acks)
  return acks_.Get(index);
}
inline ::nakama::api::StorageObjectAck* StorageObjectAcks::add_acks() {
  // @@protoc_insertion_point(field_add:nakama.api.StorageObjectAcks.acks)
  return acks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nakama::api::StorageObjectAck >&
StorageObjectAcks::acks() const {
  // @@protoc_insertion_point(field_list:nakama.api.StorageObjectAcks.acks)
  return acks_;
}

// -------------------------------------------------------------------

// StorageObjects

// repeated .nakama.api.StorageObject objects = 1;
inline int StorageObjects::objects_size() const {
  return objects_.size();
}
inline void StorageObjects::clear_objects() {
  objects_.Clear();
}
inline ::nakama::api::StorageObject* StorageObjects::mutable_objects(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.api.StorageObjects.objects)
  return objects_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nakama::api::StorageObject >*
StorageObjects::mutable_objects() {
  // @@protoc_insertion_point(field_mutable_list:nakama.api.StorageObjects.objects)
  return &objects_;
}
inline const ::nakama::api::StorageObject& StorageObjects::objects(int index) const {
  // @@protoc_insertion_point(field_get:nakama.api.StorageObjects.objects)
  return objects_.Get(index);
}
inline ::nakama::api::StorageObject* StorageObjects::add_objects() {
  // @@protoc_insertion_point(field_add:nakama.api.StorageObjects.objects)
  return objects_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nakama::api::StorageObject >&
StorageObjects::objects() const {
  // @@protoc_insertion_point(field_list:nakama.api.StorageObjects.objects)
  return objects_;
}

// -------------------------------------------------------------------

// StorageObjectList

// repeated .nakama.api.StorageObject objects = 1;
inline int StorageObjectList::objects_size() const {
  return objects_.size();
}
inline void StorageObjectList::clear_objects() {
  objects_.Clear();
}
inline ::nakama::api::StorageObject* StorageObjectList::mutable_objects(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.api.StorageObjectList.objects)
  return objects_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nakama::api::StorageObject >*
StorageObjectList::mutable_objects() {
  // @@protoc_insertion_point(field_mutable_list:nakama.api.StorageObjectList.objects)
  return &objects_;
}
inline const ::nakama::api::StorageObject& StorageObjectList::objects(int index) const {
  // @@protoc_insertion_point(field_get:nakama.api.StorageObjectList.objects)
  return objects_.Get(index);
}
inline ::nakama::api::StorageObject* StorageObjectList::add_objects() {
  // @@protoc_insertion_point(field_add:nakama.api.StorageObjectList.objects)
  return objects_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nakama::api::StorageObject >&
StorageObjectList::objects() const {
  // @@protoc_insertion_point(field_list:nakama.api.StorageObjectList.objects)
  return objects_;
}

// string cursor = 2;
inline void StorageObjectList::clear_cursor() {
  cursor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StorageObjectList::cursor() const {
  // @@protoc_insertion_point(field_get:nakama.api.StorageObjectList.cursor)
  return cursor_.GetNoArena();
}
inline void StorageObjectList::set_cursor(const ::std::string& value) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.StorageObjectList.cursor)
}
#if LANG_CXX11
inline void StorageObjectList::set_cursor(::std::string&& value) {
  
  cursor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.StorageObjectList.cursor)
}
#endif
inline void StorageObjectList::set_cursor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.StorageObjectList.cursor)
}
inline void StorageObjectList::set_cursor(const char* value, size_t size) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.StorageObjectList.cursor)
}
inline ::std::string* StorageObjectList::mutable_cursor() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.StorageObjectList.cursor)
  return cursor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StorageObjectList::release_cursor() {
  // @@protoc_insertion_point(field_release:nakama.api.StorageObjectList.cursor)
  
  return cursor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StorageObjectList::set_allocated_cursor(::std::string* cursor) {
  if (cursor != NULL) {
    
  } else {
    
  }
  cursor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cursor);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.StorageObjectList.cursor)
}

// -------------------------------------------------------------------

// Tournament

// string id = 1;
inline void Tournament::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Tournament::id() const {
  // @@protoc_insertion_point(field_get:nakama.api.Tournament.id)
  return id_.GetNoArena();
}
inline void Tournament::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.Tournament.id)
}
#if LANG_CXX11
inline void Tournament::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.Tournament.id)
}
#endif
inline void Tournament::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.Tournament.id)
}
inline void Tournament::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.Tournament.id)
}
inline ::std::string* Tournament::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.Tournament.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Tournament::release_id() {
  // @@protoc_insertion_point(field_release:nakama.api.Tournament.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Tournament::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.Tournament.id)
}

// string title = 2;
inline void Tournament::clear_title() {
  title_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Tournament::title() const {
  // @@protoc_insertion_point(field_get:nakama.api.Tournament.title)
  return title_.GetNoArena();
}
inline void Tournament::set_title(const ::std::string& value) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.Tournament.title)
}
#if LANG_CXX11
inline void Tournament::set_title(::std::string&& value) {
  
  title_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.Tournament.title)
}
#endif
inline void Tournament::set_title(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.Tournament.title)
}
inline void Tournament::set_title(const char* value, size_t size) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.Tournament.title)
}
inline ::std::string* Tournament::mutable_title() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.Tournament.title)
  return title_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Tournament::release_title() {
  // @@protoc_insertion_point(field_release:nakama.api.Tournament.title)
  
  return title_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Tournament::set_allocated_title(::std::string* title) {
  if (title != NULL) {
    
  } else {
    
  }
  title_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), title);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.Tournament.title)
}

// string description = 3;
inline void Tournament::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Tournament::description() const {
  // @@protoc_insertion_point(field_get:nakama.api.Tournament.description)
  return description_.GetNoArena();
}
inline void Tournament::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.Tournament.description)
}
#if LANG_CXX11
inline void Tournament::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.Tournament.description)
}
#endif
inline void Tournament::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.Tournament.description)
}
inline void Tournament::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.Tournament.description)
}
inline ::std::string* Tournament::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.Tournament.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Tournament::release_description() {
  // @@protoc_insertion_point(field_release:nakama.api.Tournament.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Tournament::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.Tournament.description)
}

// uint32 category = 4;
inline void Tournament::clear_category() {
  category_ = 0u;
}
inline ::google::protobuf::uint32 Tournament::category() const {
  // @@protoc_insertion_point(field_get:nakama.api.Tournament.category)
  return category_;
}
inline void Tournament::set_category(::google::protobuf::uint32 value) {
  
  category_ = value;
  // @@protoc_insertion_point(field_set:nakama.api.Tournament.category)
}

// uint32 sort_order = 5;
inline void Tournament::clear_sort_order() {
  sort_order_ = 0u;
}
inline ::google::protobuf::uint32 Tournament::sort_order() const {
  // @@protoc_insertion_point(field_get:nakama.api.Tournament.sort_order)
  return sort_order_;
}
inline void Tournament::set_sort_order(::google::protobuf::uint32 value) {
  
  sort_order_ = value;
  // @@protoc_insertion_point(field_set:nakama.api.Tournament.sort_order)
}

// uint32 size = 6;
inline void Tournament::clear_size() {
  size_ = 0u;
}
inline ::google::protobuf::uint32 Tournament::size() const {
  // @@protoc_insertion_point(field_get:nakama.api.Tournament.size)
  return size_;
}
inline void Tournament::set_size(::google::protobuf::uint32 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:nakama.api.Tournament.size)
}

// uint32 max_size = 7;
inline void Tournament::clear_max_size() {
  max_size_ = 0u;
}
inline ::google::protobuf::uint32 Tournament::max_size() const {
  // @@protoc_insertion_point(field_get:nakama.api.Tournament.max_size)
  return max_size_;
}
inline void Tournament::set_max_size(::google::protobuf::uint32 value) {
  
  max_size_ = value;
  // @@protoc_insertion_point(field_set:nakama.api.Tournament.max_size)
}

// uint32 max_num_score = 8;
inline void Tournament::clear_max_num_score() {
  max_num_score_ = 0u;
}
inline ::google::protobuf::uint32 Tournament::max_num_score() const {
  // @@protoc_insertion_point(field_get:nakama.api.Tournament.max_num_score)
  return max_num_score_;
}
inline void Tournament::set_max_num_score(::google::protobuf::uint32 value) {
  
  max_num_score_ = value;
  // @@protoc_insertion_point(field_set:nakama.api.Tournament.max_num_score)
}

// bool can_enter = 9;
inline void Tournament::clear_can_enter() {
  can_enter_ = false;
}
inline bool Tournament::can_enter() const {
  // @@protoc_insertion_point(field_get:nakama.api.Tournament.can_enter)
  return can_enter_;
}
inline void Tournament::set_can_enter(bool value) {
  
  can_enter_ = value;
  // @@protoc_insertion_point(field_set:nakama.api.Tournament.can_enter)
}

// uint32 end_active = 10;
inline void Tournament::clear_end_active() {
  end_active_ = 0u;
}
inline ::google::protobuf::uint32 Tournament::end_active() const {
  // @@protoc_insertion_point(field_get:nakama.api.Tournament.end_active)
  return end_active_;
}
inline void Tournament::set_end_active(::google::protobuf::uint32 value) {
  
  end_active_ = value;
  // @@protoc_insertion_point(field_set:nakama.api.Tournament.end_active)
}

// uint32 next_reset = 11;
inline void Tournament::clear_next_reset() {
  next_reset_ = 0u;
}
inline ::google::protobuf::uint32 Tournament::next_reset() const {
  // @@protoc_insertion_point(field_get:nakama.api.Tournament.next_reset)
  return next_reset_;
}
inline void Tournament::set_next_reset(::google::protobuf::uint32 value) {
  
  next_reset_ = value;
  // @@protoc_insertion_point(field_set:nakama.api.Tournament.next_reset)
}

// string metadata = 12;
inline void Tournament::clear_metadata() {
  metadata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Tournament::metadata() const {
  // @@protoc_insertion_point(field_get:nakama.api.Tournament.metadata)
  return metadata_.GetNoArena();
}
inline void Tournament::set_metadata(const ::std::string& value) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.Tournament.metadata)
}
#if LANG_CXX11
inline void Tournament::set_metadata(::std::string&& value) {
  
  metadata_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.Tournament.metadata)
}
#endif
inline void Tournament::set_metadata(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.Tournament.metadata)
}
inline void Tournament::set_metadata(const char* value, size_t size) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.Tournament.metadata)
}
inline ::std::string* Tournament::mutable_metadata() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.Tournament.metadata)
  return metadata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Tournament::release_metadata() {
  // @@protoc_insertion_point(field_release:nakama.api.Tournament.metadata)
  
  return metadata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Tournament::set_allocated_metadata(::std::string* metadata) {
  if (metadata != NULL) {
    
  } else {
    
  }
  metadata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), metadata);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.Tournament.metadata)
}

// .google.protobuf.Timestamp create_time = 13;
inline bool Tournament::has_create_time() const {
  return this != internal_default_instance() && create_time_ != NULL;
}
inline const ::google::protobuf::Timestamp& Tournament::_internal_create_time() const {
  return *create_time_;
}
inline const ::google::protobuf::Timestamp& Tournament::create_time() const {
  const ::google::protobuf::Timestamp* p = create_time_;
  // @@protoc_insertion_point(field_get:nakama.api.Tournament.create_time)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* Tournament::release_create_time() {
  // @@protoc_insertion_point(field_release:nakama.api.Tournament.create_time)
  
  ::google::protobuf::Timestamp* temp = create_time_;
  create_time_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* Tournament::mutable_create_time() {
  
  if (create_time_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    create_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.Tournament.create_time)
  return create_time_;
}
inline void Tournament::set_allocated_create_time(::google::protobuf::Timestamp* create_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(create_time_);
  }
  if (create_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(create_time)->GetArena();
    if (message_arena != submessage_arena) {
      create_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, create_time, submessage_arena);
    }
    
  } else {
    
  }
  create_time_ = create_time;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.Tournament.create_time)
}

// .google.protobuf.Timestamp start_time = 14;
inline bool Tournament::has_start_time() const {
  return this != internal_default_instance() && start_time_ != NULL;
}
inline const ::google::protobuf::Timestamp& Tournament::_internal_start_time() const {
  return *start_time_;
}
inline const ::google::protobuf::Timestamp& Tournament::start_time() const {
  const ::google::protobuf::Timestamp* p = start_time_;
  // @@protoc_insertion_point(field_get:nakama.api.Tournament.start_time)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* Tournament::release_start_time() {
  // @@protoc_insertion_point(field_release:nakama.api.Tournament.start_time)
  
  ::google::protobuf::Timestamp* temp = start_time_;
  start_time_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* Tournament::mutable_start_time() {
  
  if (start_time_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    start_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.Tournament.start_time)
  return start_time_;
}
inline void Tournament::set_allocated_start_time(::google::protobuf::Timestamp* start_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(start_time_);
  }
  if (start_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(start_time)->GetArena();
    if (message_arena != submessage_arena) {
      start_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.Tournament.start_time)
}

// .google.protobuf.Timestamp end_time = 15;
inline bool Tournament::has_end_time() const {
  return this != internal_default_instance() && end_time_ != NULL;
}
inline const ::google::protobuf::Timestamp& Tournament::_internal_end_time() const {
  return *end_time_;
}
inline const ::google::protobuf::Timestamp& Tournament::end_time() const {
  const ::google::protobuf::Timestamp* p = end_time_;
  // @@protoc_insertion_point(field_get:nakama.api.Tournament.end_time)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* Tournament::release_end_time() {
  // @@protoc_insertion_point(field_release:nakama.api.Tournament.end_time)
  
  ::google::protobuf::Timestamp* temp = end_time_;
  end_time_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* Tournament::mutable_end_time() {
  
  if (end_time_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    end_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.Tournament.end_time)
  return end_time_;
}
inline void Tournament::set_allocated_end_time(::google::protobuf::Timestamp* end_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(end_time_);
  }
  if (end_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(end_time)->GetArena();
    if (message_arena != submessage_arena) {
      end_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, end_time, submessage_arena);
    }
    
  } else {
    
  }
  end_time_ = end_time;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.Tournament.end_time)
}

// uint32 duration = 16;
inline void Tournament::clear_duration() {
  duration_ = 0u;
}
inline ::google::protobuf::uint32 Tournament::duration() const {
  // @@protoc_insertion_point(field_get:nakama.api.Tournament.duration)
  return duration_;
}
inline void Tournament::set_duration(::google::protobuf::uint32 value) {
  
  duration_ = value;
  // @@protoc_insertion_point(field_set:nakama.api.Tournament.duration)
}

// -------------------------------------------------------------------

// TournamentList

// repeated .nakama.api.Tournament tournaments = 1;
inline int TournamentList::tournaments_size() const {
  return tournaments_.size();
}
inline void TournamentList::clear_tournaments() {
  tournaments_.Clear();
}
inline ::nakama::api::Tournament* TournamentList::mutable_tournaments(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.api.TournamentList.tournaments)
  return tournaments_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nakama::api::Tournament >*
TournamentList::mutable_tournaments() {
  // @@protoc_insertion_point(field_mutable_list:nakama.api.TournamentList.tournaments)
  return &tournaments_;
}
inline const ::nakama::api::Tournament& TournamentList::tournaments(int index) const {
  // @@protoc_insertion_point(field_get:nakama.api.TournamentList.tournaments)
  return tournaments_.Get(index);
}
inline ::nakama::api::Tournament* TournamentList::add_tournaments() {
  // @@protoc_insertion_point(field_add:nakama.api.TournamentList.tournaments)
  return tournaments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nakama::api::Tournament >&
TournamentList::tournaments() const {
  // @@protoc_insertion_point(field_list:nakama.api.TournamentList.tournaments)
  return tournaments_;
}

// string cursor = 2;
inline void TournamentList::clear_cursor() {
  cursor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TournamentList::cursor() const {
  // @@protoc_insertion_point(field_get:nakama.api.TournamentList.cursor)
  return cursor_.GetNoArena();
}
inline void TournamentList::set_cursor(const ::std::string& value) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.TournamentList.cursor)
}
#if LANG_CXX11
inline void TournamentList::set_cursor(::std::string&& value) {
  
  cursor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.TournamentList.cursor)
}
#endif
inline void TournamentList::set_cursor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.TournamentList.cursor)
}
inline void TournamentList::set_cursor(const char* value, size_t size) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.TournamentList.cursor)
}
inline ::std::string* TournamentList::mutable_cursor() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.TournamentList.cursor)
  return cursor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TournamentList::release_cursor() {
  // @@protoc_insertion_point(field_release:nakama.api.TournamentList.cursor)
  
  return cursor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TournamentList::set_allocated_cursor(::std::string* cursor) {
  if (cursor != NULL) {
    
  } else {
    
  }
  cursor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cursor);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.TournamentList.cursor)
}

// -------------------------------------------------------------------

// TournamentRecordList

// repeated .nakama.api.LeaderboardRecord records = 1;
inline int TournamentRecordList::records_size() const {
  return records_.size();
}
inline void TournamentRecordList::clear_records() {
  records_.Clear();
}
inline ::nakama::api::LeaderboardRecord* TournamentRecordList::mutable_records(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.api.TournamentRecordList.records)
  return records_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nakama::api::LeaderboardRecord >*
TournamentRecordList::mutable_records() {
  // @@protoc_insertion_point(field_mutable_list:nakama.api.TournamentRecordList.records)
  return &records_;
}
inline const ::nakama::api::LeaderboardRecord& TournamentRecordList::records(int index) const {
  // @@protoc_insertion_point(field_get:nakama.api.TournamentRecordList.records)
  return records_.Get(index);
}
inline ::nakama::api::LeaderboardRecord* TournamentRecordList::add_records() {
  // @@protoc_insertion_point(field_add:nakama.api.TournamentRecordList.records)
  return records_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nakama::api::LeaderboardRecord >&
TournamentRecordList::records() const {
  // @@protoc_insertion_point(field_list:nakama.api.TournamentRecordList.records)
  return records_;
}

// repeated .nakama.api.LeaderboardRecord owner_records = 2;
inline int TournamentRecordList::owner_records_size() const {
  return owner_records_.size();
}
inline void TournamentRecordList::clear_owner_records() {
  owner_records_.Clear();
}
inline ::nakama::api::LeaderboardRecord* TournamentRecordList::mutable_owner_records(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.api.TournamentRecordList.owner_records)
  return owner_records_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nakama::api::LeaderboardRecord >*
TournamentRecordList::mutable_owner_records() {
  // @@protoc_insertion_point(field_mutable_list:nakama.api.TournamentRecordList.owner_records)
  return &owner_records_;
}
inline const ::nakama::api::LeaderboardRecord& TournamentRecordList::owner_records(int index) const {
  // @@protoc_insertion_point(field_get:nakama.api.TournamentRecordList.owner_records)
  return owner_records_.Get(index);
}
inline ::nakama::api::LeaderboardRecord* TournamentRecordList::add_owner_records() {
  // @@protoc_insertion_point(field_add:nakama.api.TournamentRecordList.owner_records)
  return owner_records_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nakama::api::LeaderboardRecord >&
TournamentRecordList::owner_records() const {
  // @@protoc_insertion_point(field_list:nakama.api.TournamentRecordList.owner_records)
  return owner_records_;
}

// string next_cursor = 3;
inline void TournamentRecordList::clear_next_cursor() {
  next_cursor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TournamentRecordList::next_cursor() const {
  // @@protoc_insertion_point(field_get:nakama.api.TournamentRecordList.next_cursor)
  return next_cursor_.GetNoArena();
}
inline void TournamentRecordList::set_next_cursor(const ::std::string& value) {
  
  next_cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.TournamentRecordList.next_cursor)
}
#if LANG_CXX11
inline void TournamentRecordList::set_next_cursor(::std::string&& value) {
  
  next_cursor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.TournamentRecordList.next_cursor)
}
#endif
inline void TournamentRecordList::set_next_cursor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  next_cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.TournamentRecordList.next_cursor)
}
inline void TournamentRecordList::set_next_cursor(const char* value, size_t size) {
  
  next_cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.TournamentRecordList.next_cursor)
}
inline ::std::string* TournamentRecordList::mutable_next_cursor() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.TournamentRecordList.next_cursor)
  return next_cursor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TournamentRecordList::release_next_cursor() {
  // @@protoc_insertion_point(field_release:nakama.api.TournamentRecordList.next_cursor)
  
  return next_cursor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TournamentRecordList::set_allocated_next_cursor(::std::string* next_cursor) {
  if (next_cursor != NULL) {
    
  } else {
    
  }
  next_cursor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), next_cursor);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.TournamentRecordList.next_cursor)
}

// string prev_cursor = 4;
inline void TournamentRecordList::clear_prev_cursor() {
  prev_cursor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TournamentRecordList::prev_cursor() const {
  // @@protoc_insertion_point(field_get:nakama.api.TournamentRecordList.prev_cursor)
  return prev_cursor_.GetNoArena();
}
inline void TournamentRecordList::set_prev_cursor(const ::std::string& value) {
  
  prev_cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.TournamentRecordList.prev_cursor)
}
#if LANG_CXX11
inline void TournamentRecordList::set_prev_cursor(::std::string&& value) {
  
  prev_cursor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.TournamentRecordList.prev_cursor)
}
#endif
inline void TournamentRecordList::set_prev_cursor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  prev_cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.TournamentRecordList.prev_cursor)
}
inline void TournamentRecordList::set_prev_cursor(const char* value, size_t size) {
  
  prev_cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.TournamentRecordList.prev_cursor)
}
inline ::std::string* TournamentRecordList::mutable_prev_cursor() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.TournamentRecordList.prev_cursor)
  return prev_cursor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TournamentRecordList::release_prev_cursor() {
  // @@protoc_insertion_point(field_release:nakama.api.TournamentRecordList.prev_cursor)
  
  return prev_cursor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TournamentRecordList::set_allocated_prev_cursor(::std::string* prev_cursor) {
  if (prev_cursor != NULL) {
    
  } else {
    
  }
  prev_cursor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), prev_cursor);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.TournamentRecordList.prev_cursor)
}

// -------------------------------------------------------------------

// UpdateAccountRequest

// .google.protobuf.StringValue username = 1;
inline bool UpdateAccountRequest::has_username() const {
  return this != internal_default_instance() && username_ != NULL;
}
inline const ::google::protobuf::StringValue& UpdateAccountRequest::_internal_username() const {
  return *username_;
}
inline const ::google::protobuf::StringValue& UpdateAccountRequest::username() const {
  const ::google::protobuf::StringValue* p = username_;
  // @@protoc_insertion_point(field_get:nakama.api.UpdateAccountRequest.username)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::StringValue*>(
      &::google::protobuf::_StringValue_default_instance_);
}
inline ::google::protobuf::StringValue* UpdateAccountRequest::release_username() {
  // @@protoc_insertion_point(field_release:nakama.api.UpdateAccountRequest.username)
  
  ::google::protobuf::StringValue* temp = username_;
  username_ = NULL;
  return temp;
}
inline ::google::protobuf::StringValue* UpdateAccountRequest::mutable_username() {
  
  if (username_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::StringValue>(GetArenaNoVirtual());
    username_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.UpdateAccountRequest.username)
  return username_;
}
inline void UpdateAccountRequest::set_allocated_username(::google::protobuf::StringValue* username) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(username_);
  }
  if (username) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(username)->GetArena();
    if (message_arena != submessage_arena) {
      username = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, username, submessage_arena);
    }
    
  } else {
    
  }
  username_ = username;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.UpdateAccountRequest.username)
}

// .google.protobuf.StringValue display_name = 2;
inline bool UpdateAccountRequest::has_display_name() const {
  return this != internal_default_instance() && display_name_ != NULL;
}
inline const ::google::protobuf::StringValue& UpdateAccountRequest::_internal_display_name() const {
  return *display_name_;
}
inline const ::google::protobuf::StringValue& UpdateAccountRequest::display_name() const {
  const ::google::protobuf::StringValue* p = display_name_;
  // @@protoc_insertion_point(field_get:nakama.api.UpdateAccountRequest.display_name)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::StringValue*>(
      &::google::protobuf::_StringValue_default_instance_);
}
inline ::google::protobuf::StringValue* UpdateAccountRequest::release_display_name() {
  // @@protoc_insertion_point(field_release:nakama.api.UpdateAccountRequest.display_name)
  
  ::google::protobuf::StringValue* temp = display_name_;
  display_name_ = NULL;
  return temp;
}
inline ::google::protobuf::StringValue* UpdateAccountRequest::mutable_display_name() {
  
  if (display_name_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::StringValue>(GetArenaNoVirtual());
    display_name_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.UpdateAccountRequest.display_name)
  return display_name_;
}
inline void UpdateAccountRequest::set_allocated_display_name(::google::protobuf::StringValue* display_name) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(display_name_);
  }
  if (display_name) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(display_name)->GetArena();
    if (message_arena != submessage_arena) {
      display_name = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, display_name, submessage_arena);
    }
    
  } else {
    
  }
  display_name_ = display_name;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.UpdateAccountRequest.display_name)
}

// .google.protobuf.StringValue avatar_url = 3;
inline bool UpdateAccountRequest::has_avatar_url() const {
  return this != internal_default_instance() && avatar_url_ != NULL;
}
inline const ::google::protobuf::StringValue& UpdateAccountRequest::_internal_avatar_url() const {
  return *avatar_url_;
}
inline const ::google::protobuf::StringValue& UpdateAccountRequest::avatar_url() const {
  const ::google::protobuf::StringValue* p = avatar_url_;
  // @@protoc_insertion_point(field_get:nakama.api.UpdateAccountRequest.avatar_url)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::StringValue*>(
      &::google::protobuf::_StringValue_default_instance_);
}
inline ::google::protobuf::StringValue* UpdateAccountRequest::release_avatar_url() {
  // @@protoc_insertion_point(field_release:nakama.api.UpdateAccountRequest.avatar_url)
  
  ::google::protobuf::StringValue* temp = avatar_url_;
  avatar_url_ = NULL;
  return temp;
}
inline ::google::protobuf::StringValue* UpdateAccountRequest::mutable_avatar_url() {
  
  if (avatar_url_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::StringValue>(GetArenaNoVirtual());
    avatar_url_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.UpdateAccountRequest.avatar_url)
  return avatar_url_;
}
inline void UpdateAccountRequest::set_allocated_avatar_url(::google::protobuf::StringValue* avatar_url) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(avatar_url_);
  }
  if (avatar_url) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(avatar_url)->GetArena();
    if (message_arena != submessage_arena) {
      avatar_url = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, avatar_url, submessage_arena);
    }
    
  } else {
    
  }
  avatar_url_ = avatar_url;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.UpdateAccountRequest.avatar_url)
}

// .google.protobuf.StringValue lang_tag = 4;
inline bool UpdateAccountRequest::has_lang_tag() const {
  return this != internal_default_instance() && lang_tag_ != NULL;
}
inline const ::google::protobuf::StringValue& UpdateAccountRequest::_internal_lang_tag() const {
  return *lang_tag_;
}
inline const ::google::protobuf::StringValue& UpdateAccountRequest::lang_tag() const {
  const ::google::protobuf::StringValue* p = lang_tag_;
  // @@protoc_insertion_point(field_get:nakama.api.UpdateAccountRequest.lang_tag)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::StringValue*>(
      &::google::protobuf::_StringValue_default_instance_);
}
inline ::google::protobuf::StringValue* UpdateAccountRequest::release_lang_tag() {
  // @@protoc_insertion_point(field_release:nakama.api.UpdateAccountRequest.lang_tag)
  
  ::google::protobuf::StringValue* temp = lang_tag_;
  lang_tag_ = NULL;
  return temp;
}
inline ::google::protobuf::StringValue* UpdateAccountRequest::mutable_lang_tag() {
  
  if (lang_tag_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::StringValue>(GetArenaNoVirtual());
    lang_tag_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.UpdateAccountRequest.lang_tag)
  return lang_tag_;
}
inline void UpdateAccountRequest::set_allocated_lang_tag(::google::protobuf::StringValue* lang_tag) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(lang_tag_);
  }
  if (lang_tag) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(lang_tag)->GetArena();
    if (message_arena != submessage_arena) {
      lang_tag = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lang_tag, submessage_arena);
    }
    
  } else {
    
  }
  lang_tag_ = lang_tag;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.UpdateAccountRequest.lang_tag)
}

// .google.protobuf.StringValue location = 5;
inline bool UpdateAccountRequest::has_location() const {
  return this != internal_default_instance() && location_ != NULL;
}
inline const ::google::protobuf::StringValue& UpdateAccountRequest::_internal_location() const {
  return *location_;
}
inline const ::google::protobuf::StringValue& UpdateAccountRequest::location() const {
  const ::google::protobuf::StringValue* p = location_;
  // @@protoc_insertion_point(field_get:nakama.api.UpdateAccountRequest.location)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::StringValue*>(
      &::google::protobuf::_StringValue_default_instance_);
}
inline ::google::protobuf::StringValue* UpdateAccountRequest::release_location() {
  // @@protoc_insertion_point(field_release:nakama.api.UpdateAccountRequest.location)
  
  ::google::protobuf::StringValue* temp = location_;
  location_ = NULL;
  return temp;
}
inline ::google::protobuf::StringValue* UpdateAccountRequest::mutable_location() {
  
  if (location_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::StringValue>(GetArenaNoVirtual());
    location_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.UpdateAccountRequest.location)
  return location_;
}
inline void UpdateAccountRequest::set_allocated_location(::google::protobuf::StringValue* location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(location_);
  }
  if (location) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(location)->GetArena();
    if (message_arena != submessage_arena) {
      location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.UpdateAccountRequest.location)
}

// .google.protobuf.StringValue timezone = 6;
inline bool UpdateAccountRequest::has_timezone() const {
  return this != internal_default_instance() && timezone_ != NULL;
}
inline const ::google::protobuf::StringValue& UpdateAccountRequest::_internal_timezone() const {
  return *timezone_;
}
inline const ::google::protobuf::StringValue& UpdateAccountRequest::timezone() const {
  const ::google::protobuf::StringValue* p = timezone_;
  // @@protoc_insertion_point(field_get:nakama.api.UpdateAccountRequest.timezone)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::StringValue*>(
      &::google::protobuf::_StringValue_default_instance_);
}
inline ::google::protobuf::StringValue* UpdateAccountRequest::release_timezone() {
  // @@protoc_insertion_point(field_release:nakama.api.UpdateAccountRequest.timezone)
  
  ::google::protobuf::StringValue* temp = timezone_;
  timezone_ = NULL;
  return temp;
}
inline ::google::protobuf::StringValue* UpdateAccountRequest::mutable_timezone() {
  
  if (timezone_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::StringValue>(GetArenaNoVirtual());
    timezone_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.UpdateAccountRequest.timezone)
  return timezone_;
}
inline void UpdateAccountRequest::set_allocated_timezone(::google::protobuf::StringValue* timezone) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(timezone_);
  }
  if (timezone) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(timezone)->GetArena();
    if (message_arena != submessage_arena) {
      timezone = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timezone, submessage_arena);
    }
    
  } else {
    
  }
  timezone_ = timezone;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.UpdateAccountRequest.timezone)
}

// -------------------------------------------------------------------

// UpdateGroupRequest

// string group_id = 1;
inline void UpdateGroupRequest::clear_group_id() {
  group_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UpdateGroupRequest::group_id() const {
  // @@protoc_insertion_point(field_get:nakama.api.UpdateGroupRequest.group_id)
  return group_id_.GetNoArena();
}
inline void UpdateGroupRequest::set_group_id(const ::std::string& value) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.UpdateGroupRequest.group_id)
}
#if LANG_CXX11
inline void UpdateGroupRequest::set_group_id(::std::string&& value) {
  
  group_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.UpdateGroupRequest.group_id)
}
#endif
inline void UpdateGroupRequest::set_group_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.UpdateGroupRequest.group_id)
}
inline void UpdateGroupRequest::set_group_id(const char* value, size_t size) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.UpdateGroupRequest.group_id)
}
inline ::std::string* UpdateGroupRequest::mutable_group_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.UpdateGroupRequest.group_id)
  return group_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UpdateGroupRequest::release_group_id() {
  // @@protoc_insertion_point(field_release:nakama.api.UpdateGroupRequest.group_id)
  
  return group_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpdateGroupRequest::set_allocated_group_id(::std::string* group_id) {
  if (group_id != NULL) {
    
  } else {
    
  }
  group_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), group_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.UpdateGroupRequest.group_id)
}

// .google.protobuf.StringValue name = 2;
inline bool UpdateGroupRequest::has_name() const {
  return this != internal_default_instance() && name_ != NULL;
}
inline const ::google::protobuf::StringValue& UpdateGroupRequest::_internal_name() const {
  return *name_;
}
inline const ::google::protobuf::StringValue& UpdateGroupRequest::name() const {
  const ::google::protobuf::StringValue* p = name_;
  // @@protoc_insertion_point(field_get:nakama.api.UpdateGroupRequest.name)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::StringValue*>(
      &::google::protobuf::_StringValue_default_instance_);
}
inline ::google::protobuf::StringValue* UpdateGroupRequest::release_name() {
  // @@protoc_insertion_point(field_release:nakama.api.UpdateGroupRequest.name)
  
  ::google::protobuf::StringValue* temp = name_;
  name_ = NULL;
  return temp;
}
inline ::google::protobuf::StringValue* UpdateGroupRequest::mutable_name() {
  
  if (name_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::StringValue>(GetArenaNoVirtual());
    name_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.UpdateGroupRequest.name)
  return name_;
}
inline void UpdateGroupRequest::set_allocated_name(::google::protobuf::StringValue* name) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(name_);
  }
  if (name) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(name)->GetArena();
    if (message_arena != submessage_arena) {
      name = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, name, submessage_arena);
    }
    
  } else {
    
  }
  name_ = name;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.UpdateGroupRequest.name)
}

// .google.protobuf.StringValue description = 3;
inline bool UpdateGroupRequest::has_description() const {
  return this != internal_default_instance() && description_ != NULL;
}
inline const ::google::protobuf::StringValue& UpdateGroupRequest::_internal_description() const {
  return *description_;
}
inline const ::google::protobuf::StringValue& UpdateGroupRequest::description() const {
  const ::google::protobuf::StringValue* p = description_;
  // @@protoc_insertion_point(field_get:nakama.api.UpdateGroupRequest.description)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::StringValue*>(
      &::google::protobuf::_StringValue_default_instance_);
}
inline ::google::protobuf::StringValue* UpdateGroupRequest::release_description() {
  // @@protoc_insertion_point(field_release:nakama.api.UpdateGroupRequest.description)
  
  ::google::protobuf::StringValue* temp = description_;
  description_ = NULL;
  return temp;
}
inline ::google::protobuf::StringValue* UpdateGroupRequest::mutable_description() {
  
  if (description_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::StringValue>(GetArenaNoVirtual());
    description_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.UpdateGroupRequest.description)
  return description_;
}
inline void UpdateGroupRequest::set_allocated_description(::google::protobuf::StringValue* description) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(description_);
  }
  if (description) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(description)->GetArena();
    if (message_arena != submessage_arena) {
      description = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, description, submessage_arena);
    }
    
  } else {
    
  }
  description_ = description;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.UpdateGroupRequest.description)
}

// .google.protobuf.StringValue lang_tag = 4;
inline bool UpdateGroupRequest::has_lang_tag() const {
  return this != internal_default_instance() && lang_tag_ != NULL;
}
inline const ::google::protobuf::StringValue& UpdateGroupRequest::_internal_lang_tag() const {
  return *lang_tag_;
}
inline const ::google::protobuf::StringValue& UpdateGroupRequest::lang_tag() const {
  const ::google::protobuf::StringValue* p = lang_tag_;
  // @@protoc_insertion_point(field_get:nakama.api.UpdateGroupRequest.lang_tag)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::StringValue*>(
      &::google::protobuf::_StringValue_default_instance_);
}
inline ::google::protobuf::StringValue* UpdateGroupRequest::release_lang_tag() {
  // @@protoc_insertion_point(field_release:nakama.api.UpdateGroupRequest.lang_tag)
  
  ::google::protobuf::StringValue* temp = lang_tag_;
  lang_tag_ = NULL;
  return temp;
}
inline ::google::protobuf::StringValue* UpdateGroupRequest::mutable_lang_tag() {
  
  if (lang_tag_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::StringValue>(GetArenaNoVirtual());
    lang_tag_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.UpdateGroupRequest.lang_tag)
  return lang_tag_;
}
inline void UpdateGroupRequest::set_allocated_lang_tag(::google::protobuf::StringValue* lang_tag) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(lang_tag_);
  }
  if (lang_tag) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(lang_tag)->GetArena();
    if (message_arena != submessage_arena) {
      lang_tag = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lang_tag, submessage_arena);
    }
    
  } else {
    
  }
  lang_tag_ = lang_tag;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.UpdateGroupRequest.lang_tag)
}

// .google.protobuf.StringValue avatar_url = 5;
inline bool UpdateGroupRequest::has_avatar_url() const {
  return this != internal_default_instance() && avatar_url_ != NULL;
}
inline const ::google::protobuf::StringValue& UpdateGroupRequest::_internal_avatar_url() const {
  return *avatar_url_;
}
inline const ::google::protobuf::StringValue& UpdateGroupRequest::avatar_url() const {
  const ::google::protobuf::StringValue* p = avatar_url_;
  // @@protoc_insertion_point(field_get:nakama.api.UpdateGroupRequest.avatar_url)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::StringValue*>(
      &::google::protobuf::_StringValue_default_instance_);
}
inline ::google::protobuf::StringValue* UpdateGroupRequest::release_avatar_url() {
  // @@protoc_insertion_point(field_release:nakama.api.UpdateGroupRequest.avatar_url)
  
  ::google::protobuf::StringValue* temp = avatar_url_;
  avatar_url_ = NULL;
  return temp;
}
inline ::google::protobuf::StringValue* UpdateGroupRequest::mutable_avatar_url() {
  
  if (avatar_url_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::StringValue>(GetArenaNoVirtual());
    avatar_url_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.UpdateGroupRequest.avatar_url)
  return avatar_url_;
}
inline void UpdateGroupRequest::set_allocated_avatar_url(::google::protobuf::StringValue* avatar_url) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(avatar_url_);
  }
  if (avatar_url) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(avatar_url)->GetArena();
    if (message_arena != submessage_arena) {
      avatar_url = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, avatar_url, submessage_arena);
    }
    
  } else {
    
  }
  avatar_url_ = avatar_url;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.UpdateGroupRequest.avatar_url)
}

// .google.protobuf.BoolValue open = 6;
inline bool UpdateGroupRequest::has_open() const {
  return this != internal_default_instance() && open_ != NULL;
}
inline const ::google::protobuf::BoolValue& UpdateGroupRequest::_internal_open() const {
  return *open_;
}
inline const ::google::protobuf::BoolValue& UpdateGroupRequest::open() const {
  const ::google::protobuf::BoolValue* p = open_;
  // @@protoc_insertion_point(field_get:nakama.api.UpdateGroupRequest.open)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::BoolValue*>(
      &::google::protobuf::_BoolValue_default_instance_);
}
inline ::google::protobuf::BoolValue* UpdateGroupRequest::release_open() {
  // @@protoc_insertion_point(field_release:nakama.api.UpdateGroupRequest.open)
  
  ::google::protobuf::BoolValue* temp = open_;
  open_ = NULL;
  return temp;
}
inline ::google::protobuf::BoolValue* UpdateGroupRequest::mutable_open() {
  
  if (open_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::BoolValue>(GetArenaNoVirtual());
    open_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.UpdateGroupRequest.open)
  return open_;
}
inline void UpdateGroupRequest::set_allocated_open(::google::protobuf::BoolValue* open) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(open_);
  }
  if (open) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(open)->GetArena();
    if (message_arena != submessage_arena) {
      open = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, open, submessage_arena);
    }
    
  } else {
    
  }
  open_ = open;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.UpdateGroupRequest.open)
}

// -------------------------------------------------------------------

// User

// string id = 1;
inline void User::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& User::id() const {
  // @@protoc_insertion_point(field_get:nakama.api.User.id)
  return id_.GetNoArena();
}
inline void User::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.User.id)
}
#if LANG_CXX11
inline void User::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.User.id)
}
#endif
inline void User::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.User.id)
}
inline void User::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.User.id)
}
inline ::std::string* User::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.User.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User::release_id() {
  // @@protoc_insertion_point(field_release:nakama.api.User.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.User.id)
}

// string username = 2;
inline void User::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& User::username() const {
  // @@protoc_insertion_point(field_get:nakama.api.User.username)
  return username_.GetNoArena();
}
inline void User::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.User.username)
}
#if LANG_CXX11
inline void User::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.User.username)
}
#endif
inline void User::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.User.username)
}
inline void User::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.User.username)
}
inline ::std::string* User::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.User.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User::release_username() {
  // @@protoc_insertion_point(field_release:nakama.api.User.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.User.username)
}

// string display_name = 3;
inline void User::clear_display_name() {
  display_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& User::display_name() const {
  // @@protoc_insertion_point(field_get:nakama.api.User.display_name)
  return display_name_.GetNoArena();
}
inline void User::set_display_name(const ::std::string& value) {
  
  display_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.User.display_name)
}
#if LANG_CXX11
inline void User::set_display_name(::std::string&& value) {
  
  display_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.User.display_name)
}
#endif
inline void User::set_display_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  display_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.User.display_name)
}
inline void User::set_display_name(const char* value, size_t size) {
  
  display_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.User.display_name)
}
inline ::std::string* User::mutable_display_name() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.User.display_name)
  return display_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User::release_display_name() {
  // @@protoc_insertion_point(field_release:nakama.api.User.display_name)
  
  return display_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_allocated_display_name(::std::string* display_name) {
  if (display_name != NULL) {
    
  } else {
    
  }
  display_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), display_name);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.User.display_name)
}

// string avatar_url = 4;
inline void User::clear_avatar_url() {
  avatar_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& User::avatar_url() const {
  // @@protoc_insertion_point(field_get:nakama.api.User.avatar_url)
  return avatar_url_.GetNoArena();
}
inline void User::set_avatar_url(const ::std::string& value) {
  
  avatar_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.User.avatar_url)
}
#if LANG_CXX11
inline void User::set_avatar_url(::std::string&& value) {
  
  avatar_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.User.avatar_url)
}
#endif
inline void User::set_avatar_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  avatar_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.User.avatar_url)
}
inline void User::set_avatar_url(const char* value, size_t size) {
  
  avatar_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.User.avatar_url)
}
inline ::std::string* User::mutable_avatar_url() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.User.avatar_url)
  return avatar_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User::release_avatar_url() {
  // @@protoc_insertion_point(field_release:nakama.api.User.avatar_url)
  
  return avatar_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_allocated_avatar_url(::std::string* avatar_url) {
  if (avatar_url != NULL) {
    
  } else {
    
  }
  avatar_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), avatar_url);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.User.avatar_url)
}

// string lang_tag = 5;
inline void User::clear_lang_tag() {
  lang_tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& User::lang_tag() const {
  // @@protoc_insertion_point(field_get:nakama.api.User.lang_tag)
  return lang_tag_.GetNoArena();
}
inline void User::set_lang_tag(const ::std::string& value) {
  
  lang_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.User.lang_tag)
}
#if LANG_CXX11
inline void User::set_lang_tag(::std::string&& value) {
  
  lang_tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.User.lang_tag)
}
#endif
inline void User::set_lang_tag(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  lang_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.User.lang_tag)
}
inline void User::set_lang_tag(const char* value, size_t size) {
  
  lang_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.User.lang_tag)
}
inline ::std::string* User::mutable_lang_tag() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.User.lang_tag)
  return lang_tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User::release_lang_tag() {
  // @@protoc_insertion_point(field_release:nakama.api.User.lang_tag)
  
  return lang_tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_allocated_lang_tag(::std::string* lang_tag) {
  if (lang_tag != NULL) {
    
  } else {
    
  }
  lang_tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lang_tag);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.User.lang_tag)
}

// string location = 6;
inline void User::clear_location() {
  location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& User::location() const {
  // @@protoc_insertion_point(field_get:nakama.api.User.location)
  return location_.GetNoArena();
}
inline void User::set_location(const ::std::string& value) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.User.location)
}
#if LANG_CXX11
inline void User::set_location(::std::string&& value) {
  
  location_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.User.location)
}
#endif
inline void User::set_location(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.User.location)
}
inline void User::set_location(const char* value, size_t size) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.User.location)
}
inline ::std::string* User::mutable_location() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.User.location)
  return location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User::release_location() {
  // @@protoc_insertion_point(field_release:nakama.api.User.location)
  
  return location_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_allocated_location(::std::string* location) {
  if (location != NULL) {
    
  } else {
    
  }
  location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), location);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.User.location)
}

// string timezone = 7;
inline void User::clear_timezone() {
  timezone_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& User::timezone() const {
  // @@protoc_insertion_point(field_get:nakama.api.User.timezone)
  return timezone_.GetNoArena();
}
inline void User::set_timezone(const ::std::string& value) {
  
  timezone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.User.timezone)
}
#if LANG_CXX11
inline void User::set_timezone(::std::string&& value) {
  
  timezone_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.User.timezone)
}
#endif
inline void User::set_timezone(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  timezone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.User.timezone)
}
inline void User::set_timezone(const char* value, size_t size) {
  
  timezone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.User.timezone)
}
inline ::std::string* User::mutable_timezone() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.User.timezone)
  return timezone_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User::release_timezone() {
  // @@protoc_insertion_point(field_release:nakama.api.User.timezone)
  
  return timezone_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_allocated_timezone(::std::string* timezone) {
  if (timezone != NULL) {
    
  } else {
    
  }
  timezone_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), timezone);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.User.timezone)
}

// string metadata = 8;
inline void User::clear_metadata() {
  metadata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& User::metadata() const {
  // @@protoc_insertion_point(field_get:nakama.api.User.metadata)
  return metadata_.GetNoArena();
}
inline void User::set_metadata(const ::std::string& value) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.User.metadata)
}
#if LANG_CXX11
inline void User::set_metadata(::std::string&& value) {
  
  metadata_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.User.metadata)
}
#endif
inline void User::set_metadata(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.User.metadata)
}
inline void User::set_metadata(const char* value, size_t size) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.User.metadata)
}
inline ::std::string* User::mutable_metadata() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.User.metadata)
  return metadata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User::release_metadata() {
  // @@protoc_insertion_point(field_release:nakama.api.User.metadata)
  
  return metadata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_allocated_metadata(::std::string* metadata) {
  if (metadata != NULL) {
    
  } else {
    
  }
  metadata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), metadata);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.User.metadata)
}

// string facebook_id = 9;
inline void User::clear_facebook_id() {
  facebook_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& User::facebook_id() const {
  // @@protoc_insertion_point(field_get:nakama.api.User.facebook_id)
  return facebook_id_.GetNoArena();
}
inline void User::set_facebook_id(const ::std::string& value) {
  
  facebook_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.User.facebook_id)
}
#if LANG_CXX11
inline void User::set_facebook_id(::std::string&& value) {
  
  facebook_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.User.facebook_id)
}
#endif
inline void User::set_facebook_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  facebook_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.User.facebook_id)
}
inline void User::set_facebook_id(const char* value, size_t size) {
  
  facebook_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.User.facebook_id)
}
inline ::std::string* User::mutable_facebook_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.User.facebook_id)
  return facebook_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User::release_facebook_id() {
  // @@protoc_insertion_point(field_release:nakama.api.User.facebook_id)
  
  return facebook_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_allocated_facebook_id(::std::string* facebook_id) {
  if (facebook_id != NULL) {
    
  } else {
    
  }
  facebook_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), facebook_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.User.facebook_id)
}

// string google_id = 10;
inline void User::clear_google_id() {
  google_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& User::google_id() const {
  // @@protoc_insertion_point(field_get:nakama.api.User.google_id)
  return google_id_.GetNoArena();
}
inline void User::set_google_id(const ::std::string& value) {
  
  google_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.User.google_id)
}
#if LANG_CXX11
inline void User::set_google_id(::std::string&& value) {
  
  google_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.User.google_id)
}
#endif
inline void User::set_google_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  google_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.User.google_id)
}
inline void User::set_google_id(const char* value, size_t size) {
  
  google_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.User.google_id)
}
inline ::std::string* User::mutable_google_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.User.google_id)
  return google_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User::release_google_id() {
  // @@protoc_insertion_point(field_release:nakama.api.User.google_id)
  
  return google_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_allocated_google_id(::std::string* google_id) {
  if (google_id != NULL) {
    
  } else {
    
  }
  google_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), google_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.User.google_id)
}

// string gamecenter_id = 11;
inline void User::clear_gamecenter_id() {
  gamecenter_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& User::gamecenter_id() const {
  // @@protoc_insertion_point(field_get:nakama.api.User.gamecenter_id)
  return gamecenter_id_.GetNoArena();
}
inline void User::set_gamecenter_id(const ::std::string& value) {
  
  gamecenter_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.User.gamecenter_id)
}
#if LANG_CXX11
inline void User::set_gamecenter_id(::std::string&& value) {
  
  gamecenter_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.User.gamecenter_id)
}
#endif
inline void User::set_gamecenter_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  gamecenter_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.User.gamecenter_id)
}
inline void User::set_gamecenter_id(const char* value, size_t size) {
  
  gamecenter_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.User.gamecenter_id)
}
inline ::std::string* User::mutable_gamecenter_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.User.gamecenter_id)
  return gamecenter_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User::release_gamecenter_id() {
  // @@protoc_insertion_point(field_release:nakama.api.User.gamecenter_id)
  
  return gamecenter_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_allocated_gamecenter_id(::std::string* gamecenter_id) {
  if (gamecenter_id != NULL) {
    
  } else {
    
  }
  gamecenter_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gamecenter_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.User.gamecenter_id)
}

// string steam_id = 12;
inline void User::clear_steam_id() {
  steam_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& User::steam_id() const {
  // @@protoc_insertion_point(field_get:nakama.api.User.steam_id)
  return steam_id_.GetNoArena();
}
inline void User::set_steam_id(const ::std::string& value) {
  
  steam_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.User.steam_id)
}
#if LANG_CXX11
inline void User::set_steam_id(::std::string&& value) {
  
  steam_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.User.steam_id)
}
#endif
inline void User::set_steam_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  steam_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.User.steam_id)
}
inline void User::set_steam_id(const char* value, size_t size) {
  
  steam_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.User.steam_id)
}
inline ::std::string* User::mutable_steam_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.User.steam_id)
  return steam_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User::release_steam_id() {
  // @@protoc_insertion_point(field_release:nakama.api.User.steam_id)
  
  return steam_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_allocated_steam_id(::std::string* steam_id) {
  if (steam_id != NULL) {
    
  } else {
    
  }
  steam_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), steam_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.User.steam_id)
}

// bool online = 13;
inline void User::clear_online() {
  online_ = false;
}
inline bool User::online() const {
  // @@protoc_insertion_point(field_get:nakama.api.User.online)
  return online_;
}
inline void User::set_online(bool value) {
  
  online_ = value;
  // @@protoc_insertion_point(field_set:nakama.api.User.online)
}

// int32 edge_count = 14;
inline void User::clear_edge_count() {
  edge_count_ = 0;
}
inline ::google::protobuf::int32 User::edge_count() const {
  // @@protoc_insertion_point(field_get:nakama.api.User.edge_count)
  return edge_count_;
}
inline void User::set_edge_count(::google::protobuf::int32 value) {
  
  edge_count_ = value;
  // @@protoc_insertion_point(field_set:nakama.api.User.edge_count)
}

// .google.protobuf.Timestamp create_time = 15;
inline bool User::has_create_time() const {
  return this != internal_default_instance() && create_time_ != NULL;
}
inline const ::google::protobuf::Timestamp& User::_internal_create_time() const {
  return *create_time_;
}
inline const ::google::protobuf::Timestamp& User::create_time() const {
  const ::google::protobuf::Timestamp* p = create_time_;
  // @@protoc_insertion_point(field_get:nakama.api.User.create_time)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* User::release_create_time() {
  // @@protoc_insertion_point(field_release:nakama.api.User.create_time)
  
  ::google::protobuf::Timestamp* temp = create_time_;
  create_time_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* User::mutable_create_time() {
  
  if (create_time_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    create_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.User.create_time)
  return create_time_;
}
inline void User::set_allocated_create_time(::google::protobuf::Timestamp* create_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(create_time_);
  }
  if (create_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(create_time)->GetArena();
    if (message_arena != submessage_arena) {
      create_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, create_time, submessage_arena);
    }
    
  } else {
    
  }
  create_time_ = create_time;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.User.create_time)
}

// .google.protobuf.Timestamp update_time = 16;
inline bool User::has_update_time() const {
  return this != internal_default_instance() && update_time_ != NULL;
}
inline const ::google::protobuf::Timestamp& User::_internal_update_time() const {
  return *update_time_;
}
inline const ::google::protobuf::Timestamp& User::update_time() const {
  const ::google::protobuf::Timestamp* p = update_time_;
  // @@protoc_insertion_point(field_get:nakama.api.User.update_time)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* User::release_update_time() {
  // @@protoc_insertion_point(field_release:nakama.api.User.update_time)
  
  ::google::protobuf::Timestamp* temp = update_time_;
  update_time_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* User::mutable_update_time() {
  
  if (update_time_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    update_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.User.update_time)
  return update_time_;
}
inline void User::set_allocated_update_time(::google::protobuf::Timestamp* update_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(update_time_);
  }
  if (update_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(update_time)->GetArena();
    if (message_arena != submessage_arena) {
      update_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, update_time, submessage_arena);
    }
    
  } else {
    
  }
  update_time_ = update_time;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.User.update_time)
}

// -------------------------------------------------------------------

// UserGroupList_UserGroup

// .nakama.api.Group group = 1;
inline bool UserGroupList_UserGroup::has_group() const {
  return this != internal_default_instance() && group_ != NULL;
}
inline void UserGroupList_UserGroup::clear_group() {
  if (GetArenaNoVirtual() == NULL && group_ != NULL) {
    delete group_;
  }
  group_ = NULL;
}
inline const ::nakama::api::Group& UserGroupList_UserGroup::_internal_group() const {
  return *group_;
}
inline const ::nakama::api::Group& UserGroupList_UserGroup::group() const {
  const ::nakama::api::Group* p = group_;
  // @@protoc_insertion_point(field_get:nakama.api.UserGroupList.UserGroup.group)
  return p != NULL ? *p : *reinterpret_cast<const ::nakama::api::Group*>(
      &::nakama::api::_Group_default_instance_);
}
inline ::nakama::api::Group* UserGroupList_UserGroup::release_group() {
  // @@protoc_insertion_point(field_release:nakama.api.UserGroupList.UserGroup.group)
  
  ::nakama::api::Group* temp = group_;
  group_ = NULL;
  return temp;
}
inline ::nakama::api::Group* UserGroupList_UserGroup::mutable_group() {
  
  if (group_ == NULL) {
    auto* p = CreateMaybeMessage<::nakama::api::Group>(GetArenaNoVirtual());
    group_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.UserGroupList.UserGroup.group)
  return group_;
}
inline void UserGroupList_UserGroup::set_allocated_group(::nakama::api::Group* group) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete group_;
  }
  if (group) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      group = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, group, submessage_arena);
    }
    
  } else {
    
  }
  group_ = group;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.UserGroupList.UserGroup.group)
}

// .google.protobuf.Int32Value state = 2;
inline bool UserGroupList_UserGroup::has_state() const {
  return this != internal_default_instance() && state_ != NULL;
}
inline const ::google::protobuf::Int32Value& UserGroupList_UserGroup::_internal_state() const {
  return *state_;
}
inline const ::google::protobuf::Int32Value& UserGroupList_UserGroup::state() const {
  const ::google::protobuf::Int32Value* p = state_;
  // @@protoc_insertion_point(field_get:nakama.api.UserGroupList.UserGroup.state)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* UserGroupList_UserGroup::release_state() {
  // @@protoc_insertion_point(field_release:nakama.api.UserGroupList.UserGroup.state)
  
  ::google::protobuf::Int32Value* temp = state_;
  state_ = NULL;
  return temp;
}
inline ::google::protobuf::Int32Value* UserGroupList_UserGroup::mutable_state() {
  
  if (state_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    state_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.UserGroupList.UserGroup.state)
  return state_;
}
inline void UserGroupList_UserGroup::set_allocated_state(::google::protobuf::Int32Value* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(state_);
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(state)->GetArena();
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.UserGroupList.UserGroup.state)
}

// -------------------------------------------------------------------

// UserGroupList

// repeated .nakama.api.UserGroupList.UserGroup user_groups = 1;
inline int UserGroupList::user_groups_size() const {
  return user_groups_.size();
}
inline void UserGroupList::clear_user_groups() {
  user_groups_.Clear();
}
inline ::nakama::api::UserGroupList_UserGroup* UserGroupList::mutable_user_groups(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.api.UserGroupList.user_groups)
  return user_groups_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nakama::api::UserGroupList_UserGroup >*
UserGroupList::mutable_user_groups() {
  // @@protoc_insertion_point(field_mutable_list:nakama.api.UserGroupList.user_groups)
  return &user_groups_;
}
inline const ::nakama::api::UserGroupList_UserGroup& UserGroupList::user_groups(int index) const {
  // @@protoc_insertion_point(field_get:nakama.api.UserGroupList.user_groups)
  return user_groups_.Get(index);
}
inline ::nakama::api::UserGroupList_UserGroup* UserGroupList::add_user_groups() {
  // @@protoc_insertion_point(field_add:nakama.api.UserGroupList.user_groups)
  return user_groups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nakama::api::UserGroupList_UserGroup >&
UserGroupList::user_groups() const {
  // @@protoc_insertion_point(field_list:nakama.api.UserGroupList.user_groups)
  return user_groups_;
}

// -------------------------------------------------------------------

// Users

// repeated .nakama.api.User users = 1;
inline int Users::users_size() const {
  return users_.size();
}
inline void Users::clear_users() {
  users_.Clear();
}
inline ::nakama::api::User* Users::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.api.Users.users)
  return users_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nakama::api::User >*
Users::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:nakama.api.Users.users)
  return &users_;
}
inline const ::nakama::api::User& Users::users(int index) const {
  // @@protoc_insertion_point(field_get:nakama.api.Users.users)
  return users_.Get(index);
}
inline ::nakama::api::User* Users::add_users() {
  // @@protoc_insertion_point(field_add:nakama.api.Users.users)
  return users_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nakama::api::User >&
Users::users() const {
  // @@protoc_insertion_point(field_list:nakama.api.Users.users)
  return users_;
}

// -------------------------------------------------------------------

// WriteLeaderboardRecordRequest_LeaderboardRecordWrite

// int64 score = 1;
inline void WriteLeaderboardRecordRequest_LeaderboardRecordWrite::clear_score() {
  score_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 WriteLeaderboardRecordRequest_LeaderboardRecordWrite::score() const {
  // @@protoc_insertion_point(field_get:nakama.api.WriteLeaderboardRecordRequest.LeaderboardRecordWrite.score)
  return score_;
}
inline void WriteLeaderboardRecordRequest_LeaderboardRecordWrite::set_score(::google::protobuf::int64 value) {
  
  score_ = value;
  // @@protoc_insertion_point(field_set:nakama.api.WriteLeaderboardRecordRequest.LeaderboardRecordWrite.score)
}

// int64 subscore = 2;
inline void WriteLeaderboardRecordRequest_LeaderboardRecordWrite::clear_subscore() {
  subscore_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 WriteLeaderboardRecordRequest_LeaderboardRecordWrite::subscore() const {
  // @@protoc_insertion_point(field_get:nakama.api.WriteLeaderboardRecordRequest.LeaderboardRecordWrite.subscore)
  return subscore_;
}
inline void WriteLeaderboardRecordRequest_LeaderboardRecordWrite::set_subscore(::google::protobuf::int64 value) {
  
  subscore_ = value;
  // @@protoc_insertion_point(field_set:nakama.api.WriteLeaderboardRecordRequest.LeaderboardRecordWrite.subscore)
}

// string metadata = 3;
inline void WriteLeaderboardRecordRequest_LeaderboardRecordWrite::clear_metadata() {
  metadata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WriteLeaderboardRecordRequest_LeaderboardRecordWrite::metadata() const {
  // @@protoc_insertion_point(field_get:nakama.api.WriteLeaderboardRecordRequest.LeaderboardRecordWrite.metadata)
  return metadata_.GetNoArena();
}
inline void WriteLeaderboardRecordRequest_LeaderboardRecordWrite::set_metadata(const ::std::string& value) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.WriteLeaderboardRecordRequest.LeaderboardRecordWrite.metadata)
}
#if LANG_CXX11
inline void WriteLeaderboardRecordRequest_LeaderboardRecordWrite::set_metadata(::std::string&& value) {
  
  metadata_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.WriteLeaderboardRecordRequest.LeaderboardRecordWrite.metadata)
}
#endif
inline void WriteLeaderboardRecordRequest_LeaderboardRecordWrite::set_metadata(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.WriteLeaderboardRecordRequest.LeaderboardRecordWrite.metadata)
}
inline void WriteLeaderboardRecordRequest_LeaderboardRecordWrite::set_metadata(const char* value, size_t size) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.WriteLeaderboardRecordRequest.LeaderboardRecordWrite.metadata)
}
inline ::std::string* WriteLeaderboardRecordRequest_LeaderboardRecordWrite::mutable_metadata() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.WriteLeaderboardRecordRequest.LeaderboardRecordWrite.metadata)
  return metadata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WriteLeaderboardRecordRequest_LeaderboardRecordWrite::release_metadata() {
  // @@protoc_insertion_point(field_release:nakama.api.WriteLeaderboardRecordRequest.LeaderboardRecordWrite.metadata)
  
  return metadata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WriteLeaderboardRecordRequest_LeaderboardRecordWrite::set_allocated_metadata(::std::string* metadata) {
  if (metadata != NULL) {
    
  } else {
    
  }
  metadata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), metadata);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.WriteLeaderboardRecordRequest.LeaderboardRecordWrite.metadata)
}

// -------------------------------------------------------------------

// WriteLeaderboardRecordRequest

// string leaderboard_id = 1;
inline void WriteLeaderboardRecordRequest::clear_leaderboard_id() {
  leaderboard_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WriteLeaderboardRecordRequest::leaderboard_id() const {
  // @@protoc_insertion_point(field_get:nakama.api.WriteLeaderboardRecordRequest.leaderboard_id)
  return leaderboard_id_.GetNoArena();
}
inline void WriteLeaderboardRecordRequest::set_leaderboard_id(const ::std::string& value) {
  
  leaderboard_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.WriteLeaderboardRecordRequest.leaderboard_id)
}
#if LANG_CXX11
inline void WriteLeaderboardRecordRequest::set_leaderboard_id(::std::string&& value) {
  
  leaderboard_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.WriteLeaderboardRecordRequest.leaderboard_id)
}
#endif
inline void WriteLeaderboardRecordRequest::set_leaderboard_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  leaderboard_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.WriteLeaderboardRecordRequest.leaderboard_id)
}
inline void WriteLeaderboardRecordRequest::set_leaderboard_id(const char* value, size_t size) {
  
  leaderboard_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.WriteLeaderboardRecordRequest.leaderboard_id)
}
inline ::std::string* WriteLeaderboardRecordRequest::mutable_leaderboard_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.WriteLeaderboardRecordRequest.leaderboard_id)
  return leaderboard_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WriteLeaderboardRecordRequest::release_leaderboard_id() {
  // @@protoc_insertion_point(field_release:nakama.api.WriteLeaderboardRecordRequest.leaderboard_id)
  
  return leaderboard_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WriteLeaderboardRecordRequest::set_allocated_leaderboard_id(::std::string* leaderboard_id) {
  if (leaderboard_id != NULL) {
    
  } else {
    
  }
  leaderboard_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), leaderboard_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.WriteLeaderboardRecordRequest.leaderboard_id)
}

// .nakama.api.WriteLeaderboardRecordRequest.LeaderboardRecordWrite record = 2;
inline bool WriteLeaderboardRecordRequest::has_record() const {
  return this != internal_default_instance() && record_ != NULL;
}
inline void WriteLeaderboardRecordRequest::clear_record() {
  if (GetArenaNoVirtual() == NULL && record_ != NULL) {
    delete record_;
  }
  record_ = NULL;
}
inline const ::nakama::api::WriteLeaderboardRecordRequest_LeaderboardRecordWrite& WriteLeaderboardRecordRequest::_internal_record() const {
  return *record_;
}
inline const ::nakama::api::WriteLeaderboardRecordRequest_LeaderboardRecordWrite& WriteLeaderboardRecordRequest::record() const {
  const ::nakama::api::WriteLeaderboardRecordRequest_LeaderboardRecordWrite* p = record_;
  // @@protoc_insertion_point(field_get:nakama.api.WriteLeaderboardRecordRequest.record)
  return p != NULL ? *p : *reinterpret_cast<const ::nakama::api::WriteLeaderboardRecordRequest_LeaderboardRecordWrite*>(
      &::nakama::api::_WriteLeaderboardRecordRequest_LeaderboardRecordWrite_default_instance_);
}
inline ::nakama::api::WriteLeaderboardRecordRequest_LeaderboardRecordWrite* WriteLeaderboardRecordRequest::release_record() {
  // @@protoc_insertion_point(field_release:nakama.api.WriteLeaderboardRecordRequest.record)
  
  ::nakama::api::WriteLeaderboardRecordRequest_LeaderboardRecordWrite* temp = record_;
  record_ = NULL;
  return temp;
}
inline ::nakama::api::WriteLeaderboardRecordRequest_LeaderboardRecordWrite* WriteLeaderboardRecordRequest::mutable_record() {
  
  if (record_ == NULL) {
    auto* p = CreateMaybeMessage<::nakama::api::WriteLeaderboardRecordRequest_LeaderboardRecordWrite>(GetArenaNoVirtual());
    record_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.WriteLeaderboardRecordRequest.record)
  return record_;
}
inline void WriteLeaderboardRecordRequest::set_allocated_record(::nakama::api::WriteLeaderboardRecordRequest_LeaderboardRecordWrite* record) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete record_;
  }
  if (record) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      record = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, record, submessage_arena);
    }
    
  } else {
    
  }
  record_ = record;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.WriteLeaderboardRecordRequest.record)
}

// -------------------------------------------------------------------

// WriteStorageObject

// string collection = 1;
inline void WriteStorageObject::clear_collection() {
  collection_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WriteStorageObject::collection() const {
  // @@protoc_insertion_point(field_get:nakama.api.WriteStorageObject.collection)
  return collection_.GetNoArena();
}
inline void WriteStorageObject::set_collection(const ::std::string& value) {
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.WriteStorageObject.collection)
}
#if LANG_CXX11
inline void WriteStorageObject::set_collection(::std::string&& value) {
  
  collection_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.WriteStorageObject.collection)
}
#endif
inline void WriteStorageObject::set_collection(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.WriteStorageObject.collection)
}
inline void WriteStorageObject::set_collection(const char* value, size_t size) {
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.WriteStorageObject.collection)
}
inline ::std::string* WriteStorageObject::mutable_collection() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.WriteStorageObject.collection)
  return collection_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WriteStorageObject::release_collection() {
  // @@protoc_insertion_point(field_release:nakama.api.WriteStorageObject.collection)
  
  return collection_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WriteStorageObject::set_allocated_collection(::std::string* collection) {
  if (collection != NULL) {
    
  } else {
    
  }
  collection_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), collection);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.WriteStorageObject.collection)
}

// string key = 2;
inline void WriteStorageObject::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WriteStorageObject::key() const {
  // @@protoc_insertion_point(field_get:nakama.api.WriteStorageObject.key)
  return key_.GetNoArena();
}
inline void WriteStorageObject::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.WriteStorageObject.key)
}
#if LANG_CXX11
inline void WriteStorageObject::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.WriteStorageObject.key)
}
#endif
inline void WriteStorageObject::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.WriteStorageObject.key)
}
inline void WriteStorageObject::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.WriteStorageObject.key)
}
inline ::std::string* WriteStorageObject::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.WriteStorageObject.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WriteStorageObject::release_key() {
  // @@protoc_insertion_point(field_release:nakama.api.WriteStorageObject.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WriteStorageObject::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.WriteStorageObject.key)
}

// string value = 3;
inline void WriteStorageObject::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WriteStorageObject::value() const {
  // @@protoc_insertion_point(field_get:nakama.api.WriteStorageObject.value)
  return value_.GetNoArena();
}
inline void WriteStorageObject::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.WriteStorageObject.value)
}
#if LANG_CXX11
inline void WriteStorageObject::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.WriteStorageObject.value)
}
#endif
inline void WriteStorageObject::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.WriteStorageObject.value)
}
inline void WriteStorageObject::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.WriteStorageObject.value)
}
inline ::std::string* WriteStorageObject::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.WriteStorageObject.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WriteStorageObject::release_value() {
  // @@protoc_insertion_point(field_release:nakama.api.WriteStorageObject.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WriteStorageObject::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.WriteStorageObject.value)
}

// string version = 4;
inline void WriteStorageObject::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WriteStorageObject::version() const {
  // @@protoc_insertion_point(field_get:nakama.api.WriteStorageObject.version)
  return version_.GetNoArena();
}
inline void WriteStorageObject::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.WriteStorageObject.version)
}
#if LANG_CXX11
inline void WriteStorageObject::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.WriteStorageObject.version)
}
#endif
inline void WriteStorageObject::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.WriteStorageObject.version)
}
inline void WriteStorageObject::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.WriteStorageObject.version)
}
inline ::std::string* WriteStorageObject::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.WriteStorageObject.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WriteStorageObject::release_version() {
  // @@protoc_insertion_point(field_release:nakama.api.WriteStorageObject.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WriteStorageObject::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.WriteStorageObject.version)
}

// .google.protobuf.Int32Value permission_read = 5;
inline bool WriteStorageObject::has_permission_read() const {
  return this != internal_default_instance() && permission_read_ != NULL;
}
inline const ::google::protobuf::Int32Value& WriteStorageObject::_internal_permission_read() const {
  return *permission_read_;
}
inline const ::google::protobuf::Int32Value& WriteStorageObject::permission_read() const {
  const ::google::protobuf::Int32Value* p = permission_read_;
  // @@protoc_insertion_point(field_get:nakama.api.WriteStorageObject.permission_read)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* WriteStorageObject::release_permission_read() {
  // @@protoc_insertion_point(field_release:nakama.api.WriteStorageObject.permission_read)
  
  ::google::protobuf::Int32Value* temp = permission_read_;
  permission_read_ = NULL;
  return temp;
}
inline ::google::protobuf::Int32Value* WriteStorageObject::mutable_permission_read() {
  
  if (permission_read_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    permission_read_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.WriteStorageObject.permission_read)
  return permission_read_;
}
inline void WriteStorageObject::set_allocated_permission_read(::google::protobuf::Int32Value* permission_read) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(permission_read_);
  }
  if (permission_read) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(permission_read)->GetArena();
    if (message_arena != submessage_arena) {
      permission_read = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, permission_read, submessage_arena);
    }
    
  } else {
    
  }
  permission_read_ = permission_read;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.WriteStorageObject.permission_read)
}

// .google.protobuf.Int32Value permission_write = 6;
inline bool WriteStorageObject::has_permission_write() const {
  return this != internal_default_instance() && permission_write_ != NULL;
}
inline const ::google::protobuf::Int32Value& WriteStorageObject::_internal_permission_write() const {
  return *permission_write_;
}
inline const ::google::protobuf::Int32Value& WriteStorageObject::permission_write() const {
  const ::google::protobuf::Int32Value* p = permission_write_;
  // @@protoc_insertion_point(field_get:nakama.api.WriteStorageObject.permission_write)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* WriteStorageObject::release_permission_write() {
  // @@protoc_insertion_point(field_release:nakama.api.WriteStorageObject.permission_write)
  
  ::google::protobuf::Int32Value* temp = permission_write_;
  permission_write_ = NULL;
  return temp;
}
inline ::google::protobuf::Int32Value* WriteStorageObject::mutable_permission_write() {
  
  if (permission_write_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    permission_write_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.WriteStorageObject.permission_write)
  return permission_write_;
}
inline void WriteStorageObject::set_allocated_permission_write(::google::protobuf::Int32Value* permission_write) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(permission_write_);
  }
  if (permission_write) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(permission_write)->GetArena();
    if (message_arena != submessage_arena) {
      permission_write = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, permission_write, submessage_arena);
    }
    
  } else {
    
  }
  permission_write_ = permission_write;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.WriteStorageObject.permission_write)
}

// -------------------------------------------------------------------

// WriteStorageObjectsRequest

// repeated .nakama.api.WriteStorageObject objects = 1;
inline int WriteStorageObjectsRequest::objects_size() const {
  return objects_.size();
}
inline void WriteStorageObjectsRequest::clear_objects() {
  objects_.Clear();
}
inline ::nakama::api::WriteStorageObject* WriteStorageObjectsRequest::mutable_objects(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.api.WriteStorageObjectsRequest.objects)
  return objects_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nakama::api::WriteStorageObject >*
WriteStorageObjectsRequest::mutable_objects() {
  // @@protoc_insertion_point(field_mutable_list:nakama.api.WriteStorageObjectsRequest.objects)
  return &objects_;
}
inline const ::nakama::api::WriteStorageObject& WriteStorageObjectsRequest::objects(int index) const {
  // @@protoc_insertion_point(field_get:nakama.api.WriteStorageObjectsRequest.objects)
  return objects_.Get(index);
}
inline ::nakama::api::WriteStorageObject* WriteStorageObjectsRequest::add_objects() {
  // @@protoc_insertion_point(field_add:nakama.api.WriteStorageObjectsRequest.objects)
  return objects_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nakama::api::WriteStorageObject >&
WriteStorageObjectsRequest::objects() const {
  // @@protoc_insertion_point(field_list:nakama.api.WriteStorageObjectsRequest.objects)
  return objects_;
}

// -------------------------------------------------------------------

// WriteTournamentRecordRequest_TournamentRecordWrite

// int64 score = 1;
inline void WriteTournamentRecordRequest_TournamentRecordWrite::clear_score() {
  score_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 WriteTournamentRecordRequest_TournamentRecordWrite::score() const {
  // @@protoc_insertion_point(field_get:nakama.api.WriteTournamentRecordRequest.TournamentRecordWrite.score)
  return score_;
}
inline void WriteTournamentRecordRequest_TournamentRecordWrite::set_score(::google::protobuf::int64 value) {
  
  score_ = value;
  // @@protoc_insertion_point(field_set:nakama.api.WriteTournamentRecordRequest.TournamentRecordWrite.score)
}

// int64 subscore = 2;
inline void WriteTournamentRecordRequest_TournamentRecordWrite::clear_subscore() {
  subscore_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 WriteTournamentRecordRequest_TournamentRecordWrite::subscore() const {
  // @@protoc_insertion_point(field_get:nakama.api.WriteTournamentRecordRequest.TournamentRecordWrite.subscore)
  return subscore_;
}
inline void WriteTournamentRecordRequest_TournamentRecordWrite::set_subscore(::google::protobuf::int64 value) {
  
  subscore_ = value;
  // @@protoc_insertion_point(field_set:nakama.api.WriteTournamentRecordRequest.TournamentRecordWrite.subscore)
}

// string metadata = 3;
inline void WriteTournamentRecordRequest_TournamentRecordWrite::clear_metadata() {
  metadata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WriteTournamentRecordRequest_TournamentRecordWrite::metadata() const {
  // @@protoc_insertion_point(field_get:nakama.api.WriteTournamentRecordRequest.TournamentRecordWrite.metadata)
  return metadata_.GetNoArena();
}
inline void WriteTournamentRecordRequest_TournamentRecordWrite::set_metadata(const ::std::string& value) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.WriteTournamentRecordRequest.TournamentRecordWrite.metadata)
}
#if LANG_CXX11
inline void WriteTournamentRecordRequest_TournamentRecordWrite::set_metadata(::std::string&& value) {
  
  metadata_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.WriteTournamentRecordRequest.TournamentRecordWrite.metadata)
}
#endif
inline void WriteTournamentRecordRequest_TournamentRecordWrite::set_metadata(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.WriteTournamentRecordRequest.TournamentRecordWrite.metadata)
}
inline void WriteTournamentRecordRequest_TournamentRecordWrite::set_metadata(const char* value, size_t size) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.WriteTournamentRecordRequest.TournamentRecordWrite.metadata)
}
inline ::std::string* WriteTournamentRecordRequest_TournamentRecordWrite::mutable_metadata() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.WriteTournamentRecordRequest.TournamentRecordWrite.metadata)
  return metadata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WriteTournamentRecordRequest_TournamentRecordWrite::release_metadata() {
  // @@protoc_insertion_point(field_release:nakama.api.WriteTournamentRecordRequest.TournamentRecordWrite.metadata)
  
  return metadata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WriteTournamentRecordRequest_TournamentRecordWrite::set_allocated_metadata(::std::string* metadata) {
  if (metadata != NULL) {
    
  } else {
    
  }
  metadata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), metadata);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.WriteTournamentRecordRequest.TournamentRecordWrite.metadata)
}

// -------------------------------------------------------------------

// WriteTournamentRecordRequest

// string tournament_id = 1;
inline void WriteTournamentRecordRequest::clear_tournament_id() {
  tournament_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WriteTournamentRecordRequest::tournament_id() const {
  // @@protoc_insertion_point(field_get:nakama.api.WriteTournamentRecordRequest.tournament_id)
  return tournament_id_.GetNoArena();
}
inline void WriteTournamentRecordRequest::set_tournament_id(const ::std::string& value) {
  
  tournament_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.api.WriteTournamentRecordRequest.tournament_id)
}
#if LANG_CXX11
inline void WriteTournamentRecordRequest::set_tournament_id(::std::string&& value) {
  
  tournament_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.api.WriteTournamentRecordRequest.tournament_id)
}
#endif
inline void WriteTournamentRecordRequest::set_tournament_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tournament_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.api.WriteTournamentRecordRequest.tournament_id)
}
inline void WriteTournamentRecordRequest::set_tournament_id(const char* value, size_t size) {
  
  tournament_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.api.WriteTournamentRecordRequest.tournament_id)
}
inline ::std::string* WriteTournamentRecordRequest::mutable_tournament_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.api.WriteTournamentRecordRequest.tournament_id)
  return tournament_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WriteTournamentRecordRequest::release_tournament_id() {
  // @@protoc_insertion_point(field_release:nakama.api.WriteTournamentRecordRequest.tournament_id)
  
  return tournament_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WriteTournamentRecordRequest::set_allocated_tournament_id(::std::string* tournament_id) {
  if (tournament_id != NULL) {
    
  } else {
    
  }
  tournament_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tournament_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.api.WriteTournamentRecordRequest.tournament_id)
}

// .nakama.api.WriteTournamentRecordRequest.TournamentRecordWrite record = 2;
inline bool WriteTournamentRecordRequest::has_record() const {
  return this != internal_default_instance() && record_ != NULL;
}
inline void WriteTournamentRecordRequest::clear_record() {
  if (GetArenaNoVirtual() == NULL && record_ != NULL) {
    delete record_;
  }
  record_ = NULL;
}
inline const ::nakama::api::WriteTournamentRecordRequest_TournamentRecordWrite& WriteTournamentRecordRequest::_internal_record() const {
  return *record_;
}
inline const ::nakama::api::WriteTournamentRecordRequest_TournamentRecordWrite& WriteTournamentRecordRequest::record() const {
  const ::nakama::api::WriteTournamentRecordRequest_TournamentRecordWrite* p = record_;
  // @@protoc_insertion_point(field_get:nakama.api.WriteTournamentRecordRequest.record)
  return p != NULL ? *p : *reinterpret_cast<const ::nakama::api::WriteTournamentRecordRequest_TournamentRecordWrite*>(
      &::nakama::api::_WriteTournamentRecordRequest_TournamentRecordWrite_default_instance_);
}
inline ::nakama::api::WriteTournamentRecordRequest_TournamentRecordWrite* WriteTournamentRecordRequest::release_record() {
  // @@protoc_insertion_point(field_release:nakama.api.WriteTournamentRecordRequest.record)
  
  ::nakama::api::WriteTournamentRecordRequest_TournamentRecordWrite* temp = record_;
  record_ = NULL;
  return temp;
}
inline ::nakama::api::WriteTournamentRecordRequest_TournamentRecordWrite* WriteTournamentRecordRequest::mutable_record() {
  
  if (record_ == NULL) {
    auto* p = CreateMaybeMessage<::nakama::api::WriteTournamentRecordRequest_TournamentRecordWrite>(GetArenaNoVirtual());
    record_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.api.WriteTournamentRecordRequest.record)
  return record_;
}
inline void WriteTournamentRecordRequest::set_allocated_record(::nakama::api::WriteTournamentRecordRequest_TournamentRecordWrite* record) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete record_;
  }
  if (record) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      record = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, record, submessage_arena);
    }
    
  } else {
    
  }
  record_ = record;
  // @@protoc_insertion_point(field_set_allocated:nakama.api.WriteTournamentRecordRequest.record)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace api
}  // namespace nakama

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::nakama::api::Friend_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nakama::api::Friend_State>() {
  return ::nakama::api::Friend_State_descriptor();
}
template <> struct is_proto_enum< ::nakama::api::GroupUserList_GroupUser_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nakama::api::GroupUserList_GroupUser_State>() {
  return ::nakama::api::GroupUserList_GroupUser_State_descriptor();
}
template <> struct is_proto_enum< ::nakama::api::UserGroupList_UserGroup_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nakama::api::UserGroupList_UserGroup_State>() {
  return ::nakama::api::UserGroupList_UserGroup_State_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_github_2ecom_2fheroiclabs_2fnakama_2fapi_2fapi_2eproto
