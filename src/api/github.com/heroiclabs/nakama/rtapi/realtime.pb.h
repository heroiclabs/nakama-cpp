// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: github.com/heroiclabs/nakama/rtapi/realtime.proto

#ifndef PROTOBUF_INCLUDED_github_2ecom_2fheroiclabs_2fnakama_2frtapi_2frealtime_2eproto
#define PROTOBUF_INCLUDED_github_2ecom_2fheroiclabs_2fnakama_2frtapi_2frealtime_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/wrappers.pb.h>
#include "github.com/heroiclabs/nakama/api/api.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_github_2ecom_2fheroiclabs_2fnakama_2frtapi_2frealtime_2eproto 

namespace protobuf_github_2ecom_2fheroiclabs_2fnakama_2frtapi_2frealtime_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[38];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_github_2ecom_2fheroiclabs_2fnakama_2frtapi_2frealtime_2eproto
namespace nakama {
namespace realtime {
class Channel;
class ChannelDefaultTypeInternal;
extern ChannelDefaultTypeInternal _Channel_default_instance_;
class ChannelJoin;
class ChannelJoinDefaultTypeInternal;
extern ChannelJoinDefaultTypeInternal _ChannelJoin_default_instance_;
class ChannelLeave;
class ChannelLeaveDefaultTypeInternal;
extern ChannelLeaveDefaultTypeInternal _ChannelLeave_default_instance_;
class ChannelMessageAck;
class ChannelMessageAckDefaultTypeInternal;
extern ChannelMessageAckDefaultTypeInternal _ChannelMessageAck_default_instance_;
class ChannelMessageRemove;
class ChannelMessageRemoveDefaultTypeInternal;
extern ChannelMessageRemoveDefaultTypeInternal _ChannelMessageRemove_default_instance_;
class ChannelMessageSend;
class ChannelMessageSendDefaultTypeInternal;
extern ChannelMessageSendDefaultTypeInternal _ChannelMessageSend_default_instance_;
class ChannelMessageUpdate;
class ChannelMessageUpdateDefaultTypeInternal;
extern ChannelMessageUpdateDefaultTypeInternal _ChannelMessageUpdate_default_instance_;
class ChannelPresenceEvent;
class ChannelPresenceEventDefaultTypeInternal;
extern ChannelPresenceEventDefaultTypeInternal _ChannelPresenceEvent_default_instance_;
class Envelope;
class EnvelopeDefaultTypeInternal;
extern EnvelopeDefaultTypeInternal _Envelope_default_instance_;
class Error;
class ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class Error_ContextEntry_DoNotUse;
class Error_ContextEntry_DoNotUseDefaultTypeInternal;
extern Error_ContextEntry_DoNotUseDefaultTypeInternal _Error_ContextEntry_DoNotUse_default_instance_;
class Match;
class MatchDefaultTypeInternal;
extern MatchDefaultTypeInternal _Match_default_instance_;
class MatchCreate;
class MatchCreateDefaultTypeInternal;
extern MatchCreateDefaultTypeInternal _MatchCreate_default_instance_;
class MatchData;
class MatchDataDefaultTypeInternal;
extern MatchDataDefaultTypeInternal _MatchData_default_instance_;
class MatchDataSend;
class MatchDataSendDefaultTypeInternal;
extern MatchDataSendDefaultTypeInternal _MatchDataSend_default_instance_;
class MatchJoin;
class MatchJoinDefaultTypeInternal;
extern MatchJoinDefaultTypeInternal _MatchJoin_default_instance_;
class MatchJoin_MetadataEntry_DoNotUse;
class MatchJoin_MetadataEntry_DoNotUseDefaultTypeInternal;
extern MatchJoin_MetadataEntry_DoNotUseDefaultTypeInternal _MatchJoin_MetadataEntry_DoNotUse_default_instance_;
class MatchLeave;
class MatchLeaveDefaultTypeInternal;
extern MatchLeaveDefaultTypeInternal _MatchLeave_default_instance_;
class MatchPresenceEvent;
class MatchPresenceEventDefaultTypeInternal;
extern MatchPresenceEventDefaultTypeInternal _MatchPresenceEvent_default_instance_;
class MatchmakerAdd;
class MatchmakerAddDefaultTypeInternal;
extern MatchmakerAddDefaultTypeInternal _MatchmakerAdd_default_instance_;
class MatchmakerAdd_NumericPropertiesEntry_DoNotUse;
class MatchmakerAdd_NumericPropertiesEntry_DoNotUseDefaultTypeInternal;
extern MatchmakerAdd_NumericPropertiesEntry_DoNotUseDefaultTypeInternal _MatchmakerAdd_NumericPropertiesEntry_DoNotUse_default_instance_;
class MatchmakerAdd_StringPropertiesEntry_DoNotUse;
class MatchmakerAdd_StringPropertiesEntry_DoNotUseDefaultTypeInternal;
extern MatchmakerAdd_StringPropertiesEntry_DoNotUseDefaultTypeInternal _MatchmakerAdd_StringPropertiesEntry_DoNotUse_default_instance_;
class MatchmakerMatched;
class MatchmakerMatchedDefaultTypeInternal;
extern MatchmakerMatchedDefaultTypeInternal _MatchmakerMatched_default_instance_;
class MatchmakerMatched_MatchmakerUser;
class MatchmakerMatched_MatchmakerUserDefaultTypeInternal;
extern MatchmakerMatched_MatchmakerUserDefaultTypeInternal _MatchmakerMatched_MatchmakerUser_default_instance_;
class MatchmakerMatched_MatchmakerUser_NumericPropertiesEntry_DoNotUse;
class MatchmakerMatched_MatchmakerUser_NumericPropertiesEntry_DoNotUseDefaultTypeInternal;
extern MatchmakerMatched_MatchmakerUser_NumericPropertiesEntry_DoNotUseDefaultTypeInternal _MatchmakerMatched_MatchmakerUser_NumericPropertiesEntry_DoNotUse_default_instance_;
class MatchmakerMatched_MatchmakerUser_StringPropertiesEntry_DoNotUse;
class MatchmakerMatched_MatchmakerUser_StringPropertiesEntry_DoNotUseDefaultTypeInternal;
extern MatchmakerMatched_MatchmakerUser_StringPropertiesEntry_DoNotUseDefaultTypeInternal _MatchmakerMatched_MatchmakerUser_StringPropertiesEntry_DoNotUse_default_instance_;
class MatchmakerRemove;
class MatchmakerRemoveDefaultTypeInternal;
extern MatchmakerRemoveDefaultTypeInternal _MatchmakerRemove_default_instance_;
class MatchmakerTicket;
class MatchmakerTicketDefaultTypeInternal;
extern MatchmakerTicketDefaultTypeInternal _MatchmakerTicket_default_instance_;
class Notifications;
class NotificationsDefaultTypeInternal;
extern NotificationsDefaultTypeInternal _Notifications_default_instance_;
class Status;
class StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
class StatusFollow;
class StatusFollowDefaultTypeInternal;
extern StatusFollowDefaultTypeInternal _StatusFollow_default_instance_;
class StatusPresenceEvent;
class StatusPresenceEventDefaultTypeInternal;
extern StatusPresenceEventDefaultTypeInternal _StatusPresenceEvent_default_instance_;
class StatusUnfollow;
class StatusUnfollowDefaultTypeInternal;
extern StatusUnfollowDefaultTypeInternal _StatusUnfollow_default_instance_;
class StatusUpdate;
class StatusUpdateDefaultTypeInternal;
extern StatusUpdateDefaultTypeInternal _StatusUpdate_default_instance_;
class Stream;
class StreamDefaultTypeInternal;
extern StreamDefaultTypeInternal _Stream_default_instance_;
class StreamData;
class StreamDataDefaultTypeInternal;
extern StreamDataDefaultTypeInternal _StreamData_default_instance_;
class StreamPresenceEvent;
class StreamPresenceEventDefaultTypeInternal;
extern StreamPresenceEventDefaultTypeInternal _StreamPresenceEvent_default_instance_;
class UserPresence;
class UserPresenceDefaultTypeInternal;
extern UserPresenceDefaultTypeInternal _UserPresence_default_instance_;
}  // namespace realtime
}  // namespace nakama
namespace google {
namespace protobuf {
template<> ::nakama::realtime::Channel* Arena::CreateMaybeMessage<::nakama::realtime::Channel>(Arena*);
template<> ::nakama::realtime::ChannelJoin* Arena::CreateMaybeMessage<::nakama::realtime::ChannelJoin>(Arena*);
template<> ::nakama::realtime::ChannelLeave* Arena::CreateMaybeMessage<::nakama::realtime::ChannelLeave>(Arena*);
template<> ::nakama::realtime::ChannelMessageAck* Arena::CreateMaybeMessage<::nakama::realtime::ChannelMessageAck>(Arena*);
template<> ::nakama::realtime::ChannelMessageRemove* Arena::CreateMaybeMessage<::nakama::realtime::ChannelMessageRemove>(Arena*);
template<> ::nakama::realtime::ChannelMessageSend* Arena::CreateMaybeMessage<::nakama::realtime::ChannelMessageSend>(Arena*);
template<> ::nakama::realtime::ChannelMessageUpdate* Arena::CreateMaybeMessage<::nakama::realtime::ChannelMessageUpdate>(Arena*);
template<> ::nakama::realtime::ChannelPresenceEvent* Arena::CreateMaybeMessage<::nakama::realtime::ChannelPresenceEvent>(Arena*);
template<> ::nakama::realtime::Envelope* Arena::CreateMaybeMessage<::nakama::realtime::Envelope>(Arena*);
template<> ::nakama::realtime::Error* Arena::CreateMaybeMessage<::nakama::realtime::Error>(Arena*);
template<> ::nakama::realtime::Error_ContextEntry_DoNotUse* Arena::CreateMaybeMessage<::nakama::realtime::Error_ContextEntry_DoNotUse>(Arena*);
template<> ::nakama::realtime::Match* Arena::CreateMaybeMessage<::nakama::realtime::Match>(Arena*);
template<> ::nakama::realtime::MatchCreate* Arena::CreateMaybeMessage<::nakama::realtime::MatchCreate>(Arena*);
template<> ::nakama::realtime::MatchData* Arena::CreateMaybeMessage<::nakama::realtime::MatchData>(Arena*);
template<> ::nakama::realtime::MatchDataSend* Arena::CreateMaybeMessage<::nakama::realtime::MatchDataSend>(Arena*);
template<> ::nakama::realtime::MatchJoin* Arena::CreateMaybeMessage<::nakama::realtime::MatchJoin>(Arena*);
template<> ::nakama::realtime::MatchJoin_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::nakama::realtime::MatchJoin_MetadataEntry_DoNotUse>(Arena*);
template<> ::nakama::realtime::MatchLeave* Arena::CreateMaybeMessage<::nakama::realtime::MatchLeave>(Arena*);
template<> ::nakama::realtime::MatchPresenceEvent* Arena::CreateMaybeMessage<::nakama::realtime::MatchPresenceEvent>(Arena*);
template<> ::nakama::realtime::MatchmakerAdd* Arena::CreateMaybeMessage<::nakama::realtime::MatchmakerAdd>(Arena*);
template<> ::nakama::realtime::MatchmakerAdd_NumericPropertiesEntry_DoNotUse* Arena::CreateMaybeMessage<::nakama::realtime::MatchmakerAdd_NumericPropertiesEntry_DoNotUse>(Arena*);
template<> ::nakama::realtime::MatchmakerAdd_StringPropertiesEntry_DoNotUse* Arena::CreateMaybeMessage<::nakama::realtime::MatchmakerAdd_StringPropertiesEntry_DoNotUse>(Arena*);
template<> ::nakama::realtime::MatchmakerMatched* Arena::CreateMaybeMessage<::nakama::realtime::MatchmakerMatched>(Arena*);
template<> ::nakama::realtime::MatchmakerMatched_MatchmakerUser* Arena::CreateMaybeMessage<::nakama::realtime::MatchmakerMatched_MatchmakerUser>(Arena*);
template<> ::nakama::realtime::MatchmakerMatched_MatchmakerUser_NumericPropertiesEntry_DoNotUse* Arena::CreateMaybeMessage<::nakama::realtime::MatchmakerMatched_MatchmakerUser_NumericPropertiesEntry_DoNotUse>(Arena*);
template<> ::nakama::realtime::MatchmakerMatched_MatchmakerUser_StringPropertiesEntry_DoNotUse* Arena::CreateMaybeMessage<::nakama::realtime::MatchmakerMatched_MatchmakerUser_StringPropertiesEntry_DoNotUse>(Arena*);
template<> ::nakama::realtime::MatchmakerRemove* Arena::CreateMaybeMessage<::nakama::realtime::MatchmakerRemove>(Arena*);
template<> ::nakama::realtime::MatchmakerTicket* Arena::CreateMaybeMessage<::nakama::realtime::MatchmakerTicket>(Arena*);
template<> ::nakama::realtime::Notifications* Arena::CreateMaybeMessage<::nakama::realtime::Notifications>(Arena*);
template<> ::nakama::realtime::Status* Arena::CreateMaybeMessage<::nakama::realtime::Status>(Arena*);
template<> ::nakama::realtime::StatusFollow* Arena::CreateMaybeMessage<::nakama::realtime::StatusFollow>(Arena*);
template<> ::nakama::realtime::StatusPresenceEvent* Arena::CreateMaybeMessage<::nakama::realtime::StatusPresenceEvent>(Arena*);
template<> ::nakama::realtime::StatusUnfollow* Arena::CreateMaybeMessage<::nakama::realtime::StatusUnfollow>(Arena*);
template<> ::nakama::realtime::StatusUpdate* Arena::CreateMaybeMessage<::nakama::realtime::StatusUpdate>(Arena*);
template<> ::nakama::realtime::Stream* Arena::CreateMaybeMessage<::nakama::realtime::Stream>(Arena*);
template<> ::nakama::realtime::StreamData* Arena::CreateMaybeMessage<::nakama::realtime::StreamData>(Arena*);
template<> ::nakama::realtime::StreamPresenceEvent* Arena::CreateMaybeMessage<::nakama::realtime::StreamPresenceEvent>(Arena*);
template<> ::nakama::realtime::UserPresence* Arena::CreateMaybeMessage<::nakama::realtime::UserPresence>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace nakama {
namespace realtime {

enum ChannelJoin_Type {
  ChannelJoin_Type_TYPE_UNSPECIFIED = 0,
  ChannelJoin_Type_ROOM = 1,
  ChannelJoin_Type_DIRECT_MESSAGE = 2,
  ChannelJoin_Type_GROUP = 3,
  ChannelJoin_Type_ChannelJoin_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ChannelJoin_Type_ChannelJoin_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ChannelJoin_Type_IsValid(int value);
const ChannelJoin_Type ChannelJoin_Type_Type_MIN = ChannelJoin_Type_TYPE_UNSPECIFIED;
const ChannelJoin_Type ChannelJoin_Type_Type_MAX = ChannelJoin_Type_GROUP;
const int ChannelJoin_Type_Type_ARRAYSIZE = ChannelJoin_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ChannelJoin_Type_descriptor();
inline const ::std::string& ChannelJoin_Type_Name(ChannelJoin_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ChannelJoin_Type_descriptor(), value);
}
inline bool ChannelJoin_Type_Parse(
    const ::std::string& name, ChannelJoin_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChannelJoin_Type>(
    ChannelJoin_Type_descriptor(), name, value);
}
enum Error_Code {
  Error_Code_RUNTIME_EXCEPTION = 0,
  Error_Code_UNRECOGNIZED_PAYLOAD = 1,
  Error_Code_MISSING_PAYLOAD = 2,
  Error_Code_BAD_INPUT = 3,
  Error_Code_MATCH_NOT_FOUND = 4,
  Error_Code_MATCH_JOIN_REJECTED = 5,
  Error_Code_RUNTIME_FUNCTION_NOT_FOUND = 6,
  Error_Code_RUNTIME_FUNCTION_EXCEPTION = 7,
  Error_Code_Error_Code_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Error_Code_Error_Code_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Error_Code_IsValid(int value);
const Error_Code Error_Code_Code_MIN = Error_Code_RUNTIME_EXCEPTION;
const Error_Code Error_Code_Code_MAX = Error_Code_RUNTIME_FUNCTION_EXCEPTION;
const int Error_Code_Code_ARRAYSIZE = Error_Code_Code_MAX + 1;

const ::google::protobuf::EnumDescriptor* Error_Code_descriptor();
inline const ::std::string& Error_Code_Name(Error_Code value) {
  return ::google::protobuf::internal::NameOfEnum(
    Error_Code_descriptor(), value);
}
inline bool Error_Code_Parse(
    const ::std::string& name, Error_Code* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Error_Code>(
    Error_Code_descriptor(), name, value);
}
// ===================================================================

class Envelope : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.Envelope) */ {
 public:
  Envelope();
  virtual ~Envelope();

  Envelope(const Envelope& from);

  inline Envelope& operator=(const Envelope& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Envelope(Envelope&& from) noexcept
    : Envelope() {
    *this = ::std::move(from);
  }

  inline Envelope& operator=(Envelope&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Envelope& default_instance();

  enum MessageCase {
    kChannel = 2,
    kChannelJoin = 3,
    kChannelLeave = 4,
    kChannelMessage = 5,
    kChannelMessageAck = 6,
    kChannelMessageSend = 7,
    kChannelMessageUpdate = 8,
    kChannelMessageRemove = 9,
    kChannelPresenceEvent = 10,
    kError = 11,
    kMatch = 12,
    kMatchCreate = 13,
    kMatchData = 14,
    kMatchDataSend = 15,
    kMatchJoin = 16,
    kMatchLeave = 17,
    kMatchPresenceEvent = 18,
    kMatchmakerAdd = 19,
    kMatchmakerMatched = 20,
    kMatchmakerRemove = 21,
    kMatchmakerTicket = 22,
    kNotifications = 23,
    kRpc = 24,
    kStatus = 25,
    kStatusFollow = 26,
    kStatusPresenceEvent = 27,
    kStatusUnfollow = 28,
    kStatusUpdate = 29,
    kStreamData = 30,
    kStreamPresenceEvent = 31,
    MESSAGE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Envelope* internal_default_instance() {
    return reinterpret_cast<const Envelope*>(
               &_Envelope_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Envelope* other);
  friend void swap(Envelope& a, Envelope& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Envelope* New() const final {
    return CreateMaybeMessage<Envelope>(NULL);
  }

  Envelope* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Envelope>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Envelope& from);
  void MergeFrom(const Envelope& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Envelope* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string cid = 1;
  void clear_cid();
  static const int kCidFieldNumber = 1;
  const ::std::string& cid() const;
  void set_cid(const ::std::string& value);
  #if LANG_CXX11
  void set_cid(::std::string&& value);
  #endif
  void set_cid(const char* value);
  void set_cid(const char* value, size_t size);
  ::std::string* mutable_cid();
  ::std::string* release_cid();
  void set_allocated_cid(::std::string* cid);

  // .nakama.realtime.Channel channel = 2;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 2;
  private:
  const ::nakama::realtime::Channel& _internal_channel() const;
  public:
  const ::nakama::realtime::Channel& channel() const;
  ::nakama::realtime::Channel* release_channel();
  ::nakama::realtime::Channel* mutable_channel();
  void set_allocated_channel(::nakama::realtime::Channel* channel);

  // .nakama.realtime.ChannelJoin channel_join = 3;
  bool has_channel_join() const;
  void clear_channel_join();
  static const int kChannelJoinFieldNumber = 3;
  private:
  const ::nakama::realtime::ChannelJoin& _internal_channel_join() const;
  public:
  const ::nakama::realtime::ChannelJoin& channel_join() const;
  ::nakama::realtime::ChannelJoin* release_channel_join();
  ::nakama::realtime::ChannelJoin* mutable_channel_join();
  void set_allocated_channel_join(::nakama::realtime::ChannelJoin* channel_join);

  // .nakama.realtime.ChannelLeave channel_leave = 4;
  bool has_channel_leave() const;
  void clear_channel_leave();
  static const int kChannelLeaveFieldNumber = 4;
  private:
  const ::nakama::realtime::ChannelLeave& _internal_channel_leave() const;
  public:
  const ::nakama::realtime::ChannelLeave& channel_leave() const;
  ::nakama::realtime::ChannelLeave* release_channel_leave();
  ::nakama::realtime::ChannelLeave* mutable_channel_leave();
  void set_allocated_channel_leave(::nakama::realtime::ChannelLeave* channel_leave);

  // .nakama.api.ChannelMessage channel_message = 5;
  bool has_channel_message() const;
  void clear_channel_message();
  static const int kChannelMessageFieldNumber = 5;
  private:
  const ::nakama::api::ChannelMessage& _internal_channel_message() const;
  public:
  const ::nakama::api::ChannelMessage& channel_message() const;
  ::nakama::api::ChannelMessage* release_channel_message();
  ::nakama::api::ChannelMessage* mutable_channel_message();
  void set_allocated_channel_message(::nakama::api::ChannelMessage* channel_message);

  // .nakama.realtime.ChannelMessageAck channel_message_ack = 6;
  bool has_channel_message_ack() const;
  void clear_channel_message_ack();
  static const int kChannelMessageAckFieldNumber = 6;
  private:
  const ::nakama::realtime::ChannelMessageAck& _internal_channel_message_ack() const;
  public:
  const ::nakama::realtime::ChannelMessageAck& channel_message_ack() const;
  ::nakama::realtime::ChannelMessageAck* release_channel_message_ack();
  ::nakama::realtime::ChannelMessageAck* mutable_channel_message_ack();
  void set_allocated_channel_message_ack(::nakama::realtime::ChannelMessageAck* channel_message_ack);

  // .nakama.realtime.ChannelMessageSend channel_message_send = 7;
  bool has_channel_message_send() const;
  void clear_channel_message_send();
  static const int kChannelMessageSendFieldNumber = 7;
  private:
  const ::nakama::realtime::ChannelMessageSend& _internal_channel_message_send() const;
  public:
  const ::nakama::realtime::ChannelMessageSend& channel_message_send() const;
  ::nakama::realtime::ChannelMessageSend* release_channel_message_send();
  ::nakama::realtime::ChannelMessageSend* mutable_channel_message_send();
  void set_allocated_channel_message_send(::nakama::realtime::ChannelMessageSend* channel_message_send);

  // .nakama.realtime.ChannelMessageUpdate channel_message_update = 8;
  bool has_channel_message_update() const;
  void clear_channel_message_update();
  static const int kChannelMessageUpdateFieldNumber = 8;
  private:
  const ::nakama::realtime::ChannelMessageUpdate& _internal_channel_message_update() const;
  public:
  const ::nakama::realtime::ChannelMessageUpdate& channel_message_update() const;
  ::nakama::realtime::ChannelMessageUpdate* release_channel_message_update();
  ::nakama::realtime::ChannelMessageUpdate* mutable_channel_message_update();
  void set_allocated_channel_message_update(::nakama::realtime::ChannelMessageUpdate* channel_message_update);

  // .nakama.realtime.ChannelMessageRemove channel_message_remove = 9;
  bool has_channel_message_remove() const;
  void clear_channel_message_remove();
  static const int kChannelMessageRemoveFieldNumber = 9;
  private:
  const ::nakama::realtime::ChannelMessageRemove& _internal_channel_message_remove() const;
  public:
  const ::nakama::realtime::ChannelMessageRemove& channel_message_remove() const;
  ::nakama::realtime::ChannelMessageRemove* release_channel_message_remove();
  ::nakama::realtime::ChannelMessageRemove* mutable_channel_message_remove();
  void set_allocated_channel_message_remove(::nakama::realtime::ChannelMessageRemove* channel_message_remove);

  // .nakama.realtime.ChannelPresenceEvent channel_presence_event = 10;
  bool has_channel_presence_event() const;
  void clear_channel_presence_event();
  static const int kChannelPresenceEventFieldNumber = 10;
  private:
  const ::nakama::realtime::ChannelPresenceEvent& _internal_channel_presence_event() const;
  public:
  const ::nakama::realtime::ChannelPresenceEvent& channel_presence_event() const;
  ::nakama::realtime::ChannelPresenceEvent* release_channel_presence_event();
  ::nakama::realtime::ChannelPresenceEvent* mutable_channel_presence_event();
  void set_allocated_channel_presence_event(::nakama::realtime::ChannelPresenceEvent* channel_presence_event);

  // .nakama.realtime.Error error = 11;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 11;
  private:
  const ::nakama::realtime::Error& _internal_error() const;
  public:
  const ::nakama::realtime::Error& error() const;
  ::nakama::realtime::Error* release_error();
  ::nakama::realtime::Error* mutable_error();
  void set_allocated_error(::nakama::realtime::Error* error);

  // .nakama.realtime.Match match = 12;
  bool has_match() const;
  void clear_match();
  static const int kMatchFieldNumber = 12;
  private:
  const ::nakama::realtime::Match& _internal_match() const;
  public:
  const ::nakama::realtime::Match& match() const;
  ::nakama::realtime::Match* release_match();
  ::nakama::realtime::Match* mutable_match();
  void set_allocated_match(::nakama::realtime::Match* match);

  // .nakama.realtime.MatchCreate match_create = 13;
  bool has_match_create() const;
  void clear_match_create();
  static const int kMatchCreateFieldNumber = 13;
  private:
  const ::nakama::realtime::MatchCreate& _internal_match_create() const;
  public:
  const ::nakama::realtime::MatchCreate& match_create() const;
  ::nakama::realtime::MatchCreate* release_match_create();
  ::nakama::realtime::MatchCreate* mutable_match_create();
  void set_allocated_match_create(::nakama::realtime::MatchCreate* match_create);

  // .nakama.realtime.MatchData match_data = 14;
  bool has_match_data() const;
  void clear_match_data();
  static const int kMatchDataFieldNumber = 14;
  private:
  const ::nakama::realtime::MatchData& _internal_match_data() const;
  public:
  const ::nakama::realtime::MatchData& match_data() const;
  ::nakama::realtime::MatchData* release_match_data();
  ::nakama::realtime::MatchData* mutable_match_data();
  void set_allocated_match_data(::nakama::realtime::MatchData* match_data);

  // .nakama.realtime.MatchDataSend match_data_send = 15;
  bool has_match_data_send() const;
  void clear_match_data_send();
  static const int kMatchDataSendFieldNumber = 15;
  private:
  const ::nakama::realtime::MatchDataSend& _internal_match_data_send() const;
  public:
  const ::nakama::realtime::MatchDataSend& match_data_send() const;
  ::nakama::realtime::MatchDataSend* release_match_data_send();
  ::nakama::realtime::MatchDataSend* mutable_match_data_send();
  void set_allocated_match_data_send(::nakama::realtime::MatchDataSend* match_data_send);

  // .nakama.realtime.MatchJoin match_join = 16;
  bool has_match_join() const;
  void clear_match_join();
  static const int kMatchJoinFieldNumber = 16;
  private:
  const ::nakama::realtime::MatchJoin& _internal_match_join() const;
  public:
  const ::nakama::realtime::MatchJoin& match_join() const;
  ::nakama::realtime::MatchJoin* release_match_join();
  ::nakama::realtime::MatchJoin* mutable_match_join();
  void set_allocated_match_join(::nakama::realtime::MatchJoin* match_join);

  // .nakama.realtime.MatchLeave match_leave = 17;
  bool has_match_leave() const;
  void clear_match_leave();
  static const int kMatchLeaveFieldNumber = 17;
  private:
  const ::nakama::realtime::MatchLeave& _internal_match_leave() const;
  public:
  const ::nakama::realtime::MatchLeave& match_leave() const;
  ::nakama::realtime::MatchLeave* release_match_leave();
  ::nakama::realtime::MatchLeave* mutable_match_leave();
  void set_allocated_match_leave(::nakama::realtime::MatchLeave* match_leave);

  // .nakama.realtime.MatchPresenceEvent match_presence_event = 18;
  bool has_match_presence_event() const;
  void clear_match_presence_event();
  static const int kMatchPresenceEventFieldNumber = 18;
  private:
  const ::nakama::realtime::MatchPresenceEvent& _internal_match_presence_event() const;
  public:
  const ::nakama::realtime::MatchPresenceEvent& match_presence_event() const;
  ::nakama::realtime::MatchPresenceEvent* release_match_presence_event();
  ::nakama::realtime::MatchPresenceEvent* mutable_match_presence_event();
  void set_allocated_match_presence_event(::nakama::realtime::MatchPresenceEvent* match_presence_event);

  // .nakama.realtime.MatchmakerAdd matchmaker_add = 19;
  bool has_matchmaker_add() const;
  void clear_matchmaker_add();
  static const int kMatchmakerAddFieldNumber = 19;
  private:
  const ::nakama::realtime::MatchmakerAdd& _internal_matchmaker_add() const;
  public:
  const ::nakama::realtime::MatchmakerAdd& matchmaker_add() const;
  ::nakama::realtime::MatchmakerAdd* release_matchmaker_add();
  ::nakama::realtime::MatchmakerAdd* mutable_matchmaker_add();
  void set_allocated_matchmaker_add(::nakama::realtime::MatchmakerAdd* matchmaker_add);

  // .nakama.realtime.MatchmakerMatched matchmaker_matched = 20;
  bool has_matchmaker_matched() const;
  void clear_matchmaker_matched();
  static const int kMatchmakerMatchedFieldNumber = 20;
  private:
  const ::nakama::realtime::MatchmakerMatched& _internal_matchmaker_matched() const;
  public:
  const ::nakama::realtime::MatchmakerMatched& matchmaker_matched() const;
  ::nakama::realtime::MatchmakerMatched* release_matchmaker_matched();
  ::nakama::realtime::MatchmakerMatched* mutable_matchmaker_matched();
  void set_allocated_matchmaker_matched(::nakama::realtime::MatchmakerMatched* matchmaker_matched);

  // .nakama.realtime.MatchmakerRemove matchmaker_remove = 21;
  bool has_matchmaker_remove() const;
  void clear_matchmaker_remove();
  static const int kMatchmakerRemoveFieldNumber = 21;
  private:
  const ::nakama::realtime::MatchmakerRemove& _internal_matchmaker_remove() const;
  public:
  const ::nakama::realtime::MatchmakerRemove& matchmaker_remove() const;
  ::nakama::realtime::MatchmakerRemove* release_matchmaker_remove();
  ::nakama::realtime::MatchmakerRemove* mutable_matchmaker_remove();
  void set_allocated_matchmaker_remove(::nakama::realtime::MatchmakerRemove* matchmaker_remove);

  // .nakama.realtime.MatchmakerTicket matchmaker_ticket = 22;
  bool has_matchmaker_ticket() const;
  void clear_matchmaker_ticket();
  static const int kMatchmakerTicketFieldNumber = 22;
  private:
  const ::nakama::realtime::MatchmakerTicket& _internal_matchmaker_ticket() const;
  public:
  const ::nakama::realtime::MatchmakerTicket& matchmaker_ticket() const;
  ::nakama::realtime::MatchmakerTicket* release_matchmaker_ticket();
  ::nakama::realtime::MatchmakerTicket* mutable_matchmaker_ticket();
  void set_allocated_matchmaker_ticket(::nakama::realtime::MatchmakerTicket* matchmaker_ticket);

  // .nakama.realtime.Notifications notifications = 23;
  bool has_notifications() const;
  void clear_notifications();
  static const int kNotificationsFieldNumber = 23;
  private:
  const ::nakama::realtime::Notifications& _internal_notifications() const;
  public:
  const ::nakama::realtime::Notifications& notifications() const;
  ::nakama::realtime::Notifications* release_notifications();
  ::nakama::realtime::Notifications* mutable_notifications();
  void set_allocated_notifications(::nakama::realtime::Notifications* notifications);

  // .nakama.api.Rpc rpc = 24;
  bool has_rpc() const;
  void clear_rpc();
  static const int kRpcFieldNumber = 24;
  private:
  const ::nakama::api::Rpc& _internal_rpc() const;
  public:
  const ::nakama::api::Rpc& rpc() const;
  ::nakama::api::Rpc* release_rpc();
  ::nakama::api::Rpc* mutable_rpc();
  void set_allocated_rpc(::nakama::api::Rpc* rpc);

  // .nakama.realtime.Status status = 25;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 25;
  private:
  const ::nakama::realtime::Status& _internal_status() const;
  public:
  const ::nakama::realtime::Status& status() const;
  ::nakama::realtime::Status* release_status();
  ::nakama::realtime::Status* mutable_status();
  void set_allocated_status(::nakama::realtime::Status* status);

  // .nakama.realtime.StatusFollow status_follow = 26;
  bool has_status_follow() const;
  void clear_status_follow();
  static const int kStatusFollowFieldNumber = 26;
  private:
  const ::nakama::realtime::StatusFollow& _internal_status_follow() const;
  public:
  const ::nakama::realtime::StatusFollow& status_follow() const;
  ::nakama::realtime::StatusFollow* release_status_follow();
  ::nakama::realtime::StatusFollow* mutable_status_follow();
  void set_allocated_status_follow(::nakama::realtime::StatusFollow* status_follow);

  // .nakama.realtime.StatusPresenceEvent status_presence_event = 27;
  bool has_status_presence_event() const;
  void clear_status_presence_event();
  static const int kStatusPresenceEventFieldNumber = 27;
  private:
  const ::nakama::realtime::StatusPresenceEvent& _internal_status_presence_event() const;
  public:
  const ::nakama::realtime::StatusPresenceEvent& status_presence_event() const;
  ::nakama::realtime::StatusPresenceEvent* release_status_presence_event();
  ::nakama::realtime::StatusPresenceEvent* mutable_status_presence_event();
  void set_allocated_status_presence_event(::nakama::realtime::StatusPresenceEvent* status_presence_event);

  // .nakama.realtime.StatusUnfollow status_unfollow = 28;
  bool has_status_unfollow() const;
  void clear_status_unfollow();
  static const int kStatusUnfollowFieldNumber = 28;
  private:
  const ::nakama::realtime::StatusUnfollow& _internal_status_unfollow() const;
  public:
  const ::nakama::realtime::StatusUnfollow& status_unfollow() const;
  ::nakama::realtime::StatusUnfollow* release_status_unfollow();
  ::nakama::realtime::StatusUnfollow* mutable_status_unfollow();
  void set_allocated_status_unfollow(::nakama::realtime::StatusUnfollow* status_unfollow);

  // .nakama.realtime.StatusUpdate status_update = 29;
  bool has_status_update() const;
  void clear_status_update();
  static const int kStatusUpdateFieldNumber = 29;
  private:
  const ::nakama::realtime::StatusUpdate& _internal_status_update() const;
  public:
  const ::nakama::realtime::StatusUpdate& status_update() const;
  ::nakama::realtime::StatusUpdate* release_status_update();
  ::nakama::realtime::StatusUpdate* mutable_status_update();
  void set_allocated_status_update(::nakama::realtime::StatusUpdate* status_update);

  // .nakama.realtime.StreamData stream_data = 30;
  bool has_stream_data() const;
  void clear_stream_data();
  static const int kStreamDataFieldNumber = 30;
  private:
  const ::nakama::realtime::StreamData& _internal_stream_data() const;
  public:
  const ::nakama::realtime::StreamData& stream_data() const;
  ::nakama::realtime::StreamData* release_stream_data();
  ::nakama::realtime::StreamData* mutable_stream_data();
  void set_allocated_stream_data(::nakama::realtime::StreamData* stream_data);

  // .nakama.realtime.StreamPresenceEvent stream_presence_event = 31;
  bool has_stream_presence_event() const;
  void clear_stream_presence_event();
  static const int kStreamPresenceEventFieldNumber = 31;
  private:
  const ::nakama::realtime::StreamPresenceEvent& _internal_stream_presence_event() const;
  public:
  const ::nakama::realtime::StreamPresenceEvent& stream_presence_event() const;
  ::nakama::realtime::StreamPresenceEvent* release_stream_presence_event();
  ::nakama::realtime::StreamPresenceEvent* mutable_stream_presence_event();
  void set_allocated_stream_presence_event(::nakama::realtime::StreamPresenceEvent* stream_presence_event);

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:nakama.realtime.Envelope)
 private:
  void set_has_channel();
  void set_has_channel_join();
  void set_has_channel_leave();
  void set_has_channel_message();
  void set_has_channel_message_ack();
  void set_has_channel_message_send();
  void set_has_channel_message_update();
  void set_has_channel_message_remove();
  void set_has_channel_presence_event();
  void set_has_error();
  void set_has_match();
  void set_has_match_create();
  void set_has_match_data();
  void set_has_match_data_send();
  void set_has_match_join();
  void set_has_match_leave();
  void set_has_match_presence_event();
  void set_has_matchmaker_add();
  void set_has_matchmaker_matched();
  void set_has_matchmaker_remove();
  void set_has_matchmaker_ticket();
  void set_has_notifications();
  void set_has_rpc();
  void set_has_status();
  void set_has_status_follow();
  void set_has_status_presence_event();
  void set_has_status_unfollow();
  void set_has_status_update();
  void set_has_stream_data();
  void set_has_stream_presence_event();

  inline bool has_message() const;
  inline void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr cid_;
  union MessageUnion {
    MessageUnion() {}
    ::nakama::realtime::Channel* channel_;
    ::nakama::realtime::ChannelJoin* channel_join_;
    ::nakama::realtime::ChannelLeave* channel_leave_;
    ::nakama::api::ChannelMessage* channel_message_;
    ::nakama::realtime::ChannelMessageAck* channel_message_ack_;
    ::nakama::realtime::ChannelMessageSend* channel_message_send_;
    ::nakama::realtime::ChannelMessageUpdate* channel_message_update_;
    ::nakama::realtime::ChannelMessageRemove* channel_message_remove_;
    ::nakama::realtime::ChannelPresenceEvent* channel_presence_event_;
    ::nakama::realtime::Error* error_;
    ::nakama::realtime::Match* match_;
    ::nakama::realtime::MatchCreate* match_create_;
    ::nakama::realtime::MatchData* match_data_;
    ::nakama::realtime::MatchDataSend* match_data_send_;
    ::nakama::realtime::MatchJoin* match_join_;
    ::nakama::realtime::MatchLeave* match_leave_;
    ::nakama::realtime::MatchPresenceEvent* match_presence_event_;
    ::nakama::realtime::MatchmakerAdd* matchmaker_add_;
    ::nakama::realtime::MatchmakerMatched* matchmaker_matched_;
    ::nakama::realtime::MatchmakerRemove* matchmaker_remove_;
    ::nakama::realtime::MatchmakerTicket* matchmaker_ticket_;
    ::nakama::realtime::Notifications* notifications_;
    ::nakama::api::Rpc* rpc_;
    ::nakama::realtime::Status* status_;
    ::nakama::realtime::StatusFollow* status_follow_;
    ::nakama::realtime::StatusPresenceEvent* status_presence_event_;
    ::nakama::realtime::StatusUnfollow* status_unfollow_;
    ::nakama::realtime::StatusUpdate* status_update_;
    ::nakama::realtime::StreamData* stream_data_;
    ::nakama::realtime::StreamPresenceEvent* stream_presence_event_;
  } message_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2frtapi_2frealtime_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Channel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.Channel) */ {
 public:
  Channel();
  virtual ~Channel();

  Channel(const Channel& from);

  inline Channel& operator=(const Channel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Channel(Channel&& from) noexcept
    : Channel() {
    *this = ::std::move(from);
  }

  inline Channel& operator=(Channel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Channel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Channel* internal_default_instance() {
    return reinterpret_cast<const Channel*>(
               &_Channel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Channel* other);
  friend void swap(Channel& a, Channel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Channel* New() const final {
    return CreateMaybeMessage<Channel>(NULL);
  }

  Channel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Channel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Channel& from);
  void MergeFrom(const Channel& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Channel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nakama.realtime.UserPresence presences = 2;
  int presences_size() const;
  void clear_presences();
  static const int kPresencesFieldNumber = 2;
  ::nakama::realtime::UserPresence* mutable_presences(int index);
  ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >*
      mutable_presences();
  const ::nakama::realtime::UserPresence& presences(int index) const;
  ::nakama::realtime::UserPresence* add_presences();
  const ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >&
      presences() const;

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // .nakama.realtime.UserPresence self = 3;
  bool has_self() const;
  void clear_self();
  static const int kSelfFieldNumber = 3;
  private:
  const ::nakama::realtime::UserPresence& _internal_self() const;
  public:
  const ::nakama::realtime::UserPresence& self() const;
  ::nakama::realtime::UserPresence* release_self();
  ::nakama::realtime::UserPresence* mutable_self();
  void set_allocated_self(::nakama::realtime::UserPresence* self);

  // @@protoc_insertion_point(class_scope:nakama.realtime.Channel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence > presences_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::nakama::realtime::UserPresence* self_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2frtapi_2frealtime_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ChannelJoin : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.ChannelJoin) */ {
 public:
  ChannelJoin();
  virtual ~ChannelJoin();

  ChannelJoin(const ChannelJoin& from);

  inline ChannelJoin& operator=(const ChannelJoin& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChannelJoin(ChannelJoin&& from) noexcept
    : ChannelJoin() {
    *this = ::std::move(from);
  }

  inline ChannelJoin& operator=(ChannelJoin&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChannelJoin& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChannelJoin* internal_default_instance() {
    return reinterpret_cast<const ChannelJoin*>(
               &_ChannelJoin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ChannelJoin* other);
  friend void swap(ChannelJoin& a, ChannelJoin& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChannelJoin* New() const final {
    return CreateMaybeMessage<ChannelJoin>(NULL);
  }

  ChannelJoin* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChannelJoin>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ChannelJoin& from);
  void MergeFrom(const ChannelJoin& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelJoin* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ChannelJoin_Type Type;
  static const Type TYPE_UNSPECIFIED =
    ChannelJoin_Type_TYPE_UNSPECIFIED;
  static const Type ROOM =
    ChannelJoin_Type_ROOM;
  static const Type DIRECT_MESSAGE =
    ChannelJoin_Type_DIRECT_MESSAGE;
  static const Type GROUP =
    ChannelJoin_Type_GROUP;
  static inline bool Type_IsValid(int value) {
    return ChannelJoin_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ChannelJoin_Type_Type_MIN;
  static const Type Type_MAX =
    ChannelJoin_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ChannelJoin_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ChannelJoin_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ChannelJoin_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ChannelJoin_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string target = 1;
  void clear_target();
  static const int kTargetFieldNumber = 1;
  const ::std::string& target() const;
  void set_target(const ::std::string& value);
  #if LANG_CXX11
  void set_target(::std::string&& value);
  #endif
  void set_target(const char* value);
  void set_target(const char* value, size_t size);
  ::std::string* mutable_target();
  ::std::string* release_target();
  void set_allocated_target(::std::string* target);

  // .google.protobuf.BoolValue persistence = 3;
  bool has_persistence() const;
  void clear_persistence();
  static const int kPersistenceFieldNumber = 3;
  private:
  const ::google::protobuf::BoolValue& _internal_persistence() const;
  public:
  const ::google::protobuf::BoolValue& persistence() const;
  ::google::protobuf::BoolValue* release_persistence();
  ::google::protobuf::BoolValue* mutable_persistence();
  void set_allocated_persistence(::google::protobuf::BoolValue* persistence);

  // .google.protobuf.BoolValue hidden = 4;
  bool has_hidden() const;
  void clear_hidden();
  static const int kHiddenFieldNumber = 4;
  private:
  const ::google::protobuf::BoolValue& _internal_hidden() const;
  public:
  const ::google::protobuf::BoolValue& hidden() const;
  ::google::protobuf::BoolValue* release_hidden();
  ::google::protobuf::BoolValue* mutable_hidden();
  void set_allocated_hidden(::google::protobuf::BoolValue* hidden);

  // int32 type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:nakama.realtime.ChannelJoin)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr target_;
  ::google::protobuf::BoolValue* persistence_;
  ::google::protobuf::BoolValue* hidden_;
  ::google::protobuf::int32 type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2frtapi_2frealtime_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ChannelLeave : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.ChannelLeave) */ {
 public:
  ChannelLeave();
  virtual ~ChannelLeave();

  ChannelLeave(const ChannelLeave& from);

  inline ChannelLeave& operator=(const ChannelLeave& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChannelLeave(ChannelLeave&& from) noexcept
    : ChannelLeave() {
    *this = ::std::move(from);
  }

  inline ChannelLeave& operator=(ChannelLeave&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChannelLeave& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChannelLeave* internal_default_instance() {
    return reinterpret_cast<const ChannelLeave*>(
               &_ChannelLeave_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ChannelLeave* other);
  friend void swap(ChannelLeave& a, ChannelLeave& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChannelLeave* New() const final {
    return CreateMaybeMessage<ChannelLeave>(NULL);
  }

  ChannelLeave* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChannelLeave>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ChannelLeave& from);
  void MergeFrom(const ChannelLeave& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelLeave* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string channel_id = 1;
  void clear_channel_id();
  static const int kChannelIdFieldNumber = 1;
  const ::std::string& channel_id() const;
  void set_channel_id(const ::std::string& value);
  #if LANG_CXX11
  void set_channel_id(::std::string&& value);
  #endif
  void set_channel_id(const char* value);
  void set_channel_id(const char* value, size_t size);
  ::std::string* mutable_channel_id();
  ::std::string* release_channel_id();
  void set_allocated_channel_id(::std::string* channel_id);

  // @@protoc_insertion_point(class_scope:nakama.realtime.ChannelLeave)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr channel_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2frtapi_2frealtime_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ChannelMessageAck : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.ChannelMessageAck) */ {
 public:
  ChannelMessageAck();
  virtual ~ChannelMessageAck();

  ChannelMessageAck(const ChannelMessageAck& from);

  inline ChannelMessageAck& operator=(const ChannelMessageAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChannelMessageAck(ChannelMessageAck&& from) noexcept
    : ChannelMessageAck() {
    *this = ::std::move(from);
  }

  inline ChannelMessageAck& operator=(ChannelMessageAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChannelMessageAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChannelMessageAck* internal_default_instance() {
    return reinterpret_cast<const ChannelMessageAck*>(
               &_ChannelMessageAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ChannelMessageAck* other);
  friend void swap(ChannelMessageAck& a, ChannelMessageAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChannelMessageAck* New() const final {
    return CreateMaybeMessage<ChannelMessageAck>(NULL);
  }

  ChannelMessageAck* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChannelMessageAck>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ChannelMessageAck& from);
  void MergeFrom(const ChannelMessageAck& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelMessageAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string channel_id = 1;
  void clear_channel_id();
  static const int kChannelIdFieldNumber = 1;
  const ::std::string& channel_id() const;
  void set_channel_id(const ::std::string& value);
  #if LANG_CXX11
  void set_channel_id(::std::string&& value);
  #endif
  void set_channel_id(const char* value);
  void set_channel_id(const char* value, size_t size);
  ::std::string* mutable_channel_id();
  ::std::string* release_channel_id();
  void set_allocated_channel_id(::std::string* channel_id);

  // string message_id = 2;
  void clear_message_id();
  static const int kMessageIdFieldNumber = 2;
  const ::std::string& message_id() const;
  void set_message_id(const ::std::string& value);
  #if LANG_CXX11
  void set_message_id(::std::string&& value);
  #endif
  void set_message_id(const char* value);
  void set_message_id(const char* value, size_t size);
  ::std::string* mutable_message_id();
  ::std::string* release_message_id();
  void set_allocated_message_id(::std::string* message_id);

  // string username = 4;
  void clear_username();
  static const int kUsernameFieldNumber = 4;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // .google.protobuf.Int32Value code = 3;
  bool has_code() const;
  void clear_code();
  static const int kCodeFieldNumber = 3;
  private:
  const ::google::protobuf::Int32Value& _internal_code() const;
  public:
  const ::google::protobuf::Int32Value& code() const;
  ::google::protobuf::Int32Value* release_code();
  ::google::protobuf::Int32Value* mutable_code();
  void set_allocated_code(::google::protobuf::Int32Value* code);

  // .google.protobuf.Timestamp create_time = 5;
  bool has_create_time() const;
  void clear_create_time();
  static const int kCreateTimeFieldNumber = 5;
  private:
  const ::google::protobuf::Timestamp& _internal_create_time() const;
  public:
  const ::google::protobuf::Timestamp& create_time() const;
  ::google::protobuf::Timestamp* release_create_time();
  ::google::protobuf::Timestamp* mutable_create_time();
  void set_allocated_create_time(::google::protobuf::Timestamp* create_time);

  // .google.protobuf.Timestamp update_time = 6;
  bool has_update_time() const;
  void clear_update_time();
  static const int kUpdateTimeFieldNumber = 6;
  private:
  const ::google::protobuf::Timestamp& _internal_update_time() const;
  public:
  const ::google::protobuf::Timestamp& update_time() const;
  ::google::protobuf::Timestamp* release_update_time();
  ::google::protobuf::Timestamp* mutable_update_time();
  void set_allocated_update_time(::google::protobuf::Timestamp* update_time);

  // .google.protobuf.BoolValue persistent = 7;
  bool has_persistent() const;
  void clear_persistent();
  static const int kPersistentFieldNumber = 7;
  private:
  const ::google::protobuf::BoolValue& _internal_persistent() const;
  public:
  const ::google::protobuf::BoolValue& persistent() const;
  ::google::protobuf::BoolValue* release_persistent();
  ::google::protobuf::BoolValue* mutable_persistent();
  void set_allocated_persistent(::google::protobuf::BoolValue* persistent);

  // @@protoc_insertion_point(class_scope:nakama.realtime.ChannelMessageAck)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr channel_id_;
  ::google::protobuf::internal::ArenaStringPtr message_id_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::Int32Value* code_;
  ::google::protobuf::Timestamp* create_time_;
  ::google::protobuf::Timestamp* update_time_;
  ::google::protobuf::BoolValue* persistent_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2frtapi_2frealtime_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ChannelMessageSend : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.ChannelMessageSend) */ {
 public:
  ChannelMessageSend();
  virtual ~ChannelMessageSend();

  ChannelMessageSend(const ChannelMessageSend& from);

  inline ChannelMessageSend& operator=(const ChannelMessageSend& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChannelMessageSend(ChannelMessageSend&& from) noexcept
    : ChannelMessageSend() {
    *this = ::std::move(from);
  }

  inline ChannelMessageSend& operator=(ChannelMessageSend&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChannelMessageSend& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChannelMessageSend* internal_default_instance() {
    return reinterpret_cast<const ChannelMessageSend*>(
               &_ChannelMessageSend_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ChannelMessageSend* other);
  friend void swap(ChannelMessageSend& a, ChannelMessageSend& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChannelMessageSend* New() const final {
    return CreateMaybeMessage<ChannelMessageSend>(NULL);
  }

  ChannelMessageSend* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChannelMessageSend>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ChannelMessageSend& from);
  void MergeFrom(const ChannelMessageSend& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelMessageSend* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string channel_id = 1;
  void clear_channel_id();
  static const int kChannelIdFieldNumber = 1;
  const ::std::string& channel_id() const;
  void set_channel_id(const ::std::string& value);
  #if LANG_CXX11
  void set_channel_id(::std::string&& value);
  #endif
  void set_channel_id(const char* value);
  void set_channel_id(const char* value, size_t size);
  ::std::string* mutable_channel_id();
  ::std::string* release_channel_id();
  void set_allocated_channel_id(::std::string* channel_id);

  // string content = 2;
  void clear_content();
  static const int kContentFieldNumber = 2;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  #if LANG_CXX11
  void set_content(::std::string&& value);
  #endif
  void set_content(const char* value);
  void set_content(const char* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:nakama.realtime.ChannelMessageSend)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr channel_id_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2frtapi_2frealtime_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ChannelMessageUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.ChannelMessageUpdate) */ {
 public:
  ChannelMessageUpdate();
  virtual ~ChannelMessageUpdate();

  ChannelMessageUpdate(const ChannelMessageUpdate& from);

  inline ChannelMessageUpdate& operator=(const ChannelMessageUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChannelMessageUpdate(ChannelMessageUpdate&& from) noexcept
    : ChannelMessageUpdate() {
    *this = ::std::move(from);
  }

  inline ChannelMessageUpdate& operator=(ChannelMessageUpdate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChannelMessageUpdate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChannelMessageUpdate* internal_default_instance() {
    return reinterpret_cast<const ChannelMessageUpdate*>(
               &_ChannelMessageUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ChannelMessageUpdate* other);
  friend void swap(ChannelMessageUpdate& a, ChannelMessageUpdate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChannelMessageUpdate* New() const final {
    return CreateMaybeMessage<ChannelMessageUpdate>(NULL);
  }

  ChannelMessageUpdate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChannelMessageUpdate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ChannelMessageUpdate& from);
  void MergeFrom(const ChannelMessageUpdate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelMessageUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string channel_id = 1;
  void clear_channel_id();
  static const int kChannelIdFieldNumber = 1;
  const ::std::string& channel_id() const;
  void set_channel_id(const ::std::string& value);
  #if LANG_CXX11
  void set_channel_id(::std::string&& value);
  #endif
  void set_channel_id(const char* value);
  void set_channel_id(const char* value, size_t size);
  ::std::string* mutable_channel_id();
  ::std::string* release_channel_id();
  void set_allocated_channel_id(::std::string* channel_id);

  // string message_id = 2;
  void clear_message_id();
  static const int kMessageIdFieldNumber = 2;
  const ::std::string& message_id() const;
  void set_message_id(const ::std::string& value);
  #if LANG_CXX11
  void set_message_id(::std::string&& value);
  #endif
  void set_message_id(const char* value);
  void set_message_id(const char* value, size_t size);
  ::std::string* mutable_message_id();
  ::std::string* release_message_id();
  void set_allocated_message_id(::std::string* message_id);

  // string content = 3;
  void clear_content();
  static const int kContentFieldNumber = 3;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  #if LANG_CXX11
  void set_content(::std::string&& value);
  #endif
  void set_content(const char* value);
  void set_content(const char* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:nakama.realtime.ChannelMessageUpdate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr channel_id_;
  ::google::protobuf::internal::ArenaStringPtr message_id_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2frtapi_2frealtime_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ChannelMessageRemove : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.ChannelMessageRemove) */ {
 public:
  ChannelMessageRemove();
  virtual ~ChannelMessageRemove();

  ChannelMessageRemove(const ChannelMessageRemove& from);

  inline ChannelMessageRemove& operator=(const ChannelMessageRemove& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChannelMessageRemove(ChannelMessageRemove&& from) noexcept
    : ChannelMessageRemove() {
    *this = ::std::move(from);
  }

  inline ChannelMessageRemove& operator=(ChannelMessageRemove&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChannelMessageRemove& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChannelMessageRemove* internal_default_instance() {
    return reinterpret_cast<const ChannelMessageRemove*>(
               &_ChannelMessageRemove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ChannelMessageRemove* other);
  friend void swap(ChannelMessageRemove& a, ChannelMessageRemove& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChannelMessageRemove* New() const final {
    return CreateMaybeMessage<ChannelMessageRemove>(NULL);
  }

  ChannelMessageRemove* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChannelMessageRemove>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ChannelMessageRemove& from);
  void MergeFrom(const ChannelMessageRemove& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelMessageRemove* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string channel_id = 1;
  void clear_channel_id();
  static const int kChannelIdFieldNumber = 1;
  const ::std::string& channel_id() const;
  void set_channel_id(const ::std::string& value);
  #if LANG_CXX11
  void set_channel_id(::std::string&& value);
  #endif
  void set_channel_id(const char* value);
  void set_channel_id(const char* value, size_t size);
  ::std::string* mutable_channel_id();
  ::std::string* release_channel_id();
  void set_allocated_channel_id(::std::string* channel_id);

  // string message_id = 2;
  void clear_message_id();
  static const int kMessageIdFieldNumber = 2;
  const ::std::string& message_id() const;
  void set_message_id(const ::std::string& value);
  #if LANG_CXX11
  void set_message_id(::std::string&& value);
  #endif
  void set_message_id(const char* value);
  void set_message_id(const char* value, size_t size);
  ::std::string* mutable_message_id();
  ::std::string* release_message_id();
  void set_allocated_message_id(::std::string* message_id);

  // @@protoc_insertion_point(class_scope:nakama.realtime.ChannelMessageRemove)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr channel_id_;
  ::google::protobuf::internal::ArenaStringPtr message_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2frtapi_2frealtime_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ChannelPresenceEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.ChannelPresenceEvent) */ {
 public:
  ChannelPresenceEvent();
  virtual ~ChannelPresenceEvent();

  ChannelPresenceEvent(const ChannelPresenceEvent& from);

  inline ChannelPresenceEvent& operator=(const ChannelPresenceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChannelPresenceEvent(ChannelPresenceEvent&& from) noexcept
    : ChannelPresenceEvent() {
    *this = ::std::move(from);
  }

  inline ChannelPresenceEvent& operator=(ChannelPresenceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChannelPresenceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChannelPresenceEvent* internal_default_instance() {
    return reinterpret_cast<const ChannelPresenceEvent*>(
               &_ChannelPresenceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ChannelPresenceEvent* other);
  friend void swap(ChannelPresenceEvent& a, ChannelPresenceEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChannelPresenceEvent* New() const final {
    return CreateMaybeMessage<ChannelPresenceEvent>(NULL);
  }

  ChannelPresenceEvent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChannelPresenceEvent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ChannelPresenceEvent& from);
  void MergeFrom(const ChannelPresenceEvent& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelPresenceEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nakama.realtime.UserPresence joins = 2;
  int joins_size() const;
  void clear_joins();
  static const int kJoinsFieldNumber = 2;
  ::nakama::realtime::UserPresence* mutable_joins(int index);
  ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >*
      mutable_joins();
  const ::nakama::realtime::UserPresence& joins(int index) const;
  ::nakama::realtime::UserPresence* add_joins();
  const ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >&
      joins() const;

  // repeated .nakama.realtime.UserPresence leaves = 3;
  int leaves_size() const;
  void clear_leaves();
  static const int kLeavesFieldNumber = 3;
  ::nakama::realtime::UserPresence* mutable_leaves(int index);
  ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >*
      mutable_leaves();
  const ::nakama::realtime::UserPresence& leaves(int index) const;
  ::nakama::realtime::UserPresence* add_leaves();
  const ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >&
      leaves() const;

  // string channel_id = 1;
  void clear_channel_id();
  static const int kChannelIdFieldNumber = 1;
  const ::std::string& channel_id() const;
  void set_channel_id(const ::std::string& value);
  #if LANG_CXX11
  void set_channel_id(::std::string&& value);
  #endif
  void set_channel_id(const char* value);
  void set_channel_id(const char* value, size_t size);
  ::std::string* mutable_channel_id();
  ::std::string* release_channel_id();
  void set_allocated_channel_id(::std::string* channel_id);

  // @@protoc_insertion_point(class_scope:nakama.realtime.ChannelPresenceEvent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence > joins_;
  ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence > leaves_;
  ::google::protobuf::internal::ArenaStringPtr channel_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2frtapi_2frealtime_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Error_ContextEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<Error_ContextEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<Error_ContextEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  Error_ContextEntry_DoNotUse();
  Error_ContextEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Error_ContextEntry_DoNotUse& other);
  static const Error_ContextEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Error_ContextEntry_DoNotUse*>(&_Error_ContextEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class Error : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.Error) */ {
 public:
  Error();
  virtual ~Error();

  Error(const Error& from);

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Error(Error&& from) noexcept
    : Error() {
    *this = ::std::move(from);
  }

  inline Error& operator=(Error&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Error& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(Error* other);
  friend void swap(Error& a, Error& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Error* New() const final {
    return CreateMaybeMessage<Error>(NULL);
  }

  Error* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Error>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Error* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  typedef Error_Code Code;
  static const Code RUNTIME_EXCEPTION =
    Error_Code_RUNTIME_EXCEPTION;
  static const Code UNRECOGNIZED_PAYLOAD =
    Error_Code_UNRECOGNIZED_PAYLOAD;
  static const Code MISSING_PAYLOAD =
    Error_Code_MISSING_PAYLOAD;
  static const Code BAD_INPUT =
    Error_Code_BAD_INPUT;
  static const Code MATCH_NOT_FOUND =
    Error_Code_MATCH_NOT_FOUND;
  static const Code MATCH_JOIN_REJECTED =
    Error_Code_MATCH_JOIN_REJECTED;
  static const Code RUNTIME_FUNCTION_NOT_FOUND =
    Error_Code_RUNTIME_FUNCTION_NOT_FOUND;
  static const Code RUNTIME_FUNCTION_EXCEPTION =
    Error_Code_RUNTIME_FUNCTION_EXCEPTION;
  static inline bool Code_IsValid(int value) {
    return Error_Code_IsValid(value);
  }
  static const Code Code_MIN =
    Error_Code_Code_MIN;
  static const Code Code_MAX =
    Error_Code_Code_MAX;
  static const int Code_ARRAYSIZE =
    Error_Code_Code_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Code_descriptor() {
    return Error_Code_descriptor();
  }
  static inline const ::std::string& Code_Name(Code value) {
    return Error_Code_Name(value);
  }
  static inline bool Code_Parse(const ::std::string& name,
      Code* value) {
    return Error_Code_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // map<string, string> context = 3;
  int context_size() const;
  void clear_context();
  static const int kContextFieldNumber = 3;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      context() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_context();

  // string message = 2;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:nakama.realtime.Error)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      Error_ContextEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > context_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::int32 code_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2frtapi_2frealtime_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Match : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.Match) */ {
 public:
  Match();
  virtual ~Match();

  Match(const Match& from);

  inline Match& operator=(const Match& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Match(Match&& from) noexcept
    : Match() {
    *this = ::std::move(from);
  }

  inline Match& operator=(Match&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Match& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Match* internal_default_instance() {
    return reinterpret_cast<const Match*>(
               &_Match_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(Match* other);
  friend void swap(Match& a, Match& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Match* New() const final {
    return CreateMaybeMessage<Match>(NULL);
  }

  Match* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Match>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Match& from);
  void MergeFrom(const Match& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Match* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nakama.realtime.UserPresence presences = 5;
  int presences_size() const;
  void clear_presences();
  static const int kPresencesFieldNumber = 5;
  ::nakama::realtime::UserPresence* mutable_presences(int index);
  ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >*
      mutable_presences();
  const ::nakama::realtime::UserPresence& presences(int index) const;
  ::nakama::realtime::UserPresence* add_presences();
  const ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >&
      presences() const;

  // string match_id = 1;
  void clear_match_id();
  static const int kMatchIdFieldNumber = 1;
  const ::std::string& match_id() const;
  void set_match_id(const ::std::string& value);
  #if LANG_CXX11
  void set_match_id(::std::string&& value);
  #endif
  void set_match_id(const char* value);
  void set_match_id(const char* value, size_t size);
  ::std::string* mutable_match_id();
  ::std::string* release_match_id();
  void set_allocated_match_id(::std::string* match_id);

  // .google.protobuf.StringValue label = 3;
  bool has_label() const;
  void clear_label();
  static const int kLabelFieldNumber = 3;
  private:
  const ::google::protobuf::StringValue& _internal_label() const;
  public:
  const ::google::protobuf::StringValue& label() const;
  ::google::protobuf::StringValue* release_label();
  ::google::protobuf::StringValue* mutable_label();
  void set_allocated_label(::google::protobuf::StringValue* label);

  // .nakama.realtime.UserPresence self = 6;
  bool has_self() const;
  void clear_self();
  static const int kSelfFieldNumber = 6;
  private:
  const ::nakama::realtime::UserPresence& _internal_self() const;
  public:
  const ::nakama::realtime::UserPresence& self() const;
  ::nakama::realtime::UserPresence* release_self();
  ::nakama::realtime::UserPresence* mutable_self();
  void set_allocated_self(::nakama::realtime::UserPresence* self);

  // bool authoritative = 2;
  void clear_authoritative();
  static const int kAuthoritativeFieldNumber = 2;
  bool authoritative() const;
  void set_authoritative(bool value);

  // int32 size = 4;
  void clear_size();
  static const int kSizeFieldNumber = 4;
  ::google::protobuf::int32 size() const;
  void set_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:nakama.realtime.Match)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence > presences_;
  ::google::protobuf::internal::ArenaStringPtr match_id_;
  ::google::protobuf::StringValue* label_;
  ::nakama::realtime::UserPresence* self_;
  bool authoritative_;
  ::google::protobuf::int32 size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2frtapi_2frealtime_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MatchCreate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.MatchCreate) */ {
 public:
  MatchCreate();
  virtual ~MatchCreate();

  MatchCreate(const MatchCreate& from);

  inline MatchCreate& operator=(const MatchCreate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MatchCreate(MatchCreate&& from) noexcept
    : MatchCreate() {
    *this = ::std::move(from);
  }

  inline MatchCreate& operator=(MatchCreate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchCreate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MatchCreate* internal_default_instance() {
    return reinterpret_cast<const MatchCreate*>(
               &_MatchCreate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(MatchCreate* other);
  friend void swap(MatchCreate& a, MatchCreate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MatchCreate* New() const final {
    return CreateMaybeMessage<MatchCreate>(NULL);
  }

  MatchCreate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MatchCreate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MatchCreate& from);
  void MergeFrom(const MatchCreate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchCreate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:nakama.realtime.MatchCreate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2frtapi_2frealtime_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MatchData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.MatchData) */ {
 public:
  MatchData();
  virtual ~MatchData();

  MatchData(const MatchData& from);

  inline MatchData& operator=(const MatchData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MatchData(MatchData&& from) noexcept
    : MatchData() {
    *this = ::std::move(from);
  }

  inline MatchData& operator=(MatchData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MatchData* internal_default_instance() {
    return reinterpret_cast<const MatchData*>(
               &_MatchData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(MatchData* other);
  friend void swap(MatchData& a, MatchData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MatchData* New() const final {
    return CreateMaybeMessage<MatchData>(NULL);
  }

  MatchData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MatchData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MatchData& from);
  void MergeFrom(const MatchData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string match_id = 1;
  void clear_match_id();
  static const int kMatchIdFieldNumber = 1;
  const ::std::string& match_id() const;
  void set_match_id(const ::std::string& value);
  #if LANG_CXX11
  void set_match_id(::std::string&& value);
  #endif
  void set_match_id(const char* value);
  void set_match_id(const char* value, size_t size);
  ::std::string* mutable_match_id();
  ::std::string* release_match_id();
  void set_allocated_match_id(::std::string* match_id);

  // bytes data = 4;
  void clear_data();
  static const int kDataFieldNumber = 4;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // .nakama.realtime.UserPresence presence = 2;
  bool has_presence() const;
  void clear_presence();
  static const int kPresenceFieldNumber = 2;
  private:
  const ::nakama::realtime::UserPresence& _internal_presence() const;
  public:
  const ::nakama::realtime::UserPresence& presence() const;
  ::nakama::realtime::UserPresence* release_presence();
  ::nakama::realtime::UserPresence* mutable_presence();
  void set_allocated_presence(::nakama::realtime::UserPresence* presence);

  // int64 op_code = 3;
  void clear_op_code();
  static const int kOpCodeFieldNumber = 3;
  ::google::protobuf::int64 op_code() const;
  void set_op_code(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:nakama.realtime.MatchData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr match_id_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::nakama::realtime::UserPresence* presence_;
  ::google::protobuf::int64 op_code_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2frtapi_2frealtime_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MatchDataSend : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.MatchDataSend) */ {
 public:
  MatchDataSend();
  virtual ~MatchDataSend();

  MatchDataSend(const MatchDataSend& from);

  inline MatchDataSend& operator=(const MatchDataSend& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MatchDataSend(MatchDataSend&& from) noexcept
    : MatchDataSend() {
    *this = ::std::move(from);
  }

  inline MatchDataSend& operator=(MatchDataSend&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchDataSend& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MatchDataSend* internal_default_instance() {
    return reinterpret_cast<const MatchDataSend*>(
               &_MatchDataSend_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(MatchDataSend* other);
  friend void swap(MatchDataSend& a, MatchDataSend& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MatchDataSend* New() const final {
    return CreateMaybeMessage<MatchDataSend>(NULL);
  }

  MatchDataSend* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MatchDataSend>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MatchDataSend& from);
  void MergeFrom(const MatchDataSend& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchDataSend* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nakama.realtime.UserPresence presences = 4;
  int presences_size() const;
  void clear_presences();
  static const int kPresencesFieldNumber = 4;
  ::nakama::realtime::UserPresence* mutable_presences(int index);
  ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >*
      mutable_presences();
  const ::nakama::realtime::UserPresence& presences(int index) const;
  ::nakama::realtime::UserPresence* add_presences();
  const ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >&
      presences() const;

  // string match_id = 1;
  void clear_match_id();
  static const int kMatchIdFieldNumber = 1;
  const ::std::string& match_id() const;
  void set_match_id(const ::std::string& value);
  #if LANG_CXX11
  void set_match_id(::std::string&& value);
  #endif
  void set_match_id(const char* value);
  void set_match_id(const char* value, size_t size);
  ::std::string* mutable_match_id();
  ::std::string* release_match_id();
  void set_allocated_match_id(::std::string* match_id);

  // bytes data = 3;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // int64 op_code = 2;
  void clear_op_code();
  static const int kOpCodeFieldNumber = 2;
  ::google::protobuf::int64 op_code() const;
  void set_op_code(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:nakama.realtime.MatchDataSend)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence > presences_;
  ::google::protobuf::internal::ArenaStringPtr match_id_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::int64 op_code_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2frtapi_2frealtime_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MatchJoin_MetadataEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<MatchJoin_MetadataEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<MatchJoin_MetadataEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  MatchJoin_MetadataEntry_DoNotUse();
  MatchJoin_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const MatchJoin_MetadataEntry_DoNotUse& other);
  static const MatchJoin_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MatchJoin_MetadataEntry_DoNotUse*>(&_MatchJoin_MetadataEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class MatchJoin : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.MatchJoin) */ {
 public:
  MatchJoin();
  virtual ~MatchJoin();

  MatchJoin(const MatchJoin& from);

  inline MatchJoin& operator=(const MatchJoin& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MatchJoin(MatchJoin&& from) noexcept
    : MatchJoin() {
    *this = ::std::move(from);
  }

  inline MatchJoin& operator=(MatchJoin&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchJoin& default_instance();

  enum IdCase {
    kMatchId = 1,
    kToken = 2,
    ID_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MatchJoin* internal_default_instance() {
    return reinterpret_cast<const MatchJoin*>(
               &_MatchJoin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(MatchJoin* other);
  friend void swap(MatchJoin& a, MatchJoin& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MatchJoin* New() const final {
    return CreateMaybeMessage<MatchJoin>(NULL);
  }

  MatchJoin* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MatchJoin>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MatchJoin& from);
  void MergeFrom(const MatchJoin& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchJoin* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> metadata = 3;
  int metadata_size() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 3;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      metadata() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_metadata();

  // string match_id = 1;
  private:
  bool has_match_id() const;
  public:
  void clear_match_id();
  static const int kMatchIdFieldNumber = 1;
  const ::std::string& match_id() const;
  void set_match_id(const ::std::string& value);
  #if LANG_CXX11
  void set_match_id(::std::string&& value);
  #endif
  void set_match_id(const char* value);
  void set_match_id(const char* value, size_t size);
  ::std::string* mutable_match_id();
  ::std::string* release_match_id();
  void set_allocated_match_id(::std::string* match_id);

  // string token = 2;
  private:
  bool has_token() const;
  public:
  void clear_token();
  static const int kTokenFieldNumber = 2;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  #if LANG_CXX11
  void set_token(::std::string&& value);
  #endif
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  void clear_id();
  IdCase id_case() const;
  // @@protoc_insertion_point(class_scope:nakama.realtime.MatchJoin)
 private:
  void set_has_match_id();
  void set_has_token();

  inline bool has_id() const;
  inline void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      MatchJoin_MetadataEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > metadata_;
  union IdUnion {
    IdUnion() {}
    ::google::protobuf::internal::ArenaStringPtr match_id_;
    ::google::protobuf::internal::ArenaStringPtr token_;
  } id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2frtapi_2frealtime_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MatchLeave : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.MatchLeave) */ {
 public:
  MatchLeave();
  virtual ~MatchLeave();

  MatchLeave(const MatchLeave& from);

  inline MatchLeave& operator=(const MatchLeave& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MatchLeave(MatchLeave&& from) noexcept
    : MatchLeave() {
    *this = ::std::move(from);
  }

  inline MatchLeave& operator=(MatchLeave&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchLeave& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MatchLeave* internal_default_instance() {
    return reinterpret_cast<const MatchLeave*>(
               &_MatchLeave_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(MatchLeave* other);
  friend void swap(MatchLeave& a, MatchLeave& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MatchLeave* New() const final {
    return CreateMaybeMessage<MatchLeave>(NULL);
  }

  MatchLeave* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MatchLeave>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MatchLeave& from);
  void MergeFrom(const MatchLeave& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchLeave* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string match_id = 1;
  void clear_match_id();
  static const int kMatchIdFieldNumber = 1;
  const ::std::string& match_id() const;
  void set_match_id(const ::std::string& value);
  #if LANG_CXX11
  void set_match_id(::std::string&& value);
  #endif
  void set_match_id(const char* value);
  void set_match_id(const char* value, size_t size);
  ::std::string* mutable_match_id();
  ::std::string* release_match_id();
  void set_allocated_match_id(::std::string* match_id);

  // @@protoc_insertion_point(class_scope:nakama.realtime.MatchLeave)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr match_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2frtapi_2frealtime_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MatchPresenceEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.MatchPresenceEvent) */ {
 public:
  MatchPresenceEvent();
  virtual ~MatchPresenceEvent();

  MatchPresenceEvent(const MatchPresenceEvent& from);

  inline MatchPresenceEvent& operator=(const MatchPresenceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MatchPresenceEvent(MatchPresenceEvent&& from) noexcept
    : MatchPresenceEvent() {
    *this = ::std::move(from);
  }

  inline MatchPresenceEvent& operator=(MatchPresenceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchPresenceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MatchPresenceEvent* internal_default_instance() {
    return reinterpret_cast<const MatchPresenceEvent*>(
               &_MatchPresenceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(MatchPresenceEvent* other);
  friend void swap(MatchPresenceEvent& a, MatchPresenceEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MatchPresenceEvent* New() const final {
    return CreateMaybeMessage<MatchPresenceEvent>(NULL);
  }

  MatchPresenceEvent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MatchPresenceEvent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MatchPresenceEvent& from);
  void MergeFrom(const MatchPresenceEvent& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchPresenceEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nakama.realtime.UserPresence joins = 2;
  int joins_size() const;
  void clear_joins();
  static const int kJoinsFieldNumber = 2;
  ::nakama::realtime::UserPresence* mutable_joins(int index);
  ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >*
      mutable_joins();
  const ::nakama::realtime::UserPresence& joins(int index) const;
  ::nakama::realtime::UserPresence* add_joins();
  const ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >&
      joins() const;

  // repeated .nakama.realtime.UserPresence leaves = 3;
  int leaves_size() const;
  void clear_leaves();
  static const int kLeavesFieldNumber = 3;
  ::nakama::realtime::UserPresence* mutable_leaves(int index);
  ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >*
      mutable_leaves();
  const ::nakama::realtime::UserPresence& leaves(int index) const;
  ::nakama::realtime::UserPresence* add_leaves();
  const ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >&
      leaves() const;

  // string match_id = 1;
  void clear_match_id();
  static const int kMatchIdFieldNumber = 1;
  const ::std::string& match_id() const;
  void set_match_id(const ::std::string& value);
  #if LANG_CXX11
  void set_match_id(::std::string&& value);
  #endif
  void set_match_id(const char* value);
  void set_match_id(const char* value, size_t size);
  ::std::string* mutable_match_id();
  ::std::string* release_match_id();
  void set_allocated_match_id(::std::string* match_id);

  // @@protoc_insertion_point(class_scope:nakama.realtime.MatchPresenceEvent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence > joins_;
  ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence > leaves_;
  ::google::protobuf::internal::ArenaStringPtr match_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2frtapi_2frealtime_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MatchmakerAdd_StringPropertiesEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<MatchmakerAdd_StringPropertiesEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<MatchmakerAdd_StringPropertiesEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  MatchmakerAdd_StringPropertiesEntry_DoNotUse();
  MatchmakerAdd_StringPropertiesEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const MatchmakerAdd_StringPropertiesEntry_DoNotUse& other);
  static const MatchmakerAdd_StringPropertiesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MatchmakerAdd_StringPropertiesEntry_DoNotUse*>(&_MatchmakerAdd_StringPropertiesEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class MatchmakerAdd_NumericPropertiesEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<MatchmakerAdd_NumericPropertiesEntry_DoNotUse, 
    ::std::string, double,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<MatchmakerAdd_NumericPropertiesEntry_DoNotUse, 
    ::std::string, double,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE,
    0 > SuperType;
  MatchmakerAdd_NumericPropertiesEntry_DoNotUse();
  MatchmakerAdd_NumericPropertiesEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const MatchmakerAdd_NumericPropertiesEntry_DoNotUse& other);
  static const MatchmakerAdd_NumericPropertiesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MatchmakerAdd_NumericPropertiesEntry_DoNotUse*>(&_MatchmakerAdd_NumericPropertiesEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class MatchmakerAdd : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.MatchmakerAdd) */ {
 public:
  MatchmakerAdd();
  virtual ~MatchmakerAdd();

  MatchmakerAdd(const MatchmakerAdd& from);

  inline MatchmakerAdd& operator=(const MatchmakerAdd& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MatchmakerAdd(MatchmakerAdd&& from) noexcept
    : MatchmakerAdd() {
    *this = ::std::move(from);
  }

  inline MatchmakerAdd& operator=(MatchmakerAdd&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchmakerAdd& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MatchmakerAdd* internal_default_instance() {
    return reinterpret_cast<const MatchmakerAdd*>(
               &_MatchmakerAdd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(MatchmakerAdd* other);
  friend void swap(MatchmakerAdd& a, MatchmakerAdd& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MatchmakerAdd* New() const final {
    return CreateMaybeMessage<MatchmakerAdd>(NULL);
  }

  MatchmakerAdd* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MatchmakerAdd>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MatchmakerAdd& from);
  void MergeFrom(const MatchmakerAdd& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchmakerAdd* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> string_properties = 4;
  int string_properties_size() const;
  void clear_string_properties();
  static const int kStringPropertiesFieldNumber = 4;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      string_properties() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_string_properties();

  // map<string, double> numeric_properties = 5;
  int numeric_properties_size() const;
  void clear_numeric_properties();
  static const int kNumericPropertiesFieldNumber = 5;
  const ::google::protobuf::Map< ::std::string, double >&
      numeric_properties() const;
  ::google::protobuf::Map< ::std::string, double >*
      mutable_numeric_properties();

  // string query = 3;
  void clear_query();
  static const int kQueryFieldNumber = 3;
  const ::std::string& query() const;
  void set_query(const ::std::string& value);
  #if LANG_CXX11
  void set_query(::std::string&& value);
  #endif
  void set_query(const char* value);
  void set_query(const char* value, size_t size);
  ::std::string* mutable_query();
  ::std::string* release_query();
  void set_allocated_query(::std::string* query);

  // int32 min_count = 1;
  void clear_min_count();
  static const int kMinCountFieldNumber = 1;
  ::google::protobuf::int32 min_count() const;
  void set_min_count(::google::protobuf::int32 value);

  // int32 max_count = 2;
  void clear_max_count();
  static const int kMaxCountFieldNumber = 2;
  ::google::protobuf::int32 max_count() const;
  void set_max_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:nakama.realtime.MatchmakerAdd)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      MatchmakerAdd_StringPropertiesEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > string_properties_;
  ::google::protobuf::internal::MapField<
      MatchmakerAdd_NumericPropertiesEntry_DoNotUse,
      ::std::string, double,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE,
      0 > numeric_properties_;
  ::google::protobuf::internal::ArenaStringPtr query_;
  ::google::protobuf::int32 min_count_;
  ::google::protobuf::int32 max_count_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2frtapi_2frealtime_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MatchmakerMatched_MatchmakerUser_StringPropertiesEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<MatchmakerMatched_MatchmakerUser_StringPropertiesEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<MatchmakerMatched_MatchmakerUser_StringPropertiesEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  MatchmakerMatched_MatchmakerUser_StringPropertiesEntry_DoNotUse();
  MatchmakerMatched_MatchmakerUser_StringPropertiesEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const MatchmakerMatched_MatchmakerUser_StringPropertiesEntry_DoNotUse& other);
  static const MatchmakerMatched_MatchmakerUser_StringPropertiesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MatchmakerMatched_MatchmakerUser_StringPropertiesEntry_DoNotUse*>(&_MatchmakerMatched_MatchmakerUser_StringPropertiesEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class MatchmakerMatched_MatchmakerUser_NumericPropertiesEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<MatchmakerMatched_MatchmakerUser_NumericPropertiesEntry_DoNotUse, 
    ::std::string, double,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<MatchmakerMatched_MatchmakerUser_NumericPropertiesEntry_DoNotUse, 
    ::std::string, double,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE,
    0 > SuperType;
  MatchmakerMatched_MatchmakerUser_NumericPropertiesEntry_DoNotUse();
  MatchmakerMatched_MatchmakerUser_NumericPropertiesEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const MatchmakerMatched_MatchmakerUser_NumericPropertiesEntry_DoNotUse& other);
  static const MatchmakerMatched_MatchmakerUser_NumericPropertiesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MatchmakerMatched_MatchmakerUser_NumericPropertiesEntry_DoNotUse*>(&_MatchmakerMatched_MatchmakerUser_NumericPropertiesEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class MatchmakerMatched_MatchmakerUser : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.MatchmakerMatched.MatchmakerUser) */ {
 public:
  MatchmakerMatched_MatchmakerUser();
  virtual ~MatchmakerMatched_MatchmakerUser();

  MatchmakerMatched_MatchmakerUser(const MatchmakerMatched_MatchmakerUser& from);

  inline MatchmakerMatched_MatchmakerUser& operator=(const MatchmakerMatched_MatchmakerUser& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MatchmakerMatched_MatchmakerUser(MatchmakerMatched_MatchmakerUser&& from) noexcept
    : MatchmakerMatched_MatchmakerUser() {
    *this = ::std::move(from);
  }

  inline MatchmakerMatched_MatchmakerUser& operator=(MatchmakerMatched_MatchmakerUser&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchmakerMatched_MatchmakerUser& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MatchmakerMatched_MatchmakerUser* internal_default_instance() {
    return reinterpret_cast<const MatchmakerMatched_MatchmakerUser*>(
               &_MatchmakerMatched_MatchmakerUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(MatchmakerMatched_MatchmakerUser* other);
  friend void swap(MatchmakerMatched_MatchmakerUser& a, MatchmakerMatched_MatchmakerUser& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MatchmakerMatched_MatchmakerUser* New() const final {
    return CreateMaybeMessage<MatchmakerMatched_MatchmakerUser>(NULL);
  }

  MatchmakerMatched_MatchmakerUser* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MatchmakerMatched_MatchmakerUser>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MatchmakerMatched_MatchmakerUser& from);
  void MergeFrom(const MatchmakerMatched_MatchmakerUser& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchmakerMatched_MatchmakerUser* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> string_properties = 5;
  int string_properties_size() const;
  void clear_string_properties();
  static const int kStringPropertiesFieldNumber = 5;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      string_properties() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_string_properties();

  // map<string, double> numeric_properties = 6;
  int numeric_properties_size() const;
  void clear_numeric_properties();
  static const int kNumericPropertiesFieldNumber = 6;
  const ::google::protobuf::Map< ::std::string, double >&
      numeric_properties() const;
  ::google::protobuf::Map< ::std::string, double >*
      mutable_numeric_properties();

  // .nakama.realtime.UserPresence presence = 1;
  bool has_presence() const;
  void clear_presence();
  static const int kPresenceFieldNumber = 1;
  private:
  const ::nakama::realtime::UserPresence& _internal_presence() const;
  public:
  const ::nakama::realtime::UserPresence& presence() const;
  ::nakama::realtime::UserPresence* release_presence();
  ::nakama::realtime::UserPresence* mutable_presence();
  void set_allocated_presence(::nakama::realtime::UserPresence* presence);

  // @@protoc_insertion_point(class_scope:nakama.realtime.MatchmakerMatched.MatchmakerUser)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      MatchmakerMatched_MatchmakerUser_StringPropertiesEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > string_properties_;
  ::google::protobuf::internal::MapField<
      MatchmakerMatched_MatchmakerUser_NumericPropertiesEntry_DoNotUse,
      ::std::string, double,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE,
      0 > numeric_properties_;
  ::nakama::realtime::UserPresence* presence_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2frtapi_2frealtime_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MatchmakerMatched : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.MatchmakerMatched) */ {
 public:
  MatchmakerMatched();
  virtual ~MatchmakerMatched();

  MatchmakerMatched(const MatchmakerMatched& from);

  inline MatchmakerMatched& operator=(const MatchmakerMatched& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MatchmakerMatched(MatchmakerMatched&& from) noexcept
    : MatchmakerMatched() {
    *this = ::std::move(from);
  }

  inline MatchmakerMatched& operator=(MatchmakerMatched&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchmakerMatched& default_instance();

  enum IdCase {
    kMatchId = 2,
    kToken = 3,
    ID_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MatchmakerMatched* internal_default_instance() {
    return reinterpret_cast<const MatchmakerMatched*>(
               &_MatchmakerMatched_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(MatchmakerMatched* other);
  friend void swap(MatchmakerMatched& a, MatchmakerMatched& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MatchmakerMatched* New() const final {
    return CreateMaybeMessage<MatchmakerMatched>(NULL);
  }

  MatchmakerMatched* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MatchmakerMatched>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MatchmakerMatched& from);
  void MergeFrom(const MatchmakerMatched& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchmakerMatched* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MatchmakerMatched_MatchmakerUser MatchmakerUser;

  // accessors -------------------------------------------------------

  // repeated .nakama.realtime.MatchmakerMatched.MatchmakerUser users = 4;
  int users_size() const;
  void clear_users();
  static const int kUsersFieldNumber = 4;
  ::nakama::realtime::MatchmakerMatched_MatchmakerUser* mutable_users(int index);
  ::google::protobuf::RepeatedPtrField< ::nakama::realtime::MatchmakerMatched_MatchmakerUser >*
      mutable_users();
  const ::nakama::realtime::MatchmakerMatched_MatchmakerUser& users(int index) const;
  ::nakama::realtime::MatchmakerMatched_MatchmakerUser* add_users();
  const ::google::protobuf::RepeatedPtrField< ::nakama::realtime::MatchmakerMatched_MatchmakerUser >&
      users() const;

  // string ticket = 1;
  void clear_ticket();
  static const int kTicketFieldNumber = 1;
  const ::std::string& ticket() const;
  void set_ticket(const ::std::string& value);
  #if LANG_CXX11
  void set_ticket(::std::string&& value);
  #endif
  void set_ticket(const char* value);
  void set_ticket(const char* value, size_t size);
  ::std::string* mutable_ticket();
  ::std::string* release_ticket();
  void set_allocated_ticket(::std::string* ticket);

  // .nakama.realtime.MatchmakerMatched.MatchmakerUser self = 5;
  bool has_self() const;
  void clear_self();
  static const int kSelfFieldNumber = 5;
  private:
  const ::nakama::realtime::MatchmakerMatched_MatchmakerUser& _internal_self() const;
  public:
  const ::nakama::realtime::MatchmakerMatched_MatchmakerUser& self() const;
  ::nakama::realtime::MatchmakerMatched_MatchmakerUser* release_self();
  ::nakama::realtime::MatchmakerMatched_MatchmakerUser* mutable_self();
  void set_allocated_self(::nakama::realtime::MatchmakerMatched_MatchmakerUser* self);

  // string match_id = 2;
  private:
  bool has_match_id() const;
  public:
  void clear_match_id();
  static const int kMatchIdFieldNumber = 2;
  const ::std::string& match_id() const;
  void set_match_id(const ::std::string& value);
  #if LANG_CXX11
  void set_match_id(::std::string&& value);
  #endif
  void set_match_id(const char* value);
  void set_match_id(const char* value, size_t size);
  ::std::string* mutable_match_id();
  ::std::string* release_match_id();
  void set_allocated_match_id(::std::string* match_id);

  // string token = 3;
  private:
  bool has_token() const;
  public:
  void clear_token();
  static const int kTokenFieldNumber = 3;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  #if LANG_CXX11
  void set_token(::std::string&& value);
  #endif
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  void clear_id();
  IdCase id_case() const;
  // @@protoc_insertion_point(class_scope:nakama.realtime.MatchmakerMatched)
 private:
  void set_has_match_id();
  void set_has_token();

  inline bool has_id() const;
  inline void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::nakama::realtime::MatchmakerMatched_MatchmakerUser > users_;
  ::google::protobuf::internal::ArenaStringPtr ticket_;
  ::nakama::realtime::MatchmakerMatched_MatchmakerUser* self_;
  union IdUnion {
    IdUnion() {}
    ::google::protobuf::internal::ArenaStringPtr match_id_;
    ::google::protobuf::internal::ArenaStringPtr token_;
  } id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2frtapi_2frealtime_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MatchmakerRemove : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.MatchmakerRemove) */ {
 public:
  MatchmakerRemove();
  virtual ~MatchmakerRemove();

  MatchmakerRemove(const MatchmakerRemove& from);

  inline MatchmakerRemove& operator=(const MatchmakerRemove& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MatchmakerRemove(MatchmakerRemove&& from) noexcept
    : MatchmakerRemove() {
    *this = ::std::move(from);
  }

  inline MatchmakerRemove& operator=(MatchmakerRemove&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchmakerRemove& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MatchmakerRemove* internal_default_instance() {
    return reinterpret_cast<const MatchmakerRemove*>(
               &_MatchmakerRemove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(MatchmakerRemove* other);
  friend void swap(MatchmakerRemove& a, MatchmakerRemove& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MatchmakerRemove* New() const final {
    return CreateMaybeMessage<MatchmakerRemove>(NULL);
  }

  MatchmakerRemove* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MatchmakerRemove>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MatchmakerRemove& from);
  void MergeFrom(const MatchmakerRemove& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchmakerRemove* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ticket = 1;
  void clear_ticket();
  static const int kTicketFieldNumber = 1;
  const ::std::string& ticket() const;
  void set_ticket(const ::std::string& value);
  #if LANG_CXX11
  void set_ticket(::std::string&& value);
  #endif
  void set_ticket(const char* value);
  void set_ticket(const char* value, size_t size);
  ::std::string* mutable_ticket();
  ::std::string* release_ticket();
  void set_allocated_ticket(::std::string* ticket);

  // @@protoc_insertion_point(class_scope:nakama.realtime.MatchmakerRemove)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ticket_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2frtapi_2frealtime_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MatchmakerTicket : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.MatchmakerTicket) */ {
 public:
  MatchmakerTicket();
  virtual ~MatchmakerTicket();

  MatchmakerTicket(const MatchmakerTicket& from);

  inline MatchmakerTicket& operator=(const MatchmakerTicket& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MatchmakerTicket(MatchmakerTicket&& from) noexcept
    : MatchmakerTicket() {
    *this = ::std::move(from);
  }

  inline MatchmakerTicket& operator=(MatchmakerTicket&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchmakerTicket& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MatchmakerTicket* internal_default_instance() {
    return reinterpret_cast<const MatchmakerTicket*>(
               &_MatchmakerTicket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(MatchmakerTicket* other);
  friend void swap(MatchmakerTicket& a, MatchmakerTicket& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MatchmakerTicket* New() const final {
    return CreateMaybeMessage<MatchmakerTicket>(NULL);
  }

  MatchmakerTicket* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MatchmakerTicket>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MatchmakerTicket& from);
  void MergeFrom(const MatchmakerTicket& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchmakerTicket* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ticket = 1;
  void clear_ticket();
  static const int kTicketFieldNumber = 1;
  const ::std::string& ticket() const;
  void set_ticket(const ::std::string& value);
  #if LANG_CXX11
  void set_ticket(::std::string&& value);
  #endif
  void set_ticket(const char* value);
  void set_ticket(const char* value, size_t size);
  ::std::string* mutable_ticket();
  ::std::string* release_ticket();
  void set_allocated_ticket(::std::string* ticket);

  // @@protoc_insertion_point(class_scope:nakama.realtime.MatchmakerTicket)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ticket_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2frtapi_2frealtime_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Notifications : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.Notifications) */ {
 public:
  Notifications();
  virtual ~Notifications();

  Notifications(const Notifications& from);

  inline Notifications& operator=(const Notifications& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Notifications(Notifications&& from) noexcept
    : Notifications() {
    *this = ::std::move(from);
  }

  inline Notifications& operator=(Notifications&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Notifications& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Notifications* internal_default_instance() {
    return reinterpret_cast<const Notifications*>(
               &_Notifications_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(Notifications* other);
  friend void swap(Notifications& a, Notifications& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Notifications* New() const final {
    return CreateMaybeMessage<Notifications>(NULL);
  }

  Notifications* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Notifications>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Notifications& from);
  void MergeFrom(const Notifications& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Notifications* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nakama.api.Notification notifications = 1;
  int notifications_size() const;
  void clear_notifications();
  static const int kNotificationsFieldNumber = 1;
  ::nakama::api::Notification* mutable_notifications(int index);
  ::google::protobuf::RepeatedPtrField< ::nakama::api::Notification >*
      mutable_notifications();
  const ::nakama::api::Notification& notifications(int index) const;
  ::nakama::api::Notification* add_notifications();
  const ::google::protobuf::RepeatedPtrField< ::nakama::api::Notification >&
      notifications() const;

  // @@protoc_insertion_point(class_scope:nakama.realtime.Notifications)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::nakama::api::Notification > notifications_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2frtapi_2frealtime_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Status : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.Status) */ {
 public:
  Status();
  virtual ~Status();

  Status(const Status& from);

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Status(Status&& from) noexcept
    : Status() {
    *this = ::std::move(from);
  }

  inline Status& operator=(Status&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Status& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
               &_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(Status* other);
  friend void swap(Status& a, Status& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Status* New() const final {
    return CreateMaybeMessage<Status>(NULL);
  }

  Status* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Status>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Status& from);
  void MergeFrom(const Status& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Status* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nakama.realtime.UserPresence presences = 1;
  int presences_size() const;
  void clear_presences();
  static const int kPresencesFieldNumber = 1;
  ::nakama::realtime::UserPresence* mutable_presences(int index);
  ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >*
      mutable_presences();
  const ::nakama::realtime::UserPresence& presences(int index) const;
  ::nakama::realtime::UserPresence* add_presences();
  const ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >&
      presences() const;

  // @@protoc_insertion_point(class_scope:nakama.realtime.Status)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence > presences_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2frtapi_2frealtime_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StatusFollow : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.StatusFollow) */ {
 public:
  StatusFollow();
  virtual ~StatusFollow();

  StatusFollow(const StatusFollow& from);

  inline StatusFollow& operator=(const StatusFollow& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StatusFollow(StatusFollow&& from) noexcept
    : StatusFollow() {
    *this = ::std::move(from);
  }

  inline StatusFollow& operator=(StatusFollow&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusFollow& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatusFollow* internal_default_instance() {
    return reinterpret_cast<const StatusFollow*>(
               &_StatusFollow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(StatusFollow* other);
  friend void swap(StatusFollow& a, StatusFollow& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StatusFollow* New() const final {
    return CreateMaybeMessage<StatusFollow>(NULL);
  }

  StatusFollow* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StatusFollow>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StatusFollow& from);
  void MergeFrom(const StatusFollow& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusFollow* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string user_ids = 1;
  int user_ids_size() const;
  void clear_user_ids();
  static const int kUserIdsFieldNumber = 1;
  const ::std::string& user_ids(int index) const;
  ::std::string* mutable_user_ids(int index);
  void set_user_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_user_ids(int index, ::std::string&& value);
  #endif
  void set_user_ids(int index, const char* value);
  void set_user_ids(int index, const char* value, size_t size);
  ::std::string* add_user_ids();
  void add_user_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_user_ids(::std::string&& value);
  #endif
  void add_user_ids(const char* value);
  void add_user_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& user_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_user_ids();

  // @@protoc_insertion_point(class_scope:nakama.realtime.StatusFollow)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> user_ids_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2frtapi_2frealtime_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StatusPresenceEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.StatusPresenceEvent) */ {
 public:
  StatusPresenceEvent();
  virtual ~StatusPresenceEvent();

  StatusPresenceEvent(const StatusPresenceEvent& from);

  inline StatusPresenceEvent& operator=(const StatusPresenceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StatusPresenceEvent(StatusPresenceEvent&& from) noexcept
    : StatusPresenceEvent() {
    *this = ::std::move(from);
  }

  inline StatusPresenceEvent& operator=(StatusPresenceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusPresenceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatusPresenceEvent* internal_default_instance() {
    return reinterpret_cast<const StatusPresenceEvent*>(
               &_StatusPresenceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(StatusPresenceEvent* other);
  friend void swap(StatusPresenceEvent& a, StatusPresenceEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StatusPresenceEvent* New() const final {
    return CreateMaybeMessage<StatusPresenceEvent>(NULL);
  }

  StatusPresenceEvent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StatusPresenceEvent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StatusPresenceEvent& from);
  void MergeFrom(const StatusPresenceEvent& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusPresenceEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nakama.realtime.UserPresence joins = 2;
  int joins_size() const;
  void clear_joins();
  static const int kJoinsFieldNumber = 2;
  ::nakama::realtime::UserPresence* mutable_joins(int index);
  ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >*
      mutable_joins();
  const ::nakama::realtime::UserPresence& joins(int index) const;
  ::nakama::realtime::UserPresence* add_joins();
  const ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >&
      joins() const;

  // repeated .nakama.realtime.UserPresence leaves = 3;
  int leaves_size() const;
  void clear_leaves();
  static const int kLeavesFieldNumber = 3;
  ::nakama::realtime::UserPresence* mutable_leaves(int index);
  ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >*
      mutable_leaves();
  const ::nakama::realtime::UserPresence& leaves(int index) const;
  ::nakama::realtime::UserPresence* add_leaves();
  const ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >&
      leaves() const;

  // @@protoc_insertion_point(class_scope:nakama.realtime.StatusPresenceEvent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence > joins_;
  ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence > leaves_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2frtapi_2frealtime_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StatusUnfollow : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.StatusUnfollow) */ {
 public:
  StatusUnfollow();
  virtual ~StatusUnfollow();

  StatusUnfollow(const StatusUnfollow& from);

  inline StatusUnfollow& operator=(const StatusUnfollow& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StatusUnfollow(StatusUnfollow&& from) noexcept
    : StatusUnfollow() {
    *this = ::std::move(from);
  }

  inline StatusUnfollow& operator=(StatusUnfollow&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusUnfollow& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatusUnfollow* internal_default_instance() {
    return reinterpret_cast<const StatusUnfollow*>(
               &_StatusUnfollow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(StatusUnfollow* other);
  friend void swap(StatusUnfollow& a, StatusUnfollow& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StatusUnfollow* New() const final {
    return CreateMaybeMessage<StatusUnfollow>(NULL);
  }

  StatusUnfollow* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StatusUnfollow>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StatusUnfollow& from);
  void MergeFrom(const StatusUnfollow& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusUnfollow* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string user_ids = 1;
  int user_ids_size() const;
  void clear_user_ids();
  static const int kUserIdsFieldNumber = 1;
  const ::std::string& user_ids(int index) const;
  ::std::string* mutable_user_ids(int index);
  void set_user_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_user_ids(int index, ::std::string&& value);
  #endif
  void set_user_ids(int index, const char* value);
  void set_user_ids(int index, const char* value, size_t size);
  ::std::string* add_user_ids();
  void add_user_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_user_ids(::std::string&& value);
  #endif
  void add_user_ids(const char* value);
  void add_user_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& user_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_user_ids();

  // @@protoc_insertion_point(class_scope:nakama.realtime.StatusUnfollow)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> user_ids_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2frtapi_2frealtime_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StatusUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.StatusUpdate) */ {
 public:
  StatusUpdate();
  virtual ~StatusUpdate();

  StatusUpdate(const StatusUpdate& from);

  inline StatusUpdate& operator=(const StatusUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StatusUpdate(StatusUpdate&& from) noexcept
    : StatusUpdate() {
    *this = ::std::move(from);
  }

  inline StatusUpdate& operator=(StatusUpdate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusUpdate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatusUpdate* internal_default_instance() {
    return reinterpret_cast<const StatusUpdate*>(
               &_StatusUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(StatusUpdate* other);
  friend void swap(StatusUpdate& a, StatusUpdate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StatusUpdate* New() const final {
    return CreateMaybeMessage<StatusUpdate>(NULL);
  }

  StatusUpdate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StatusUpdate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StatusUpdate& from);
  void MergeFrom(const StatusUpdate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.StringValue status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  private:
  const ::google::protobuf::StringValue& _internal_status() const;
  public:
  const ::google::protobuf::StringValue& status() const;
  ::google::protobuf::StringValue* release_status();
  ::google::protobuf::StringValue* mutable_status();
  void set_allocated_status(::google::protobuf::StringValue* status);

  // @@protoc_insertion_point(class_scope:nakama.realtime.StatusUpdate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::StringValue* status_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2frtapi_2frealtime_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Stream : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.Stream) */ {
 public:
  Stream();
  virtual ~Stream();

  Stream(const Stream& from);

  inline Stream& operator=(const Stream& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Stream(Stream&& from) noexcept
    : Stream() {
    *this = ::std::move(from);
  }

  inline Stream& operator=(Stream&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Stream& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Stream* internal_default_instance() {
    return reinterpret_cast<const Stream*>(
               &_Stream_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(Stream* other);
  friend void swap(Stream& a, Stream& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Stream* New() const final {
    return CreateMaybeMessage<Stream>(NULL);
  }

  Stream* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Stream>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Stream& from);
  void MergeFrom(const Stream& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Stream* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string subject = 2;
  void clear_subject();
  static const int kSubjectFieldNumber = 2;
  const ::std::string& subject() const;
  void set_subject(const ::std::string& value);
  #if LANG_CXX11
  void set_subject(::std::string&& value);
  #endif
  void set_subject(const char* value);
  void set_subject(const char* value, size_t size);
  ::std::string* mutable_subject();
  ::std::string* release_subject();
  void set_allocated_subject(::std::string* subject);

  // string descriptor = 3;
  void clear_descriptor();
  static const int kDescriptorFieldNumber = 3;
  const ::std::string& descriptor() const;
  void set_descriptor(const ::std::string& value);
  #if LANG_CXX11
  void set_descriptor(::std::string&& value);
  #endif
  void set_descriptor(const char* value);
  void set_descriptor(const char* value, size_t size);
  ::std::string* mutable_descriptor();
  ::std::string* release_descriptor();
  void set_allocated_descriptor(::std::string* descriptor);

  // string label = 4;
  void clear_label();
  static const int kLabelFieldNumber = 4;
  const ::std::string& label() const;
  void set_label(const ::std::string& value);
  #if LANG_CXX11
  void set_label(::std::string&& value);
  #endif
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  ::std::string* mutable_label();
  ::std::string* release_label();
  void set_allocated_label(::std::string* label);

  // int32 mode = 1;
  void clear_mode();
  static const int kModeFieldNumber = 1;
  ::google::protobuf::int32 mode() const;
  void set_mode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:nakama.realtime.Stream)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr subject_;
  ::google::protobuf::internal::ArenaStringPtr descriptor_;
  ::google::protobuf::internal::ArenaStringPtr label_;
  ::google::protobuf::int32 mode_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2frtapi_2frealtime_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StreamData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.StreamData) */ {
 public:
  StreamData();
  virtual ~StreamData();

  StreamData(const StreamData& from);

  inline StreamData& operator=(const StreamData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StreamData(StreamData&& from) noexcept
    : StreamData() {
    *this = ::std::move(from);
  }

  inline StreamData& operator=(StreamData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StreamData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StreamData* internal_default_instance() {
    return reinterpret_cast<const StreamData*>(
               &_StreamData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  void Swap(StreamData* other);
  friend void swap(StreamData& a, StreamData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StreamData* New() const final {
    return CreateMaybeMessage<StreamData>(NULL);
  }

  StreamData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StreamData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StreamData& from);
  void MergeFrom(const StreamData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string data = 3;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const char* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // .nakama.realtime.Stream stream = 1;
  bool has_stream() const;
  void clear_stream();
  static const int kStreamFieldNumber = 1;
  private:
  const ::nakama::realtime::Stream& _internal_stream() const;
  public:
  const ::nakama::realtime::Stream& stream() const;
  ::nakama::realtime::Stream* release_stream();
  ::nakama::realtime::Stream* mutable_stream();
  void set_allocated_stream(::nakama::realtime::Stream* stream);

  // .nakama.realtime.UserPresence sender = 2;
  bool has_sender() const;
  void clear_sender();
  static const int kSenderFieldNumber = 2;
  private:
  const ::nakama::realtime::UserPresence& _internal_sender() const;
  public:
  const ::nakama::realtime::UserPresence& sender() const;
  ::nakama::realtime::UserPresence* release_sender();
  ::nakama::realtime::UserPresence* mutable_sender();
  void set_allocated_sender(::nakama::realtime::UserPresence* sender);

  // @@protoc_insertion_point(class_scope:nakama.realtime.StreamData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::nakama::realtime::Stream* stream_;
  ::nakama::realtime::UserPresence* sender_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2frtapi_2frealtime_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StreamPresenceEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.StreamPresenceEvent) */ {
 public:
  StreamPresenceEvent();
  virtual ~StreamPresenceEvent();

  StreamPresenceEvent(const StreamPresenceEvent& from);

  inline StreamPresenceEvent& operator=(const StreamPresenceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StreamPresenceEvent(StreamPresenceEvent&& from) noexcept
    : StreamPresenceEvent() {
    *this = ::std::move(from);
  }

  inline StreamPresenceEvent& operator=(StreamPresenceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StreamPresenceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StreamPresenceEvent* internal_default_instance() {
    return reinterpret_cast<const StreamPresenceEvent*>(
               &_StreamPresenceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  void Swap(StreamPresenceEvent* other);
  friend void swap(StreamPresenceEvent& a, StreamPresenceEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StreamPresenceEvent* New() const final {
    return CreateMaybeMessage<StreamPresenceEvent>(NULL);
  }

  StreamPresenceEvent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StreamPresenceEvent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StreamPresenceEvent& from);
  void MergeFrom(const StreamPresenceEvent& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamPresenceEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nakama.realtime.UserPresence joins = 2;
  int joins_size() const;
  void clear_joins();
  static const int kJoinsFieldNumber = 2;
  ::nakama::realtime::UserPresence* mutable_joins(int index);
  ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >*
      mutable_joins();
  const ::nakama::realtime::UserPresence& joins(int index) const;
  ::nakama::realtime::UserPresence* add_joins();
  const ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >&
      joins() const;

  // repeated .nakama.realtime.UserPresence leaves = 3;
  int leaves_size() const;
  void clear_leaves();
  static const int kLeavesFieldNumber = 3;
  ::nakama::realtime::UserPresence* mutable_leaves(int index);
  ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >*
      mutable_leaves();
  const ::nakama::realtime::UserPresence& leaves(int index) const;
  ::nakama::realtime::UserPresence* add_leaves();
  const ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >&
      leaves() const;

  // .nakama.realtime.Stream stream = 1;
  bool has_stream() const;
  void clear_stream();
  static const int kStreamFieldNumber = 1;
  private:
  const ::nakama::realtime::Stream& _internal_stream() const;
  public:
  const ::nakama::realtime::Stream& stream() const;
  ::nakama::realtime::Stream* release_stream();
  ::nakama::realtime::Stream* mutable_stream();
  void set_allocated_stream(::nakama::realtime::Stream* stream);

  // @@protoc_insertion_point(class_scope:nakama.realtime.StreamPresenceEvent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence > joins_;
  ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence > leaves_;
  ::nakama::realtime::Stream* stream_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2frtapi_2frealtime_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserPresence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nakama.realtime.UserPresence) */ {
 public:
  UserPresence();
  virtual ~UserPresence();

  UserPresence(const UserPresence& from);

  inline UserPresence& operator=(const UserPresence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserPresence(UserPresence&& from) noexcept
    : UserPresence() {
    *this = ::std::move(from);
  }

  inline UserPresence& operator=(UserPresence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserPresence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserPresence* internal_default_instance() {
    return reinterpret_cast<const UserPresence*>(
               &_UserPresence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  void Swap(UserPresence* other);
  friend void swap(UserPresence& a, UserPresence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserPresence* New() const final {
    return CreateMaybeMessage<UserPresence>(NULL);
  }

  UserPresence* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserPresence>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserPresence& from);
  void MergeFrom(const UserPresence& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserPresence* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string user_id = 1;
  void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  const ::std::string& user_id() const;
  void set_user_id(const ::std::string& value);
  #if LANG_CXX11
  void set_user_id(::std::string&& value);
  #endif
  void set_user_id(const char* value);
  void set_user_id(const char* value, size_t size);
  ::std::string* mutable_user_id();
  ::std::string* release_user_id();
  void set_allocated_user_id(::std::string* user_id);

  // string session_id = 2;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  const ::std::string& session_id() const;
  void set_session_id(const ::std::string& value);
  #if LANG_CXX11
  void set_session_id(::std::string&& value);
  #endif
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  ::std::string* mutable_session_id();
  ::std::string* release_session_id();
  void set_allocated_session_id(::std::string* session_id);

  // string username = 3;
  void clear_username();
  static const int kUsernameFieldNumber = 3;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // .google.protobuf.StringValue status = 5;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 5;
  private:
  const ::google::protobuf::StringValue& _internal_status() const;
  public:
  const ::google::protobuf::StringValue& status() const;
  ::google::protobuf::StringValue* release_status();
  ::google::protobuf::StringValue* mutable_status();
  void set_allocated_status(::google::protobuf::StringValue* status);

  // bool persistence = 4;
  void clear_persistence();
  static const int kPersistenceFieldNumber = 4;
  bool persistence() const;
  void set_persistence(bool value);

  // @@protoc_insertion_point(class_scope:nakama.realtime.UserPresence)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr user_id_;
  ::google::protobuf::internal::ArenaStringPtr session_id_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::StringValue* status_;
  bool persistence_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_github_2ecom_2fheroiclabs_2fnakama_2frtapi_2frealtime_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Envelope

// string cid = 1;
inline void Envelope::clear_cid() {
  cid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Envelope::cid() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.cid)
  return cid_.GetNoArena();
}
inline void Envelope::set_cid(const ::std::string& value) {
  
  cid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.realtime.Envelope.cid)
}
#if LANG_CXX11
inline void Envelope::set_cid(::std::string&& value) {
  
  cid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.Envelope.cid)
}
#endif
inline void Envelope::set_cid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.realtime.Envelope.cid)
}
inline void Envelope::set_cid(const char* value, size_t size) {
  
  cid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.Envelope.cid)
}
inline ::std::string* Envelope::mutable_cid() {
  
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.cid)
  return cid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Envelope::release_cid() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.cid)
  
  return cid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Envelope::set_allocated_cid(::std::string* cid) {
  if (cid != NULL) {
    
  } else {
    
  }
  cid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cid);
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.Envelope.cid)
}

// .nakama.realtime.Channel channel = 2;
inline bool Envelope::has_channel() const {
  return message_case() == kChannel;
}
inline void Envelope::set_has_channel() {
  _oneof_case_[0] = kChannel;
}
inline void Envelope::clear_channel() {
  if (has_channel()) {
    delete message_.channel_;
    clear_has_message();
  }
}
inline const ::nakama::realtime::Channel& Envelope::_internal_channel() const {
  return *message_.channel_;
}
inline ::nakama::realtime::Channel* Envelope::release_channel() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.channel)
  if (has_channel()) {
    clear_has_message();
      ::nakama::realtime::Channel* temp = message_.channel_;
    message_.channel_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::nakama::realtime::Channel& Envelope::channel() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.channel)
  return has_channel()
      ? *message_.channel_
      : *reinterpret_cast< ::nakama::realtime::Channel*>(&::nakama::realtime::_Channel_default_instance_);
}
inline ::nakama::realtime::Channel* Envelope::mutable_channel() {
  if (!has_channel()) {
    clear_message();
    set_has_channel();
    message_.channel_ = CreateMaybeMessage< ::nakama::realtime::Channel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.channel)
  return message_.channel_;
}

// .nakama.realtime.ChannelJoin channel_join = 3;
inline bool Envelope::has_channel_join() const {
  return message_case() == kChannelJoin;
}
inline void Envelope::set_has_channel_join() {
  _oneof_case_[0] = kChannelJoin;
}
inline void Envelope::clear_channel_join() {
  if (has_channel_join()) {
    delete message_.channel_join_;
    clear_has_message();
  }
}
inline const ::nakama::realtime::ChannelJoin& Envelope::_internal_channel_join() const {
  return *message_.channel_join_;
}
inline ::nakama::realtime::ChannelJoin* Envelope::release_channel_join() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.channel_join)
  if (has_channel_join()) {
    clear_has_message();
      ::nakama::realtime::ChannelJoin* temp = message_.channel_join_;
    message_.channel_join_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::nakama::realtime::ChannelJoin& Envelope::channel_join() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.channel_join)
  return has_channel_join()
      ? *message_.channel_join_
      : *reinterpret_cast< ::nakama::realtime::ChannelJoin*>(&::nakama::realtime::_ChannelJoin_default_instance_);
}
inline ::nakama::realtime::ChannelJoin* Envelope::mutable_channel_join() {
  if (!has_channel_join()) {
    clear_message();
    set_has_channel_join();
    message_.channel_join_ = CreateMaybeMessage< ::nakama::realtime::ChannelJoin >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.channel_join)
  return message_.channel_join_;
}

// .nakama.realtime.ChannelLeave channel_leave = 4;
inline bool Envelope::has_channel_leave() const {
  return message_case() == kChannelLeave;
}
inline void Envelope::set_has_channel_leave() {
  _oneof_case_[0] = kChannelLeave;
}
inline void Envelope::clear_channel_leave() {
  if (has_channel_leave()) {
    delete message_.channel_leave_;
    clear_has_message();
  }
}
inline const ::nakama::realtime::ChannelLeave& Envelope::_internal_channel_leave() const {
  return *message_.channel_leave_;
}
inline ::nakama::realtime::ChannelLeave* Envelope::release_channel_leave() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.channel_leave)
  if (has_channel_leave()) {
    clear_has_message();
      ::nakama::realtime::ChannelLeave* temp = message_.channel_leave_;
    message_.channel_leave_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::nakama::realtime::ChannelLeave& Envelope::channel_leave() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.channel_leave)
  return has_channel_leave()
      ? *message_.channel_leave_
      : *reinterpret_cast< ::nakama::realtime::ChannelLeave*>(&::nakama::realtime::_ChannelLeave_default_instance_);
}
inline ::nakama::realtime::ChannelLeave* Envelope::mutable_channel_leave() {
  if (!has_channel_leave()) {
    clear_message();
    set_has_channel_leave();
    message_.channel_leave_ = CreateMaybeMessage< ::nakama::realtime::ChannelLeave >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.channel_leave)
  return message_.channel_leave_;
}

// .nakama.api.ChannelMessage channel_message = 5;
inline bool Envelope::has_channel_message() const {
  return message_case() == kChannelMessage;
}
inline void Envelope::set_has_channel_message() {
  _oneof_case_[0] = kChannelMessage;
}
inline const ::nakama::api::ChannelMessage& Envelope::_internal_channel_message() const {
  return *message_.channel_message_;
}
inline ::nakama::api::ChannelMessage* Envelope::release_channel_message() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.channel_message)
  if (has_channel_message()) {
    clear_has_message();
      ::nakama::api::ChannelMessage* temp = message_.channel_message_;
    message_.channel_message_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::nakama::api::ChannelMessage& Envelope::channel_message() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.channel_message)
  return has_channel_message()
      ? *message_.channel_message_
      : *reinterpret_cast< ::nakama::api::ChannelMessage*>(&::nakama::api::_ChannelMessage_default_instance_);
}
inline ::nakama::api::ChannelMessage* Envelope::mutable_channel_message() {
  if (!has_channel_message()) {
    clear_message();
    set_has_channel_message();
    message_.channel_message_ = CreateMaybeMessage< ::nakama::api::ChannelMessage >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.channel_message)
  return message_.channel_message_;
}

// .nakama.realtime.ChannelMessageAck channel_message_ack = 6;
inline bool Envelope::has_channel_message_ack() const {
  return message_case() == kChannelMessageAck;
}
inline void Envelope::set_has_channel_message_ack() {
  _oneof_case_[0] = kChannelMessageAck;
}
inline void Envelope::clear_channel_message_ack() {
  if (has_channel_message_ack()) {
    delete message_.channel_message_ack_;
    clear_has_message();
  }
}
inline const ::nakama::realtime::ChannelMessageAck& Envelope::_internal_channel_message_ack() const {
  return *message_.channel_message_ack_;
}
inline ::nakama::realtime::ChannelMessageAck* Envelope::release_channel_message_ack() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.channel_message_ack)
  if (has_channel_message_ack()) {
    clear_has_message();
      ::nakama::realtime::ChannelMessageAck* temp = message_.channel_message_ack_;
    message_.channel_message_ack_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::nakama::realtime::ChannelMessageAck& Envelope::channel_message_ack() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.channel_message_ack)
  return has_channel_message_ack()
      ? *message_.channel_message_ack_
      : *reinterpret_cast< ::nakama::realtime::ChannelMessageAck*>(&::nakama::realtime::_ChannelMessageAck_default_instance_);
}
inline ::nakama::realtime::ChannelMessageAck* Envelope::mutable_channel_message_ack() {
  if (!has_channel_message_ack()) {
    clear_message();
    set_has_channel_message_ack();
    message_.channel_message_ack_ = CreateMaybeMessage< ::nakama::realtime::ChannelMessageAck >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.channel_message_ack)
  return message_.channel_message_ack_;
}

// .nakama.realtime.ChannelMessageSend channel_message_send = 7;
inline bool Envelope::has_channel_message_send() const {
  return message_case() == kChannelMessageSend;
}
inline void Envelope::set_has_channel_message_send() {
  _oneof_case_[0] = kChannelMessageSend;
}
inline void Envelope::clear_channel_message_send() {
  if (has_channel_message_send()) {
    delete message_.channel_message_send_;
    clear_has_message();
  }
}
inline const ::nakama::realtime::ChannelMessageSend& Envelope::_internal_channel_message_send() const {
  return *message_.channel_message_send_;
}
inline ::nakama::realtime::ChannelMessageSend* Envelope::release_channel_message_send() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.channel_message_send)
  if (has_channel_message_send()) {
    clear_has_message();
      ::nakama::realtime::ChannelMessageSend* temp = message_.channel_message_send_;
    message_.channel_message_send_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::nakama::realtime::ChannelMessageSend& Envelope::channel_message_send() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.channel_message_send)
  return has_channel_message_send()
      ? *message_.channel_message_send_
      : *reinterpret_cast< ::nakama::realtime::ChannelMessageSend*>(&::nakama::realtime::_ChannelMessageSend_default_instance_);
}
inline ::nakama::realtime::ChannelMessageSend* Envelope::mutable_channel_message_send() {
  if (!has_channel_message_send()) {
    clear_message();
    set_has_channel_message_send();
    message_.channel_message_send_ = CreateMaybeMessage< ::nakama::realtime::ChannelMessageSend >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.channel_message_send)
  return message_.channel_message_send_;
}

// .nakama.realtime.ChannelMessageUpdate channel_message_update = 8;
inline bool Envelope::has_channel_message_update() const {
  return message_case() == kChannelMessageUpdate;
}
inline void Envelope::set_has_channel_message_update() {
  _oneof_case_[0] = kChannelMessageUpdate;
}
inline void Envelope::clear_channel_message_update() {
  if (has_channel_message_update()) {
    delete message_.channel_message_update_;
    clear_has_message();
  }
}
inline const ::nakama::realtime::ChannelMessageUpdate& Envelope::_internal_channel_message_update() const {
  return *message_.channel_message_update_;
}
inline ::nakama::realtime::ChannelMessageUpdate* Envelope::release_channel_message_update() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.channel_message_update)
  if (has_channel_message_update()) {
    clear_has_message();
      ::nakama::realtime::ChannelMessageUpdate* temp = message_.channel_message_update_;
    message_.channel_message_update_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::nakama::realtime::ChannelMessageUpdate& Envelope::channel_message_update() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.channel_message_update)
  return has_channel_message_update()
      ? *message_.channel_message_update_
      : *reinterpret_cast< ::nakama::realtime::ChannelMessageUpdate*>(&::nakama::realtime::_ChannelMessageUpdate_default_instance_);
}
inline ::nakama::realtime::ChannelMessageUpdate* Envelope::mutable_channel_message_update() {
  if (!has_channel_message_update()) {
    clear_message();
    set_has_channel_message_update();
    message_.channel_message_update_ = CreateMaybeMessage< ::nakama::realtime::ChannelMessageUpdate >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.channel_message_update)
  return message_.channel_message_update_;
}

// .nakama.realtime.ChannelMessageRemove channel_message_remove = 9;
inline bool Envelope::has_channel_message_remove() const {
  return message_case() == kChannelMessageRemove;
}
inline void Envelope::set_has_channel_message_remove() {
  _oneof_case_[0] = kChannelMessageRemove;
}
inline void Envelope::clear_channel_message_remove() {
  if (has_channel_message_remove()) {
    delete message_.channel_message_remove_;
    clear_has_message();
  }
}
inline const ::nakama::realtime::ChannelMessageRemove& Envelope::_internal_channel_message_remove() const {
  return *message_.channel_message_remove_;
}
inline ::nakama::realtime::ChannelMessageRemove* Envelope::release_channel_message_remove() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.channel_message_remove)
  if (has_channel_message_remove()) {
    clear_has_message();
      ::nakama::realtime::ChannelMessageRemove* temp = message_.channel_message_remove_;
    message_.channel_message_remove_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::nakama::realtime::ChannelMessageRemove& Envelope::channel_message_remove() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.channel_message_remove)
  return has_channel_message_remove()
      ? *message_.channel_message_remove_
      : *reinterpret_cast< ::nakama::realtime::ChannelMessageRemove*>(&::nakama::realtime::_ChannelMessageRemove_default_instance_);
}
inline ::nakama::realtime::ChannelMessageRemove* Envelope::mutable_channel_message_remove() {
  if (!has_channel_message_remove()) {
    clear_message();
    set_has_channel_message_remove();
    message_.channel_message_remove_ = CreateMaybeMessage< ::nakama::realtime::ChannelMessageRemove >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.channel_message_remove)
  return message_.channel_message_remove_;
}

// .nakama.realtime.ChannelPresenceEvent channel_presence_event = 10;
inline bool Envelope::has_channel_presence_event() const {
  return message_case() == kChannelPresenceEvent;
}
inline void Envelope::set_has_channel_presence_event() {
  _oneof_case_[0] = kChannelPresenceEvent;
}
inline void Envelope::clear_channel_presence_event() {
  if (has_channel_presence_event()) {
    delete message_.channel_presence_event_;
    clear_has_message();
  }
}
inline const ::nakama::realtime::ChannelPresenceEvent& Envelope::_internal_channel_presence_event() const {
  return *message_.channel_presence_event_;
}
inline ::nakama::realtime::ChannelPresenceEvent* Envelope::release_channel_presence_event() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.channel_presence_event)
  if (has_channel_presence_event()) {
    clear_has_message();
      ::nakama::realtime::ChannelPresenceEvent* temp = message_.channel_presence_event_;
    message_.channel_presence_event_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::nakama::realtime::ChannelPresenceEvent& Envelope::channel_presence_event() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.channel_presence_event)
  return has_channel_presence_event()
      ? *message_.channel_presence_event_
      : *reinterpret_cast< ::nakama::realtime::ChannelPresenceEvent*>(&::nakama::realtime::_ChannelPresenceEvent_default_instance_);
}
inline ::nakama::realtime::ChannelPresenceEvent* Envelope::mutable_channel_presence_event() {
  if (!has_channel_presence_event()) {
    clear_message();
    set_has_channel_presence_event();
    message_.channel_presence_event_ = CreateMaybeMessage< ::nakama::realtime::ChannelPresenceEvent >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.channel_presence_event)
  return message_.channel_presence_event_;
}

// .nakama.realtime.Error error = 11;
inline bool Envelope::has_error() const {
  return message_case() == kError;
}
inline void Envelope::set_has_error() {
  _oneof_case_[0] = kError;
}
inline void Envelope::clear_error() {
  if (has_error()) {
    delete message_.error_;
    clear_has_message();
  }
}
inline const ::nakama::realtime::Error& Envelope::_internal_error() const {
  return *message_.error_;
}
inline ::nakama::realtime::Error* Envelope::release_error() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.error)
  if (has_error()) {
    clear_has_message();
      ::nakama::realtime::Error* temp = message_.error_;
    message_.error_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::nakama::realtime::Error& Envelope::error() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.error)
  return has_error()
      ? *message_.error_
      : *reinterpret_cast< ::nakama::realtime::Error*>(&::nakama::realtime::_Error_default_instance_);
}
inline ::nakama::realtime::Error* Envelope::mutable_error() {
  if (!has_error()) {
    clear_message();
    set_has_error();
    message_.error_ = CreateMaybeMessage< ::nakama::realtime::Error >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.error)
  return message_.error_;
}

// .nakama.realtime.Match match = 12;
inline bool Envelope::has_match() const {
  return message_case() == kMatch;
}
inline void Envelope::set_has_match() {
  _oneof_case_[0] = kMatch;
}
inline void Envelope::clear_match() {
  if (has_match()) {
    delete message_.match_;
    clear_has_message();
  }
}
inline const ::nakama::realtime::Match& Envelope::_internal_match() const {
  return *message_.match_;
}
inline ::nakama::realtime::Match* Envelope::release_match() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.match)
  if (has_match()) {
    clear_has_message();
      ::nakama::realtime::Match* temp = message_.match_;
    message_.match_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::nakama::realtime::Match& Envelope::match() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.match)
  return has_match()
      ? *message_.match_
      : *reinterpret_cast< ::nakama::realtime::Match*>(&::nakama::realtime::_Match_default_instance_);
}
inline ::nakama::realtime::Match* Envelope::mutable_match() {
  if (!has_match()) {
    clear_message();
    set_has_match();
    message_.match_ = CreateMaybeMessage< ::nakama::realtime::Match >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.match)
  return message_.match_;
}

// .nakama.realtime.MatchCreate match_create = 13;
inline bool Envelope::has_match_create() const {
  return message_case() == kMatchCreate;
}
inline void Envelope::set_has_match_create() {
  _oneof_case_[0] = kMatchCreate;
}
inline void Envelope::clear_match_create() {
  if (has_match_create()) {
    delete message_.match_create_;
    clear_has_message();
  }
}
inline const ::nakama::realtime::MatchCreate& Envelope::_internal_match_create() const {
  return *message_.match_create_;
}
inline ::nakama::realtime::MatchCreate* Envelope::release_match_create() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.match_create)
  if (has_match_create()) {
    clear_has_message();
      ::nakama::realtime::MatchCreate* temp = message_.match_create_;
    message_.match_create_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::nakama::realtime::MatchCreate& Envelope::match_create() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.match_create)
  return has_match_create()
      ? *message_.match_create_
      : *reinterpret_cast< ::nakama::realtime::MatchCreate*>(&::nakama::realtime::_MatchCreate_default_instance_);
}
inline ::nakama::realtime::MatchCreate* Envelope::mutable_match_create() {
  if (!has_match_create()) {
    clear_message();
    set_has_match_create();
    message_.match_create_ = CreateMaybeMessage< ::nakama::realtime::MatchCreate >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.match_create)
  return message_.match_create_;
}

// .nakama.realtime.MatchData match_data = 14;
inline bool Envelope::has_match_data() const {
  return message_case() == kMatchData;
}
inline void Envelope::set_has_match_data() {
  _oneof_case_[0] = kMatchData;
}
inline void Envelope::clear_match_data() {
  if (has_match_data()) {
    delete message_.match_data_;
    clear_has_message();
  }
}
inline const ::nakama::realtime::MatchData& Envelope::_internal_match_data() const {
  return *message_.match_data_;
}
inline ::nakama::realtime::MatchData* Envelope::release_match_data() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.match_data)
  if (has_match_data()) {
    clear_has_message();
      ::nakama::realtime::MatchData* temp = message_.match_data_;
    message_.match_data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::nakama::realtime::MatchData& Envelope::match_data() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.match_data)
  return has_match_data()
      ? *message_.match_data_
      : *reinterpret_cast< ::nakama::realtime::MatchData*>(&::nakama::realtime::_MatchData_default_instance_);
}
inline ::nakama::realtime::MatchData* Envelope::mutable_match_data() {
  if (!has_match_data()) {
    clear_message();
    set_has_match_data();
    message_.match_data_ = CreateMaybeMessage< ::nakama::realtime::MatchData >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.match_data)
  return message_.match_data_;
}

// .nakama.realtime.MatchDataSend match_data_send = 15;
inline bool Envelope::has_match_data_send() const {
  return message_case() == kMatchDataSend;
}
inline void Envelope::set_has_match_data_send() {
  _oneof_case_[0] = kMatchDataSend;
}
inline void Envelope::clear_match_data_send() {
  if (has_match_data_send()) {
    delete message_.match_data_send_;
    clear_has_message();
  }
}
inline const ::nakama::realtime::MatchDataSend& Envelope::_internal_match_data_send() const {
  return *message_.match_data_send_;
}
inline ::nakama::realtime::MatchDataSend* Envelope::release_match_data_send() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.match_data_send)
  if (has_match_data_send()) {
    clear_has_message();
      ::nakama::realtime::MatchDataSend* temp = message_.match_data_send_;
    message_.match_data_send_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::nakama::realtime::MatchDataSend& Envelope::match_data_send() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.match_data_send)
  return has_match_data_send()
      ? *message_.match_data_send_
      : *reinterpret_cast< ::nakama::realtime::MatchDataSend*>(&::nakama::realtime::_MatchDataSend_default_instance_);
}
inline ::nakama::realtime::MatchDataSend* Envelope::mutable_match_data_send() {
  if (!has_match_data_send()) {
    clear_message();
    set_has_match_data_send();
    message_.match_data_send_ = CreateMaybeMessage< ::nakama::realtime::MatchDataSend >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.match_data_send)
  return message_.match_data_send_;
}

// .nakama.realtime.MatchJoin match_join = 16;
inline bool Envelope::has_match_join() const {
  return message_case() == kMatchJoin;
}
inline void Envelope::set_has_match_join() {
  _oneof_case_[0] = kMatchJoin;
}
inline void Envelope::clear_match_join() {
  if (has_match_join()) {
    delete message_.match_join_;
    clear_has_message();
  }
}
inline const ::nakama::realtime::MatchJoin& Envelope::_internal_match_join() const {
  return *message_.match_join_;
}
inline ::nakama::realtime::MatchJoin* Envelope::release_match_join() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.match_join)
  if (has_match_join()) {
    clear_has_message();
      ::nakama::realtime::MatchJoin* temp = message_.match_join_;
    message_.match_join_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::nakama::realtime::MatchJoin& Envelope::match_join() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.match_join)
  return has_match_join()
      ? *message_.match_join_
      : *reinterpret_cast< ::nakama::realtime::MatchJoin*>(&::nakama::realtime::_MatchJoin_default_instance_);
}
inline ::nakama::realtime::MatchJoin* Envelope::mutable_match_join() {
  if (!has_match_join()) {
    clear_message();
    set_has_match_join();
    message_.match_join_ = CreateMaybeMessage< ::nakama::realtime::MatchJoin >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.match_join)
  return message_.match_join_;
}

// .nakama.realtime.MatchLeave match_leave = 17;
inline bool Envelope::has_match_leave() const {
  return message_case() == kMatchLeave;
}
inline void Envelope::set_has_match_leave() {
  _oneof_case_[0] = kMatchLeave;
}
inline void Envelope::clear_match_leave() {
  if (has_match_leave()) {
    delete message_.match_leave_;
    clear_has_message();
  }
}
inline const ::nakama::realtime::MatchLeave& Envelope::_internal_match_leave() const {
  return *message_.match_leave_;
}
inline ::nakama::realtime::MatchLeave* Envelope::release_match_leave() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.match_leave)
  if (has_match_leave()) {
    clear_has_message();
      ::nakama::realtime::MatchLeave* temp = message_.match_leave_;
    message_.match_leave_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::nakama::realtime::MatchLeave& Envelope::match_leave() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.match_leave)
  return has_match_leave()
      ? *message_.match_leave_
      : *reinterpret_cast< ::nakama::realtime::MatchLeave*>(&::nakama::realtime::_MatchLeave_default_instance_);
}
inline ::nakama::realtime::MatchLeave* Envelope::mutable_match_leave() {
  if (!has_match_leave()) {
    clear_message();
    set_has_match_leave();
    message_.match_leave_ = CreateMaybeMessage< ::nakama::realtime::MatchLeave >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.match_leave)
  return message_.match_leave_;
}

// .nakama.realtime.MatchPresenceEvent match_presence_event = 18;
inline bool Envelope::has_match_presence_event() const {
  return message_case() == kMatchPresenceEvent;
}
inline void Envelope::set_has_match_presence_event() {
  _oneof_case_[0] = kMatchPresenceEvent;
}
inline void Envelope::clear_match_presence_event() {
  if (has_match_presence_event()) {
    delete message_.match_presence_event_;
    clear_has_message();
  }
}
inline const ::nakama::realtime::MatchPresenceEvent& Envelope::_internal_match_presence_event() const {
  return *message_.match_presence_event_;
}
inline ::nakama::realtime::MatchPresenceEvent* Envelope::release_match_presence_event() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.match_presence_event)
  if (has_match_presence_event()) {
    clear_has_message();
      ::nakama::realtime::MatchPresenceEvent* temp = message_.match_presence_event_;
    message_.match_presence_event_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::nakama::realtime::MatchPresenceEvent& Envelope::match_presence_event() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.match_presence_event)
  return has_match_presence_event()
      ? *message_.match_presence_event_
      : *reinterpret_cast< ::nakama::realtime::MatchPresenceEvent*>(&::nakama::realtime::_MatchPresenceEvent_default_instance_);
}
inline ::nakama::realtime::MatchPresenceEvent* Envelope::mutable_match_presence_event() {
  if (!has_match_presence_event()) {
    clear_message();
    set_has_match_presence_event();
    message_.match_presence_event_ = CreateMaybeMessage< ::nakama::realtime::MatchPresenceEvent >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.match_presence_event)
  return message_.match_presence_event_;
}

// .nakama.realtime.MatchmakerAdd matchmaker_add = 19;
inline bool Envelope::has_matchmaker_add() const {
  return message_case() == kMatchmakerAdd;
}
inline void Envelope::set_has_matchmaker_add() {
  _oneof_case_[0] = kMatchmakerAdd;
}
inline void Envelope::clear_matchmaker_add() {
  if (has_matchmaker_add()) {
    delete message_.matchmaker_add_;
    clear_has_message();
  }
}
inline const ::nakama::realtime::MatchmakerAdd& Envelope::_internal_matchmaker_add() const {
  return *message_.matchmaker_add_;
}
inline ::nakama::realtime::MatchmakerAdd* Envelope::release_matchmaker_add() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.matchmaker_add)
  if (has_matchmaker_add()) {
    clear_has_message();
      ::nakama::realtime::MatchmakerAdd* temp = message_.matchmaker_add_;
    message_.matchmaker_add_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::nakama::realtime::MatchmakerAdd& Envelope::matchmaker_add() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.matchmaker_add)
  return has_matchmaker_add()
      ? *message_.matchmaker_add_
      : *reinterpret_cast< ::nakama::realtime::MatchmakerAdd*>(&::nakama::realtime::_MatchmakerAdd_default_instance_);
}
inline ::nakama::realtime::MatchmakerAdd* Envelope::mutable_matchmaker_add() {
  if (!has_matchmaker_add()) {
    clear_message();
    set_has_matchmaker_add();
    message_.matchmaker_add_ = CreateMaybeMessage< ::nakama::realtime::MatchmakerAdd >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.matchmaker_add)
  return message_.matchmaker_add_;
}

// .nakama.realtime.MatchmakerMatched matchmaker_matched = 20;
inline bool Envelope::has_matchmaker_matched() const {
  return message_case() == kMatchmakerMatched;
}
inline void Envelope::set_has_matchmaker_matched() {
  _oneof_case_[0] = kMatchmakerMatched;
}
inline void Envelope::clear_matchmaker_matched() {
  if (has_matchmaker_matched()) {
    delete message_.matchmaker_matched_;
    clear_has_message();
  }
}
inline const ::nakama::realtime::MatchmakerMatched& Envelope::_internal_matchmaker_matched() const {
  return *message_.matchmaker_matched_;
}
inline ::nakama::realtime::MatchmakerMatched* Envelope::release_matchmaker_matched() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.matchmaker_matched)
  if (has_matchmaker_matched()) {
    clear_has_message();
      ::nakama::realtime::MatchmakerMatched* temp = message_.matchmaker_matched_;
    message_.matchmaker_matched_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::nakama::realtime::MatchmakerMatched& Envelope::matchmaker_matched() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.matchmaker_matched)
  return has_matchmaker_matched()
      ? *message_.matchmaker_matched_
      : *reinterpret_cast< ::nakama::realtime::MatchmakerMatched*>(&::nakama::realtime::_MatchmakerMatched_default_instance_);
}
inline ::nakama::realtime::MatchmakerMatched* Envelope::mutable_matchmaker_matched() {
  if (!has_matchmaker_matched()) {
    clear_message();
    set_has_matchmaker_matched();
    message_.matchmaker_matched_ = CreateMaybeMessage< ::nakama::realtime::MatchmakerMatched >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.matchmaker_matched)
  return message_.matchmaker_matched_;
}

// .nakama.realtime.MatchmakerRemove matchmaker_remove = 21;
inline bool Envelope::has_matchmaker_remove() const {
  return message_case() == kMatchmakerRemove;
}
inline void Envelope::set_has_matchmaker_remove() {
  _oneof_case_[0] = kMatchmakerRemove;
}
inline void Envelope::clear_matchmaker_remove() {
  if (has_matchmaker_remove()) {
    delete message_.matchmaker_remove_;
    clear_has_message();
  }
}
inline const ::nakama::realtime::MatchmakerRemove& Envelope::_internal_matchmaker_remove() const {
  return *message_.matchmaker_remove_;
}
inline ::nakama::realtime::MatchmakerRemove* Envelope::release_matchmaker_remove() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.matchmaker_remove)
  if (has_matchmaker_remove()) {
    clear_has_message();
      ::nakama::realtime::MatchmakerRemove* temp = message_.matchmaker_remove_;
    message_.matchmaker_remove_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::nakama::realtime::MatchmakerRemove& Envelope::matchmaker_remove() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.matchmaker_remove)
  return has_matchmaker_remove()
      ? *message_.matchmaker_remove_
      : *reinterpret_cast< ::nakama::realtime::MatchmakerRemove*>(&::nakama::realtime::_MatchmakerRemove_default_instance_);
}
inline ::nakama::realtime::MatchmakerRemove* Envelope::mutable_matchmaker_remove() {
  if (!has_matchmaker_remove()) {
    clear_message();
    set_has_matchmaker_remove();
    message_.matchmaker_remove_ = CreateMaybeMessage< ::nakama::realtime::MatchmakerRemove >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.matchmaker_remove)
  return message_.matchmaker_remove_;
}

// .nakama.realtime.MatchmakerTicket matchmaker_ticket = 22;
inline bool Envelope::has_matchmaker_ticket() const {
  return message_case() == kMatchmakerTicket;
}
inline void Envelope::set_has_matchmaker_ticket() {
  _oneof_case_[0] = kMatchmakerTicket;
}
inline void Envelope::clear_matchmaker_ticket() {
  if (has_matchmaker_ticket()) {
    delete message_.matchmaker_ticket_;
    clear_has_message();
  }
}
inline const ::nakama::realtime::MatchmakerTicket& Envelope::_internal_matchmaker_ticket() const {
  return *message_.matchmaker_ticket_;
}
inline ::nakama::realtime::MatchmakerTicket* Envelope::release_matchmaker_ticket() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.matchmaker_ticket)
  if (has_matchmaker_ticket()) {
    clear_has_message();
      ::nakama::realtime::MatchmakerTicket* temp = message_.matchmaker_ticket_;
    message_.matchmaker_ticket_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::nakama::realtime::MatchmakerTicket& Envelope::matchmaker_ticket() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.matchmaker_ticket)
  return has_matchmaker_ticket()
      ? *message_.matchmaker_ticket_
      : *reinterpret_cast< ::nakama::realtime::MatchmakerTicket*>(&::nakama::realtime::_MatchmakerTicket_default_instance_);
}
inline ::nakama::realtime::MatchmakerTicket* Envelope::mutable_matchmaker_ticket() {
  if (!has_matchmaker_ticket()) {
    clear_message();
    set_has_matchmaker_ticket();
    message_.matchmaker_ticket_ = CreateMaybeMessage< ::nakama::realtime::MatchmakerTicket >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.matchmaker_ticket)
  return message_.matchmaker_ticket_;
}

// .nakama.realtime.Notifications notifications = 23;
inline bool Envelope::has_notifications() const {
  return message_case() == kNotifications;
}
inline void Envelope::set_has_notifications() {
  _oneof_case_[0] = kNotifications;
}
inline void Envelope::clear_notifications() {
  if (has_notifications()) {
    delete message_.notifications_;
    clear_has_message();
  }
}
inline const ::nakama::realtime::Notifications& Envelope::_internal_notifications() const {
  return *message_.notifications_;
}
inline ::nakama::realtime::Notifications* Envelope::release_notifications() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.notifications)
  if (has_notifications()) {
    clear_has_message();
      ::nakama::realtime::Notifications* temp = message_.notifications_;
    message_.notifications_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::nakama::realtime::Notifications& Envelope::notifications() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.notifications)
  return has_notifications()
      ? *message_.notifications_
      : *reinterpret_cast< ::nakama::realtime::Notifications*>(&::nakama::realtime::_Notifications_default_instance_);
}
inline ::nakama::realtime::Notifications* Envelope::mutable_notifications() {
  if (!has_notifications()) {
    clear_message();
    set_has_notifications();
    message_.notifications_ = CreateMaybeMessage< ::nakama::realtime::Notifications >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.notifications)
  return message_.notifications_;
}

// .nakama.api.Rpc rpc = 24;
inline bool Envelope::has_rpc() const {
  return message_case() == kRpc;
}
inline void Envelope::set_has_rpc() {
  _oneof_case_[0] = kRpc;
}
inline const ::nakama::api::Rpc& Envelope::_internal_rpc() const {
  return *message_.rpc_;
}
inline ::nakama::api::Rpc* Envelope::release_rpc() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.rpc)
  if (has_rpc()) {
    clear_has_message();
      ::nakama::api::Rpc* temp = message_.rpc_;
    message_.rpc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::nakama::api::Rpc& Envelope::rpc() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.rpc)
  return has_rpc()
      ? *message_.rpc_
      : *reinterpret_cast< ::nakama::api::Rpc*>(&::nakama::api::_Rpc_default_instance_);
}
inline ::nakama::api::Rpc* Envelope::mutable_rpc() {
  if (!has_rpc()) {
    clear_message();
    set_has_rpc();
    message_.rpc_ = CreateMaybeMessage< ::nakama::api::Rpc >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.rpc)
  return message_.rpc_;
}

// .nakama.realtime.Status status = 25;
inline bool Envelope::has_status() const {
  return message_case() == kStatus;
}
inline void Envelope::set_has_status() {
  _oneof_case_[0] = kStatus;
}
inline void Envelope::clear_status() {
  if (has_status()) {
    delete message_.status_;
    clear_has_message();
  }
}
inline const ::nakama::realtime::Status& Envelope::_internal_status() const {
  return *message_.status_;
}
inline ::nakama::realtime::Status* Envelope::release_status() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.status)
  if (has_status()) {
    clear_has_message();
      ::nakama::realtime::Status* temp = message_.status_;
    message_.status_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::nakama::realtime::Status& Envelope::status() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.status)
  return has_status()
      ? *message_.status_
      : *reinterpret_cast< ::nakama::realtime::Status*>(&::nakama::realtime::_Status_default_instance_);
}
inline ::nakama::realtime::Status* Envelope::mutable_status() {
  if (!has_status()) {
    clear_message();
    set_has_status();
    message_.status_ = CreateMaybeMessage< ::nakama::realtime::Status >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.status)
  return message_.status_;
}

// .nakama.realtime.StatusFollow status_follow = 26;
inline bool Envelope::has_status_follow() const {
  return message_case() == kStatusFollow;
}
inline void Envelope::set_has_status_follow() {
  _oneof_case_[0] = kStatusFollow;
}
inline void Envelope::clear_status_follow() {
  if (has_status_follow()) {
    delete message_.status_follow_;
    clear_has_message();
  }
}
inline const ::nakama::realtime::StatusFollow& Envelope::_internal_status_follow() const {
  return *message_.status_follow_;
}
inline ::nakama::realtime::StatusFollow* Envelope::release_status_follow() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.status_follow)
  if (has_status_follow()) {
    clear_has_message();
      ::nakama::realtime::StatusFollow* temp = message_.status_follow_;
    message_.status_follow_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::nakama::realtime::StatusFollow& Envelope::status_follow() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.status_follow)
  return has_status_follow()
      ? *message_.status_follow_
      : *reinterpret_cast< ::nakama::realtime::StatusFollow*>(&::nakama::realtime::_StatusFollow_default_instance_);
}
inline ::nakama::realtime::StatusFollow* Envelope::mutable_status_follow() {
  if (!has_status_follow()) {
    clear_message();
    set_has_status_follow();
    message_.status_follow_ = CreateMaybeMessage< ::nakama::realtime::StatusFollow >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.status_follow)
  return message_.status_follow_;
}

// .nakama.realtime.StatusPresenceEvent status_presence_event = 27;
inline bool Envelope::has_status_presence_event() const {
  return message_case() == kStatusPresenceEvent;
}
inline void Envelope::set_has_status_presence_event() {
  _oneof_case_[0] = kStatusPresenceEvent;
}
inline void Envelope::clear_status_presence_event() {
  if (has_status_presence_event()) {
    delete message_.status_presence_event_;
    clear_has_message();
  }
}
inline const ::nakama::realtime::StatusPresenceEvent& Envelope::_internal_status_presence_event() const {
  return *message_.status_presence_event_;
}
inline ::nakama::realtime::StatusPresenceEvent* Envelope::release_status_presence_event() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.status_presence_event)
  if (has_status_presence_event()) {
    clear_has_message();
      ::nakama::realtime::StatusPresenceEvent* temp = message_.status_presence_event_;
    message_.status_presence_event_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::nakama::realtime::StatusPresenceEvent& Envelope::status_presence_event() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.status_presence_event)
  return has_status_presence_event()
      ? *message_.status_presence_event_
      : *reinterpret_cast< ::nakama::realtime::StatusPresenceEvent*>(&::nakama::realtime::_StatusPresenceEvent_default_instance_);
}
inline ::nakama::realtime::StatusPresenceEvent* Envelope::mutable_status_presence_event() {
  if (!has_status_presence_event()) {
    clear_message();
    set_has_status_presence_event();
    message_.status_presence_event_ = CreateMaybeMessage< ::nakama::realtime::StatusPresenceEvent >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.status_presence_event)
  return message_.status_presence_event_;
}

// .nakama.realtime.StatusUnfollow status_unfollow = 28;
inline bool Envelope::has_status_unfollow() const {
  return message_case() == kStatusUnfollow;
}
inline void Envelope::set_has_status_unfollow() {
  _oneof_case_[0] = kStatusUnfollow;
}
inline void Envelope::clear_status_unfollow() {
  if (has_status_unfollow()) {
    delete message_.status_unfollow_;
    clear_has_message();
  }
}
inline const ::nakama::realtime::StatusUnfollow& Envelope::_internal_status_unfollow() const {
  return *message_.status_unfollow_;
}
inline ::nakama::realtime::StatusUnfollow* Envelope::release_status_unfollow() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.status_unfollow)
  if (has_status_unfollow()) {
    clear_has_message();
      ::nakama::realtime::StatusUnfollow* temp = message_.status_unfollow_;
    message_.status_unfollow_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::nakama::realtime::StatusUnfollow& Envelope::status_unfollow() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.status_unfollow)
  return has_status_unfollow()
      ? *message_.status_unfollow_
      : *reinterpret_cast< ::nakama::realtime::StatusUnfollow*>(&::nakama::realtime::_StatusUnfollow_default_instance_);
}
inline ::nakama::realtime::StatusUnfollow* Envelope::mutable_status_unfollow() {
  if (!has_status_unfollow()) {
    clear_message();
    set_has_status_unfollow();
    message_.status_unfollow_ = CreateMaybeMessage< ::nakama::realtime::StatusUnfollow >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.status_unfollow)
  return message_.status_unfollow_;
}

// .nakama.realtime.StatusUpdate status_update = 29;
inline bool Envelope::has_status_update() const {
  return message_case() == kStatusUpdate;
}
inline void Envelope::set_has_status_update() {
  _oneof_case_[0] = kStatusUpdate;
}
inline void Envelope::clear_status_update() {
  if (has_status_update()) {
    delete message_.status_update_;
    clear_has_message();
  }
}
inline const ::nakama::realtime::StatusUpdate& Envelope::_internal_status_update() const {
  return *message_.status_update_;
}
inline ::nakama::realtime::StatusUpdate* Envelope::release_status_update() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.status_update)
  if (has_status_update()) {
    clear_has_message();
      ::nakama::realtime::StatusUpdate* temp = message_.status_update_;
    message_.status_update_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::nakama::realtime::StatusUpdate& Envelope::status_update() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.status_update)
  return has_status_update()
      ? *message_.status_update_
      : *reinterpret_cast< ::nakama::realtime::StatusUpdate*>(&::nakama::realtime::_StatusUpdate_default_instance_);
}
inline ::nakama::realtime::StatusUpdate* Envelope::mutable_status_update() {
  if (!has_status_update()) {
    clear_message();
    set_has_status_update();
    message_.status_update_ = CreateMaybeMessage< ::nakama::realtime::StatusUpdate >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.status_update)
  return message_.status_update_;
}

// .nakama.realtime.StreamData stream_data = 30;
inline bool Envelope::has_stream_data() const {
  return message_case() == kStreamData;
}
inline void Envelope::set_has_stream_data() {
  _oneof_case_[0] = kStreamData;
}
inline void Envelope::clear_stream_data() {
  if (has_stream_data()) {
    delete message_.stream_data_;
    clear_has_message();
  }
}
inline const ::nakama::realtime::StreamData& Envelope::_internal_stream_data() const {
  return *message_.stream_data_;
}
inline ::nakama::realtime::StreamData* Envelope::release_stream_data() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.stream_data)
  if (has_stream_data()) {
    clear_has_message();
      ::nakama::realtime::StreamData* temp = message_.stream_data_;
    message_.stream_data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::nakama::realtime::StreamData& Envelope::stream_data() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.stream_data)
  return has_stream_data()
      ? *message_.stream_data_
      : *reinterpret_cast< ::nakama::realtime::StreamData*>(&::nakama::realtime::_StreamData_default_instance_);
}
inline ::nakama::realtime::StreamData* Envelope::mutable_stream_data() {
  if (!has_stream_data()) {
    clear_message();
    set_has_stream_data();
    message_.stream_data_ = CreateMaybeMessage< ::nakama::realtime::StreamData >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.stream_data)
  return message_.stream_data_;
}

// .nakama.realtime.StreamPresenceEvent stream_presence_event = 31;
inline bool Envelope::has_stream_presence_event() const {
  return message_case() == kStreamPresenceEvent;
}
inline void Envelope::set_has_stream_presence_event() {
  _oneof_case_[0] = kStreamPresenceEvent;
}
inline void Envelope::clear_stream_presence_event() {
  if (has_stream_presence_event()) {
    delete message_.stream_presence_event_;
    clear_has_message();
  }
}
inline const ::nakama::realtime::StreamPresenceEvent& Envelope::_internal_stream_presence_event() const {
  return *message_.stream_presence_event_;
}
inline ::nakama::realtime::StreamPresenceEvent* Envelope::release_stream_presence_event() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Envelope.stream_presence_event)
  if (has_stream_presence_event()) {
    clear_has_message();
      ::nakama::realtime::StreamPresenceEvent* temp = message_.stream_presence_event_;
    message_.stream_presence_event_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::nakama::realtime::StreamPresenceEvent& Envelope::stream_presence_event() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Envelope.stream_presence_event)
  return has_stream_presence_event()
      ? *message_.stream_presence_event_
      : *reinterpret_cast< ::nakama::realtime::StreamPresenceEvent*>(&::nakama::realtime::_StreamPresenceEvent_default_instance_);
}
inline ::nakama::realtime::StreamPresenceEvent* Envelope::mutable_stream_presence_event() {
  if (!has_stream_presence_event()) {
    clear_message();
    set_has_stream_presence_event();
    message_.stream_presence_event_ = CreateMaybeMessage< ::nakama::realtime::StreamPresenceEvent >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Envelope.stream_presence_event)
  return message_.stream_presence_event_;
}

inline bool Envelope::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void Envelope::clear_has_message() {
  _oneof_case_[0] = MESSAGE_NOT_SET;
}
inline Envelope::MessageCase Envelope::message_case() const {
  return Envelope::MessageCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Channel

// string id = 1;
inline void Channel::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Channel::id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Channel.id)
  return id_.GetNoArena();
}
inline void Channel::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.realtime.Channel.id)
}
#if LANG_CXX11
inline void Channel::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.Channel.id)
}
#endif
inline void Channel::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.realtime.Channel.id)
}
inline void Channel::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.Channel.id)
}
inline ::std::string* Channel::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Channel.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Channel::release_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Channel.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Channel::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.Channel.id)
}

// repeated .nakama.realtime.UserPresence presences = 2;
inline int Channel::presences_size() const {
  return presences_.size();
}
inline void Channel::clear_presences() {
  presences_.Clear();
}
inline ::nakama::realtime::UserPresence* Channel::mutable_presences(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Channel.presences)
  return presences_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >*
Channel::mutable_presences() {
  // @@protoc_insertion_point(field_mutable_list:nakama.realtime.Channel.presences)
  return &presences_;
}
inline const ::nakama::realtime::UserPresence& Channel::presences(int index) const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Channel.presences)
  return presences_.Get(index);
}
inline ::nakama::realtime::UserPresence* Channel::add_presences() {
  // @@protoc_insertion_point(field_add:nakama.realtime.Channel.presences)
  return presences_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >&
Channel::presences() const {
  // @@protoc_insertion_point(field_list:nakama.realtime.Channel.presences)
  return presences_;
}

// .nakama.realtime.UserPresence self = 3;
inline bool Channel::has_self() const {
  return this != internal_default_instance() && self_ != NULL;
}
inline void Channel::clear_self() {
  if (GetArenaNoVirtual() == NULL && self_ != NULL) {
    delete self_;
  }
  self_ = NULL;
}
inline const ::nakama::realtime::UserPresence& Channel::_internal_self() const {
  return *self_;
}
inline const ::nakama::realtime::UserPresence& Channel::self() const {
  const ::nakama::realtime::UserPresence* p = self_;
  // @@protoc_insertion_point(field_get:nakama.realtime.Channel.self)
  return p != NULL ? *p : *reinterpret_cast<const ::nakama::realtime::UserPresence*>(
      &::nakama::realtime::_UserPresence_default_instance_);
}
inline ::nakama::realtime::UserPresence* Channel::release_self() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Channel.self)
  
  ::nakama::realtime::UserPresence* temp = self_;
  self_ = NULL;
  return temp;
}
inline ::nakama::realtime::UserPresence* Channel::mutable_self() {
  
  if (self_ == NULL) {
    auto* p = CreateMaybeMessage<::nakama::realtime::UserPresence>(GetArenaNoVirtual());
    self_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Channel.self)
  return self_;
}
inline void Channel::set_allocated_self(::nakama::realtime::UserPresence* self) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete self_;
  }
  if (self) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      self = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, self, submessage_arena);
    }
    
  } else {
    
  }
  self_ = self;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.Channel.self)
}

// -------------------------------------------------------------------

// ChannelJoin

// string target = 1;
inline void ChannelJoin::clear_target() {
  target_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChannelJoin::target() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelJoin.target)
  return target_.GetNoArena();
}
inline void ChannelJoin::set_target(const ::std::string& value) {
  
  target_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.realtime.ChannelJoin.target)
}
#if LANG_CXX11
inline void ChannelJoin::set_target(::std::string&& value) {
  
  target_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.ChannelJoin.target)
}
#endif
inline void ChannelJoin::set_target(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  target_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.realtime.ChannelJoin.target)
}
inline void ChannelJoin::set_target(const char* value, size_t size) {
  
  target_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.ChannelJoin.target)
}
inline ::std::string* ChannelJoin::mutable_target() {
  
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelJoin.target)
  return target_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChannelJoin::release_target() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelJoin.target)
  
  return target_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChannelJoin::set_allocated_target(::std::string* target) {
  if (target != NULL) {
    
  } else {
    
  }
  target_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target);
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelJoin.target)
}

// int32 type = 2;
inline void ChannelJoin::clear_type() {
  type_ = 0;
}
inline ::google::protobuf::int32 ChannelJoin::type() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelJoin.type)
  return type_;
}
inline void ChannelJoin::set_type(::google::protobuf::int32 value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:nakama.realtime.ChannelJoin.type)
}

// .google.protobuf.BoolValue persistence = 3;
inline bool ChannelJoin::has_persistence() const {
  return this != internal_default_instance() && persistence_ != NULL;
}
inline const ::google::protobuf::BoolValue& ChannelJoin::_internal_persistence() const {
  return *persistence_;
}
inline const ::google::protobuf::BoolValue& ChannelJoin::persistence() const {
  const ::google::protobuf::BoolValue* p = persistence_;
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelJoin.persistence)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::BoolValue*>(
      &::google::protobuf::_BoolValue_default_instance_);
}
inline ::google::protobuf::BoolValue* ChannelJoin::release_persistence() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelJoin.persistence)
  
  ::google::protobuf::BoolValue* temp = persistence_;
  persistence_ = NULL;
  return temp;
}
inline ::google::protobuf::BoolValue* ChannelJoin::mutable_persistence() {
  
  if (persistence_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::BoolValue>(GetArenaNoVirtual());
    persistence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelJoin.persistence)
  return persistence_;
}
inline void ChannelJoin::set_allocated_persistence(::google::protobuf::BoolValue* persistence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(persistence_);
  }
  if (persistence) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(persistence)->GetArena();
    if (message_arena != submessage_arena) {
      persistence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, persistence, submessage_arena);
    }
    
  } else {
    
  }
  persistence_ = persistence;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelJoin.persistence)
}

// .google.protobuf.BoolValue hidden = 4;
inline bool ChannelJoin::has_hidden() const {
  return this != internal_default_instance() && hidden_ != NULL;
}
inline const ::google::protobuf::BoolValue& ChannelJoin::_internal_hidden() const {
  return *hidden_;
}
inline const ::google::protobuf::BoolValue& ChannelJoin::hidden() const {
  const ::google::protobuf::BoolValue* p = hidden_;
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelJoin.hidden)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::BoolValue*>(
      &::google::protobuf::_BoolValue_default_instance_);
}
inline ::google::protobuf::BoolValue* ChannelJoin::release_hidden() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelJoin.hidden)
  
  ::google::protobuf::BoolValue* temp = hidden_;
  hidden_ = NULL;
  return temp;
}
inline ::google::protobuf::BoolValue* ChannelJoin::mutable_hidden() {
  
  if (hidden_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::BoolValue>(GetArenaNoVirtual());
    hidden_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelJoin.hidden)
  return hidden_;
}
inline void ChannelJoin::set_allocated_hidden(::google::protobuf::BoolValue* hidden) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(hidden_);
  }
  if (hidden) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(hidden)->GetArena();
    if (message_arena != submessage_arena) {
      hidden = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, hidden, submessage_arena);
    }
    
  } else {
    
  }
  hidden_ = hidden;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelJoin.hidden)
}

// -------------------------------------------------------------------

// ChannelLeave

// string channel_id = 1;
inline void ChannelLeave::clear_channel_id() {
  channel_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChannelLeave::channel_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelLeave.channel_id)
  return channel_id_.GetNoArena();
}
inline void ChannelLeave::set_channel_id(const ::std::string& value) {
  
  channel_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.realtime.ChannelLeave.channel_id)
}
#if LANG_CXX11
inline void ChannelLeave::set_channel_id(::std::string&& value) {
  
  channel_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.ChannelLeave.channel_id)
}
#endif
inline void ChannelLeave::set_channel_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  channel_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.realtime.ChannelLeave.channel_id)
}
inline void ChannelLeave::set_channel_id(const char* value, size_t size) {
  
  channel_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.ChannelLeave.channel_id)
}
inline ::std::string* ChannelLeave::mutable_channel_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelLeave.channel_id)
  return channel_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChannelLeave::release_channel_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelLeave.channel_id)
  
  return channel_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChannelLeave::set_allocated_channel_id(::std::string* channel_id) {
  if (channel_id != NULL) {
    
  } else {
    
  }
  channel_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), channel_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelLeave.channel_id)
}

// -------------------------------------------------------------------

// ChannelMessageAck

// string channel_id = 1;
inline void ChannelMessageAck::clear_channel_id() {
  channel_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChannelMessageAck::channel_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelMessageAck.channel_id)
  return channel_id_.GetNoArena();
}
inline void ChannelMessageAck::set_channel_id(const ::std::string& value) {
  
  channel_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.realtime.ChannelMessageAck.channel_id)
}
#if LANG_CXX11
inline void ChannelMessageAck::set_channel_id(::std::string&& value) {
  
  channel_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.ChannelMessageAck.channel_id)
}
#endif
inline void ChannelMessageAck::set_channel_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  channel_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.realtime.ChannelMessageAck.channel_id)
}
inline void ChannelMessageAck::set_channel_id(const char* value, size_t size) {
  
  channel_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.ChannelMessageAck.channel_id)
}
inline ::std::string* ChannelMessageAck::mutable_channel_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelMessageAck.channel_id)
  return channel_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChannelMessageAck::release_channel_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelMessageAck.channel_id)
  
  return channel_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChannelMessageAck::set_allocated_channel_id(::std::string* channel_id) {
  if (channel_id != NULL) {
    
  } else {
    
  }
  channel_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), channel_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelMessageAck.channel_id)
}

// string message_id = 2;
inline void ChannelMessageAck::clear_message_id() {
  message_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChannelMessageAck::message_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelMessageAck.message_id)
  return message_id_.GetNoArena();
}
inline void ChannelMessageAck::set_message_id(const ::std::string& value) {
  
  message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.realtime.ChannelMessageAck.message_id)
}
#if LANG_CXX11
inline void ChannelMessageAck::set_message_id(::std::string&& value) {
  
  message_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.ChannelMessageAck.message_id)
}
#endif
inline void ChannelMessageAck::set_message_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.realtime.ChannelMessageAck.message_id)
}
inline void ChannelMessageAck::set_message_id(const char* value, size_t size) {
  
  message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.ChannelMessageAck.message_id)
}
inline ::std::string* ChannelMessageAck::mutable_message_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelMessageAck.message_id)
  return message_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChannelMessageAck::release_message_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelMessageAck.message_id)
  
  return message_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChannelMessageAck::set_allocated_message_id(::std::string* message_id) {
  if (message_id != NULL) {
    
  } else {
    
  }
  message_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelMessageAck.message_id)
}

// .google.protobuf.Int32Value code = 3;
inline bool ChannelMessageAck::has_code() const {
  return this != internal_default_instance() && code_ != NULL;
}
inline const ::google::protobuf::Int32Value& ChannelMessageAck::_internal_code() const {
  return *code_;
}
inline const ::google::protobuf::Int32Value& ChannelMessageAck::code() const {
  const ::google::protobuf::Int32Value* p = code_;
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelMessageAck.code)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* ChannelMessageAck::release_code() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelMessageAck.code)
  
  ::google::protobuf::Int32Value* temp = code_;
  code_ = NULL;
  return temp;
}
inline ::google::protobuf::Int32Value* ChannelMessageAck::mutable_code() {
  
  if (code_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    code_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelMessageAck.code)
  return code_;
}
inline void ChannelMessageAck::set_allocated_code(::google::protobuf::Int32Value* code) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(code_);
  }
  if (code) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(code)->GetArena();
    if (message_arena != submessage_arena) {
      code = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, code, submessage_arena);
    }
    
  } else {
    
  }
  code_ = code;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelMessageAck.code)
}

// string username = 4;
inline void ChannelMessageAck::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChannelMessageAck::username() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelMessageAck.username)
  return username_.GetNoArena();
}
inline void ChannelMessageAck::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.realtime.ChannelMessageAck.username)
}
#if LANG_CXX11
inline void ChannelMessageAck::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.ChannelMessageAck.username)
}
#endif
inline void ChannelMessageAck::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.realtime.ChannelMessageAck.username)
}
inline void ChannelMessageAck::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.ChannelMessageAck.username)
}
inline ::std::string* ChannelMessageAck::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelMessageAck.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChannelMessageAck::release_username() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelMessageAck.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChannelMessageAck::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelMessageAck.username)
}

// .google.protobuf.Timestamp create_time = 5;
inline bool ChannelMessageAck::has_create_time() const {
  return this != internal_default_instance() && create_time_ != NULL;
}
inline const ::google::protobuf::Timestamp& ChannelMessageAck::_internal_create_time() const {
  return *create_time_;
}
inline const ::google::protobuf::Timestamp& ChannelMessageAck::create_time() const {
  const ::google::protobuf::Timestamp* p = create_time_;
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelMessageAck.create_time)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* ChannelMessageAck::release_create_time() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelMessageAck.create_time)
  
  ::google::protobuf::Timestamp* temp = create_time_;
  create_time_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* ChannelMessageAck::mutable_create_time() {
  
  if (create_time_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    create_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelMessageAck.create_time)
  return create_time_;
}
inline void ChannelMessageAck::set_allocated_create_time(::google::protobuf::Timestamp* create_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(create_time_);
  }
  if (create_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(create_time)->GetArena();
    if (message_arena != submessage_arena) {
      create_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, create_time, submessage_arena);
    }
    
  } else {
    
  }
  create_time_ = create_time;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelMessageAck.create_time)
}

// .google.protobuf.Timestamp update_time = 6;
inline bool ChannelMessageAck::has_update_time() const {
  return this != internal_default_instance() && update_time_ != NULL;
}
inline const ::google::protobuf::Timestamp& ChannelMessageAck::_internal_update_time() const {
  return *update_time_;
}
inline const ::google::protobuf::Timestamp& ChannelMessageAck::update_time() const {
  const ::google::protobuf::Timestamp* p = update_time_;
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelMessageAck.update_time)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* ChannelMessageAck::release_update_time() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelMessageAck.update_time)
  
  ::google::protobuf::Timestamp* temp = update_time_;
  update_time_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* ChannelMessageAck::mutable_update_time() {
  
  if (update_time_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    update_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelMessageAck.update_time)
  return update_time_;
}
inline void ChannelMessageAck::set_allocated_update_time(::google::protobuf::Timestamp* update_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(update_time_);
  }
  if (update_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(update_time)->GetArena();
    if (message_arena != submessage_arena) {
      update_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, update_time, submessage_arena);
    }
    
  } else {
    
  }
  update_time_ = update_time;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelMessageAck.update_time)
}

// .google.protobuf.BoolValue persistent = 7;
inline bool ChannelMessageAck::has_persistent() const {
  return this != internal_default_instance() && persistent_ != NULL;
}
inline const ::google::protobuf::BoolValue& ChannelMessageAck::_internal_persistent() const {
  return *persistent_;
}
inline const ::google::protobuf::BoolValue& ChannelMessageAck::persistent() const {
  const ::google::protobuf::BoolValue* p = persistent_;
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelMessageAck.persistent)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::BoolValue*>(
      &::google::protobuf::_BoolValue_default_instance_);
}
inline ::google::protobuf::BoolValue* ChannelMessageAck::release_persistent() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelMessageAck.persistent)
  
  ::google::protobuf::BoolValue* temp = persistent_;
  persistent_ = NULL;
  return temp;
}
inline ::google::protobuf::BoolValue* ChannelMessageAck::mutable_persistent() {
  
  if (persistent_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::BoolValue>(GetArenaNoVirtual());
    persistent_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelMessageAck.persistent)
  return persistent_;
}
inline void ChannelMessageAck::set_allocated_persistent(::google::protobuf::BoolValue* persistent) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(persistent_);
  }
  if (persistent) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(persistent)->GetArena();
    if (message_arena != submessage_arena) {
      persistent = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, persistent, submessage_arena);
    }
    
  } else {
    
  }
  persistent_ = persistent;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelMessageAck.persistent)
}

// -------------------------------------------------------------------

// ChannelMessageSend

// string channel_id = 1;
inline void ChannelMessageSend::clear_channel_id() {
  channel_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChannelMessageSend::channel_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelMessageSend.channel_id)
  return channel_id_.GetNoArena();
}
inline void ChannelMessageSend::set_channel_id(const ::std::string& value) {
  
  channel_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.realtime.ChannelMessageSend.channel_id)
}
#if LANG_CXX11
inline void ChannelMessageSend::set_channel_id(::std::string&& value) {
  
  channel_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.ChannelMessageSend.channel_id)
}
#endif
inline void ChannelMessageSend::set_channel_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  channel_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.realtime.ChannelMessageSend.channel_id)
}
inline void ChannelMessageSend::set_channel_id(const char* value, size_t size) {
  
  channel_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.ChannelMessageSend.channel_id)
}
inline ::std::string* ChannelMessageSend::mutable_channel_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelMessageSend.channel_id)
  return channel_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChannelMessageSend::release_channel_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelMessageSend.channel_id)
  
  return channel_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChannelMessageSend::set_allocated_channel_id(::std::string* channel_id) {
  if (channel_id != NULL) {
    
  } else {
    
  }
  channel_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), channel_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelMessageSend.channel_id)
}

// string content = 2;
inline void ChannelMessageSend::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChannelMessageSend::content() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelMessageSend.content)
  return content_.GetNoArena();
}
inline void ChannelMessageSend::set_content(const ::std::string& value) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.realtime.ChannelMessageSend.content)
}
#if LANG_CXX11
inline void ChannelMessageSend::set_content(::std::string&& value) {
  
  content_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.ChannelMessageSend.content)
}
#endif
inline void ChannelMessageSend::set_content(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.realtime.ChannelMessageSend.content)
}
inline void ChannelMessageSend::set_content(const char* value, size_t size) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.ChannelMessageSend.content)
}
inline ::std::string* ChannelMessageSend::mutable_content() {
  
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelMessageSend.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChannelMessageSend::release_content() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelMessageSend.content)
  
  return content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChannelMessageSend::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    
  } else {
    
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelMessageSend.content)
}

// -------------------------------------------------------------------

// ChannelMessageUpdate

// string channel_id = 1;
inline void ChannelMessageUpdate::clear_channel_id() {
  channel_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChannelMessageUpdate::channel_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelMessageUpdate.channel_id)
  return channel_id_.GetNoArena();
}
inline void ChannelMessageUpdate::set_channel_id(const ::std::string& value) {
  
  channel_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.realtime.ChannelMessageUpdate.channel_id)
}
#if LANG_CXX11
inline void ChannelMessageUpdate::set_channel_id(::std::string&& value) {
  
  channel_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.ChannelMessageUpdate.channel_id)
}
#endif
inline void ChannelMessageUpdate::set_channel_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  channel_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.realtime.ChannelMessageUpdate.channel_id)
}
inline void ChannelMessageUpdate::set_channel_id(const char* value, size_t size) {
  
  channel_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.ChannelMessageUpdate.channel_id)
}
inline ::std::string* ChannelMessageUpdate::mutable_channel_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelMessageUpdate.channel_id)
  return channel_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChannelMessageUpdate::release_channel_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelMessageUpdate.channel_id)
  
  return channel_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChannelMessageUpdate::set_allocated_channel_id(::std::string* channel_id) {
  if (channel_id != NULL) {
    
  } else {
    
  }
  channel_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), channel_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelMessageUpdate.channel_id)
}

// string message_id = 2;
inline void ChannelMessageUpdate::clear_message_id() {
  message_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChannelMessageUpdate::message_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelMessageUpdate.message_id)
  return message_id_.GetNoArena();
}
inline void ChannelMessageUpdate::set_message_id(const ::std::string& value) {
  
  message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.realtime.ChannelMessageUpdate.message_id)
}
#if LANG_CXX11
inline void ChannelMessageUpdate::set_message_id(::std::string&& value) {
  
  message_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.ChannelMessageUpdate.message_id)
}
#endif
inline void ChannelMessageUpdate::set_message_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.realtime.ChannelMessageUpdate.message_id)
}
inline void ChannelMessageUpdate::set_message_id(const char* value, size_t size) {
  
  message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.ChannelMessageUpdate.message_id)
}
inline ::std::string* ChannelMessageUpdate::mutable_message_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelMessageUpdate.message_id)
  return message_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChannelMessageUpdate::release_message_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelMessageUpdate.message_id)
  
  return message_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChannelMessageUpdate::set_allocated_message_id(::std::string* message_id) {
  if (message_id != NULL) {
    
  } else {
    
  }
  message_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelMessageUpdate.message_id)
}

// string content = 3;
inline void ChannelMessageUpdate::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChannelMessageUpdate::content() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelMessageUpdate.content)
  return content_.GetNoArena();
}
inline void ChannelMessageUpdate::set_content(const ::std::string& value) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.realtime.ChannelMessageUpdate.content)
}
#if LANG_CXX11
inline void ChannelMessageUpdate::set_content(::std::string&& value) {
  
  content_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.ChannelMessageUpdate.content)
}
#endif
inline void ChannelMessageUpdate::set_content(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.realtime.ChannelMessageUpdate.content)
}
inline void ChannelMessageUpdate::set_content(const char* value, size_t size) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.ChannelMessageUpdate.content)
}
inline ::std::string* ChannelMessageUpdate::mutable_content() {
  
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelMessageUpdate.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChannelMessageUpdate::release_content() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelMessageUpdate.content)
  
  return content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChannelMessageUpdate::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    
  } else {
    
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelMessageUpdate.content)
}

// -------------------------------------------------------------------

// ChannelMessageRemove

// string channel_id = 1;
inline void ChannelMessageRemove::clear_channel_id() {
  channel_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChannelMessageRemove::channel_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelMessageRemove.channel_id)
  return channel_id_.GetNoArena();
}
inline void ChannelMessageRemove::set_channel_id(const ::std::string& value) {
  
  channel_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.realtime.ChannelMessageRemove.channel_id)
}
#if LANG_CXX11
inline void ChannelMessageRemove::set_channel_id(::std::string&& value) {
  
  channel_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.ChannelMessageRemove.channel_id)
}
#endif
inline void ChannelMessageRemove::set_channel_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  channel_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.realtime.ChannelMessageRemove.channel_id)
}
inline void ChannelMessageRemove::set_channel_id(const char* value, size_t size) {
  
  channel_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.ChannelMessageRemove.channel_id)
}
inline ::std::string* ChannelMessageRemove::mutable_channel_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelMessageRemove.channel_id)
  return channel_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChannelMessageRemove::release_channel_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelMessageRemove.channel_id)
  
  return channel_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChannelMessageRemove::set_allocated_channel_id(::std::string* channel_id) {
  if (channel_id != NULL) {
    
  } else {
    
  }
  channel_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), channel_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelMessageRemove.channel_id)
}

// string message_id = 2;
inline void ChannelMessageRemove::clear_message_id() {
  message_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChannelMessageRemove::message_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelMessageRemove.message_id)
  return message_id_.GetNoArena();
}
inline void ChannelMessageRemove::set_message_id(const ::std::string& value) {
  
  message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.realtime.ChannelMessageRemove.message_id)
}
#if LANG_CXX11
inline void ChannelMessageRemove::set_message_id(::std::string&& value) {
  
  message_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.ChannelMessageRemove.message_id)
}
#endif
inline void ChannelMessageRemove::set_message_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.realtime.ChannelMessageRemove.message_id)
}
inline void ChannelMessageRemove::set_message_id(const char* value, size_t size) {
  
  message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.ChannelMessageRemove.message_id)
}
inline ::std::string* ChannelMessageRemove::mutable_message_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelMessageRemove.message_id)
  return message_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChannelMessageRemove::release_message_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelMessageRemove.message_id)
  
  return message_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChannelMessageRemove::set_allocated_message_id(::std::string* message_id) {
  if (message_id != NULL) {
    
  } else {
    
  }
  message_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelMessageRemove.message_id)
}

// -------------------------------------------------------------------

// ChannelPresenceEvent

// string channel_id = 1;
inline void ChannelPresenceEvent::clear_channel_id() {
  channel_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChannelPresenceEvent::channel_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelPresenceEvent.channel_id)
  return channel_id_.GetNoArena();
}
inline void ChannelPresenceEvent::set_channel_id(const ::std::string& value) {
  
  channel_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.realtime.ChannelPresenceEvent.channel_id)
}
#if LANG_CXX11
inline void ChannelPresenceEvent::set_channel_id(::std::string&& value) {
  
  channel_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.ChannelPresenceEvent.channel_id)
}
#endif
inline void ChannelPresenceEvent::set_channel_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  channel_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.realtime.ChannelPresenceEvent.channel_id)
}
inline void ChannelPresenceEvent::set_channel_id(const char* value, size_t size) {
  
  channel_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.ChannelPresenceEvent.channel_id)
}
inline ::std::string* ChannelPresenceEvent::mutable_channel_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelPresenceEvent.channel_id)
  return channel_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChannelPresenceEvent::release_channel_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.ChannelPresenceEvent.channel_id)
  
  return channel_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChannelPresenceEvent::set_allocated_channel_id(::std::string* channel_id) {
  if (channel_id != NULL) {
    
  } else {
    
  }
  channel_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), channel_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.ChannelPresenceEvent.channel_id)
}

// repeated .nakama.realtime.UserPresence joins = 2;
inline int ChannelPresenceEvent::joins_size() const {
  return joins_.size();
}
inline void ChannelPresenceEvent::clear_joins() {
  joins_.Clear();
}
inline ::nakama::realtime::UserPresence* ChannelPresenceEvent::mutable_joins(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelPresenceEvent.joins)
  return joins_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >*
ChannelPresenceEvent::mutable_joins() {
  // @@protoc_insertion_point(field_mutable_list:nakama.realtime.ChannelPresenceEvent.joins)
  return &joins_;
}
inline const ::nakama::realtime::UserPresence& ChannelPresenceEvent::joins(int index) const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelPresenceEvent.joins)
  return joins_.Get(index);
}
inline ::nakama::realtime::UserPresence* ChannelPresenceEvent::add_joins() {
  // @@protoc_insertion_point(field_add:nakama.realtime.ChannelPresenceEvent.joins)
  return joins_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >&
ChannelPresenceEvent::joins() const {
  // @@protoc_insertion_point(field_list:nakama.realtime.ChannelPresenceEvent.joins)
  return joins_;
}

// repeated .nakama.realtime.UserPresence leaves = 3;
inline int ChannelPresenceEvent::leaves_size() const {
  return leaves_.size();
}
inline void ChannelPresenceEvent::clear_leaves() {
  leaves_.Clear();
}
inline ::nakama::realtime::UserPresence* ChannelPresenceEvent::mutable_leaves(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.ChannelPresenceEvent.leaves)
  return leaves_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >*
ChannelPresenceEvent::mutable_leaves() {
  // @@protoc_insertion_point(field_mutable_list:nakama.realtime.ChannelPresenceEvent.leaves)
  return &leaves_;
}
inline const ::nakama::realtime::UserPresence& ChannelPresenceEvent::leaves(int index) const {
  // @@protoc_insertion_point(field_get:nakama.realtime.ChannelPresenceEvent.leaves)
  return leaves_.Get(index);
}
inline ::nakama::realtime::UserPresence* ChannelPresenceEvent::add_leaves() {
  // @@protoc_insertion_point(field_add:nakama.realtime.ChannelPresenceEvent.leaves)
  return leaves_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >&
ChannelPresenceEvent::leaves() const {
  // @@protoc_insertion_point(field_list:nakama.realtime.ChannelPresenceEvent.leaves)
  return leaves_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Error

// int32 code = 1;
inline void Error::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 Error::code() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Error.code)
  return code_;
}
inline void Error::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:nakama.realtime.Error.code)
}

// string message = 2;
inline void Error::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Error::message() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Error.message)
  return message_.GetNoArena();
}
inline void Error::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.realtime.Error.message)
}
#if LANG_CXX11
inline void Error::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.Error.message)
}
#endif
inline void Error::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.realtime.Error.message)
}
inline void Error::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.Error.message)
}
inline ::std::string* Error::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Error.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Error::release_message() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Error.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Error::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.Error.message)
}

// map<string, string> context = 3;
inline int Error::context_size() const {
  return context_.size();
}
inline void Error::clear_context() {
  context_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
Error::context() const {
  // @@protoc_insertion_point(field_map:nakama.realtime.Error.context)
  return context_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
Error::mutable_context() {
  // @@protoc_insertion_point(field_mutable_map:nakama.realtime.Error.context)
  return context_.MutableMap();
}

// -------------------------------------------------------------------

// Match

// string match_id = 1;
inline void Match::clear_match_id() {
  match_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Match::match_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Match.match_id)
  return match_id_.GetNoArena();
}
inline void Match::set_match_id(const ::std::string& value) {
  
  match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.realtime.Match.match_id)
}
#if LANG_CXX11
inline void Match::set_match_id(::std::string&& value) {
  
  match_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.Match.match_id)
}
#endif
inline void Match::set_match_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.realtime.Match.match_id)
}
inline void Match::set_match_id(const char* value, size_t size) {
  
  match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.Match.match_id)
}
inline ::std::string* Match::mutable_match_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Match.match_id)
  return match_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Match::release_match_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Match.match_id)
  
  return match_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Match::set_allocated_match_id(::std::string* match_id) {
  if (match_id != NULL) {
    
  } else {
    
  }
  match_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), match_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.Match.match_id)
}

// bool authoritative = 2;
inline void Match::clear_authoritative() {
  authoritative_ = false;
}
inline bool Match::authoritative() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Match.authoritative)
  return authoritative_;
}
inline void Match::set_authoritative(bool value) {
  
  authoritative_ = value;
  // @@protoc_insertion_point(field_set:nakama.realtime.Match.authoritative)
}

// .google.protobuf.StringValue label = 3;
inline bool Match::has_label() const {
  return this != internal_default_instance() && label_ != NULL;
}
inline const ::google::protobuf::StringValue& Match::_internal_label() const {
  return *label_;
}
inline const ::google::protobuf::StringValue& Match::label() const {
  const ::google::protobuf::StringValue* p = label_;
  // @@protoc_insertion_point(field_get:nakama.realtime.Match.label)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::StringValue*>(
      &::google::protobuf::_StringValue_default_instance_);
}
inline ::google::protobuf::StringValue* Match::release_label() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Match.label)
  
  ::google::protobuf::StringValue* temp = label_;
  label_ = NULL;
  return temp;
}
inline ::google::protobuf::StringValue* Match::mutable_label() {
  
  if (label_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::StringValue>(GetArenaNoVirtual());
    label_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Match.label)
  return label_;
}
inline void Match::set_allocated_label(::google::protobuf::StringValue* label) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(label_);
  }
  if (label) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(label)->GetArena();
    if (message_arena != submessage_arena) {
      label = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, label, submessage_arena);
    }
    
  } else {
    
  }
  label_ = label;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.Match.label)
}

// int32 size = 4;
inline void Match::clear_size() {
  size_ = 0;
}
inline ::google::protobuf::int32 Match::size() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Match.size)
  return size_;
}
inline void Match::set_size(::google::protobuf::int32 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:nakama.realtime.Match.size)
}

// repeated .nakama.realtime.UserPresence presences = 5;
inline int Match::presences_size() const {
  return presences_.size();
}
inline void Match::clear_presences() {
  presences_.Clear();
}
inline ::nakama::realtime::UserPresence* Match::mutable_presences(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Match.presences)
  return presences_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >*
Match::mutable_presences() {
  // @@protoc_insertion_point(field_mutable_list:nakama.realtime.Match.presences)
  return &presences_;
}
inline const ::nakama::realtime::UserPresence& Match::presences(int index) const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Match.presences)
  return presences_.Get(index);
}
inline ::nakama::realtime::UserPresence* Match::add_presences() {
  // @@protoc_insertion_point(field_add:nakama.realtime.Match.presences)
  return presences_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >&
Match::presences() const {
  // @@protoc_insertion_point(field_list:nakama.realtime.Match.presences)
  return presences_;
}

// .nakama.realtime.UserPresence self = 6;
inline bool Match::has_self() const {
  return this != internal_default_instance() && self_ != NULL;
}
inline void Match::clear_self() {
  if (GetArenaNoVirtual() == NULL && self_ != NULL) {
    delete self_;
  }
  self_ = NULL;
}
inline const ::nakama::realtime::UserPresence& Match::_internal_self() const {
  return *self_;
}
inline const ::nakama::realtime::UserPresence& Match::self() const {
  const ::nakama::realtime::UserPresence* p = self_;
  // @@protoc_insertion_point(field_get:nakama.realtime.Match.self)
  return p != NULL ? *p : *reinterpret_cast<const ::nakama::realtime::UserPresence*>(
      &::nakama::realtime::_UserPresence_default_instance_);
}
inline ::nakama::realtime::UserPresence* Match::release_self() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Match.self)
  
  ::nakama::realtime::UserPresence* temp = self_;
  self_ = NULL;
  return temp;
}
inline ::nakama::realtime::UserPresence* Match::mutable_self() {
  
  if (self_ == NULL) {
    auto* p = CreateMaybeMessage<::nakama::realtime::UserPresence>(GetArenaNoVirtual());
    self_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Match.self)
  return self_;
}
inline void Match::set_allocated_self(::nakama::realtime::UserPresence* self) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete self_;
  }
  if (self) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      self = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, self, submessage_arena);
    }
    
  } else {
    
  }
  self_ = self;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.Match.self)
}

// -------------------------------------------------------------------

// MatchCreate

// -------------------------------------------------------------------

// MatchData

// string match_id = 1;
inline void MatchData::clear_match_id() {
  match_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MatchData::match_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchData.match_id)
  return match_id_.GetNoArena();
}
inline void MatchData::set_match_id(const ::std::string& value) {
  
  match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchData.match_id)
}
#if LANG_CXX11
inline void MatchData::set_match_id(::std::string&& value) {
  
  match_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.MatchData.match_id)
}
#endif
inline void MatchData::set_match_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.realtime.MatchData.match_id)
}
inline void MatchData::set_match_id(const char* value, size_t size) {
  
  match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.MatchData.match_id)
}
inline ::std::string* MatchData::mutable_match_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchData.match_id)
  return match_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MatchData::release_match_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.MatchData.match_id)
  
  return match_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MatchData::set_allocated_match_id(::std::string* match_id) {
  if (match_id != NULL) {
    
  } else {
    
  }
  match_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), match_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.MatchData.match_id)
}

// .nakama.realtime.UserPresence presence = 2;
inline bool MatchData::has_presence() const {
  return this != internal_default_instance() && presence_ != NULL;
}
inline void MatchData::clear_presence() {
  if (GetArenaNoVirtual() == NULL && presence_ != NULL) {
    delete presence_;
  }
  presence_ = NULL;
}
inline const ::nakama::realtime::UserPresence& MatchData::_internal_presence() const {
  return *presence_;
}
inline const ::nakama::realtime::UserPresence& MatchData::presence() const {
  const ::nakama::realtime::UserPresence* p = presence_;
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchData.presence)
  return p != NULL ? *p : *reinterpret_cast<const ::nakama::realtime::UserPresence*>(
      &::nakama::realtime::_UserPresence_default_instance_);
}
inline ::nakama::realtime::UserPresence* MatchData::release_presence() {
  // @@protoc_insertion_point(field_release:nakama.realtime.MatchData.presence)
  
  ::nakama::realtime::UserPresence* temp = presence_;
  presence_ = NULL;
  return temp;
}
inline ::nakama::realtime::UserPresence* MatchData::mutable_presence() {
  
  if (presence_ == NULL) {
    auto* p = CreateMaybeMessage<::nakama::realtime::UserPresence>(GetArenaNoVirtual());
    presence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchData.presence)
  return presence_;
}
inline void MatchData::set_allocated_presence(::nakama::realtime::UserPresence* presence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete presence_;
  }
  if (presence) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      presence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, presence, submessage_arena);
    }
    
  } else {
    
  }
  presence_ = presence;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.MatchData.presence)
}

// int64 op_code = 3;
inline void MatchData::clear_op_code() {
  op_code_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 MatchData::op_code() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchData.op_code)
  return op_code_;
}
inline void MatchData::set_op_code(::google::protobuf::int64 value) {
  
  op_code_ = value;
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchData.op_code)
}

// bytes data = 4;
inline void MatchData::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MatchData::data() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchData.data)
  return data_.GetNoArena();
}
inline void MatchData::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchData.data)
}
#if LANG_CXX11
inline void MatchData::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.MatchData.data)
}
#endif
inline void MatchData::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.realtime.MatchData.data)
}
inline void MatchData::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.MatchData.data)
}
inline ::std::string* MatchData::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchData.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MatchData::release_data() {
  // @@protoc_insertion_point(field_release:nakama.realtime.MatchData.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MatchData::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.MatchData.data)
}

// -------------------------------------------------------------------

// MatchDataSend

// string match_id = 1;
inline void MatchDataSend::clear_match_id() {
  match_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MatchDataSend::match_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchDataSend.match_id)
  return match_id_.GetNoArena();
}
inline void MatchDataSend::set_match_id(const ::std::string& value) {
  
  match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchDataSend.match_id)
}
#if LANG_CXX11
inline void MatchDataSend::set_match_id(::std::string&& value) {
  
  match_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.MatchDataSend.match_id)
}
#endif
inline void MatchDataSend::set_match_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.realtime.MatchDataSend.match_id)
}
inline void MatchDataSend::set_match_id(const char* value, size_t size) {
  
  match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.MatchDataSend.match_id)
}
inline ::std::string* MatchDataSend::mutable_match_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchDataSend.match_id)
  return match_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MatchDataSend::release_match_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.MatchDataSend.match_id)
  
  return match_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MatchDataSend::set_allocated_match_id(::std::string* match_id) {
  if (match_id != NULL) {
    
  } else {
    
  }
  match_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), match_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.MatchDataSend.match_id)
}

// int64 op_code = 2;
inline void MatchDataSend::clear_op_code() {
  op_code_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 MatchDataSend::op_code() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchDataSend.op_code)
  return op_code_;
}
inline void MatchDataSend::set_op_code(::google::protobuf::int64 value) {
  
  op_code_ = value;
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchDataSend.op_code)
}

// bytes data = 3;
inline void MatchDataSend::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MatchDataSend::data() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchDataSend.data)
  return data_.GetNoArena();
}
inline void MatchDataSend::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchDataSend.data)
}
#if LANG_CXX11
inline void MatchDataSend::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.MatchDataSend.data)
}
#endif
inline void MatchDataSend::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.realtime.MatchDataSend.data)
}
inline void MatchDataSend::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.MatchDataSend.data)
}
inline ::std::string* MatchDataSend::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchDataSend.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MatchDataSend::release_data() {
  // @@protoc_insertion_point(field_release:nakama.realtime.MatchDataSend.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MatchDataSend::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.MatchDataSend.data)
}

// repeated .nakama.realtime.UserPresence presences = 4;
inline int MatchDataSend::presences_size() const {
  return presences_.size();
}
inline void MatchDataSend::clear_presences() {
  presences_.Clear();
}
inline ::nakama::realtime::UserPresence* MatchDataSend::mutable_presences(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchDataSend.presences)
  return presences_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >*
MatchDataSend::mutable_presences() {
  // @@protoc_insertion_point(field_mutable_list:nakama.realtime.MatchDataSend.presences)
  return &presences_;
}
inline const ::nakama::realtime::UserPresence& MatchDataSend::presences(int index) const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchDataSend.presences)
  return presences_.Get(index);
}
inline ::nakama::realtime::UserPresence* MatchDataSend::add_presences() {
  // @@protoc_insertion_point(field_add:nakama.realtime.MatchDataSend.presences)
  return presences_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >&
MatchDataSend::presences() const {
  // @@protoc_insertion_point(field_list:nakama.realtime.MatchDataSend.presences)
  return presences_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MatchJoin

// string match_id = 1;
inline bool MatchJoin::has_match_id() const {
  return id_case() == kMatchId;
}
inline void MatchJoin::set_has_match_id() {
  _oneof_case_[0] = kMatchId;
}
inline void MatchJoin::clear_match_id() {
  if (has_match_id()) {
    id_.match_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_id();
  }
}
inline const ::std::string& MatchJoin::match_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchJoin.match_id)
  if (has_match_id()) {
    return id_.match_id_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void MatchJoin::set_match_id(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchJoin.match_id)
  if (!has_match_id()) {
    clear_id();
    set_has_match_id();
    id_.match_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchJoin.match_id)
}
#if LANG_CXX11
inline void MatchJoin::set_match_id(::std::string&& value) {
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchJoin.match_id)
  if (!has_match_id()) {
    clear_id();
    set_has_match_id();
    id_.match_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.MatchJoin.match_id)
}
#endif
inline void MatchJoin::set_match_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_match_id()) {
    clear_id();
    set_has_match_id();
    id_.match_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.realtime.MatchJoin.match_id)
}
inline void MatchJoin::set_match_id(const char* value, size_t size) {
  if (!has_match_id()) {
    clear_id();
    set_has_match_id();
    id_.match_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.MatchJoin.match_id)
}
inline ::std::string* MatchJoin::mutable_match_id() {
  if (!has_match_id()) {
    clear_id();
    set_has_match_id();
    id_.match_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchJoin.match_id)
  return id_.match_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MatchJoin::release_match_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.MatchJoin.match_id)
  if (has_match_id()) {
    clear_has_id();
    return id_.match_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void MatchJoin::set_allocated_match_id(::std::string* match_id) {
  if (!has_match_id()) {
    id_.match_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_id();
  if (match_id != NULL) {
    set_has_match_id();
    id_.match_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), match_id);
  }
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.MatchJoin.match_id)
}

// string token = 2;
inline bool MatchJoin::has_token() const {
  return id_case() == kToken;
}
inline void MatchJoin::set_has_token() {
  _oneof_case_[0] = kToken;
}
inline void MatchJoin::clear_token() {
  if (has_token()) {
    id_.token_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_id();
  }
}
inline const ::std::string& MatchJoin::token() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchJoin.token)
  if (has_token()) {
    return id_.token_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void MatchJoin::set_token(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchJoin.token)
  if (!has_token()) {
    clear_id();
    set_has_token();
    id_.token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchJoin.token)
}
#if LANG_CXX11
inline void MatchJoin::set_token(::std::string&& value) {
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchJoin.token)
  if (!has_token()) {
    clear_id();
    set_has_token();
    id_.token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.MatchJoin.token)
}
#endif
inline void MatchJoin::set_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_token()) {
    clear_id();
    set_has_token();
    id_.token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.realtime.MatchJoin.token)
}
inline void MatchJoin::set_token(const char* value, size_t size) {
  if (!has_token()) {
    clear_id();
    set_has_token();
    id_.token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.MatchJoin.token)
}
inline ::std::string* MatchJoin::mutable_token() {
  if (!has_token()) {
    clear_id();
    set_has_token();
    id_.token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchJoin.token)
  return id_.token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MatchJoin::release_token() {
  // @@protoc_insertion_point(field_release:nakama.realtime.MatchJoin.token)
  if (has_token()) {
    clear_has_id();
    return id_.token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void MatchJoin::set_allocated_token(::std::string* token) {
  if (!has_token()) {
    id_.token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_id();
  if (token != NULL) {
    set_has_token();
    id_.token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  }
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.MatchJoin.token)
}

// map<string, string> metadata = 3;
inline int MatchJoin::metadata_size() const {
  return metadata_.size();
}
inline void MatchJoin::clear_metadata() {
  metadata_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
MatchJoin::metadata() const {
  // @@protoc_insertion_point(field_map:nakama.realtime.MatchJoin.metadata)
  return metadata_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
MatchJoin::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:nakama.realtime.MatchJoin.metadata)
  return metadata_.MutableMap();
}

inline bool MatchJoin::has_id() const {
  return id_case() != ID_NOT_SET;
}
inline void MatchJoin::clear_has_id() {
  _oneof_case_[0] = ID_NOT_SET;
}
inline MatchJoin::IdCase MatchJoin::id_case() const {
  return MatchJoin::IdCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MatchLeave

// string match_id = 1;
inline void MatchLeave::clear_match_id() {
  match_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MatchLeave::match_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchLeave.match_id)
  return match_id_.GetNoArena();
}
inline void MatchLeave::set_match_id(const ::std::string& value) {
  
  match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchLeave.match_id)
}
#if LANG_CXX11
inline void MatchLeave::set_match_id(::std::string&& value) {
  
  match_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.MatchLeave.match_id)
}
#endif
inline void MatchLeave::set_match_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.realtime.MatchLeave.match_id)
}
inline void MatchLeave::set_match_id(const char* value, size_t size) {
  
  match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.MatchLeave.match_id)
}
inline ::std::string* MatchLeave::mutable_match_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchLeave.match_id)
  return match_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MatchLeave::release_match_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.MatchLeave.match_id)
  
  return match_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MatchLeave::set_allocated_match_id(::std::string* match_id) {
  if (match_id != NULL) {
    
  } else {
    
  }
  match_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), match_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.MatchLeave.match_id)
}

// -------------------------------------------------------------------

// MatchPresenceEvent

// string match_id = 1;
inline void MatchPresenceEvent::clear_match_id() {
  match_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MatchPresenceEvent::match_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchPresenceEvent.match_id)
  return match_id_.GetNoArena();
}
inline void MatchPresenceEvent::set_match_id(const ::std::string& value) {
  
  match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchPresenceEvent.match_id)
}
#if LANG_CXX11
inline void MatchPresenceEvent::set_match_id(::std::string&& value) {
  
  match_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.MatchPresenceEvent.match_id)
}
#endif
inline void MatchPresenceEvent::set_match_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.realtime.MatchPresenceEvent.match_id)
}
inline void MatchPresenceEvent::set_match_id(const char* value, size_t size) {
  
  match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.MatchPresenceEvent.match_id)
}
inline ::std::string* MatchPresenceEvent::mutable_match_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchPresenceEvent.match_id)
  return match_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MatchPresenceEvent::release_match_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.MatchPresenceEvent.match_id)
  
  return match_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MatchPresenceEvent::set_allocated_match_id(::std::string* match_id) {
  if (match_id != NULL) {
    
  } else {
    
  }
  match_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), match_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.MatchPresenceEvent.match_id)
}

// repeated .nakama.realtime.UserPresence joins = 2;
inline int MatchPresenceEvent::joins_size() const {
  return joins_.size();
}
inline void MatchPresenceEvent::clear_joins() {
  joins_.Clear();
}
inline ::nakama::realtime::UserPresence* MatchPresenceEvent::mutable_joins(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchPresenceEvent.joins)
  return joins_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >*
MatchPresenceEvent::mutable_joins() {
  // @@protoc_insertion_point(field_mutable_list:nakama.realtime.MatchPresenceEvent.joins)
  return &joins_;
}
inline const ::nakama::realtime::UserPresence& MatchPresenceEvent::joins(int index) const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchPresenceEvent.joins)
  return joins_.Get(index);
}
inline ::nakama::realtime::UserPresence* MatchPresenceEvent::add_joins() {
  // @@protoc_insertion_point(field_add:nakama.realtime.MatchPresenceEvent.joins)
  return joins_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >&
MatchPresenceEvent::joins() const {
  // @@protoc_insertion_point(field_list:nakama.realtime.MatchPresenceEvent.joins)
  return joins_;
}

// repeated .nakama.realtime.UserPresence leaves = 3;
inline int MatchPresenceEvent::leaves_size() const {
  return leaves_.size();
}
inline void MatchPresenceEvent::clear_leaves() {
  leaves_.Clear();
}
inline ::nakama::realtime::UserPresence* MatchPresenceEvent::mutable_leaves(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchPresenceEvent.leaves)
  return leaves_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >*
MatchPresenceEvent::mutable_leaves() {
  // @@protoc_insertion_point(field_mutable_list:nakama.realtime.MatchPresenceEvent.leaves)
  return &leaves_;
}
inline const ::nakama::realtime::UserPresence& MatchPresenceEvent::leaves(int index) const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchPresenceEvent.leaves)
  return leaves_.Get(index);
}
inline ::nakama::realtime::UserPresence* MatchPresenceEvent::add_leaves() {
  // @@protoc_insertion_point(field_add:nakama.realtime.MatchPresenceEvent.leaves)
  return leaves_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >&
MatchPresenceEvent::leaves() const {
  // @@protoc_insertion_point(field_list:nakama.realtime.MatchPresenceEvent.leaves)
  return leaves_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MatchmakerAdd

// int32 min_count = 1;
inline void MatchmakerAdd::clear_min_count() {
  min_count_ = 0;
}
inline ::google::protobuf::int32 MatchmakerAdd::min_count() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchmakerAdd.min_count)
  return min_count_;
}
inline void MatchmakerAdd::set_min_count(::google::protobuf::int32 value) {
  
  min_count_ = value;
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchmakerAdd.min_count)
}

// int32 max_count = 2;
inline void MatchmakerAdd::clear_max_count() {
  max_count_ = 0;
}
inline ::google::protobuf::int32 MatchmakerAdd::max_count() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchmakerAdd.max_count)
  return max_count_;
}
inline void MatchmakerAdd::set_max_count(::google::protobuf::int32 value) {
  
  max_count_ = value;
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchmakerAdd.max_count)
}

// string query = 3;
inline void MatchmakerAdd::clear_query() {
  query_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MatchmakerAdd::query() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchmakerAdd.query)
  return query_.GetNoArena();
}
inline void MatchmakerAdd::set_query(const ::std::string& value) {
  
  query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchmakerAdd.query)
}
#if LANG_CXX11
inline void MatchmakerAdd::set_query(::std::string&& value) {
  
  query_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.MatchmakerAdd.query)
}
#endif
inline void MatchmakerAdd::set_query(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.realtime.MatchmakerAdd.query)
}
inline void MatchmakerAdd::set_query(const char* value, size_t size) {
  
  query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.MatchmakerAdd.query)
}
inline ::std::string* MatchmakerAdd::mutable_query() {
  
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchmakerAdd.query)
  return query_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MatchmakerAdd::release_query() {
  // @@protoc_insertion_point(field_release:nakama.realtime.MatchmakerAdd.query)
  
  return query_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MatchmakerAdd::set_allocated_query(::std::string* query) {
  if (query != NULL) {
    
  } else {
    
  }
  query_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), query);
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.MatchmakerAdd.query)
}

// map<string, string> string_properties = 4;
inline int MatchmakerAdd::string_properties_size() const {
  return string_properties_.size();
}
inline void MatchmakerAdd::clear_string_properties() {
  string_properties_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
MatchmakerAdd::string_properties() const {
  // @@protoc_insertion_point(field_map:nakama.realtime.MatchmakerAdd.string_properties)
  return string_properties_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
MatchmakerAdd::mutable_string_properties() {
  // @@protoc_insertion_point(field_mutable_map:nakama.realtime.MatchmakerAdd.string_properties)
  return string_properties_.MutableMap();
}

// map<string, double> numeric_properties = 5;
inline int MatchmakerAdd::numeric_properties_size() const {
  return numeric_properties_.size();
}
inline void MatchmakerAdd::clear_numeric_properties() {
  numeric_properties_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, double >&
MatchmakerAdd::numeric_properties() const {
  // @@protoc_insertion_point(field_map:nakama.realtime.MatchmakerAdd.numeric_properties)
  return numeric_properties_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, double >*
MatchmakerAdd::mutable_numeric_properties() {
  // @@protoc_insertion_point(field_mutable_map:nakama.realtime.MatchmakerAdd.numeric_properties)
  return numeric_properties_.MutableMap();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MatchmakerMatched_MatchmakerUser

// .nakama.realtime.UserPresence presence = 1;
inline bool MatchmakerMatched_MatchmakerUser::has_presence() const {
  return this != internal_default_instance() && presence_ != NULL;
}
inline void MatchmakerMatched_MatchmakerUser::clear_presence() {
  if (GetArenaNoVirtual() == NULL && presence_ != NULL) {
    delete presence_;
  }
  presence_ = NULL;
}
inline const ::nakama::realtime::UserPresence& MatchmakerMatched_MatchmakerUser::_internal_presence() const {
  return *presence_;
}
inline const ::nakama::realtime::UserPresence& MatchmakerMatched_MatchmakerUser::presence() const {
  const ::nakama::realtime::UserPresence* p = presence_;
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchmakerMatched.MatchmakerUser.presence)
  return p != NULL ? *p : *reinterpret_cast<const ::nakama::realtime::UserPresence*>(
      &::nakama::realtime::_UserPresence_default_instance_);
}
inline ::nakama::realtime::UserPresence* MatchmakerMatched_MatchmakerUser::release_presence() {
  // @@protoc_insertion_point(field_release:nakama.realtime.MatchmakerMatched.MatchmakerUser.presence)
  
  ::nakama::realtime::UserPresence* temp = presence_;
  presence_ = NULL;
  return temp;
}
inline ::nakama::realtime::UserPresence* MatchmakerMatched_MatchmakerUser::mutable_presence() {
  
  if (presence_ == NULL) {
    auto* p = CreateMaybeMessage<::nakama::realtime::UserPresence>(GetArenaNoVirtual());
    presence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchmakerMatched.MatchmakerUser.presence)
  return presence_;
}
inline void MatchmakerMatched_MatchmakerUser::set_allocated_presence(::nakama::realtime::UserPresence* presence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete presence_;
  }
  if (presence) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      presence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, presence, submessage_arena);
    }
    
  } else {
    
  }
  presence_ = presence;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.MatchmakerMatched.MatchmakerUser.presence)
}

// map<string, string> string_properties = 5;
inline int MatchmakerMatched_MatchmakerUser::string_properties_size() const {
  return string_properties_.size();
}
inline void MatchmakerMatched_MatchmakerUser::clear_string_properties() {
  string_properties_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
MatchmakerMatched_MatchmakerUser::string_properties() const {
  // @@protoc_insertion_point(field_map:nakama.realtime.MatchmakerMatched.MatchmakerUser.string_properties)
  return string_properties_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
MatchmakerMatched_MatchmakerUser::mutable_string_properties() {
  // @@protoc_insertion_point(field_mutable_map:nakama.realtime.MatchmakerMatched.MatchmakerUser.string_properties)
  return string_properties_.MutableMap();
}

// map<string, double> numeric_properties = 6;
inline int MatchmakerMatched_MatchmakerUser::numeric_properties_size() const {
  return numeric_properties_.size();
}
inline void MatchmakerMatched_MatchmakerUser::clear_numeric_properties() {
  numeric_properties_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, double >&
MatchmakerMatched_MatchmakerUser::numeric_properties() const {
  // @@protoc_insertion_point(field_map:nakama.realtime.MatchmakerMatched.MatchmakerUser.numeric_properties)
  return numeric_properties_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, double >*
MatchmakerMatched_MatchmakerUser::mutable_numeric_properties() {
  // @@protoc_insertion_point(field_mutable_map:nakama.realtime.MatchmakerMatched.MatchmakerUser.numeric_properties)
  return numeric_properties_.MutableMap();
}

// -------------------------------------------------------------------

// MatchmakerMatched

// string ticket = 1;
inline void MatchmakerMatched::clear_ticket() {
  ticket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MatchmakerMatched::ticket() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchmakerMatched.ticket)
  return ticket_.GetNoArena();
}
inline void MatchmakerMatched::set_ticket(const ::std::string& value) {
  
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchmakerMatched.ticket)
}
#if LANG_CXX11
inline void MatchmakerMatched::set_ticket(::std::string&& value) {
  
  ticket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.MatchmakerMatched.ticket)
}
#endif
inline void MatchmakerMatched::set_ticket(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.realtime.MatchmakerMatched.ticket)
}
inline void MatchmakerMatched::set_ticket(const char* value, size_t size) {
  
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.MatchmakerMatched.ticket)
}
inline ::std::string* MatchmakerMatched::mutable_ticket() {
  
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchmakerMatched.ticket)
  return ticket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MatchmakerMatched::release_ticket() {
  // @@protoc_insertion_point(field_release:nakama.realtime.MatchmakerMatched.ticket)
  
  return ticket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MatchmakerMatched::set_allocated_ticket(::std::string* ticket) {
  if (ticket != NULL) {
    
  } else {
    
  }
  ticket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ticket);
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.MatchmakerMatched.ticket)
}

// string match_id = 2;
inline bool MatchmakerMatched::has_match_id() const {
  return id_case() == kMatchId;
}
inline void MatchmakerMatched::set_has_match_id() {
  _oneof_case_[0] = kMatchId;
}
inline void MatchmakerMatched::clear_match_id() {
  if (has_match_id()) {
    id_.match_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_id();
  }
}
inline const ::std::string& MatchmakerMatched::match_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchmakerMatched.match_id)
  if (has_match_id()) {
    return id_.match_id_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void MatchmakerMatched::set_match_id(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchmakerMatched.match_id)
  if (!has_match_id()) {
    clear_id();
    set_has_match_id();
    id_.match_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchmakerMatched.match_id)
}
#if LANG_CXX11
inline void MatchmakerMatched::set_match_id(::std::string&& value) {
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchmakerMatched.match_id)
  if (!has_match_id()) {
    clear_id();
    set_has_match_id();
    id_.match_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.MatchmakerMatched.match_id)
}
#endif
inline void MatchmakerMatched::set_match_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_match_id()) {
    clear_id();
    set_has_match_id();
    id_.match_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.realtime.MatchmakerMatched.match_id)
}
inline void MatchmakerMatched::set_match_id(const char* value, size_t size) {
  if (!has_match_id()) {
    clear_id();
    set_has_match_id();
    id_.match_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.MatchmakerMatched.match_id)
}
inline ::std::string* MatchmakerMatched::mutable_match_id() {
  if (!has_match_id()) {
    clear_id();
    set_has_match_id();
    id_.match_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchmakerMatched.match_id)
  return id_.match_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MatchmakerMatched::release_match_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.MatchmakerMatched.match_id)
  if (has_match_id()) {
    clear_has_id();
    return id_.match_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void MatchmakerMatched::set_allocated_match_id(::std::string* match_id) {
  if (!has_match_id()) {
    id_.match_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_id();
  if (match_id != NULL) {
    set_has_match_id();
    id_.match_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), match_id);
  }
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.MatchmakerMatched.match_id)
}

// string token = 3;
inline bool MatchmakerMatched::has_token() const {
  return id_case() == kToken;
}
inline void MatchmakerMatched::set_has_token() {
  _oneof_case_[0] = kToken;
}
inline void MatchmakerMatched::clear_token() {
  if (has_token()) {
    id_.token_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_id();
  }
}
inline const ::std::string& MatchmakerMatched::token() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchmakerMatched.token)
  if (has_token()) {
    return id_.token_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void MatchmakerMatched::set_token(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchmakerMatched.token)
  if (!has_token()) {
    clear_id();
    set_has_token();
    id_.token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchmakerMatched.token)
}
#if LANG_CXX11
inline void MatchmakerMatched::set_token(::std::string&& value) {
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchmakerMatched.token)
  if (!has_token()) {
    clear_id();
    set_has_token();
    id_.token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.MatchmakerMatched.token)
}
#endif
inline void MatchmakerMatched::set_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_token()) {
    clear_id();
    set_has_token();
    id_.token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.realtime.MatchmakerMatched.token)
}
inline void MatchmakerMatched::set_token(const char* value, size_t size) {
  if (!has_token()) {
    clear_id();
    set_has_token();
    id_.token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.MatchmakerMatched.token)
}
inline ::std::string* MatchmakerMatched::mutable_token() {
  if (!has_token()) {
    clear_id();
    set_has_token();
    id_.token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchmakerMatched.token)
  return id_.token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MatchmakerMatched::release_token() {
  // @@protoc_insertion_point(field_release:nakama.realtime.MatchmakerMatched.token)
  if (has_token()) {
    clear_has_id();
    return id_.token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void MatchmakerMatched::set_allocated_token(::std::string* token) {
  if (!has_token()) {
    id_.token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_id();
  if (token != NULL) {
    set_has_token();
    id_.token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  }
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.MatchmakerMatched.token)
}

// repeated .nakama.realtime.MatchmakerMatched.MatchmakerUser users = 4;
inline int MatchmakerMatched::users_size() const {
  return users_.size();
}
inline void MatchmakerMatched::clear_users() {
  users_.Clear();
}
inline ::nakama::realtime::MatchmakerMatched_MatchmakerUser* MatchmakerMatched::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchmakerMatched.users)
  return users_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nakama::realtime::MatchmakerMatched_MatchmakerUser >*
MatchmakerMatched::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:nakama.realtime.MatchmakerMatched.users)
  return &users_;
}
inline const ::nakama::realtime::MatchmakerMatched_MatchmakerUser& MatchmakerMatched::users(int index) const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchmakerMatched.users)
  return users_.Get(index);
}
inline ::nakama::realtime::MatchmakerMatched_MatchmakerUser* MatchmakerMatched::add_users() {
  // @@protoc_insertion_point(field_add:nakama.realtime.MatchmakerMatched.users)
  return users_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nakama::realtime::MatchmakerMatched_MatchmakerUser >&
MatchmakerMatched::users() const {
  // @@protoc_insertion_point(field_list:nakama.realtime.MatchmakerMatched.users)
  return users_;
}

// .nakama.realtime.MatchmakerMatched.MatchmakerUser self = 5;
inline bool MatchmakerMatched::has_self() const {
  return this != internal_default_instance() && self_ != NULL;
}
inline void MatchmakerMatched::clear_self() {
  if (GetArenaNoVirtual() == NULL && self_ != NULL) {
    delete self_;
  }
  self_ = NULL;
}
inline const ::nakama::realtime::MatchmakerMatched_MatchmakerUser& MatchmakerMatched::_internal_self() const {
  return *self_;
}
inline const ::nakama::realtime::MatchmakerMatched_MatchmakerUser& MatchmakerMatched::self() const {
  const ::nakama::realtime::MatchmakerMatched_MatchmakerUser* p = self_;
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchmakerMatched.self)
  return p != NULL ? *p : *reinterpret_cast<const ::nakama::realtime::MatchmakerMatched_MatchmakerUser*>(
      &::nakama::realtime::_MatchmakerMatched_MatchmakerUser_default_instance_);
}
inline ::nakama::realtime::MatchmakerMatched_MatchmakerUser* MatchmakerMatched::release_self() {
  // @@protoc_insertion_point(field_release:nakama.realtime.MatchmakerMatched.self)
  
  ::nakama::realtime::MatchmakerMatched_MatchmakerUser* temp = self_;
  self_ = NULL;
  return temp;
}
inline ::nakama::realtime::MatchmakerMatched_MatchmakerUser* MatchmakerMatched::mutable_self() {
  
  if (self_ == NULL) {
    auto* p = CreateMaybeMessage<::nakama::realtime::MatchmakerMatched_MatchmakerUser>(GetArenaNoVirtual());
    self_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchmakerMatched.self)
  return self_;
}
inline void MatchmakerMatched::set_allocated_self(::nakama::realtime::MatchmakerMatched_MatchmakerUser* self) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete self_;
  }
  if (self) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      self = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, self, submessage_arena);
    }
    
  } else {
    
  }
  self_ = self;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.MatchmakerMatched.self)
}

inline bool MatchmakerMatched::has_id() const {
  return id_case() != ID_NOT_SET;
}
inline void MatchmakerMatched::clear_has_id() {
  _oneof_case_[0] = ID_NOT_SET;
}
inline MatchmakerMatched::IdCase MatchmakerMatched::id_case() const {
  return MatchmakerMatched::IdCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MatchmakerRemove

// string ticket = 1;
inline void MatchmakerRemove::clear_ticket() {
  ticket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MatchmakerRemove::ticket() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchmakerRemove.ticket)
  return ticket_.GetNoArena();
}
inline void MatchmakerRemove::set_ticket(const ::std::string& value) {
  
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchmakerRemove.ticket)
}
#if LANG_CXX11
inline void MatchmakerRemove::set_ticket(::std::string&& value) {
  
  ticket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.MatchmakerRemove.ticket)
}
#endif
inline void MatchmakerRemove::set_ticket(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.realtime.MatchmakerRemove.ticket)
}
inline void MatchmakerRemove::set_ticket(const char* value, size_t size) {
  
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.MatchmakerRemove.ticket)
}
inline ::std::string* MatchmakerRemove::mutable_ticket() {
  
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchmakerRemove.ticket)
  return ticket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MatchmakerRemove::release_ticket() {
  // @@protoc_insertion_point(field_release:nakama.realtime.MatchmakerRemove.ticket)
  
  return ticket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MatchmakerRemove::set_allocated_ticket(::std::string* ticket) {
  if (ticket != NULL) {
    
  } else {
    
  }
  ticket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ticket);
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.MatchmakerRemove.ticket)
}

// -------------------------------------------------------------------

// MatchmakerTicket

// string ticket = 1;
inline void MatchmakerTicket::clear_ticket() {
  ticket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MatchmakerTicket::ticket() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.MatchmakerTicket.ticket)
  return ticket_.GetNoArena();
}
inline void MatchmakerTicket::set_ticket(const ::std::string& value) {
  
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.realtime.MatchmakerTicket.ticket)
}
#if LANG_CXX11
inline void MatchmakerTicket::set_ticket(::std::string&& value) {
  
  ticket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.MatchmakerTicket.ticket)
}
#endif
inline void MatchmakerTicket::set_ticket(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.realtime.MatchmakerTicket.ticket)
}
inline void MatchmakerTicket::set_ticket(const char* value, size_t size) {
  
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.MatchmakerTicket.ticket)
}
inline ::std::string* MatchmakerTicket::mutable_ticket() {
  
  // @@protoc_insertion_point(field_mutable:nakama.realtime.MatchmakerTicket.ticket)
  return ticket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MatchmakerTicket::release_ticket() {
  // @@protoc_insertion_point(field_release:nakama.realtime.MatchmakerTicket.ticket)
  
  return ticket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MatchmakerTicket::set_allocated_ticket(::std::string* ticket) {
  if (ticket != NULL) {
    
  } else {
    
  }
  ticket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ticket);
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.MatchmakerTicket.ticket)
}

// -------------------------------------------------------------------

// Notifications

// repeated .nakama.api.Notification notifications = 1;
inline int Notifications::notifications_size() const {
  return notifications_.size();
}
inline ::nakama::api::Notification* Notifications::mutable_notifications(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Notifications.notifications)
  return notifications_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nakama::api::Notification >*
Notifications::mutable_notifications() {
  // @@protoc_insertion_point(field_mutable_list:nakama.realtime.Notifications.notifications)
  return &notifications_;
}
inline const ::nakama::api::Notification& Notifications::notifications(int index) const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Notifications.notifications)
  return notifications_.Get(index);
}
inline ::nakama::api::Notification* Notifications::add_notifications() {
  // @@protoc_insertion_point(field_add:nakama.realtime.Notifications.notifications)
  return notifications_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nakama::api::Notification >&
Notifications::notifications() const {
  // @@protoc_insertion_point(field_list:nakama.realtime.Notifications.notifications)
  return notifications_;
}

// -------------------------------------------------------------------

// Status

// repeated .nakama.realtime.UserPresence presences = 1;
inline int Status::presences_size() const {
  return presences_.size();
}
inline void Status::clear_presences() {
  presences_.Clear();
}
inline ::nakama::realtime::UserPresence* Status::mutable_presences(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Status.presences)
  return presences_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >*
Status::mutable_presences() {
  // @@protoc_insertion_point(field_mutable_list:nakama.realtime.Status.presences)
  return &presences_;
}
inline const ::nakama::realtime::UserPresence& Status::presences(int index) const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Status.presences)
  return presences_.Get(index);
}
inline ::nakama::realtime::UserPresence* Status::add_presences() {
  // @@protoc_insertion_point(field_add:nakama.realtime.Status.presences)
  return presences_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >&
Status::presences() const {
  // @@protoc_insertion_point(field_list:nakama.realtime.Status.presences)
  return presences_;
}

// -------------------------------------------------------------------

// StatusFollow

// repeated string user_ids = 1;
inline int StatusFollow::user_ids_size() const {
  return user_ids_.size();
}
inline void StatusFollow::clear_user_ids() {
  user_ids_.Clear();
}
inline const ::std::string& StatusFollow::user_ids(int index) const {
  // @@protoc_insertion_point(field_get:nakama.realtime.StatusFollow.user_ids)
  return user_ids_.Get(index);
}
inline ::std::string* StatusFollow::mutable_user_ids(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.StatusFollow.user_ids)
  return user_ids_.Mutable(index);
}
inline void StatusFollow::set_user_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:nakama.realtime.StatusFollow.user_ids)
  user_ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void StatusFollow::set_user_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:nakama.realtime.StatusFollow.user_ids)
  user_ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void StatusFollow::set_user_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  user_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nakama.realtime.StatusFollow.user_ids)
}
inline void StatusFollow::set_user_ids(int index, const char* value, size_t size) {
  user_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.StatusFollow.user_ids)
}
inline ::std::string* StatusFollow::add_user_ids() {
  // @@protoc_insertion_point(field_add_mutable:nakama.realtime.StatusFollow.user_ids)
  return user_ids_.Add();
}
inline void StatusFollow::add_user_ids(const ::std::string& value) {
  user_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:nakama.realtime.StatusFollow.user_ids)
}
#if LANG_CXX11
inline void StatusFollow::add_user_ids(::std::string&& value) {
  user_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:nakama.realtime.StatusFollow.user_ids)
}
#endif
inline void StatusFollow::add_user_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  user_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nakama.realtime.StatusFollow.user_ids)
}
inline void StatusFollow::add_user_ids(const char* value, size_t size) {
  user_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nakama.realtime.StatusFollow.user_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
StatusFollow::user_ids() const {
  // @@protoc_insertion_point(field_list:nakama.realtime.StatusFollow.user_ids)
  return user_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
StatusFollow::mutable_user_ids() {
  // @@protoc_insertion_point(field_mutable_list:nakama.realtime.StatusFollow.user_ids)
  return &user_ids_;
}

// -------------------------------------------------------------------

// StatusPresenceEvent

// repeated .nakama.realtime.UserPresence joins = 2;
inline int StatusPresenceEvent::joins_size() const {
  return joins_.size();
}
inline void StatusPresenceEvent::clear_joins() {
  joins_.Clear();
}
inline ::nakama::realtime::UserPresence* StatusPresenceEvent::mutable_joins(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.StatusPresenceEvent.joins)
  return joins_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >*
StatusPresenceEvent::mutable_joins() {
  // @@protoc_insertion_point(field_mutable_list:nakama.realtime.StatusPresenceEvent.joins)
  return &joins_;
}
inline const ::nakama::realtime::UserPresence& StatusPresenceEvent::joins(int index) const {
  // @@protoc_insertion_point(field_get:nakama.realtime.StatusPresenceEvent.joins)
  return joins_.Get(index);
}
inline ::nakama::realtime::UserPresence* StatusPresenceEvent::add_joins() {
  // @@protoc_insertion_point(field_add:nakama.realtime.StatusPresenceEvent.joins)
  return joins_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >&
StatusPresenceEvent::joins() const {
  // @@protoc_insertion_point(field_list:nakama.realtime.StatusPresenceEvent.joins)
  return joins_;
}

// repeated .nakama.realtime.UserPresence leaves = 3;
inline int StatusPresenceEvent::leaves_size() const {
  return leaves_.size();
}
inline void StatusPresenceEvent::clear_leaves() {
  leaves_.Clear();
}
inline ::nakama::realtime::UserPresence* StatusPresenceEvent::mutable_leaves(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.StatusPresenceEvent.leaves)
  return leaves_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >*
StatusPresenceEvent::mutable_leaves() {
  // @@protoc_insertion_point(field_mutable_list:nakama.realtime.StatusPresenceEvent.leaves)
  return &leaves_;
}
inline const ::nakama::realtime::UserPresence& StatusPresenceEvent::leaves(int index) const {
  // @@protoc_insertion_point(field_get:nakama.realtime.StatusPresenceEvent.leaves)
  return leaves_.Get(index);
}
inline ::nakama::realtime::UserPresence* StatusPresenceEvent::add_leaves() {
  // @@protoc_insertion_point(field_add:nakama.realtime.StatusPresenceEvent.leaves)
  return leaves_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >&
StatusPresenceEvent::leaves() const {
  // @@protoc_insertion_point(field_list:nakama.realtime.StatusPresenceEvent.leaves)
  return leaves_;
}

// -------------------------------------------------------------------

// StatusUnfollow

// repeated string user_ids = 1;
inline int StatusUnfollow::user_ids_size() const {
  return user_ids_.size();
}
inline void StatusUnfollow::clear_user_ids() {
  user_ids_.Clear();
}
inline const ::std::string& StatusUnfollow::user_ids(int index) const {
  // @@protoc_insertion_point(field_get:nakama.realtime.StatusUnfollow.user_ids)
  return user_ids_.Get(index);
}
inline ::std::string* StatusUnfollow::mutable_user_ids(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.StatusUnfollow.user_ids)
  return user_ids_.Mutable(index);
}
inline void StatusUnfollow::set_user_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:nakama.realtime.StatusUnfollow.user_ids)
  user_ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void StatusUnfollow::set_user_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:nakama.realtime.StatusUnfollow.user_ids)
  user_ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void StatusUnfollow::set_user_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  user_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nakama.realtime.StatusUnfollow.user_ids)
}
inline void StatusUnfollow::set_user_ids(int index, const char* value, size_t size) {
  user_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.StatusUnfollow.user_ids)
}
inline ::std::string* StatusUnfollow::add_user_ids() {
  // @@protoc_insertion_point(field_add_mutable:nakama.realtime.StatusUnfollow.user_ids)
  return user_ids_.Add();
}
inline void StatusUnfollow::add_user_ids(const ::std::string& value) {
  user_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:nakama.realtime.StatusUnfollow.user_ids)
}
#if LANG_CXX11
inline void StatusUnfollow::add_user_ids(::std::string&& value) {
  user_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:nakama.realtime.StatusUnfollow.user_ids)
}
#endif
inline void StatusUnfollow::add_user_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  user_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nakama.realtime.StatusUnfollow.user_ids)
}
inline void StatusUnfollow::add_user_ids(const char* value, size_t size) {
  user_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nakama.realtime.StatusUnfollow.user_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
StatusUnfollow::user_ids() const {
  // @@protoc_insertion_point(field_list:nakama.realtime.StatusUnfollow.user_ids)
  return user_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
StatusUnfollow::mutable_user_ids() {
  // @@protoc_insertion_point(field_mutable_list:nakama.realtime.StatusUnfollow.user_ids)
  return &user_ids_;
}

// -------------------------------------------------------------------

// StatusUpdate

// .google.protobuf.StringValue status = 1;
inline bool StatusUpdate::has_status() const {
  return this != internal_default_instance() && status_ != NULL;
}
inline const ::google::protobuf::StringValue& StatusUpdate::_internal_status() const {
  return *status_;
}
inline const ::google::protobuf::StringValue& StatusUpdate::status() const {
  const ::google::protobuf::StringValue* p = status_;
  // @@protoc_insertion_point(field_get:nakama.realtime.StatusUpdate.status)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::StringValue*>(
      &::google::protobuf::_StringValue_default_instance_);
}
inline ::google::protobuf::StringValue* StatusUpdate::release_status() {
  // @@protoc_insertion_point(field_release:nakama.realtime.StatusUpdate.status)
  
  ::google::protobuf::StringValue* temp = status_;
  status_ = NULL;
  return temp;
}
inline ::google::protobuf::StringValue* StatusUpdate::mutable_status() {
  
  if (status_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::StringValue>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.StatusUpdate.status)
  return status_;
}
inline void StatusUpdate::set_allocated_status(::google::protobuf::StringValue* status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(status_);
  }
  if (status) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(status)->GetArena();
    if (message_arena != submessage_arena) {
      status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.StatusUpdate.status)
}

// -------------------------------------------------------------------

// Stream

// int32 mode = 1;
inline void Stream::clear_mode() {
  mode_ = 0;
}
inline ::google::protobuf::int32 Stream::mode() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Stream.mode)
  return mode_;
}
inline void Stream::set_mode(::google::protobuf::int32 value) {
  
  mode_ = value;
  // @@protoc_insertion_point(field_set:nakama.realtime.Stream.mode)
}

// string subject = 2;
inline void Stream::clear_subject() {
  subject_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Stream::subject() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Stream.subject)
  return subject_.GetNoArena();
}
inline void Stream::set_subject(const ::std::string& value) {
  
  subject_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.realtime.Stream.subject)
}
#if LANG_CXX11
inline void Stream::set_subject(::std::string&& value) {
  
  subject_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.Stream.subject)
}
#endif
inline void Stream::set_subject(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  subject_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.realtime.Stream.subject)
}
inline void Stream::set_subject(const char* value, size_t size) {
  
  subject_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.Stream.subject)
}
inline ::std::string* Stream::mutable_subject() {
  
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Stream.subject)
  return subject_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Stream::release_subject() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Stream.subject)
  
  return subject_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Stream::set_allocated_subject(::std::string* subject) {
  if (subject != NULL) {
    
  } else {
    
  }
  subject_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), subject);
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.Stream.subject)
}

// string descriptor = 3;
inline void Stream::clear_descriptor() {
  descriptor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Stream::descriptor() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Stream.descriptor)
  return descriptor_.GetNoArena();
}
inline void Stream::set_descriptor(const ::std::string& value) {
  
  descriptor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.realtime.Stream.descriptor)
}
#if LANG_CXX11
inline void Stream::set_descriptor(::std::string&& value) {
  
  descriptor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.Stream.descriptor)
}
#endif
inline void Stream::set_descriptor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  descriptor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.realtime.Stream.descriptor)
}
inline void Stream::set_descriptor(const char* value, size_t size) {
  
  descriptor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.Stream.descriptor)
}
inline ::std::string* Stream::mutable_descriptor() {
  
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Stream.descriptor)
  return descriptor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Stream::release_descriptor() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Stream.descriptor)
  
  return descriptor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Stream::set_allocated_descriptor(::std::string* descriptor) {
  if (descriptor != NULL) {
    
  } else {
    
  }
  descriptor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), descriptor);
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.Stream.descriptor)
}

// string label = 4;
inline void Stream::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Stream::label() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.Stream.label)
  return label_.GetNoArena();
}
inline void Stream::set_label(const ::std::string& value) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.realtime.Stream.label)
}
#if LANG_CXX11
inline void Stream::set_label(::std::string&& value) {
  
  label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.Stream.label)
}
#endif
inline void Stream::set_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.realtime.Stream.label)
}
inline void Stream::set_label(const char* value, size_t size) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.Stream.label)
}
inline ::std::string* Stream::mutable_label() {
  
  // @@protoc_insertion_point(field_mutable:nakama.realtime.Stream.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Stream::release_label() {
  // @@protoc_insertion_point(field_release:nakama.realtime.Stream.label)
  
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Stream::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    
  } else {
    
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.Stream.label)
}

// -------------------------------------------------------------------

// StreamData

// .nakama.realtime.Stream stream = 1;
inline bool StreamData::has_stream() const {
  return this != internal_default_instance() && stream_ != NULL;
}
inline void StreamData::clear_stream() {
  if (GetArenaNoVirtual() == NULL && stream_ != NULL) {
    delete stream_;
  }
  stream_ = NULL;
}
inline const ::nakama::realtime::Stream& StreamData::_internal_stream() const {
  return *stream_;
}
inline const ::nakama::realtime::Stream& StreamData::stream() const {
  const ::nakama::realtime::Stream* p = stream_;
  // @@protoc_insertion_point(field_get:nakama.realtime.StreamData.stream)
  return p != NULL ? *p : *reinterpret_cast<const ::nakama::realtime::Stream*>(
      &::nakama::realtime::_Stream_default_instance_);
}
inline ::nakama::realtime::Stream* StreamData::release_stream() {
  // @@protoc_insertion_point(field_release:nakama.realtime.StreamData.stream)
  
  ::nakama::realtime::Stream* temp = stream_;
  stream_ = NULL;
  return temp;
}
inline ::nakama::realtime::Stream* StreamData::mutable_stream() {
  
  if (stream_ == NULL) {
    auto* p = CreateMaybeMessage<::nakama::realtime::Stream>(GetArenaNoVirtual());
    stream_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.StreamData.stream)
  return stream_;
}
inline void StreamData::set_allocated_stream(::nakama::realtime::Stream* stream) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete stream_;
  }
  if (stream) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      stream = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    
  } else {
    
  }
  stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.StreamData.stream)
}

// .nakama.realtime.UserPresence sender = 2;
inline bool StreamData::has_sender() const {
  return this != internal_default_instance() && sender_ != NULL;
}
inline void StreamData::clear_sender() {
  if (GetArenaNoVirtual() == NULL && sender_ != NULL) {
    delete sender_;
  }
  sender_ = NULL;
}
inline const ::nakama::realtime::UserPresence& StreamData::_internal_sender() const {
  return *sender_;
}
inline const ::nakama::realtime::UserPresence& StreamData::sender() const {
  const ::nakama::realtime::UserPresence* p = sender_;
  // @@protoc_insertion_point(field_get:nakama.realtime.StreamData.sender)
  return p != NULL ? *p : *reinterpret_cast<const ::nakama::realtime::UserPresence*>(
      &::nakama::realtime::_UserPresence_default_instance_);
}
inline ::nakama::realtime::UserPresence* StreamData::release_sender() {
  // @@protoc_insertion_point(field_release:nakama.realtime.StreamData.sender)
  
  ::nakama::realtime::UserPresence* temp = sender_;
  sender_ = NULL;
  return temp;
}
inline ::nakama::realtime::UserPresence* StreamData::mutable_sender() {
  
  if (sender_ == NULL) {
    auto* p = CreateMaybeMessage<::nakama::realtime::UserPresence>(GetArenaNoVirtual());
    sender_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.StreamData.sender)
  return sender_;
}
inline void StreamData::set_allocated_sender(::nakama::realtime::UserPresence* sender) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sender_;
  }
  if (sender) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sender = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sender, submessage_arena);
    }
    
  } else {
    
  }
  sender_ = sender;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.StreamData.sender)
}

// string data = 3;
inline void StreamData::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StreamData::data() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.StreamData.data)
  return data_.GetNoArena();
}
inline void StreamData::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.realtime.StreamData.data)
}
#if LANG_CXX11
inline void StreamData::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.StreamData.data)
}
#endif
inline void StreamData::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.realtime.StreamData.data)
}
inline void StreamData::set_data(const char* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.StreamData.data)
}
inline ::std::string* StreamData::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:nakama.realtime.StreamData.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StreamData::release_data() {
  // @@protoc_insertion_point(field_release:nakama.realtime.StreamData.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StreamData::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.StreamData.data)
}

// -------------------------------------------------------------------

// StreamPresenceEvent

// .nakama.realtime.Stream stream = 1;
inline bool StreamPresenceEvent::has_stream() const {
  return this != internal_default_instance() && stream_ != NULL;
}
inline void StreamPresenceEvent::clear_stream() {
  if (GetArenaNoVirtual() == NULL && stream_ != NULL) {
    delete stream_;
  }
  stream_ = NULL;
}
inline const ::nakama::realtime::Stream& StreamPresenceEvent::_internal_stream() const {
  return *stream_;
}
inline const ::nakama::realtime::Stream& StreamPresenceEvent::stream() const {
  const ::nakama::realtime::Stream* p = stream_;
  // @@protoc_insertion_point(field_get:nakama.realtime.StreamPresenceEvent.stream)
  return p != NULL ? *p : *reinterpret_cast<const ::nakama::realtime::Stream*>(
      &::nakama::realtime::_Stream_default_instance_);
}
inline ::nakama::realtime::Stream* StreamPresenceEvent::release_stream() {
  // @@protoc_insertion_point(field_release:nakama.realtime.StreamPresenceEvent.stream)
  
  ::nakama::realtime::Stream* temp = stream_;
  stream_ = NULL;
  return temp;
}
inline ::nakama::realtime::Stream* StreamPresenceEvent::mutable_stream() {
  
  if (stream_ == NULL) {
    auto* p = CreateMaybeMessage<::nakama::realtime::Stream>(GetArenaNoVirtual());
    stream_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.StreamPresenceEvent.stream)
  return stream_;
}
inline void StreamPresenceEvent::set_allocated_stream(::nakama::realtime::Stream* stream) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete stream_;
  }
  if (stream) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      stream = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    
  } else {
    
  }
  stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.StreamPresenceEvent.stream)
}

// repeated .nakama.realtime.UserPresence joins = 2;
inline int StreamPresenceEvent::joins_size() const {
  return joins_.size();
}
inline void StreamPresenceEvent::clear_joins() {
  joins_.Clear();
}
inline ::nakama::realtime::UserPresence* StreamPresenceEvent::mutable_joins(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.StreamPresenceEvent.joins)
  return joins_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >*
StreamPresenceEvent::mutable_joins() {
  // @@protoc_insertion_point(field_mutable_list:nakama.realtime.StreamPresenceEvent.joins)
  return &joins_;
}
inline const ::nakama::realtime::UserPresence& StreamPresenceEvent::joins(int index) const {
  // @@protoc_insertion_point(field_get:nakama.realtime.StreamPresenceEvent.joins)
  return joins_.Get(index);
}
inline ::nakama::realtime::UserPresence* StreamPresenceEvent::add_joins() {
  // @@protoc_insertion_point(field_add:nakama.realtime.StreamPresenceEvent.joins)
  return joins_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >&
StreamPresenceEvent::joins() const {
  // @@protoc_insertion_point(field_list:nakama.realtime.StreamPresenceEvent.joins)
  return joins_;
}

// repeated .nakama.realtime.UserPresence leaves = 3;
inline int StreamPresenceEvent::leaves_size() const {
  return leaves_.size();
}
inline void StreamPresenceEvent::clear_leaves() {
  leaves_.Clear();
}
inline ::nakama::realtime::UserPresence* StreamPresenceEvent::mutable_leaves(int index) {
  // @@protoc_insertion_point(field_mutable:nakama.realtime.StreamPresenceEvent.leaves)
  return leaves_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >*
StreamPresenceEvent::mutable_leaves() {
  // @@protoc_insertion_point(field_mutable_list:nakama.realtime.StreamPresenceEvent.leaves)
  return &leaves_;
}
inline const ::nakama::realtime::UserPresence& StreamPresenceEvent::leaves(int index) const {
  // @@protoc_insertion_point(field_get:nakama.realtime.StreamPresenceEvent.leaves)
  return leaves_.Get(index);
}
inline ::nakama::realtime::UserPresence* StreamPresenceEvent::add_leaves() {
  // @@protoc_insertion_point(field_add:nakama.realtime.StreamPresenceEvent.leaves)
  return leaves_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nakama::realtime::UserPresence >&
StreamPresenceEvent::leaves() const {
  // @@protoc_insertion_point(field_list:nakama.realtime.StreamPresenceEvent.leaves)
  return leaves_;
}

// -------------------------------------------------------------------

// UserPresence

// string user_id = 1;
inline void UserPresence::clear_user_id() {
  user_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserPresence::user_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.UserPresence.user_id)
  return user_id_.GetNoArena();
}
inline void UserPresence::set_user_id(const ::std::string& value) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.realtime.UserPresence.user_id)
}
#if LANG_CXX11
inline void UserPresence::set_user_id(::std::string&& value) {
  
  user_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.UserPresence.user_id)
}
#endif
inline void UserPresence::set_user_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.realtime.UserPresence.user_id)
}
inline void UserPresence::set_user_id(const char* value, size_t size) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.UserPresence.user_id)
}
inline ::std::string* UserPresence::mutable_user_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.realtime.UserPresence.user_id)
  return user_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserPresence::release_user_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.UserPresence.user_id)
  
  return user_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserPresence::set_allocated_user_id(::std::string* user_id) {
  if (user_id != NULL) {
    
  } else {
    
  }
  user_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.UserPresence.user_id)
}

// string session_id = 2;
inline void UserPresence::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserPresence::session_id() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.UserPresence.session_id)
  return session_id_.GetNoArena();
}
inline void UserPresence::set_session_id(const ::std::string& value) {
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.realtime.UserPresence.session_id)
}
#if LANG_CXX11
inline void UserPresence::set_session_id(::std::string&& value) {
  
  session_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.UserPresence.session_id)
}
#endif
inline void UserPresence::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.realtime.UserPresence.session_id)
}
inline void UserPresence::set_session_id(const char* value, size_t size) {
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.UserPresence.session_id)
}
inline ::std::string* UserPresence::mutable_session_id() {
  
  // @@protoc_insertion_point(field_mutable:nakama.realtime.UserPresence.session_id)
  return session_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserPresence::release_session_id() {
  // @@protoc_insertion_point(field_release:nakama.realtime.UserPresence.session_id)
  
  return session_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserPresence::set_allocated_session_id(::std::string* session_id) {
  if (session_id != NULL) {
    
  } else {
    
  }
  session_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.UserPresence.session_id)
}

// string username = 3;
inline void UserPresence::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserPresence::username() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.UserPresence.username)
  return username_.GetNoArena();
}
inline void UserPresence::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nakama.realtime.UserPresence.username)
}
#if LANG_CXX11
inline void UserPresence::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nakama.realtime.UserPresence.username)
}
#endif
inline void UserPresence::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nakama.realtime.UserPresence.username)
}
inline void UserPresence::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nakama.realtime.UserPresence.username)
}
inline ::std::string* UserPresence::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:nakama.realtime.UserPresence.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserPresence::release_username() {
  // @@protoc_insertion_point(field_release:nakama.realtime.UserPresence.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserPresence::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.UserPresence.username)
}

// bool persistence = 4;
inline void UserPresence::clear_persistence() {
  persistence_ = false;
}
inline bool UserPresence::persistence() const {
  // @@protoc_insertion_point(field_get:nakama.realtime.UserPresence.persistence)
  return persistence_;
}
inline void UserPresence::set_persistence(bool value) {
  
  persistence_ = value;
  // @@protoc_insertion_point(field_set:nakama.realtime.UserPresence.persistence)
}

// .google.protobuf.StringValue status = 5;
inline bool UserPresence::has_status() const {
  return this != internal_default_instance() && status_ != NULL;
}
inline const ::google::protobuf::StringValue& UserPresence::_internal_status() const {
  return *status_;
}
inline const ::google::protobuf::StringValue& UserPresence::status() const {
  const ::google::protobuf::StringValue* p = status_;
  // @@protoc_insertion_point(field_get:nakama.realtime.UserPresence.status)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::StringValue*>(
      &::google::protobuf::_StringValue_default_instance_);
}
inline ::google::protobuf::StringValue* UserPresence::release_status() {
  // @@protoc_insertion_point(field_release:nakama.realtime.UserPresence.status)
  
  ::google::protobuf::StringValue* temp = status_;
  status_ = NULL;
  return temp;
}
inline ::google::protobuf::StringValue* UserPresence::mutable_status() {
  
  if (status_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::StringValue>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nakama.realtime.UserPresence.status)
  return status_;
}
inline void UserPresence::set_allocated_status(::google::protobuf::StringValue* status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(status_);
  }
  if (status) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(status)->GetArena();
    if (message_arena != submessage_arena) {
      status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:nakama.realtime.UserPresence.status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace realtime
}  // namespace nakama

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::nakama::realtime::ChannelJoin_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nakama::realtime::ChannelJoin_Type>() {
  return ::nakama::realtime::ChannelJoin_Type_descriptor();
}
template <> struct is_proto_enum< ::nakama::realtime::Error_Code> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nakama::realtime::Error_Code>() {
  return ::nakama::realtime::Error_Code_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_github_2ecom_2fheroiclabs_2fnakama_2frtapi_2frealtime_2eproto
